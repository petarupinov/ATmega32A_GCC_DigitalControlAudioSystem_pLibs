
ATmega32A_GCC_DigitalControlAudioSystem_pLibs.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000017aa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000006d6  00800060  000017aa  0000183e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002b  00800736  00800736  00001f14  2**0
                  ALLOC
  3 .debug_aranges 00000180  00000000  00000000  00001f14  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000a30  00000000  00000000  00002094  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002e44  00000000  00000000  00002ac4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d49  00000000  00000000  00005908  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002a28  00000000  00000000  00006651  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007d0  00000000  00000000  0000907c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000b5a  00000000  00000000  0000984c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000dbe  00000000  00000000  0000a3a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000798  00000000  00000000  0000b164  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 e5 04 	jmp	0x9ca	; 0x9ca <__vector_1>
       8:	0c 94 91 00 	jmp	0x122	; 0x122 <__vector_2>
       c:	0c 94 9b 00 	jmp	0x136	; 0x136 <__vector_3>
      10:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__vector_4>
      14:	0c 94 af 00 	jmp	0x15e	; 0x15e <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	17 e0       	ldi	r17, 0x07	; 7
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea ea       	ldi	r30, 0xAA	; 170
      68:	f7 e1       	ldi	r31, 0x17	; 23
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 33       	cpi	r26, 0x36	; 54
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a6 e3       	ldi	r26, 0x36	; 54
      7a:	b7 e0       	ldi	r27, 0x07	; 7
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 36       	cpi	r26, 0x61	; 97
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 6e 04 	call	0x8dc	; 0x8dc <main>
      8a:	0c 94 d3 0b 	jmp	0x17a6	; 0x17a6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <port_init>:
*****************************************/
void port_init(void)
{	

// PORT A connections
	DDRA  = 0b11111111;		//  PA7:U8/PGA2310,CS; PA6:U7/PGA2310,CS; PA5:CON2LCD,RS; PA4:CON2LCD,RW; PA3:CON2LCD,E; PA2:U2/74HC595,RCLK(LCD); PA1:U2/74HC595,SCLK(LCD); PA0:U2/74HC595,DATA(LCD);
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	8a bb       	out	0x1a, r24	; 26
	PORTA = 0b00000000;		//	Interfaces: NOT USED. PULLUP DISABLE in PORTA.
      96:	1b ba       	out	0x1b, r1	; 27

// PORT B connections
	DDRB  = 0b10111000;		//  PB7:U6,U7,U8/PGA2310,SCLK; PB6:U6,U7,U8/PGA2310,SDO(CON33,36,39); PB5:U6,U7,U8/PGA2310,SDI; PB4:U12/74HC595,DATA(REL_OUT); PB3:U6/PGA2310,CS; PB2:CON8/BUTTON,"ESCAPE",INT2; PB1:CON5/BUTTON,"ON/OFF"; PB0:CON14TempSensor/DS18S20,DQ,IN/OUT;
      98:	88 eb       	ldi	r24, 0xB8	; 184
      9a:	87 bb       	out	0x17, r24	; 23
	PORTB = 0b00000111;		//	Interfaces: EXTERNAL INTERRUPT 2; SPI. set pullup to IRTSOP2240 / BUTTON(on/off) / DS18s20.
      9c:	87 e0       	ldi	r24, 0x07	; 7
      9e:	88 bb       	out	0x18, r24	; 24

// PORT C connections
	DDRC  = 0b11001100;		//  PC7:U10/74HC595,DATA(REL_IN); PC6:U10/74HC595,SCLK(REL_IN); PC5:EncoderED1112S,A; PC4:EncoderED1112S,B; PC3:U10/74HC595,RCLK(REL_IN); PC2:Q2/BD237(RELAY_POWER_SUPPLY); PC1:DS1307/24C64,I2C/SDA; PC0:DS1307/24C64,I2C/SCL;
      a0:	8c ec       	ldi	r24, 0xCC	; 204
      a2:	84 bb       	out	0x14, r24	; 20
	PORTC = 0b00000000;		//	Interfaces: I2C. PULLUP DISABLE in PORTC.
      a4:	15 ba       	out	0x15, r1	; 21

// PORT D connections
	DDRD  = 0b11110000;		//  PD7:U12/74HC595,RCLK(REL_OUT); PD6:U12/74HC595,SCLK(REL_OUT); PD5:Q1/BD237(FAN_CONTROL_PWM); PD4:LED5/"ON/OFF AUDIO SYSTEM"; PD3:CON11/EncoderBUTTON,"MENU/ENTER"/INT1; PD2:CON12/IR/TSOP2240,/INT0; PD1:CON14/MAX232,UART/TXD; PD0:CON14/MAX232,UART/RXD;
      a6:	80 ef       	ldi	r24, 0xF0	; 240
      a8:	81 bb       	out	0x11, r24	; 17
	PORTD = 0b00001100;		//	Interfaces: TIMER1; UART/USART; EXTERNAL INTERRUPT 0, 1. PULLUP DISABLE in PORTD.
      aa:	8c e0       	ldi	r24, 0x0C	; 12
      ac:	82 bb       	out	0x12, r24	; 18
//	DDRD&=~_BV(0);// DDD0 = "0"  (DDD0=DDRD nulev bit) set PORTD pin0 to zero as input
//	PORTD|=_BV(0);// PD0  = "1"  Enable pull up
//	PORTD|=_BV(1);// PD1  = "1"  led
//	DDRD|=_BV(1); // DDD1 = "1"  (DDD1=DDRD parvi bit) set PORTD pin1 to one as output

}
      ae:	08 95       	ret

000000b0 <ext0_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 0 **
*******************************************/
void ext0_intrpt_init(void)
{
	MCUCR = 0b00000010;	// SETUP EXT INT 0, ISC01 = 1, ISC00 = 0: Falling edge on INT0 activates the interrupt; ISC01 = 1, ISC00 = 1: Rising edge on INT0 activates the interrupt;
      b0:	82 e0       	ldi	r24, 0x02	; 2
      b2:	85 bf       	out	0x35, r24	; 53

// IN FUNCTIONS:
//	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
//	GIFR   = 0b01000000;	// Clear INT0 flag.
}
      b4:	08 95       	ret

000000b6 <ext0_intrpt_on>:
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      b6:	80 e4       	ldi	r24, 0x40	; 64
      b8:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      ba:	8a bf       	out	0x3a, r24	; 58
}
      bc:	08 95       	ret

000000be <ext0_intrpt_off>:
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      be:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      c0:	80 e4       	ldi	r24, 0x40	; 64
      c2:	8a bf       	out	0x3a, r24	; 58
}
      c4:	08 95       	ret

000000c6 <ext1_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 1 **
*******************************************/
void ext1_intrpt_init(void)
{
}
      c6:	08 95       	ret

000000c8 <ext2_intrpt_init>:
//	MCUCSR = 0b00000000;	// SETUP EXT INT 2, ISC2 = 0: Falling edge on INT2 activates the interrupt; ISC2 = 1: Rising edge on INT2 activates the interrupt;

// IN FUNCTIONS:
//	GICR   = 0b00100000;	// INT2 = 0: Disable External Interrupt on INT2; INT2 = 1: Enable External Interrupt on INT2;
//	GIFR   = 0b00100000;	// Clear INT2 flag.
}
      c8:	08 95       	ret

000000ca <timer1_init>:
*****************************/
void timer1_init()
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  = 0b00000000;	// maskov registar za prekasvaniq
      ca:	19 be       	out	0x39, r1	; 57
	TCNT1H = 0b00000000;
      cc:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
      ce:	1c bc       	out	0x2c, r1	; 44

//	OCR1BH = 100; //20;			// 0   = 0b00000000 (DEC = BIN)	// LED
//	OCR1BL = 100; //20;			// 200 = 0b11001000 (DEC = BIN)	// LED

//	TIMSK = (1 << OCIE1A);
}
      d0:	08 95       	ret

000000d2 <timer2_init>:
/*****************************
** INITIZLIZATION OF TIMER2 **
*****************************/
void timer2_init(void)
{
	SFIOR = 0b00000010;		// Prescaler Reset Timer2 (bit1 –> PSR2)
      d2:	82 e0       	ldi	r24, 0x02	; 2
      d4:	80 bf       	out	0x30, r24	; 48
	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      d6:	81 e8       	ldi	r24, 0x81	; 129
      d8:	85 bd       	out	0x25, r24	; 37
	OCR2 = 0; // FAN PWM ON
      da:	13 bc       	out	0x23, r1	; 35
}
      dc:	08 95       	ret

000000de <timer1_on_speed1>:
/***************************************
******** DEFINITIONS OF TIMER 1 ********
***************************************/
void timer1_on_speed1()
{
	TCCR1A = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      de:	81 e8       	ldi	r24, 0x81	; 129
      e0:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00010001;
      e2:	81 e1       	ldi	r24, 0x11	; 17
      e4:	8e bd       	out	0x2e, r24	; 46

	OCR1AH = 0; // FAN PWM ON
      e6:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 1; // FAN PWM ON
      e8:	81 e0       	ldi	r24, 0x01	; 1
      ea:	8a bd       	out	0x2a, r24	; 42

//	OCR1BH = 0; // LED PWM ON
//	OCR1BL = 1; // LED PWM ON
}
      ec:	08 95       	ret

000000ee <timer1_off>:

void timer1_off()
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
      ee:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
      f0:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
      f2:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
      f4:	1a bc       	out	0x2a, r1	; 42

//	OCR1BH = 0; // LED PWM OFF
//	OCR1BL = 0; // LED PWM OFF
}
      f6:	08 95       	ret

000000f8 <FAN_PWM_SPEED1>:
/***************************************
******** DEFINITIONS OF TIMER 1 ********
***************************************/
void timer1_on_speed1()
{
	TCCR1A = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      f8:	81 e8       	ldi	r24, 0x81	; 129
      fa:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00010001;
      fc:	81 e1       	ldi	r24, 0x11	; 17
      fe:	8e bd       	out	0x2e, r24	; 46

	OCR1AH = 0; // FAN PWM ON
     100:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 1; // FAN PWM ON
     102:	81 e0       	ldi	r24, 0x01	; 1
     104:	8a bd       	out	0x2a, r24	; 42
******** DEFINITIONS OF FAN ********
***********************************/
void FAN_PWM_SPEED1()
{
	timer1_on_speed1();
}
     106:	08 95       	ret

00000108 <FAN_PWM_OFF>:
//	OCR1BL = 1; // LED PWM ON
}

void timer1_off()
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     108:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     10a:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     10c:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     10e:	1a bc       	out	0x2a, r1	; 42
	timer1_on_speed1();
}
void FAN_PWM_OFF()
{
	timer1_off();
}
     110:	08 95       	ret

00000112 <timer2_on>:
/***************************************
******** DEFINITIONS OF TIMER 2 ********
***************************************/
void timer2_on(void)	// Timer2 On
{
	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     112:	81 e8       	ldi	r24, 0x81	; 129
     114:	85 bd       	out	0x25, r24	; 37
	OCR2 = 1; // FAN PWM ON
     116:	81 e0       	ldi	r24, 0x01	; 1
     118:	83 bd       	out	0x23, r24	; 35
}
     11a:	08 95       	ret

0000011c <timer2_off>:

void timer2_off(void)	// Timer2 Off
{
	TCCR2 = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     11c:	15 bc       	out	0x25, r1	; 37
	OCR2 = 0; // FAN PWM OFF
     11e:	13 bc       	out	0x23, r1	; 35
}
     120:	08 95       	ret

00000122 <__vector_2>:

/*****************************************
**** EXTERNAL INTERRUPT 1 VECTOR 02 ******
*****************************************/
ISR(INT1_vect)
{
     122:	1f 92       	push	r1
     124:	0f 92       	push	r0
     126:	0f b6       	in	r0, 0x3f	; 63
     128:	0f 92       	push	r0
     12a:	11 24       	eor	r1, r1
}
     12c:	0f 90       	pop	r0
     12e:	0f be       	out	0x3f, r0	; 63
     130:	0f 90       	pop	r0
     132:	1f 90       	pop	r1
     134:	18 95       	reti

00000136 <__vector_3>:

/*****************************************
**** EXTERNAL INTERRUPT 2 VECTOR 03 ******
*****************************************/
ISR(INT2_vect)
{
     136:	1f 92       	push	r1
     138:	0f 92       	push	r0
     13a:	0f b6       	in	r0, 0x3f	; 63
     13c:	0f 92       	push	r0
     13e:	11 24       	eor	r1, r1
}
     140:	0f 90       	pop	r0
     142:	0f be       	out	0x3f, r0	; 63
     144:	0f 90       	pop	r0
     146:	1f 90       	pop	r1
     148:	18 95       	reti

0000014a <__vector_4>:

/*****************************************
**** TIMER 2 OUTPUT COMPARE VECTOR 04 ****
*****************************************/
ISR(TIMER2_COMP_vect)
{
     14a:	1f 92       	push	r1
     14c:	0f 92       	push	r0
     14e:	0f b6       	in	r0, 0x3f	; 63
     150:	0f 92       	push	r0
     152:	11 24       	eor	r1, r1
}
     154:	0f 90       	pop	r0
     156:	0f be       	out	0x3f, r0	; 63
     158:	0f 90       	pop	r0
     15a:	1f 90       	pop	r1
     15c:	18 95       	reti

0000015e <__vector_5>:

/*****************************************
**** TIMER 2 OVERFLOW VECTOR 05 **********
*****************************************/
ISR(TIMER2_OVF_vect)
{
     15e:	1f 92       	push	r1
     160:	0f 92       	push	r0
     162:	0f b6       	in	r0, 0x3f	; 63
     164:	0f 92       	push	r0
     166:	11 24       	eor	r1, r1
}
     168:	0f 90       	pop	r0
     16a:	0f be       	out	0x3f, r0	; 63
     16c:	0f 90       	pop	r0
     16e:	1f 90       	pop	r1
     170:	18 95       	reti

00000172 <about>:

	return temper;
}

void about(void)
{
     172:	0f 93       	push	r16
     174:	1f 93       	push	r17
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] =====================================================\r\n");
     176:	00 e6       	ldi	r16, 0x60	; 96
     178:	10 e0       	ldi	r17, 0x00	; 0
     17a:	c8 01       	movw	r24, r16
     17c:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartString("[UART INFO] \tAuthors and creators: P.Upinov and P.Stoyanov\r\n");
     180:	84 ea       	ldi	r24, 0xA4	; 164
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartString("[UART INFO] \tDevice name: Digital Control Audio System\r\n");
     188:	81 ee       	ldi	r24, 0xE1	; 225
     18a:	90 e0       	ldi	r25, 0x00	; 0
     18c:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartString("[UART INFO] \tFirmware version beta ");
     190:	8a e1       	ldi	r24, 0x1A	; 26
     192:	91 e0       	ldi	r25, 0x01	; 1
     194:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartInt(FIRMWARE_VERSION);
     198:	8c e1       	ldi	r24, 0x1C	; 28
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	0e 94 72 08 	call	0x10e4	; 0x10e4 <transmitUartInt>
		transmitUartString("\r\n");
     1a0:	8e e3       	ldi	r24, 0x3E	; 62
     1a2:	91 e0       	ldi	r25, 0x01	; 1
     1a4:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartString("[UART INFO] =====================================================\r\n");
     1a8:	c8 01       	movw	r24, r16
     1aa:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartString("[UART INFO] Da dobavq upravlenie na:\
     1ae:	81 e4       	ldi	r24, 0x41	; 65
     1b0:	91 e0       	ldi	r25, 0x01	; 1
     1b2:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
						\r\n[UART INFO] - FAN smart controlling			\
						\r\n[UART INFO] - DS18S20						\
						\r\n[UART INFO] - RTC							\
						\r\n[UART INFO] - Memory\r\n");
	#endif
}
     1b6:	1f 91       	pop	r17
     1b8:	0f 91       	pop	r16
     1ba:	08 95       	ret

000001bc <init_all>:
*********************************** START OF APPLICATION ************************************
********************************************************************************************/

void init_all()
{
	port_init();		// IO init and configure all port
     1bc:	0e 94 49 00 	call	0x92	; 0x92 <port_init>
//	timer2_init();
	LCD_INIT();			// LCD init and reset all lcd contain
     1c0:	0e 94 e6 06 	call	0xdcc	; 0xdcc <LCD_INIT>
	uart_init();		// UART debug init
     1c4:	0e 94 aa 08 	call	0x1154	; 0x1154 <uart_init>
	about();			// Any debug important information
     1c8:	0e 94 b9 00 	call	0x172	; 0x172 <about>

	pga2310_init();		// SPI init and reset all (U6, U7, U8) PGA2310 volume values to null
     1cc:	0e 94 db 07 	call	0xfb6	; 0xfb6 <pga2310_init>
//	relays_in_init();	// ?? nujno li e ?
//	relays_out_init();	// ?? nujno li e ?


}
     1d0:	08 95       	ret

000001d2 <temperMeasur>:
	}
	return 0;
}

char temperMeasur(unsigned char byte0, unsigned char byte1, unsigned char byte6, unsigned char byte7)
{
     1d2:	1f 93       	push	r17
	char tC = 0;
	char temper = 0;
	double k = 0;
	double j = 0;

	byte0 = storeTemp [0];
     1d4:	10 91 38 07 	lds	r17, 0x0738
	byte1 = storeTemp [1];
     1d8:	80 91 39 07 	lds	r24, 0x0739
	byte6 = storeTemp [6];
	byte7 = storeTemp [7];

	k = ((byte7 - byte6) / byte7) + 0.25;

	if((byte1 == 0x00) && (byte0 == 0x00))
     1dc:	88 23       	and	r24, r24
     1de:	61 f5       	brne	.+88     	; 0x238 <temperMeasur+0x66>
     1e0:	11 23       	and	r17, r17
     1e2:	79 f4       	brne	.+30     	; 0x202 <temperMeasur+0x30>
	{
		tC = (byte0/2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     1e4:	85 ef       	ldi	r24, 0xF5	; 245
     1e6:	91 e0       	ldi	r25, 0x01	; 1
     1e8:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     1ec:	80 e0       	ldi	r24, 0x00	; 0
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	0e 94 72 08 	call	0x10e4	; 0x10e4 <transmitUartInt>
		transmitUartString(".0 C\r\n");			// uart debug information string
     1f4:	8f e0       	ldi	r24, 0x0F	; 15
     1f6:	92 e0       	ldi	r25, 0x02	; 2
     1f8:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     1fc:	80 e0       	ldi	r24, 0x00	; 0
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	13 c0       	rjmp	.+38     	; 0x228 <temperMeasur+0x56>
	LCD_DATA_STRING(".0 C");		//
	}
	else if((byte1 == 0x00) && (byte0 != 0x00))
	{
		transmitUartString("+");
     202:	8b e1       	ldi	r24, 0x1B	; 27
     204:	92 e0       	ldi	r25, 0x02	; 2
     206:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		tC = (byte0/2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     20a:	85 ef       	ldi	r24, 0xF5	; 245
     20c:	91 e0       	ldi	r25, 0x01	; 1
     20e:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     212:	16 95       	lsr	r17
     214:	81 2f       	mov	r24, r17
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	0e 94 72 08 	call	0x10e4	; 0x10e4 <transmitUartInt>
		transmitUartString(".0 C\r\n");			// uart debug information string
     21c:	8f e0       	ldi	r24, 0x0F	; 15
     21e:	92 e0       	ldi	r25, 0x02	; 2
     220:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     224:	81 2f       	mov	r24, r17
     226:	90 e0       	ldi	r25, 0x00	; 0
     228:	0e 94 8c 07 	call	0xf18	; 0xf18 <LCD_DATA_INT>
	LCD_DATA_STRING(".0 C");		//
     22c:	86 e1       	ldi	r24, 0x16	; 22
     22e:	92 e0       	ldi	r25, 0x02	; 2
     230:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
     234:	80 e0       	ldi	r24, 0x00	; 0
     236:	1b c0       	rjmp	.+54     	; 0x26e <temperMeasur+0x9c>
	}
	else if((byte1 == 0xFF) && (byte0 != 0x00))
     238:	8f 3f       	cpi	r24, 0xFF	; 255
     23a:	a1 f4       	brne	.+40     	; 0x264 <temperMeasur+0x92>
     23c:	11 23       	and	r17, r17
     23e:	91 f0       	breq	.+36     	; 0x264 <temperMeasur+0x92>
	{
		transmitUartString("-");
     240:	8d e1       	ldi	r24, 0x1D	; 29
     242:	92 e0       	ldi	r25, 0x02	; 2
     244:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
//		tC = ((byte0 - 255.5) / 2);		// ne e dobre obraboteno za otricatelni chisla
		tC = ((byte0 - 255) / 2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     248:	85 ef       	ldi	r24, 0xF5	; 245
     24a:	91 e0       	ldi	r25, 0x01	; 1
     24c:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     250:	81 2f       	mov	r24, r17
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	8f 5f       	subi	r24, 0xFF	; 255
     256:	90 40       	sbci	r25, 0x00	; 0
     258:	62 e0       	ldi	r22, 0x02	; 2
     25a:	70 e0       	ldi	r23, 0x00	; 0
     25c:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <__divmodhi4>
     260:	16 2f       	mov	r17, r22
     262:	d8 cf       	rjmp	.-80     	; 0x214 <temperMeasur+0x42>
	}
	else
	{
		//lcdDataString("ERROR!");	// ERROR not return to display!!!!
	#ifdef DEBUG_ERROR
		transmitUartString("[UART ERROR] ERROR TEMPERATURE\r\n");		// uart debug information string
     264:	8f e1       	ldi	r24, 0x1F	; 31
     266:	92 e0       	ldi	r25, 0x02	; 2
     268:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
     26c:	81 e0       	ldi	r24, 0x01	; 1
	#endif
		return 1;
	}

	return temper;
}
     26e:	1f 91       	pop	r17
     270:	08 95       	ret

00000272 <oneWireRight>:
	}
	return 0;
}

unsigned char oneWireRight()
{
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
	unsigned char i;

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
     276:	80 e4       	ldi	r24, 0x40	; 64
     278:	92 e0       	ldi	r25, 0x02	; 2
     27a:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     27e:	0e 94 78 05 	call	0xaf0	; 0xaf0 <reset>
     282:	88 23       	and	r24, r24
     284:	09 f4       	brne	.+2      	; 0x288 <oneWireRight+0x16>
     286:	4d c0       	rjmp	.+154    	; 0x322 <oneWireRight+0xb0>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     288:	85 e5       	ldi	r24, 0x55	; 85
     28a:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		// 64-bit ROM CODE
		write_byte(0x10);	// Byte 0
     28e:	80 e1       	ldi	r24, 0x10	; 16
     290:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0x6D);	// Byte 1
     294:	8d e6       	ldi	r24, 0x6D	; 109
     296:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0xF4);	// Byte 2
     29a:	84 ef       	ldi	r24, 0xF4	; 244
     29c:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0x8F);	// Byte 3
     2a0:	8f e8       	ldi	r24, 0x8F	; 143
     2a2:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0x02);	// Byte 4
     2a6:	82 e0       	ldi	r24, 0x02	; 2
     2a8:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0x08);	// Byte 5
     2ac:	88 e0       	ldi	r24, 0x08	; 8
     2ae:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0x00);	// Byte 6
     2b2:	80 e0       	ldi	r24, 0x00	; 0
     2b4:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0xB1);	// Byte 7
     2b8:	81 eb       	ldi	r24, 0xB1	; 177
     2ba:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		// 64-bit ROM CODE

		write_byte(0x44);	// Master issues Convert T command.
     2be:	84 e4       	ldi	r24, 0x44	; 68
     2c0:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     2c4:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     2c8:	0e 94 78 05 	call	0xaf0	; 0xaf0 <reset>
     2cc:	88 23       	and	r24, r24
     2ce:	49 f1       	breq	.+82     	; 0x322 <oneWireRight+0xb0>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     2d0:	85 e5       	ldi	r24, 0x55	; 85
     2d2:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			// 64-bit ROM CODE
			write_byte(0x10);	// Byte 0
     2d6:	80 e1       	ldi	r24, 0x10	; 16
     2d8:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0x6D);	// Byte 1
     2dc:	8d e6       	ldi	r24, 0x6D	; 109
     2de:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0xF4);	// Byte 2
     2e2:	84 ef       	ldi	r24, 0xF4	; 244
     2e4:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0x8F);	// Byte 3
     2e8:	8f e8       	ldi	r24, 0x8F	; 143
     2ea:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0x02);	// Byte 4
     2ee:	82 e0       	ldi	r24, 0x02	; 2
     2f0:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0x08);	// Byte 5
     2f4:	88 e0       	ldi	r24, 0x08	; 8
     2f6:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0x00);	// Byte 6
     2fa:	80 e0       	ldi	r24, 0x00	; 0
     2fc:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0xB1);	// Byte 7
     300:	81 eb       	ldi	r24, 0xB1	; 177
     302:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
     306:	8e eb       	ldi	r24, 0xBE	; 190
     308:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
     30c:	c8 e3       	ldi	r28, 0x38	; 56
     30e:	d7 e0       	ldi	r29, 0x07	; 7
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     310:	0e 94 a4 05 	call	0xb48	; 0xb48 <read_byte>
     314:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     316:	87 e0       	ldi	r24, 0x07	; 7
     318:	c1 34       	cpi	r28, 0x41	; 65
     31a:	d8 07       	cpc	r29, r24
     31c:	c9 f7       	brne	.-14     	; 0x310 <oneWireRight+0x9e>
     31e:	81 e0       	ldi	r24, 0x01	; 1
     320:	01 c0       	rjmp	.+2      	; 0x324 <oneWireRight+0xb2>
     322:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     324:	df 91       	pop	r29
     326:	cf 91       	pop	r28
     328:	08 95       	ret

0000032a <oneWireLeft>:

/*******************************************
**** 1-WIRE DS18x20 Temperature Sensors ****
*******************************************/
unsigned char oneWireLeft()
{
     32a:	cf 93       	push	r28
     32c:	df 93       	push	r29
	unsigned char i;

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
     32e:	81 e8       	ldi	r24, 0x81	; 129
     330:	92 e0       	ldi	r25, 0x02	; 2
     332:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     336:	0e 94 78 05 	call	0xaf0	; 0xaf0 <reset>
     33a:	88 23       	and	r24, r24
     33c:	09 f4       	brne	.+2      	; 0x340 <oneWireLeft+0x16>
     33e:	4d c0       	rjmp	.+154    	; 0x3da <oneWireLeft+0xb0>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     340:	85 e5       	ldi	r24, 0x55	; 85
     342:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		// 64-bit ROM CODE
		write_byte(0x10);	// Byte 0
     346:	80 e1       	ldi	r24, 0x10	; 16
     348:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0xDB);	// Byte 1
     34c:	8b ed       	ldi	r24, 0xDB	; 219
     34e:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0x09);	// Byte 2
     352:	89 e0       	ldi	r24, 0x09	; 9
     354:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0xA5);	// Byte 3
     358:	85 ea       	ldi	r24, 0xA5	; 165
     35a:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0x01);	// Byte 4
     35e:	81 e0       	ldi	r24, 0x01	; 1
     360:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0x08);	// Byte 5
     364:	88 e0       	ldi	r24, 0x08	; 8
     366:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0x00);	// Byte 6
     36a:	80 e0       	ldi	r24, 0x00	; 0
     36c:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0xC1);	// Byte 7
     370:	81 ec       	ldi	r24, 0xC1	; 193
     372:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		// 64-bit ROM CODE

		write_byte(0x44);	// Master issues Convert T command.
     376:	84 e4       	ldi	r24, 0x44	; 68
     378:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     37c:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     380:	0e 94 78 05 	call	0xaf0	; 0xaf0 <reset>
     384:	88 23       	and	r24, r24
     386:	49 f1       	breq	.+82     	; 0x3da <oneWireLeft+0xb0>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     388:	85 e5       	ldi	r24, 0x55	; 85
     38a:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			// 64-bit ROM CODE
			write_byte(0x10);	// Byte 0
     38e:	80 e1       	ldi	r24, 0x10	; 16
     390:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0xDB);	// Byte 1
     394:	8b ed       	ldi	r24, 0xDB	; 219
     396:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0x09);	// Byte 2
     39a:	89 e0       	ldi	r24, 0x09	; 9
     39c:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0xA5);	// Byte 3
     3a0:	85 ea       	ldi	r24, 0xA5	; 165
     3a2:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0x01);	// Byte 4
     3a6:	81 e0       	ldi	r24, 0x01	; 1
     3a8:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0x08);	// Byte 5
     3ac:	88 e0       	ldi	r24, 0x08	; 8
     3ae:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0x00);	// Byte 6
     3b2:	80 e0       	ldi	r24, 0x00	; 0
     3b4:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0xC1);	// Byte 7
     3b8:	81 ec       	ldi	r24, 0xC1	; 193
     3ba:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
     3be:	8e eb       	ldi	r24, 0xBE	; 190
     3c0:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
     3c4:	c8 e3       	ldi	r28, 0x38	; 56
     3c6:	d7 e0       	ldi	r29, 0x07	; 7
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     3c8:	0e 94 a4 05 	call	0xb48	; 0xb48 <read_byte>
     3cc:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     3ce:	87 e0       	ldi	r24, 0x07	; 7
     3d0:	c1 34       	cpi	r28, 0x41	; 65
     3d2:	d8 07       	cpc	r29, r24
     3d4:	c9 f7       	brne	.-14     	; 0x3c8 <oneWireLeft+0x9e>
     3d6:	81 e0       	ldi	r24, 0x01	; 1
     3d8:	01 c0       	rjmp	.+2      	; 0x3dc <oneWireLeft+0xb2>
     3da:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     3dc:	df 91       	pop	r29
     3de:	cf 91       	pop	r28
     3e0:	08 95       	ret

000003e2 <temperature>:

/*****************************
**** TEMPERATURE FUNCTION ****
*****************************/
void temperature()
{
     3e2:	cf 93       	push	r28
     3e4:	df 93       	push	r29
	unsigned char i;
//	LED_low_DISPLAYLED_high();
//	LCD_INIT();								// LCD INITIZLIZATION
	LCD_COMMAND(LCD_SELECT_1ROW);	// select row 1
     3e6:	80 e0       	ldi	r24, 0x00	; 0
     3e8:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
	LCD_DATA_STRING("    TEPERATURE    ");		//
     3ec:	81 ec       	ldi	r24, 0xC1	; 193
     3ee:	92 e0       	ldi	r25, 0x02	; 2
     3f0:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
     3f4:	80 ec       	ldi	r24, 0xC0	; 192
     3f6:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
	LCD_DATA_STRING("LEFT  SENSOR: ");				//
     3fa:	84 ed       	ldi	r24, 0xD4	; 212
     3fc:	92 e0       	ldi	r25, 0x02	; 2
     3fe:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>

	oneWireLeft();
     402:	0e 94 95 01 	call	0x32a	; 0x32a <oneWireLeft>
     406:	c0 e0       	ldi	r28, 0x00	; 0
     408:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] byte ");
     40a:	83 ee       	ldi	r24, 0xE3	; 227
     40c:	92 e0       	ldi	r25, 0x02	; 2
     40e:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartInt(i);
     412:	ce 01       	movw	r24, r28
     414:	0e 94 72 08 	call	0x10e4	; 0x10e4 <transmitUartInt>
		transmitUartString(" : ");
     418:	85 ef       	ldi	r24, 0xF5	; 245
     41a:	92 e0       	ldi	r25, 0x02	; 2
     41c:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartInt(storeTemp[i]);
     420:	fe 01       	movw	r30, r28
     422:	e8 5c       	subi	r30, 0xC8	; 200
     424:	f8 4f       	sbci	r31, 0xF8	; 248
     426:	80 81       	ld	r24, Z
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	0e 94 72 08 	call	0x10e4	; 0x10e4 <transmitUartInt>
		transmitUartString("\r\n");
     42e:	8e e3       	ldi	r24, 0x3E	; 62
     430:	91 e0       	ldi	r25, 0x01	; 1
     432:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
     436:	21 96       	adiw	r28, 0x01	; 1
	LCD_DATA_STRING("    TEPERATURE    ");		//
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
	LCD_DATA_STRING("LEFT  SENSOR: ");				//

	oneWireLeft();
	for(i=0; i<9; i++)
     438:	c9 30       	cpi	r28, 0x09	; 9
     43a:	d1 05       	cpc	r29, r1
     43c:	31 f7       	brne	.-52     	; 0x40a <temperature+0x28>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     43e:	80 91 55 07 	lds	r24, 0x0755
     442:	60 91 51 07 	lds	r22, 0x0751
     446:	40 91 50 07 	lds	r20, 0x0750
     44a:	20 91 4d 07 	lds	r18, 0x074D
     44e:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
     452:	84 e9       	ldi	r24, 0x94	; 148
     454:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
     458:	89 ef       	ldi	r24, 0xF9	; 249
     45a:	92 e0       	ldi	r25, 0x02	; 2
     45c:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
	oneWireRight();
     460:	0e 94 39 01 	call	0x272	; 0x272 <oneWireRight>
     464:	c0 e0       	ldi	r28, 0x00	; 0
     466:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] byte ");
     468:	83 ee       	ldi	r24, 0xE3	; 227
     46a:	92 e0       	ldi	r25, 0x02	; 2
     46c:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartInt(i);
     470:	ce 01       	movw	r24, r28
     472:	0e 94 72 08 	call	0x10e4	; 0x10e4 <transmitUartInt>
		transmitUartString(" : ");
     476:	85 ef       	ldi	r24, 0xF5	; 245
     478:	92 e0       	ldi	r25, 0x02	; 2
     47a:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartInt(storeTemp[i]);
     47e:	fe 01       	movw	r30, r28
     480:	e8 5c       	subi	r30, 0xC8	; 200
     482:	f8 4f       	sbci	r31, 0xF8	; 248
     484:	80 81       	ld	r24, Z
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	0e 94 72 08 	call	0x10e4	; 0x10e4 <transmitUartInt>
		transmitUartString("\r\n");
     48c:	8e e3       	ldi	r24, 0x3E	; 62
     48e:	91 e0       	ldi	r25, 0x01	; 1
     490:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
     494:	21 96       	adiw	r28, 0x01	; 1
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
	oneWireRight();
	for(i=0; i<9; i++)
     496:	c9 30       	cpi	r28, 0x09	; 9
     498:	d1 05       	cpc	r29, r1
     49a:	31 f7       	brne	.-52     	; 0x468 <temperature+0x86>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     49c:	80 91 55 07 	lds	r24, 0x0755
     4a0:	60 91 51 07 	lds	r22, 0x0751
     4a4:	40 91 50 07 	lds	r20, 0x0750
     4a8:	20 91 4d 07 	lds	r18, 0x074D
     4ac:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
     4b0:	84 ed       	ldi	r24, 0xD4	; 212
     4b2:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
	LCD_DATA_STRING("             DS18x20");		//
     4b6:	88 e0       	ldi	r24, 0x08	; 8
     4b8:	93 e0       	ldi	r25, 0x03	; 3
     4ba:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
}
     4be:	df 91       	pop	r29
     4c0:	cf 91       	pop	r28
     4c2:	08 95       	ret

000004c4 <commonEncoder>:
**********************************************/
void commonEncoder(void)	// not finished
{
	static signed char saveValue = 0;	// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!! static ???
	signed char temp = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     4c4:	0e 94 52 09 	call	0x12a4	; 0x12a4 <rotaryEncoderNikBarzakov>
	if(0==temp)
     4c8:	88 23       	and	r24, r24
     4ca:	09 f4       	brne	.+2      	; 0x4ce <commonEncoder+0xa>
     4cc:	4f c0       	rjmp	.+158    	; 0x56c <commonEncoder+0xa8>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     4ce:	8f 3f       	cpi	r24, 0xFF	; 255
     4d0:	41 f5       	brne	.+80     	; 0x522 <commonEncoder+0x5e>
	{
		// encoder is decrement
		if(saveValue < -127)
     4d2:	80 91 42 07 	lds	r24, 0x0742
     4d6:	80 38       	cpi	r24, 0x80	; 128
     4d8:	11 f4       	brne	.+4      	; 0x4de <commonEncoder+0x1a>
		{
			saveValue = 127;	// SIGNED CHAR MIN VALUE = -127
     4da:	8f e7       	ldi	r24, 0x7F	; 127
     4dc:	01 c0       	rjmp	.+2      	; 0x4e0 <commonEncoder+0x1c>
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     4de:	81 50       	subi	r24, 0x01	; 1
     4e0:	80 93 42 07 	sts	0x0742, r24
		}
// LCD PRINT VALUE
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     4e4:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     4e6:	8c e0       	ldi	r24, 0x0C	; 12
     4e8:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     4ec:	84 ed       	ldi	r24, 0xD4	; 212
     4ee:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
		if (saveValue > 99)
     4f2:	80 91 42 07 	lds	r24, 0x0742
     4f6:	84 36       	cpi	r24, 0x64	; 100
     4f8:	1c f0       	brlt	.+6      	; 0x500 <commonEncoder+0x3c>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     4fa:	8d e1       	ldi	r24, 0x1D	; 29
     4fc:	93 e0       	ldi	r25, 0x03	; 3
     4fe:	07 c0       	rjmp	.+14     	; 0x50e <commonEncoder+0x4a>
		}
		else if (saveValue > 9)
     500:	8a 30       	cpi	r24, 0x0A	; 10
     502:	1c f0       	brlt	.+6      	; 0x50a <commonEncoder+0x46>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     504:	86 e2       	ldi	r24, 0x26	; 38
     506:	93 e0       	ldi	r25, 0x03	; 3
     508:	02 c0       	rjmp	.+4      	; 0x50e <commonEncoder+0x4a>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     50a:	80 e3       	ldi	r24, 0x30	; 48
     50c:	93 e0       	ldi	r25, 0x03	; 3
     50e:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     512:	80 91 42 07 	lds	r24, 0x0742
     516:	99 27       	eor	r25, r25
     518:	87 fd       	sbrc	r24, 7
     51a:	90 95       	com	r25
     51c:	0e 94 8c 07 	call	0xf18	; 0xf18 <LCD_DATA_INT>
     520:	08 95       	ret
	}
	else if(1==temp)
     522:	81 30       	cpi	r24, 0x01	; 1
     524:	19 f5       	brne	.+70     	; 0x56c <commonEncoder+0xa8>
		{
			saveValue = 128;	// SIGNED CHAR MAX VALUE = +128
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     526:	80 91 42 07 	lds	r24, 0x0742
     52a:	8f 5f       	subi	r24, 0xFF	; 255
     52c:	80 93 42 07 	sts	0x0742, r24
		}

	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     530:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     532:	8c e0       	ldi	r24, 0x0C	; 12
     534:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     538:	84 ed       	ldi	r24, 0xD4	; 212
     53a:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
		if (saveValue > 99)
     53e:	80 91 42 07 	lds	r24, 0x0742
     542:	84 36       	cpi	r24, 0x64	; 100
     544:	1c f0       	brlt	.+6      	; 0x54c <commonEncoder+0x88>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     546:	8d e1       	ldi	r24, 0x1D	; 29
     548:	93 e0       	ldi	r25, 0x03	; 3
     54a:	07 c0       	rjmp	.+14     	; 0x55a <commonEncoder+0x96>
		}
		else if (saveValue > 9)
     54c:	8a 30       	cpi	r24, 0x0A	; 10
     54e:	1c f0       	brlt	.+6      	; 0x556 <commonEncoder+0x92>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     550:	86 e2       	ldi	r24, 0x26	; 38
     552:	93 e0       	ldi	r25, 0x03	; 3
     554:	02 c0       	rjmp	.+4      	; 0x55a <commonEncoder+0x96>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     556:	80 e3       	ldi	r24, 0x30	; 48
     558:	93 e0       	ldi	r25, 0x03	; 3
     55a:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     55e:	80 91 42 07 	lds	r24, 0x0742
     562:	99 27       	eor	r25, r25
     564:	87 fd       	sbrc	r24, 7
     566:	90 95       	com	r25
     568:	0e 94 8c 07 	call	0xf18	; 0xf18 <LCD_DATA_INT>
     56c:	08 95       	ret

0000056e <volumeUpdate>:
/*************************************
**** VOLUME UPDATE and LCD UPDATE ****
*************************************/
void volumeUpdate(void)
{
	PGA2310_Volume_Update(volumeValue[volumeIndex], volumeValue[volumeIndex]);	// update volume value on all channels
     56e:	e0 91 37 07 	lds	r30, 0x0737
     572:	f0 e0       	ldi	r31, 0x00	; 0
     574:	ed 5a       	subi	r30, 0xAD	; 173
     576:	f9 4f       	sbci	r31, 0xF9	; 249
     578:	60 81       	ld	r22, Z
     57a:	86 2f       	mov	r24, r22
     57c:	0e 94 c4 07 	call	0xf88	; 0xf88 <PGA2310_Volume_Update>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     580:	84 ed       	ldi	r24, 0xD4	; 212
     582:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
//		LCD_DATA_STRING("Volume: ");	// 20 symbols
	if (volumeIndex > 9)
     586:	80 91 37 07 	lds	r24, 0x0737
     58a:	8a 30       	cpi	r24, 0x0A	; 10
     58c:	18 f0       	brcs	.+6      	; 0x594 <volumeUpdate+0x26>
	{
		LCD_DATA_STRING("Volume: ");	// 20 symbols
     58e:	8d e1       	ldi	r24, 0x1D	; 29
     590:	93 e0       	ldi	r25, 0x03	; 3
     592:	02 c0       	rjmp	.+4      	; 0x598 <volumeUpdate+0x2a>
	}
	else
	{
		LCD_DATA_STRING("Volume: 0");	// 20 symbols
     594:	86 e2       	ldi	r24, 0x26	; 38
     596:	93 e0       	ldi	r25, 0x03	; 3
     598:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
	}
	LCD_DATA_INT(volumeIndex);			// 20 symbols
     59c:	80 91 37 07 	lds	r24, 0x0737
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	0e 94 8c 07 	call	0xf18	; 0xf18 <LCD_DATA_INT>
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Volume: ");		// uart debug information string
     5a6:	8b e3       	ldi	r24, 0x3B	; 59
     5a8:	93 e0       	ldi	r25, 0x03	; 3
     5aa:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartInt(volumeIndex);		// uart debug information string 
     5ae:	80 91 37 07 	lds	r24, 0x0737
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	0e 94 72 08 	call	0x10e4	; 0x10e4 <transmitUartInt>
		transmitUartString("\r\n");			// uart debug information string
     5b8:	8e e3       	ldi	r24, 0x3E	; 62
     5ba:	91 e0       	ldi	r25, 0x01	; 1
     5bc:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif
}
     5c0:	08 95       	ret

000005c2 <volumeMute>:
/************************************
**** VOLUME MUTE/UNMUTE FUNCTION ****
************************************/
void volumeMute(void)
{
	if(flagStatusBits->flagMute == 0)
     5c2:	e0 91 53 07 	lds	r30, 0x0753
     5c6:	f0 91 54 07 	lds	r31, 0x0754
     5ca:	80 81       	ld	r24, Z
     5cc:	81 fd       	sbrc	r24, 1
     5ce:	0c c0       	rjmp	.+24     	; 0x5e8 <volumeMute+0x26>
	{
		volumeBuffer = volumeIndex;		// strore volume volue
     5d0:	80 91 37 07 	lds	r24, 0x0737
     5d4:	80 93 36 07 	sts	0x0736, r24
		volumeIndex = VOLUME_MUTE;		// MUTE ON
     5d8:	10 92 37 07 	sts	0x0737, r1
		flagStatusBits->flagMute = 1;	// MUTE ON
     5dc:	80 81       	ld	r24, Z
     5de:	82 60       	ori	r24, 0x02	; 2
     5e0:	80 83       	st	Z, r24
		#ifdef DEBUG_INFO
			transmitUartString("[UART INFO] Volume mute is on\r\n");
     5e2:	80 e5       	ldi	r24, 0x50	; 80
     5e4:	93 e0       	ldi	r25, 0x03	; 3
     5e6:	0b c0       	rjmp	.+22     	; 0x5fe <volumeMute+0x3c>
		#endif
	}
	else
	{
		volumeIndex = volumeBuffer;		// MUTE OFF
     5e8:	80 91 36 07 	lds	r24, 0x0736
     5ec:	80 93 37 07 	sts	0x0737, r24
		volumeBuffer = VOLUME_MUTE;		// clear volume volue
     5f0:	10 92 36 07 	sts	0x0736, r1
		flagStatusBits->flagMute = 0;	// MUTE OFF
     5f4:	80 81       	ld	r24, Z
     5f6:	8d 7f       	andi	r24, 0xFD	; 253
     5f8:	80 83       	st	Z, r24
		#ifdef DEBUG_INFO
			transmitUartString("[UART INFO] Volume mute is off\r\n");
     5fa:	80 e7       	ldi	r24, 0x70	; 112
     5fc:	93 e0       	ldi	r25, 0x03	; 3
     5fe:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		#endif
	}
	volumeUpdate();
     602:	0e 94 b7 02 	call	0x56e	; 0x56e <volumeUpdate>
}
     606:	08 95       	ret

00000608 <volumeProcessRemote>:
/********************************************
**** VOLUME PROCESS FUNCTION FROM REMOTE ****
********************************************/
void volumeProcessRemote(signed char temp)
{
	if(-1==temp)
     608:	8f 3f       	cpi	r24, 0xFF	; 255
     60a:	69 f4       	brne	.+26     	; 0x626 <volumeProcessRemote+0x1e>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     60c:	80 91 37 07 	lds	r24, 0x0737
     610:	88 23       	and	r24, r24
     612:	19 f4       	brne	.+6      	; 0x61a <volumeProcessRemote+0x12>
		{
			volumeIndex = VOLUME_MUTE;
     614:	10 92 37 07 	sts	0x0737, r1
     618:	03 c0       	rjmp	.+6      	; 0x620 <volumeProcessRemote+0x18>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     61a:	81 50       	subi	r24, 0x01	; 1
     61c:	80 93 37 07 	sts	0x0737, r24
		}
		volumeUpdate();
     620:	0e 94 b7 02 	call	0x56e	; 0x56e <volumeUpdate>
     624:	08 95       	ret
	}
	else if(1==temp)
     626:	81 30       	cpi	r24, 0x01	; 1
     628:	59 f4       	brne	.+22     	; 0x640 <volumeProcessRemote+0x38>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     62a:	80 91 37 07 	lds	r24, 0x0737
     62e:	83 31       	cpi	r24, 0x13	; 19
     630:	10 f0       	brcs	.+4      	; 0x636 <volumeProcessRemote+0x2e>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     632:	83 e1       	ldi	r24, 0x13	; 19
     634:	01 c0       	rjmp	.+2      	; 0x638 <volumeProcessRemote+0x30>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     636:	8f 5f       	subi	r24, 0xFF	; 255
     638:	80 93 37 07 	sts	0x0737, r24
		}
		volumeUpdate();
     63c:	0e 94 b7 02 	call	0x56e	; 0x56e <volumeUpdate>
     640:	08 95       	ret

00000642 <volumeProcess>:
**** VOLUME PROCESS FUNCTION FROM ENCODER ****
*********************************************/
void volumeProcess(void)
{
	signed char temp = 0;//, tempEnc = 0, tempRem = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     642:	0e 94 52 09 	call	0x12a4	; 0x12a4 <rotaryEncoderNikBarzakov>
	if(0==temp)
     646:	88 23       	and	r24, r24
     648:	e1 f0       	breq	.+56     	; 0x682 <volumeProcess+0x40>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     64a:	8f 3f       	cpi	r24, 0xFF	; 255
     64c:	69 f4       	brne	.+26     	; 0x668 <volumeProcess+0x26>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     64e:	80 91 37 07 	lds	r24, 0x0737
     652:	88 23       	and	r24, r24
     654:	19 f4       	brne	.+6      	; 0x65c <volumeProcess+0x1a>
		{
			volumeIndex = VOLUME_MUTE;
     656:	10 92 37 07 	sts	0x0737, r1
     65a:	03 c0       	rjmp	.+6      	; 0x662 <volumeProcess+0x20>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     65c:	81 50       	subi	r24, 0x01	; 1
     65e:	80 93 37 07 	sts	0x0737, r24
		}
		volumeUpdate();
     662:	0e 94 b7 02 	call	0x56e	; 0x56e <volumeUpdate>
     666:	08 95       	ret
	}
	else if(1==temp)
     668:	81 30       	cpi	r24, 0x01	; 1
     66a:	59 f4       	brne	.+22     	; 0x682 <volumeProcess+0x40>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     66c:	80 91 37 07 	lds	r24, 0x0737
     670:	83 31       	cpi	r24, 0x13	; 19
     672:	10 f0       	brcs	.+4      	; 0x678 <volumeProcess+0x36>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     674:	83 e1       	ldi	r24, 0x13	; 19
     676:	01 c0       	rjmp	.+2      	; 0x67a <volumeProcess+0x38>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     678:	8f 5f       	subi	r24, 0xFF	; 255
     67a:	80 93 37 07 	sts	0x0737, r24
		}
		volumeUpdate();
     67e:	0e 94 b7 02 	call	0x56e	; 0x56e <volumeUpdate>
     682:	08 95       	ret

00000684 <ampliferOff>:
/*********************
**** AMPLIFER OFF ****
*********************/
void ampliferOff(void)
{
	flagStatusBits->flagPower = 0;		// flag for amplifer off
     684:	e0 91 53 07 	lds	r30, 0x0753
     688:	f0 91 54 07 	lds	r31, 0x0754
     68c:	80 81       	ld	r24, Z
     68e:	8e 7f       	andi	r24, 0xFE	; 254
     690:	80 83       	st	Z, r24

	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     692:	80 e0       	ldi	r24, 0x00	; 0
     694:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer Off    ");	// 20 symbols
     698:	81 e9       	ldi	r24, 0x91	; 145
     69a:	93 e0       	ldi	r25, 0x03	; 3
     69c:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>

	LCD_COMMAND(LCD_OFF);						// LCD ON without CURSOR
     6a0:	88 e0       	ldi	r24, 0x08	; 8
     6a2:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>

//			FAN_low();		// PORTD5 - FAN OFF (logic "0")  NON PWM, NON TIMER1

// RELAYS OFF FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays out for all 6 channels\r\n");		// uart debug information string
     6a6:	86 ea       	ldi	r24, 0xA6	; 166
     6a8:	93 e0       	ldi	r25, 0x03	; 3
     6aa:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif
	relays_out_off();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     6ae:	0e 94 f6 09 	call	0x13ec	; 0x13ec <relays_out_off>
     6b2:	88 e5       	ldi	r24, 0x58	; 88
     6b4:	9b e1       	ldi	r25, 0x1B	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     6b6:	20 e9       	ldi	r18, 0x90	; 144
     6b8:	31 e0       	ldi	r19, 0x01	; 1
     6ba:	f9 01       	movw	r30, r18
     6bc:	31 97       	sbiw	r30, 0x01	; 1
     6be:	f1 f7       	brne	.-4      	; 0x6bc <ampliferOff+0x38>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6c0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     6c2:	d9 f7       	brne	.-10     	; 0x6ba <ampliferOff+0x36>
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays in for all 6 channels\r\n");		// uart debug information string
     6c4:	84 ee       	ldi	r24, 0xE4	; 228
     6c6:	93 e0       	ldi	r25, 0x03	; 3
     6c8:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif
	relays_in_off();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     6cc:	0e 94 cf 09 	call	0x139e	; 0x139e <relays_in_off>
     6d0:	88 e5       	ldi	r24, 0x58	; 88
     6d2:	9b e1       	ldi	r25, 0x1B	; 27
     6d4:	20 e9       	ldi	r18, 0x90	; 144
     6d6:	31 e0       	ldi	r19, 0x01	; 1
     6d8:	f9 01       	movw	r30, r18
     6da:	31 97       	sbiw	r30, 0x01	; 1
     6dc:	f1 f7       	brne	.-4      	; 0x6da <ampliferOff+0x56>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6de:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     6e0:	d9 f7       	brne	.-10     	; 0x6d8 <ampliferOff+0x54>
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays for power 220V\r\n");		// uart debug information string
     6e2:	81 e2       	ldi	r24, 0x21	; 33
     6e4:	94 e0       	ldi	r25, 0x04	; 4
     6e6:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif
	REL_POWER_low();// RELAY POWER OFF				// PESHO COMMENT 14.08.2015, 21:10
     6ea:	aa 98       	cbi	0x15, 2	; 21

// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan is off\r\n");
     6ec:	87 e5       	ldi	r24, 0x57	; 87
     6ee:	94 e0       	ldi	r25, 0x04	; 4
     6f0:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
//	OCR1BL = 1; // LED PWM ON
}

void timer1_off()
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     6f4:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     6f6:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     6f8:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     6fa:	1a bc       	out	0x2a, r1	; 42
		transmitUartString("[UART INFO] Fan is off\r\n");
	#endif
	FAN_PWM_OFF();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1

// FANS FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();
     6fc:	0e 94 de 06 	call	0xdbc	; 0xdbc <LCD_CLEAR_CONTAIN>
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display off and status led on\r\n");
     700:	80 e7       	ldi	r24, 0x70	; 112
     702:	94 e0       	ldi	r25, 0x04	; 4
     704:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif

// LED ON FUNC
	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     708:	94 9a       	sbi	0x12, 4	; 18

// UART MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Amplifer is off\r\n");
     70a:	8c e9       	ldi	r24, 0x9C	; 156
     70c:	94 e0       	ldi	r25, 0x04	; 4
     70e:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
     712:	88 e8       	ldi	r24, 0x88	; 136
     714:	93 e1       	ldi	r25, 0x13	; 19
     716:	20 e9       	ldi	r18, 0x90	; 144
     718:	31 e0       	ldi	r19, 0x01	; 1
     71a:	f9 01       	movw	r30, r18
     71c:	31 97       	sbiw	r30, 0x01	; 1
     71e:	f1 f7       	brne	.-4      	; 0x71c <ampliferOff+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     720:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     722:	d9 f7       	brne	.-10     	; 0x71a <ampliferOff+0x96>
	#endif

	_delay_ms(500);	// izchakvane pri natiskane za izkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton
}
     724:	08 95       	ret

00000726 <ampliferOn>:
/********************
**** AMPLIFER ON ****
********************/
void ampliferOn(void)
{
	flagStatusBits->flagPower = 1;		// flag for amplifer on
     726:	e0 91 53 07 	lds	r30, 0x0753
     72a:	f0 91 54 07 	lds	r31, 0x0754
     72e:	80 81       	ld	r24, Z
     730:	81 60       	ori	r24, 0x01	; 1
     732:	80 83       	st	Z, r24

// UART MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Amplifer is on\r\n");
     734:	8a eb       	ldi	r24, 0xBA	; 186
     736:	94 e0       	ldi	r25, 0x04	; 4
     738:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display on and status led off\r\n");
     73c:	87 ed       	ldi	r24, 0xD7	; 215
     73e:	94 e0       	ldi	r25, 0x04	; 4
     740:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif

// LED OFF FUNC
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     744:	94 98       	cbi	0x12, 4	; 18

// LCD FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();						// clear all contain on display
     746:	0e 94 de 06 	call	0xdbc	; 0xdbc <LCD_CLEAR_CONTAIN>
	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     74a:	80 e0       	ldi	r24, 0x00	; 0
     74c:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer On     ");	// 20 symbols
     750:	83 e0       	ldi	r24, 0x03	; 3
     752:	95 e0       	ldi	r25, 0x05	; 5
     754:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);				// select row 2
     758:	80 ec       	ldi	r24, 0xC0	; 192
     75a:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
	LCD_DATA_STRING("P.UPINOV  P.STOYANOV");	// 20 symbols //	LCD_EXECUTE_DATA("P.UPINOV  P.STOYANOV",20);	// char "DATA", int 13 of chars of "DATA"
     75e:	88 e1       	ldi	r24, 0x18	; 24
     760:	95 e0       	ldi	r25, 0x05	; 5
     762:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     766:	8c e0       	ldi	r24, 0x0C	; 12
     768:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan is on\r\n");
     76c:	8d e2       	ldi	r24, 0x2D	; 45
     76e:	95 e0       	ldi	r25, 0x05	; 5
     770:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
		transmitUartString("[UART INFO] Fan is always on, it isn't sensitive to temperature, because DS18S20 is disabling\r\n");
     774:	85 e4       	ldi	r24, 0x45	; 69
     776:	95 e0       	ldi	r25, 0x05	; 5
     778:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
/***************************************
******** DEFINITIONS OF TIMER 1 ********
***************************************/
void timer1_on_speed1()
{
	TCCR1A = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     77c:	81 e8       	ldi	r24, 0x81	; 129
     77e:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00010001;
     780:	81 e1       	ldi	r24, 0x11	; 17
     782:	8e bd       	out	0x2e, r24	; 46

	OCR1AH = 0; // FAN PWM ON
     784:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 1; // FAN PWM ON
     786:	81 e0       	ldi	r24, 0x01	; 1
     788:	8a bd       	out	0x2a, r24	; 42
	FAN_PWM_SPEED1();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1
//	FAN_high();			// PORTD5 - FAN ON (logic "1")	NON PWM, NON TIMER1

// RELAYS ON FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays for power 220V\r\n");		// uart debug information string
     78a:	85 ea       	ldi	r24, 0xA5	; 165
     78c:	95 e0       	ldi	r25, 0x05	; 5
     78e:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif
	REL_POWER_high();// RELAY POWER ON TRAFs		// PESHO COMMENT 14.08.2015, 21:10
     792:	aa 9a       	sbi	0x15, 2	; 21
     794:	80 e4       	ldi	r24, 0x40	; 64
     796:	9c e9       	ldi	r25, 0x9C	; 156
     798:	20 e9       	ldi	r18, 0x90	; 144
     79a:	31 e0       	ldi	r19, 0x01	; 1
     79c:	f9 01       	movw	r30, r18
     79e:	31 97       	sbiw	r30, 0x01	; 1
     7a0:	f1 f7       	brne	.-4      	; 0x79e <ampliferOn+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7a2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7a4:	d9 f7       	brne	.-10     	; 0x79c <ampliferOn+0x76>
	_delay_ms(4000);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays in for all 6 channels\r\n");		// uart debug information string
     7a6:	8a ed       	ldi	r24, 0xDA	; 218
     7a8:	95 e0       	ldi	r25, 0x05	; 5
     7aa:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif
	relays_in1_6ch();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     7ae:	0e 94 bb 09 	call	0x1376	; 0x1376 <relays_in1_6ch>
     7b2:	88 e5       	ldi	r24, 0x58	; 88
     7b4:	9b e1       	ldi	r25, 0x1B	; 27
     7b6:	20 e9       	ldi	r18, 0x90	; 144
     7b8:	31 e0       	ldi	r19, 0x01	; 1
     7ba:	f9 01       	movw	r30, r18
     7bc:	31 97       	sbiw	r30, 0x01	; 1
     7be:	f1 f7       	brne	.-4      	; 0x7bc <ampliferOn+0x96>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7c0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7c2:	d9 f7       	brne	.-10     	; 0x7ba <ampliferOn+0x94>
	_delay_ms(700);									// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays out for all 6 channels\r\n");		// uart debug information string
     7c4:	86 e1       	ldi	r24, 0x16	; 22
     7c6:	96 e0       	ldi	r25, 0x06	; 6
     7c8:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
	#endif
	relays_out_6ch();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     7cc:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <relays_out_6ch>
     7d0:	80 e1       	ldi	r24, 0x10	; 16
     7d2:	97 e2       	ldi	r25, 0x27	; 39
     7d4:	20 e9       	ldi	r18, 0x90	; 144
     7d6:	31 e0       	ldi	r19, 0x01	; 1
     7d8:	f9 01       	movw	r30, r18
     7da:	31 97       	sbiw	r30, 0x01	; 1
     7dc:	f1 f7       	brne	.-4      	; 0x7da <ampliferOn+0xb4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7de:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7e0:	d9 f7       	brne	.-10     	; 0x7d8 <ampliferOn+0xb2>
	_delay_ms(1000);	// izchakvane pri natiskane za vkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton
}
     7e2:	08 95       	ret

000007e4 <buttons_press>:


}

void buttons_press()
{
     7e4:	cf 93       	push	r28
     7e6:	df 93       	push	r29
	flagStatusBits = &fSB;
     7e8:	8b e5       	ldi	r24, 0x5B	; 91
     7ea:	97 e0       	ldi	r25, 0x07	; 7
     7ec:	90 93 54 07 	sts	0x0754, r25
     7f0:	80 93 53 07 	sts	0x0753, r24
	flagStatusBits->flagPower=0;	// inicializirane s nuli, no nai veroqtno poradi tova che e globalna stru
     7f4:	80 91 5b 07 	lds	r24, 0x075B
	flagStatusBits->flagMute=0;		// inicializirane
     7f8:	8c 7f       	andi	r24, 0xFC	; 252
     7fa:	80 93 5b 07 	sts	0x075B, r24
     7fe:	c0 e9       	ldi	r28, 0x90	; 144
     800:	d1 e0       	ldi	r29, 0x01	; 1
		LCD_DATA_INT(flagStatusBits->flagMute);		// 20 symbols
	_delay_ms(2000);
*/
	while(1)
	{
		if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)	// obj ptr flagStatusBtnRegister from struct flagStatusBtnOnOff
     802:	b1 99       	sbic	0x16, 1	; 22
     804:	0a c0       	rjmp	.+20     	; 0x81a <buttons_press+0x36>
     806:	e0 91 53 07 	lds	r30, 0x0753
     80a:	f0 91 54 07 	lds	r31, 0x0754
     80e:	80 81       	ld	r24, Z
     810:	80 fd       	sbrc	r24, 0
     812:	03 c0       	rjmp	.+6      	; 0x81a <buttons_press+0x36>
		{
//			flagStatusBits->flagPower = 1;			// filter za buton ON
			ampliferOn();
     814:	0e 94 93 03 	call	0x726	; 0x726 <ampliferOn>
     818:	f4 cf       	rjmp	.-24     	; 0x802 <buttons_press+0x1e>
//			_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
		}
		else if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     81a:	b1 99       	sbic	0x16, 1	; 22
     81c:	0a c0       	rjmp	.+20     	; 0x832 <buttons_press+0x4e>
     81e:	e0 91 53 07 	lds	r30, 0x0753
     822:	f0 91 54 07 	lds	r31, 0x0754
     826:	80 81       	ld	r24, Z
     828:	80 ff       	sbrs	r24, 0
     82a:	03 c0       	rjmp	.+6      	; 0x832 <buttons_press+0x4e>
		{
//			flagStatusBits->flagPower = 0;			// filter za buton OFF
			ampliferOff();
     82c:	0e 94 42 03 	call	0x684	; 0x684 <ampliferOff>
     830:	e8 cf       	rjmp	.-48     	; 0x802 <buttons_press+0x1e>
		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     832:	b2 99       	sbic	0x16, 2	; 22
     834:	11 c0       	rjmp	.+34     	; 0x858 <buttons_press+0x74>
     836:	e0 91 53 07 	lds	r30, 0x0753
     83a:	f0 91 54 07 	lds	r31, 0x0754
     83e:	80 81       	ld	r24, Z
     840:	80 ff       	sbrs	r24, 0
     842:	0a c0       	rjmp	.+20     	; 0x858 <buttons_press+0x74>
		{
//			LCD_DATA_STRING("PRESSED BTN ESCAPE  ");	// 20 symbols
//			LCD_COMMAND(LCD_ON);
			LCD_CLEAR_CONTAIN();
     844:	0e 94 de 06 	call	0xdbc	; 0xdbc <LCD_CLEAR_CONTAIN>
     848:	88 e8       	ldi	r24, 0x88	; 136
     84a:	93 e1       	ldi	r25, 0x13	; 19
     84c:	fe 01       	movw	r30, r28
     84e:	31 97       	sbiw	r30, 0x01	; 1
     850:	f1 f7       	brne	.-4      	; 0x84e <buttons_press+0x6a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     852:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     854:	d9 f7       	brne	.-10     	; 0x84c <buttons_press+0x68>
     856:	d5 cf       	rjmp	.-86     	; 0x802 <buttons_press+0x1e>
			_delay_ms(500);
//			volumeUp();
//			_delay_ms(200);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     858:	83 99       	sbic	0x10, 3	; 16
     85a:	0f c0       	rjmp	.+30     	; 0x87a <__stack+0x1b>
     85c:	e0 91 53 07 	lds	r30, 0x0753
     860:	f0 91 54 07 	lds	r31, 0x0754
     864:	80 81       	ld	r24, Z
     866:	80 ff       	sbrs	r24, 0
     868:	08 c0       	rjmp	.+16     	; 0x87a <__stack+0x1b>
     86a:	88 e8       	ldi	r24, 0x88	; 136
     86c:	93 e1       	ldi	r25, 0x13	; 19
     86e:	fe 01       	movw	r30, r28
     870:	31 97       	sbiw	r30, 0x01	; 1
     872:	f1 f7       	brne	.-4      	; 0x870 <__stack+0x11>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     874:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     876:	d9 f7       	brne	.-10     	; 0x86e <__stack+0xf>
     878:	c4 cf       	rjmp	.-120    	; 0x802 <buttons_press+0x1e>
			_delay_ms(500);
//			volumeDown();
//			_delay_ms(200);

		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     87a:	b2 99       	sbic	0x16, 2	; 22
     87c:	0f c0       	rjmp	.+30     	; 0x89c <__stack+0x3d>
     87e:	e0 91 53 07 	lds	r30, 0x0753
     882:	f0 91 54 07 	lds	r31, 0x0754
     886:	80 81       	ld	r24, Z
     888:	80 fd       	sbrc	r24, 0
     88a:	08 c0       	rjmp	.+16     	; 0x89c <__stack+0x3d>
     88c:	88 e8       	ldi	r24, 0x88	; 136
     88e:	93 e1       	ldi	r25, 0x13	; 19
     890:	fe 01       	movw	r30, r28
     892:	31 97       	sbiw	r30, 0x01	; 1
     894:	f1 f7       	brne	.-4      	; 0x892 <__stack+0x33>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     896:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     898:	d9 f7       	brne	.-10     	; 0x890 <__stack+0x31>
     89a:	b3 cf       	rjmp	.-154    	; 0x802 <buttons_press+0x1e>
//			LCD_COMMAND(LCD_ON);
			_delay_ms(500);
//			setupMode();
//			_delay_ms(1000);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     89c:	83 99       	sbic	0x10, 3	; 16
     89e:	11 c0       	rjmp	.+34     	; 0x8c2 <__stack+0x63>
     8a0:	e0 91 53 07 	lds	r30, 0x0753
     8a4:	f0 91 54 07 	lds	r31, 0x0754
     8a8:	80 81       	ld	r24, Z
     8aa:	80 fd       	sbrc	r24, 0
     8ac:	0a c0       	rjmp	.+20     	; 0x8c2 <__stack+0x63>
		{
			temperature();
     8ae:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <temperature>
     8b2:	88 e8       	ldi	r24, 0x88	; 136
     8b4:	93 e1       	ldi	r25, 0x13	; 19
     8b6:	fe 01       	movw	r30, r28
     8b8:	31 97       	sbiw	r30, 0x01	; 1
     8ba:	f1 f7       	brne	.-4      	; 0x8b8 <__stack+0x59>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8bc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8be:	d9 f7       	brne	.-10     	; 0x8b6 <__stack+0x57>
     8c0:	a0 cf       	rjmp	.-192    	; 0x802 <buttons_press+0x1e>
//			LCD_COMMAND(LCD_OFF);
			_delay_ms(500);
//			about();
//			_delay_ms(1000);
		}
		else if(flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     8c2:	e0 91 53 07 	lds	r30, 0x0753
     8c6:	f0 91 54 07 	lds	r31, 0x0754
     8ca:	80 81       	ld	r24, Z
     8cc:	80 ff       	sbrs	r24, 0
     8ce:	03 c0       	rjmp	.+6      	; 0x8d6 <__stack+0x77>
		{
			volumeProcess();
     8d0:	0e 94 21 03 	call	0x642	; 0x642 <volumeProcess>
     8d4:	96 cf       	rjmp	.-212    	; 0x802 <buttons_press+0x1e>
		}
		else if(flagStatusBits->flagPower == 0)
		{
			commonEncoder();
     8d6:	0e 94 62 02 	call	0x4c4	; 0x4c4 <commonEncoder>
     8da:	93 cf       	rjmp	.-218    	; 0x802 <buttons_press+0x1e>

000008dc <main>:
******************************** START OF MAIN APPLICATION **********************************
********************************************************************************************/

int main(void)
{
	init_all();				// inicializacia na vsichko
     8dc:	0e 94 de 00 	call	0x1bc	; 0x1bc <init_all>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     8e0:	80 e4       	ldi	r24, 0x40	; 64
     8e2:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     8e4:	8a bf       	out	0x3a, r24	; 58
{
	init_all();				// inicializacia na vsichko
	ext0_intrpt_on();		// ENABLE interrupts to access IR DETECTION as call to function "IR_DECODER()" for -> SONY IR REMOTE
//	ext2_intrpt_on();

	sei();							// file "avr/interrupt.h"
     8e6:	78 94       	sei
//	SREG = (1<<I);

	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     8e8:	94 9a       	sbi	0x12, 4	; 18
	while(1)
	{		
		buttons_press();	// izchakvane za natiskane na buton
     8ea:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <buttons_press>
     8ee:	fd cf       	rjmp	.-6      	; 0x8ea <main+0xe>

000008f0 <irDecode>:
************************************/
void irDecode(void)
{
//	byte byteSS0, byteSS1, byteMM0, byteMM1, byteHH0, byteHH1, byteDD0, byteDD1, byteMont0, byteMont1, byteYY0, byteYY1; // variables for convert DEC to BCD for LCD and UART for Time and Date

	GetSIRC12();
     8f0:	0e 94 fe 09 	call	0x13fc	; 0x13fc <GetSIRC12>
	if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 0)		// IR POWER -> ON
     8f4:	90 91 57 07 	lds	r25, 0x0757
     8f8:	91 30       	cpi	r25, 0x01	; 1
     8fa:	29 f4       	brne	.+10     	; 0x906 <irDecode+0x16>
     8fc:	80 91 52 07 	lds	r24, 0x0752
     900:	85 31       	cpi	r24, 0x15	; 21
     902:	99 f4       	brne	.+38     	; 0x92a <irDecode+0x3a>
     904:	06 c0       	rjmp	.+12     	; 0x912 <irDecode+0x22>
     906:	94 30       	cpi	r25, 0x04	; 4
     908:	29 f5       	brne	.+74     	; 0x954 <irDecode+0x64>
     90a:	80 91 52 07 	lds	r24, 0x0752
     90e:	8d 30       	cpi	r24, 0x0D	; 13
     910:	99 f4       	brne	.+38     	; 0x938 <irDecode+0x48>
     912:	e0 91 53 07 	lds	r30, 0x0753
     916:	f0 91 54 07 	lds	r31, 0x0754
     91a:	80 81       	ld	r24, Z
     91c:	80 fd       	sbrc	r24, 0
     91e:	03 c0       	rjmp	.+6      	; 0x926 <irDecode+0x36>
	{		
		ampliferOn();
     920:	0e 94 93 03 	call	0x726	; 0x726 <ampliferOn>
     924:	48 c0       	rjmp	.+144    	; 0x9b6 <irDecode+0xc6>
//		_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 1)	// IR POWER -> OFF
     926:	91 30       	cpi	r25, 0x01	; 1
     928:	29 f4       	brne	.+10     	; 0x934 <irDecode+0x44>
     92a:	80 91 52 07 	lds	r24, 0x0752
     92e:	85 31       	cpi	r24, 0x15	; 21
     930:	a9 f4       	brne	.+42     	; 0x95c <irDecode+0x6c>
     932:	06 c0       	rjmp	.+12     	; 0x940 <irDecode+0x50>
     934:	94 30       	cpi	r25, 0x04	; 4
     936:	71 f4       	brne	.+28     	; 0x954 <irDecode+0x64>
     938:	80 91 52 07 	lds	r24, 0x0752
     93c:	8d 30       	cpi	r24, 0x0D	; 13
     93e:	71 f4       	brne	.+28     	; 0x95c <irDecode+0x6c>
     940:	e0 91 53 07 	lds	r30, 0x0753
     944:	f0 91 54 07 	lds	r31, 0x0754
     948:	80 81       	ld	r24, Z
     94a:	80 ff       	sbrs	r24, 0
     94c:	03 c0       	rjmp	.+6      	; 0x954 <irDecode+0x64>
	{
		ampliferOff();
     94e:	0e 94 42 03 	call	0x684	; 0x684 <ampliferOff>
     952:	31 c0       	rjmp	.+98     	; 0x9b6 <irDecode+0xc6>
//		flagPower = 0;			// filter za buton OFF
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLUP)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME UP"
     954:	91 30       	cpi	r25, 0x01	; 1
     956:	11 f0       	breq	.+4      	; 0x95c <irDecode+0x6c>
     958:	94 30       	cpi	r25, 0x04	; 4
     95a:	69 f5       	brne	.+90     	; 0x9b6 <irDecode+0xc6>
     95c:	20 91 52 07 	lds	r18, 0x0752
     960:	22 31       	cpi	r18, 0x12	; 18
     962:	49 f4       	brne	.+18     	; 0x976 <irDecode+0x86>
     964:	e0 91 53 07 	lds	r30, 0x0753
     968:	f0 91 54 07 	lds	r31, 0x0754
     96c:	80 81       	ld	r24, Z
     96e:	80 ff       	sbrs	r24, 0
     970:	02 c0       	rjmp	.+4      	; 0x976 <irDecode+0x86>
	{	// VOLUME UP
		volumeProcessRemote(REMOTE_VOLUME_UP);
     972:	81 e0       	ldi	r24, 0x01	; 1
     974:	0e c0       	rjmp	.+28     	; 0x992 <irDecode+0xa2>
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLDN)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME DOWN"
     976:	91 30       	cpi	r25, 0x01	; 1
     978:	11 f0       	breq	.+4      	; 0x97e <irDecode+0x8e>
     97a:	94 30       	cpi	r25, 0x04	; 4
     97c:	e1 f4       	brne	.+56     	; 0x9b6 <irDecode+0xc6>
     97e:	23 31       	cpi	r18, 0x13	; 19
     980:	59 f4       	brne	.+22     	; 0x998 <irDecode+0xa8>
     982:	e0 91 53 07 	lds	r30, 0x0753
     986:	f0 91 54 07 	lds	r31, 0x0754
     98a:	80 81       	ld	r24, Z
     98c:	80 ff       	sbrs	r24, 0
     98e:	04 c0       	rjmp	.+8      	; 0x998 <irDecode+0xa8>
	{	// VOLUME DOWN
		volumeProcessRemote(REMOTE_VOLUME_DOWN);
     990:	8f ef       	ldi	r24, 0xFF	; 255
     992:	0e 94 04 03 	call	0x608	; 0x608 <volumeProcessRemote>
     996:	0f c0       	rjmp	.+30     	; 0x9b6 <irDecode+0xc6>
//		break;
	}

	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_ATT)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     998:	91 30       	cpi	r25, 0x01	; 1
     99a:	11 f0       	breq	.+4      	; 0x9a0 <irDecode+0xb0>
     99c:	94 30       	cpi	r25, 0x04	; 4
     99e:	59 f4       	brne	.+22     	; 0x9b6 <irDecode+0xc6>
     9a0:	24 31       	cpi	r18, 0x14	; 20
     9a2:	49 f4       	brne	.+18     	; 0x9b6 <irDecode+0xc6>
     9a4:	e0 91 53 07 	lds	r30, 0x0753
     9a8:	f0 91 54 07 	lds	r31, 0x0754
     9ac:	80 81       	ld	r24, Z
     9ae:	80 ff       	sbrs	r24, 0
     9b0:	02 c0       	rjmp	.+4      	; 0x9b6 <irDecode+0xc6>
	{	// MUTE
		volumeMute();
     9b2:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <volumeMute>
     9b6:	80 ed       	ldi	r24, 0xD0	; 208
     9b8:	97 e0       	ldi	r25, 0x07	; 7
     9ba:	20 e9       	ldi	r18, 0x90	; 144
     9bc:	31 e0       	ldi	r19, 0x01	; 1
     9be:	f9 01       	movw	r30, r18
     9c0:	31 97       	sbiw	r30, 0x01	; 1
     9c2:	f1 f7       	brne	.-4      	; 0x9c0 <irDecode+0xd0>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     9c4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     9c6:	d9 f7       	brne	.-10     	; 0x9be <irDecode+0xce>
	else
	{
		// DO NOTING
	}
	_delay_ms(200);
}
     9c8:	08 95       	ret

000009ca <__vector_1>:

/*****************************************
**** EXTERNAL INTERRUPT 0 VECTOR 01 ******
*****************************************/
ISR(INT0_vect)
{
     9ca:	1f 92       	push	r1
     9cc:	0f 92       	push	r0
     9ce:	0f b6       	in	r0, 0x3f	; 63
     9d0:	0f 92       	push	r0
     9d2:	11 24       	eor	r1, r1
     9d4:	2f 93       	push	r18
     9d6:	3f 93       	push	r19
     9d8:	4f 93       	push	r20
     9da:	5f 93       	push	r21
     9dc:	6f 93       	push	r22
     9de:	7f 93       	push	r23
     9e0:	8f 93       	push	r24
     9e2:	9f 93       	push	r25
     9e4:	af 93       	push	r26
     9e6:	bf 93       	push	r27
     9e8:	ef 93       	push	r30
     9ea:	ff 93       	push	r31
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     9ec:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     9ee:	80 e4       	ldi	r24, 0x40	; 64
     9f0:	8a bf       	out	0x3a, r24	; 58
	ext0_intrpt_off();	// DISABLE new IR DETECTION

// LOGIC CHECK BEGIN
// VERIFY PRESSED IR BUTTON and switch to low line of IR pin PD2
	unsigned char low_level = 0;
    if(irPin == 0)
     9f2:	82 99       	sbic	0x10, 2	; 16
     9f4:	0b c0       	rjmp	.+22     	; 0xa0c <__vector_1+0x42>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     9f6:	8a e0       	ldi	r24, 0x0A	; 10
     9f8:	98 2f       	mov	r25, r24
     9fa:	9a 95       	dec	r25
     9fc:	f1 f7       	brne	.-4      	; 0x9fa <__vector_1+0x30>
     9fe:	98 2f       	mov	r25, r24
     a00:	9a 95       	dec	r25
     a02:	f1 f7       	brne	.-4      	; 0xa00 <__vector_1+0x36>
     a04:	8a 95       	dec	r24
     a06:	f1 f7       	brne	.-4      	; 0xa04 <__vector_1+0x3a>
			_delay_us(2);	//2uS delay
		}

		if(low_level == 3)
		{
			irDecode();
     a08:	0e 94 78 04 	call	0x8f0	; 0x8f0 <irDecode>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     a0c:	80 e4       	ldi	r24, 0x40	; 64
     a0e:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     a10:	8a bf       	out	0x3a, r24	; 58
		}
    }
// LOGIC CHECK END

	ext0_intrpt_on();	// ENABLE new IR DETECTION
}
     a12:	ff 91       	pop	r31
     a14:	ef 91       	pop	r30
     a16:	bf 91       	pop	r27
     a18:	af 91       	pop	r26
     a1a:	9f 91       	pop	r25
     a1c:	8f 91       	pop	r24
     a1e:	7f 91       	pop	r23
     a20:	6f 91       	pop	r22
     a22:	5f 91       	pop	r21
     a24:	4f 91       	pop	r20
     a26:	3f 91       	pop	r19
     a28:	2f 91       	pop	r18
     a2a:	0f 90       	pop	r0
     a2c:	0f be       	out	0x3f, r0	; 63
     a2e:	0f 90       	pop	r0
     a30:	1f 90       	pop	r1
     a32:	18 95       	reti

00000a34 <eeprom_24c64_read>:
	// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
	// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !
	
	byte eepromReceiveByte0, eepromReceiveByte1, eepromReceiveByte2, eepromReceiveByte3, eepromReceiveByte4, eepromReceiveByte5;
// EEPROM READ
	i2c_start();
     a34:	0e 94 28 06 	call	0xc50	; 0xc50 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);		// EEPROM 24C64 ADDRESS ACCESS WRITE
     a38:	80 ea       	ldi	r24, 0xA0	; 160
     a3a:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     a3e:	80 e0       	ldi	r24, 0x00	; 0
     a40:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     a44:	80 e0       	ldi	r24, 0x00	; 0
     a46:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>

	i2c_start();
     a4a:	0e 94 28 06 	call	0xc50	; 0xc50 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_READ);		// EEPROM 24C64 ADDRESS ACCESS READ
     a4e:	81 ea       	ldi	r24, 0xA1	; 161
     a50:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
	eepromReceiveByte0	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	0e 94 38 06 	call	0xc70	; 0xc70 <i2c_read>
	eepromReceiveByte1	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     a5a:	80 e0       	ldi	r24, 0x00	; 0
     a5c:	0e 94 38 06 	call	0xc70	; 0xc70 <i2c_read>
	eepromReceiveByte2	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     a60:	80 e0       	ldi	r24, 0x00	; 0
     a62:	0e 94 38 06 	call	0xc70	; 0xc70 <i2c_read>
	eepromReceiveByte3	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     a66:	80 e0       	ldi	r24, 0x00	; 0
     a68:	0e 94 38 06 	call	0xc70	; 0xc70 <i2c_read>
	eepromReceiveByte4	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     a6c:	80 e0       	ldi	r24, 0x00	; 0
     a6e:	0e 94 38 06 	call	0xc70	; 0xc70 <i2c_read>
	eepromReceiveByte5	= i2c_read(1);				// EEPROM DATA READ BYTE	// i2c_read(1) parametar razlichen ot 0 spira komunikaciqta NACK
     a72:	81 e0       	ldi	r24, 0x01	; 1
     a74:	0e 94 38 06 	call	0xc70	; 0xc70 <i2c_read>
	i2c_stop();
     a78:	0e 94 2e 06 	call	0xc5c	; 0xc5c <i2c_stop>
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte2);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte3);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte4);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte5);
*/
}
     a7c:	08 95       	ret

00000a7e <eeprom_24c64_write>:
// Za da se vijda tova koeto se e zapisalo v pametta, a ne ot tozi bibliotechen fail !!!!!!!!!
// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !

// EEPROM WRITE
	i2c_start();
     a7e:	0e 94 28 06 	call	0xc50	; 0xc50 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     a82:	80 ea       	ldi	r24, 0xA0	; 160
     a84:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     a8e:	80 e0       	ldi	r24, 0x00	; 0
     a90:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
// Write data
	i2c_write(0x30);	// Data is stored: 0x30 - '0'
     a94:	80 e3       	ldi	r24, 0x30	; 48
     a96:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
	i2c_write(0x31);	// Data is stored: 0x31 - '1'
     a9a:	81 e3       	ldi	r24, 0x31	; 49
     a9c:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
	i2c_write(0x32);	// Data is stored: 0x32 - '2'
     aa0:	82 e3       	ldi	r24, 0x32	; 50
     aa2:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
	i2c_write(0x33);	// Data is stored: 0x33 - '3'
     aa6:	83 e3       	ldi	r24, 0x33	; 51
     aa8:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
	i2c_write(0x34);	// Data is stored: 0x34 - '4'
     aac:	84 e3       	ldi	r24, 0x34	; 52
     aae:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
	i2c_stop();
     ab2:	0e 94 2e 06 	call	0xc5c	; 0xc5c <i2c_stop>
}
     ab6:	08 95       	ret

00000ab8 <eeprom_24c64_reset>:

/*************************************
** RESET AND ZERO FILL EEPROM 24C64 **
*************************************/
void eeprom_24c64_reset()
{
     ab8:	cf 93       	push	r28
     aba:	df 93       	push	r29
	unsigned int i;	// 16 bits
// EEPROM WRITE
	i2c_start();
     abc:	0e 94 28 06 	call	0xc50	; 0xc50 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     ac0:	80 ea       	ldi	r24, 0xA0	; 160
     ac2:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     ac6:	80 e0       	ldi	r24, 0x00	; 0
     ac8:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     acc:	80 e0       	ldi	r24, 0x00	; 0
     ace:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
     ad2:	c0 e0       	ldi	r28, 0x00	; 0
     ad4:	d0 e0       	ldi	r29, 0x00	; 0
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
     ad6:	80 e0       	ldi	r24, 0x00	; 0
     ad8:	0e 94 31 06 	call	0xc62	; 0xc62 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
     adc:	21 96       	adiw	r28, 0x01	; 1
     ade:	8f e1       	ldi	r24, 0x1F	; 31
     ae0:	cf 3f       	cpi	r28, 0xFF	; 255
     ae2:	d8 07       	cpc	r29, r24
     ae4:	c1 f7       	brne	.-16     	; 0xad6 <eeprom_24c64_reset+0x1e>
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
	}
	i2c_stop();
     ae6:	0e 94 2e 06 	call	0xc5c	; 0xc5c <i2c_stop>
}
     aea:	df 91       	pop	r29
     aec:	cf 91       	pop	r28
     aee:	08 95       	ret

00000af0 <reset>:
}
*/

unsigned char reset(void)
{
    DDRx |= (1<<Px);            //Ausgang
     af0:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     af2:	c0 98       	cbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     af4:	80 e8       	ldi	r24, 0x80	; 128
     af6:	97 e0       	ldi	r25, 0x07	; 7
     af8:	01 97       	sbiw	r24, 0x01	; 1
     afa:	f1 f7       	brne	.-4      	; 0xaf8 <reset+0x8>
    _delay_us(480);
	DDRx &= ~(1<<Px);
     afc:	b8 98       	cbi	0x17, 0	; 23
     afe:	80 e4       	ldi	r24, 0x40	; 64
     b00:	91 e0       	ldi	r25, 0x01	; 1
     b02:	01 97       	sbiw	r24, 0x01	; 1
     b04:	f1 f7       	brne	.-4      	; 0xb02 <reset+0x12>
    _delay_us(80);
	if(!(PINx & (1<<Px)))     //Prüfe Slave-Antwort
     b06:	b0 9b       	sbis	0x16, 0	; 22
     b08:	02 c0       	rjmp	.+4      	; 0xb0e <reset+0x1e>
     b0a:	80 e0       	ldi	r24, 0x00	; 0
     b0c:	08 95       	ret
     b0e:	88 e0       	ldi	r24, 0x08	; 8
     b10:	97 e0       	ldi	r25, 0x07	; 7
     b12:	01 97       	sbiw	r24, 0x01	; 1
     b14:	f1 f7       	brne	.-4      	; 0xb12 <reset+0x22>
     b16:	81 e0       	ldi	r24, 0x01	; 1
	}
    else
	{
        return 0;
	}
}
     b18:	08 95       	ret

00000b1a <read_bit>:

unsigned char read_bit(void)
{
    DDRx |= (1<<Px);            //Ausgang
     b1a:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     b1c:	c0 98       	cbi	0x18, 0	; 24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     b1e:	85 e0       	ldi	r24, 0x05	; 5
     b20:	8a 95       	dec	r24
     b22:	f1 f7       	brne	.-4      	; 0xb20 <read_bit+0x6>
    _delay_us(1);
	DDRx &= ~(1<<Px);
     b24:	b8 98       	cbi	0x17, 0	; 23
     b26:	80 e4       	ldi	r24, 0x40	; 64
     b28:	8a 95       	dec	r24
     b2a:	f1 f7       	brne	.-4      	; 0xb28 <read_bit+0xe>
    _delay_us(12);
    if(!(PINx & (1<<Px)))       //Abtastung innerhalb von 15µs
     b2c:	86 b3       	in	r24, 0x16	; 22
	}
	else
    {
		return 1;
	}
}
     b2e:	81 70       	andi	r24, 0x01	; 1
     b30:	08 95       	ret

00000b32 <write_bit>:

void write_bit(unsigned char bitval)    //kann 0 oder 1 sein
{
    DDRx |= (1<<Px);            //Ausgang
     b32:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     b34:	c0 98       	cbi	0x18, 0	; 24
    if(bitval)
     b36:	81 11       	cpse	r24, r1
	{
        PORTx |= (1<<Px);      //H-Pegel
     b38:	c0 9a       	sbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     b3a:	88 eb       	ldi	r24, 0xB8	; 184
     b3c:	91 e0       	ldi	r25, 0x01	; 1
     b3e:	01 97       	sbiw	r24, 0x01	; 1
     b40:	f1 f7       	brne	.-4      	; 0xb3e <write_bit+0xc>
    }
	_delay_us(110);        
    DDRx &= ~(1<<Px);
     b42:	b8 98       	cbi	0x17, 0	; 23
    PORTx &= ~(1<<Px);
     b44:	c0 98       	cbi	0x18, 0	; 24
}
     b46:	08 95       	ret

00000b48 <read_byte>:

unsigned char read_byte(void)
{
     b48:	cf 92       	push	r12
     b4a:	df 92       	push	r13
     b4c:	ef 92       	push	r14
     b4e:	ff 92       	push	r15
     b50:	1f 93       	push	r17
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	10 e0       	ldi	r17, 0x00	; 0
     b58:	c0 e0       	ldi	r28, 0x00	; 0
     b5a:	d0 e0       	ldi	r29, 0x00	; 0
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
		{
            byte |= (1<<i);
     b5c:	91 e0       	ldi	r25, 0x01	; 1
     b5e:	c9 2e       	mov	r12, r25
     b60:	d1 2c       	mov	r13, r1
     b62:	80 ee       	ldi	r24, 0xE0	; 224
     b64:	e8 2e       	mov	r14, r24
     b66:	81 e0       	ldi	r24, 0x01	; 1
     b68:	f8 2e       	mov	r15, r24
unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
     b6a:	0e 94 8d 05 	call	0xb1a	; 0xb1a <read_bit>
     b6e:	88 23       	and	r24, r24
     b70:	41 f0       	breq	.+16     	; 0xb82 <read_byte+0x3a>
		{
            byte |= (1<<i);
     b72:	c6 01       	movw	r24, r12
     b74:	0c 2e       	mov	r0, r28
     b76:	02 c0       	rjmp	.+4      	; 0xb7c <read_byte+0x34>
     b78:	88 0f       	add	r24, r24
     b7a:	99 1f       	adc	r25, r25
     b7c:	0a 94       	dec	r0
     b7e:	e2 f7       	brpl	.-8      	; 0xb78 <read_byte+0x30>
     b80:	18 2b       	or	r17, r24
     b82:	c7 01       	movw	r24, r14
     b84:	01 97       	sbiw	r24, 0x01	; 1
     b86:	f1 f7       	brne	.-4      	; 0xb84 <read_byte+0x3c>
     b88:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
     b8a:	c8 30       	cpi	r28, 0x08	; 8
     b8c:	d1 05       	cpc	r29, r1
     b8e:	69 f7       	brne	.-38     	; 0xb6a <read_byte+0x22>
            byte |= (1<<i);
		}
        _delay_us(120);
    }
    return byte;
}
     b90:	81 2f       	mov	r24, r17
     b92:	df 91       	pop	r29
     b94:	cf 91       	pop	r28
     b96:	1f 91       	pop	r17
     b98:	ff 90       	pop	r15
     b9a:	ef 90       	pop	r14
     b9c:	df 90       	pop	r13
     b9e:	cf 90       	pop	r12
     ba0:	08 95       	ret

00000ba2 <write_byte>:

void write_byte(unsigned char byte)
{
     ba2:	0f 93       	push	r16
     ba4:	1f 93       	push	r17
     ba6:	cf 93       	push	r28
     ba8:	df 93       	push	r29
     baa:	c0 e0       	ldi	r28, 0x00	; 0
     bac:	d0 e0       	ldi	r29, 0x00	; 0
    for(unsigned char i=0; i<8; i++)
	{
        if(byte & (1<<i))
     bae:	08 2f       	mov	r16, r24
     bb0:	10 e0       	ldi	r17, 0x00	; 0
     bb2:	c8 01       	movw	r24, r16
     bb4:	0c 2e       	mov	r0, r28
     bb6:	02 c0       	rjmp	.+4      	; 0xbbc <write_byte+0x1a>
     bb8:	95 95       	asr	r25
     bba:	87 95       	ror	r24
     bbc:	0a 94       	dec	r0
     bbe:	e2 f7       	brpl	.-8      	; 0xbb8 <write_byte+0x16>
     bc0:	80 ff       	sbrs	r24, 0
     bc2:	02 c0       	rjmp	.+4      	; 0xbc8 <write_byte+0x26>
		{
			write_bit(1);
     bc4:	81 e0       	ldi	r24, 0x01	; 1
     bc6:	01 c0       	rjmp	.+2      	; 0xbca <write_byte+0x28>
		}
        else
		{
            write_bit(0);
     bc8:	80 e0       	ldi	r24, 0x00	; 0
     bca:	0e 94 99 05 	call	0xb32	; 0xb32 <write_bit>
     bce:	21 96       	adiw	r28, 0x01	; 1
    return byte;
}

void write_byte(unsigned char byte)
{
    for(unsigned char i=0; i<8; i++)
     bd0:	c8 30       	cpi	r28, 0x08	; 8
     bd2:	d1 05       	cpc	r29, r1
     bd4:	71 f7       	brne	.-36     	; 0xbb2 <write_byte+0x10>
     bd6:	80 ee       	ldi	r24, 0xE0	; 224
     bd8:	91 e0       	ldi	r25, 0x01	; 1
     bda:	01 97       	sbiw	r24, 0x01	; 1
     bdc:	f1 f7       	brne	.-4      	; 0xbda <write_byte+0x38>
		{
            write_bit(0);
		}
	}
    _delay_us(120);
}  
     bde:	df 91       	pop	r29
     be0:	cf 91       	pop	r28
     be2:	1f 91       	pop	r17
     be4:	0f 91       	pop	r16
     be6:	08 95       	ret

00000be8 <wait_ready>:
	return 0;
}

void wait_ready(void)
{
	while(!(read_bit()));
     be8:	0e 94 8d 05 	call	0xb1a	; 0xb1a <read_bit>
     bec:	88 23       	and	r24, r24
     bee:	e1 f3       	breq	.-8      	; 0xbe8 <wait_ready>
}
     bf0:	08 95       	ret

00000bf2 <read_scratchpad>:
	}
    _delay_us(120);
}  

unsigned char read_scratchpad(void)
{
     bf2:	cf 93       	push	r28
     bf4:	df 93       	push	r29

	if(reset())
     bf6:	0e 94 78 05 	call	0xaf0	; 0xaf0 <reset>
     bfa:	88 23       	and	r24, r24
     bfc:	e9 f0       	breq	.+58     	; 0xc38 <read_scratchpad+0x46>
	{
		write_byte(0xCC);
     bfe:	8c ec       	ldi	r24, 0xCC	; 204
     c00:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		write_byte(0x44);
     c04:	84 e4       	ldi	r24, 0x44	; 68
     c06:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
		wait_ready();
     c0a:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <wait_ready>
		if(reset())
     c0e:	0e 94 78 05 	call	0xaf0	; 0xaf0 <reset>
     c12:	88 23       	and	r24, r24
     c14:	89 f0       	breq	.+34     	; 0xc38 <read_scratchpad+0x46>
		{
			write_byte(0xCC);
     c16:	8c ec       	ldi	r24, 0xCC	; 204
     c18:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
			write_byte(0xBE);
     c1c:	8e eb       	ldi	r24, 0xBE	; 190
     c1e:	0e 94 d1 05 	call	0xba2	; 0xba2 <write_byte>
     c22:	c3 e4       	ldi	r28, 0x43	; 67
     c24:	d7 e0       	ldi	r29, 0x07	; 7
			for(unsigned char i=0; i<9; i++)
			{
				scratchpad [i] = read_byte();
     c26:	0e 94 a4 05 	call	0xb48	; 0xb48 <read_byte>
     c2a:	89 93       	st	Y+, r24
		wait_ready();
		if(reset())
		{
			write_byte(0xCC);
			write_byte(0xBE);
			for(unsigned char i=0; i<9; i++)
     c2c:	87 e0       	ldi	r24, 0x07	; 7
     c2e:	cc 34       	cpi	r28, 0x4C	; 76
     c30:	d8 07       	cpc	r29, r24
     c32:	c9 f7       	brne	.-14     	; 0xc26 <read_scratchpad+0x34>
     c34:	81 e0       	ldi	r24, 0x01	; 1
     c36:	01 c0       	rjmp	.+2      	; 0xc3a <read_scratchpad+0x48>
     c38:	80 e0       	ldi	r24, 0x00	; 0
			}
			return 1;
		}
	}
	return 0;
}
     c3a:	df 91       	pop	r29
     c3c:	cf 91       	pop	r28
     c3e:	08 95       	ret

00000c40 <i2c_init>:
|== TWPS = 1 => (4^TWPS)= 4  // TWSR = (0<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx01 => TWSR = 1 (DEC) => 4^1 =  4 =|
|== TWPS = 2 => (4^TWPS)=16  // TWSR = (1<<TWPS1)|(0<<TWPS0) => TWSR = 0bxxxxxx10 => TWSR = 2 (DEC) => 4^2 = 16 =|
|== TWPS = 3 => (4^TWPS)=64  // TWSR = (1<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx11 => TWSR = 3 (DEC) => 4^3 = 64 =|
|===============================================================================================================*/

	TWBR = 0b00010010;	// HEX=0x12	or DEC=18	// FCPU = 16 000 000 |-> SCL = 16000000 / (16+(2*TWBR*(4^TWPS)) = 16000000 / (16+(2*18*(4))) = 16000000 / 160 = 100 000 Hz = 100 kHz
     c40:	82 e1       	ldi	r24, 0x12	; 18
     c42:	80 b9       	out	0x00, r24	; 0
	TWSR = (0<<TWPS1)|(1<<TWPS0);	// SCL = 16 000 000 / 64  = 250 000 = 250kHz
     c44:	81 e0       	ldi	r24, 0x01	; 1
     c46:	81 b9       	out	0x01, r24	; 1
	TWCR = (1<<TWEN);	//	TWCR = 0x04; // TWCR = (x<<TWINT)|(x<<TWEA)|(x<<TWSTA)|(x<<TWSTO)|(x<<TWEN)|(x<<TWIE);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz
     c48:	84 e0       	ldi	r24, 0x04	; 4
     c4a:	86 bf       	out	0x36, r24	; 54
	TWDR = 0b00000000;
     c4c:	13 b8       	out	0x03, r1	; 3
}
     c4e:	08 95       	ret

00000c50 <i2c_start>:
/*****************************************
** START CONDITION OF I2C COMMUNICATION **
*****************************************/
void i2c_start(void)
{
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     c50:	84 ea       	ldi	r24, 0xA4	; 164
     c52:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     c54:	06 b6       	in	r0, 0x36	; 54
     c56:	07 fe       	sbrs	r0, 7
     c58:	fd cf       	rjmp	.-6      	; 0xc54 <i2c_start+0x4>
	{
	}
}
     c5a:	08 95       	ret

00000c5c <i2c_stop>:
/****************************************
** STOP CONDITION OF I2C COMMUNICATION **
****************************************/
void i2c_stop()
{
	TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     c5c:	84 e9       	ldi	r24, 0x94	; 148
     c5e:	86 bf       	out	0x36, r24	; 54
}
     c60:	08 95       	ret

00000c62 <i2c_write>:
/*******************************************
** WRITE/SEND 1 BYTE OF I2C COMMUNICATION **
*******************************************/
void i2c_write(unsigned char data)
{
	TWDR = data;
     c62:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT)|(1<<TWEN);
     c64:	84 e8       	ldi	r24, 0x84	; 132
     c66:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     c68:	06 b6       	in	r0, 0x36	; 54
     c6a:	07 fe       	sbrs	r0, 7
     c6c:	fd cf       	rjmp	.-6      	; 0xc68 <i2c_write+0x6>
	{
	}
}
     c6e:	08 95       	ret

00000c70 <i2c_read>:
/**********************************************
** READ/RECEIVE BYTE(S) OF I2C COMMUNICATION **
**********************************************/
unsigned char i2c_read(unsigned char isLast)
{
	if(isLast == 0 )
     c70:	88 23       	and	r24, r24
     c72:	11 f4       	brne	.+4      	; 0xc78 <i2c_read+0x8>
	{
		TWCR = (1<<TWINT)|(1<<TWEA)|(1<<TWEN);	// to next receive byte
     c74:	84 ec       	ldi	r24, 0xC4	; 196
     c76:	01 c0       	rjmp	.+2      	; 0xc7a <i2c_read+0xa>
	}
	else
	{
		TWCR = (1<<TWINT)|(1<<TWEN);			// to end of communication
     c78:	84 e8       	ldi	r24, 0x84	; 132
     c7a:	86 bf       	out	0x36, r24	; 54
	}
	
	while((TWCR & (1<<TWINT)) == 0)
     c7c:	06 b6       	in	r0, 0x36	; 54
     c7e:	07 fe       	sbrs	r0, 7
     c80:	fd cf       	rjmp	.-6      	; 0xc7c <i2c_read+0xc>
	{
	}
	return TWDR;
     c82:	83 b1       	in	r24, 0x03	; 3
}
     c84:	08 95       	ret

00000c86 <LCD_EXECUTE_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_EXECUTE_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     c86:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     c88:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     c8a:	87 ff       	sbrs	r24, 7
     c8c:	02 c0       	rjmp	.+4      	; 0xc92 <LCD_EXECUTE_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     c8e:	d8 9a       	sbi	0x1b, 0	; 27
     c90:	01 c0       	rjmp	.+2      	; 0xc94 <LCD_EXECUTE_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     c92:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     c94:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     c96:	9f 5f       	subi	r25, 0xFF	; 255
     c98:	98 30       	cpi	r25, 0x08	; 8
     c9a:	11 f0       	breq	.+4      	; 0xca0 <LCD_EXECUTE_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     c9c:	88 0f       	add	r24, r24
     c9e:	f4 cf       	rjmp	.-24     	; 0xc88 <LCD_EXECUTE_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     ca0:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     ca2:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     ca4:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     ca6:	da 98       	cbi	0x1b, 2	; 27
     ca8:	88 ea       	ldi	r24, 0xA8	; 168
     caa:	92 e0       	ldi	r25, 0x02	; 2
     cac:	fc 01       	movw	r30, r24
     cae:	31 97       	sbiw	r30, 0x01	; 1
     cb0:	f1 f7       	brne	.-4      	; 0xcae <LCD_EXECUTE_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     cb2:	da 9a       	sbi	0x1b, 2	; 27
     cb4:	01 97       	sbiw	r24, 0x01	; 1
     cb6:	f1 f7       	brne	.-4      	; 0xcb4 <LCD_EXECUTE_COMMAND+0x2e>
	LCD_REGSELECT_low();	// RS = 0
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);			//rcall 180 us
*/
	LCD_ENABLE_low();		// EN = 0
     cb8:	db 98       	cbi	0x1b, 3	; 27
     cba:	80 e9       	ldi	r24, 0x90	; 144
     cbc:	91 e0       	ldi	r25, 0x01	; 1
     cbe:	01 97       	sbiw	r24, 0x01	; 1
     cc0:	f1 f7       	brne	.-4      	; 0xcbe <LCD_EXECUTE_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us

}
     cc2:	08 95       	ret

00000cc4 <LCD_EXECUTE_DATA>:

/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
     cc4:	cf 93       	push	r28
     cc6:	df 93       	push	r29
     cc8:	40 e0       	ldi	r20, 0x00	; 0
     cca:	50 e0       	ldi	r21, 0x00	; 0
     ccc:	a8 ea       	ldi	r26, 0xA8	; 168
     cce:	b2 e0       	ldi	r27, 0x02	; 2
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];
     cd0:	c0 e9       	ldi	r28, 0x90	; 144
     cd2:	d1 e0       	ldi	r29, 0x01	; 1
     cd4:	22 c0       	rjmp	.+68     	; 0xd1a <LCD_EXECUTE_DATA+0x56>
     cd6:	fc 01       	movw	r30, r24
     cd8:	e4 0f       	add	r30, r20
     cda:	f5 1f       	adc	r31, r21
     cdc:	e0 81       	ld	r30, Z
     cde:	20 e0       	ldi	r18, 0x00	; 0

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     ce0:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     ce2:	e7 ff       	sbrs	r30, 7
     ce4:	02 c0       	rjmp	.+4      	; 0xcea <LCD_EXECUTE_DATA+0x26>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     ce6:	d8 9a       	sbi	0x1b, 0	; 27
     ce8:	01 c0       	rjmp	.+2      	; 0xcec <LCD_EXECUTE_DATA+0x28>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     cea:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     cec:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     cee:	2f 5f       	subi	r18, 0xFF	; 255
     cf0:	28 30       	cpi	r18, 0x08	; 8
     cf2:	11 f0       	breq	.+4      	; 0xcf8 <LCD_EXECUTE_DATA+0x34>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     cf4:	ee 0f       	add	r30, r30
     cf6:	f4 cf       	rjmp	.-24     	; 0xce0 <LCD_EXECUTE_DATA+0x1c>
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     cf8:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     cfa:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     cfc:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     cfe:	da 98       	cbi	0x1b, 2	; 27
     d00:	fd 01       	movw	r30, r26
     d02:	31 97       	sbiw	r30, 0x01	; 1
     d04:	f1 f7       	brne	.-4      	; 0xd02 <LCD_EXECUTE_DATA+0x3e>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     d06:	da 9a       	sbi	0x1b, 2	; 27
     d08:	fd 01       	movw	r30, r26
     d0a:	31 97       	sbiw	r30, 0x01	; 1
     d0c:	f1 f7       	brne	.-4      	; 0xd0a <LCD_EXECUTE_DATA+0x46>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     d0e:	db 98       	cbi	0x1b, 3	; 27
     d10:	fe 01       	movw	r30, r28
     d12:	31 97       	sbiw	r30, 0x01	; 1
     d14:	f1 f7       	brne	.-4      	; 0xd12 <LCD_EXECUTE_DATA+0x4e>
/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
     d16:	4f 5f       	subi	r20, 0xFF	; 255
     d18:	5f 4f       	sbci	r21, 0xFF	; 255
     d1a:	46 17       	cp	r20, r22
     d1c:	57 07       	cpc	r21, r23
     d1e:	dc f2       	brlt	.-74     	; 0xcd6 <LCD_EXECUTE_DATA+0x12>
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}

//	LCD_EXECUTE_DATA_LAST();	// flush -> posleden simvol ili gore v cikala count_ns < numsymbols+1 ili count_ns <= numsymbols
}
     d20:	df 91       	pop	r29
     d22:	cf 91       	pop	r28
     d24:	08 95       	ret

00000d26 <LCD_EXECUTE_DATA_ONE>:

/************************************************
** WRITE/TRANSMIT ONE DATA BYTE TO LCD DISPLAY **
************************************************/
void LCD_EXECUTE_DATA_ONE(unsigned char data)	// HELP: LCD_EXECUTE_DATA(unsigned char data_byte_symbols) // LCD shift left out, msb is first
{
     d26:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     d28:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     d2a:	87 ff       	sbrs	r24, 7
     d2c:	02 c0       	rjmp	.+4      	; 0xd32 <LCD_EXECUTE_DATA_ONE+0xc>
		{
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     d2e:	d8 9a       	sbi	0x1b, 0	; 27
     d30:	01 c0       	rjmp	.+2      	; 0xd34 <LCD_EXECUTE_DATA_ONE+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     d32:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     d34:	d9 9a       	sbi	0x1b, 1	; 27
{
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     d36:	9f 5f       	subi	r25, 0xFF	; 255
     d38:	98 30       	cpi	r25, 0x08	; 8
     d3a:	11 f0       	breq	.+4      	; 0xd40 <LCD_EXECUTE_DATA_ONE+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     d3c:	88 0f       	add	r24, r24
     d3e:	f4 cf       	rjmp	.-24     	; 0xd28 <LCD_EXECUTE_DATA_ONE+0x2>
	}
//update from down comment
	LCD_REGSELECT_high();	// RS = 1
     d40:	dd 9a       	sbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     d42:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     d44:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment

	LCD_RCK_low();
     d46:	da 98       	cbi	0x1b, 2	; 27
     d48:	88 ea       	ldi	r24, 0xA8	; 168
     d4a:	92 e0       	ldi	r25, 0x02	; 2
     d4c:	fc 01       	movw	r30, r24
     d4e:	31 97       	sbiw	r30, 0x01	; 1
     d50:	f1 f7       	brne	.-4      	; 0xd4e <LCD_EXECUTE_DATA_ONE+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     d52:	da 9a       	sbi	0x1b, 2	; 27
     d54:	01 97       	sbiw	r24, 0x01	; 1
     d56:	f1 f7       	brne	.-4      	; 0xd54 <LCD_EXECUTE_DATA_ONE+0x2e>
	LCD_REGSELECT_high();	// RS = 1
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);
*/
	LCD_ENABLE_low();		// EN = 0
     d58:	db 98       	cbi	0x1b, 3	; 27
     d5a:	80 e9       	ldi	r24, 0x90	; 144
     d5c:	91 e0       	ldi	r25, 0x01	; 1
     d5e:	01 97       	sbiw	r24, 0x01	; 1
     d60:	f1 f7       	brne	.-4      	; 0xd5e <LCD_EXECUTE_DATA_ONE+0x38>
	_delay_us(100);
}
     d62:	08 95       	ret

00000d64 <LCD_EXECUTE_DATA_LAST>:
/*****************************************************************************
** WRITE/TRANSMIT LAST DATA BYTE TO LCD DISPLAY AND FLUSH SN74HC595 BUFFER  **
*****************************************************************************/
void LCD_EXECUTE_DATA_LAST()	// flush -> izchistvane na bufer - prinuditelno izpisvane na posleden simvol
{
	LCD_ENABLE_low();
     d64:	db 98       	cbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     d66:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     d68:	dd 9a       	sbi	0x1b, 5	; 27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     d6a:	85 ed       	ldi	r24, 0xD5	; 213
     d6c:	98 2f       	mov	r25, r24
     d6e:	9a 95       	dec	r25
     d70:	f1 f7       	brne	.-4      	; 0xd6e <LCD_EXECUTE_DATA_LAST+0xa>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
	LCD_ENABLE_high();
     d72:	db 9a       	sbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     d74:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     d76:	dd 9a       	sbi	0x1b, 5	; 27
     d78:	8a 95       	dec	r24
     d7a:	f1 f7       	brne	.-4      	; 0xd78 <LCD_EXECUTE_DATA_LAST+0x14>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
}
     d7c:	08 95       	ret

00000d7e <LCD_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     d7e:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     d80:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     d82:	87 ff       	sbrs	r24, 7
     d84:	02 c0       	rjmp	.+4      	; 0xd8a <LCD_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     d86:	d8 9a       	sbi	0x1b, 0	; 27
     d88:	01 c0       	rjmp	.+2      	; 0xd8c <LCD_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     d8a:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     d8c:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     d8e:	9f 5f       	subi	r25, 0xFF	; 255
     d90:	98 30       	cpi	r25, 0x08	; 8
     d92:	11 f0       	breq	.+4      	; 0xd98 <LCD_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     d94:	88 0f       	add	r24, r24
     d96:	f4 cf       	rjmp	.-24     	; 0xd80 <LCD_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     d98:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     d9a:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     d9c:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     d9e:	da 98       	cbi	0x1b, 2	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     da0:	88 ea       	ldi	r24, 0xA8	; 168
     da2:	92 e0       	ldi	r25, 0x02	; 2
     da4:	fc 01       	movw	r30, r24
     da6:	31 97       	sbiw	r30, 0x01	; 1
     da8:	f1 f7       	brne	.-4      	; 0xda6 <LCD_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     daa:	da 9a       	sbi	0x1b, 2	; 27
     dac:	01 97       	sbiw	r24, 0x01	; 1
     dae:	f1 f7       	brne	.-4      	; 0xdac <LCD_COMMAND+0x2e>
	_delay_us(170);			//rcall 180 us

	LCD_ENABLE_low();		// EN = 0
     db0:	db 98       	cbi	0x1b, 3	; 27
     db2:	80 e9       	ldi	r24, 0x90	; 144
     db4:	91 e0       	ldi	r25, 0x01	; 1
     db6:	01 97       	sbiw	r24, 0x01	; 1
     db8:	f1 f7       	brne	.-4      	; 0xdb6 <LCD_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us
}
     dba:	08 95       	ret

00000dbc <LCD_CLEAR_CONTAIN>:
/**************************************
** CLEAR ALL CONTAINS ON LCD DISPLAY **
**************************************/
void LCD_CLEAR_CONTAIN()
{
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 1. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     dbc:	81 e0       	ldi	r24, 0x01	; 1
     dbe:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
     dc2:	80 ec       	ldi	r24, 0xC0	; 192
     dc4:	92 e1       	ldi	r25, 0x12	; 18
     dc6:	01 97       	sbiw	r24, 0x01	; 1
     dc8:	f1 f7       	brne	.-4      	; 0xdc6 <LCD_CLEAR_CONTAIN+0xa>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
}
     dca:	08 95       	ret

00000dcc <LCD_INIT>:
/**********************************
** INITIZLIZATION OF LCD DISPLAY **
**********************************/
void LCD_INIT()
{
	LCD_COMMAND(LCD_8BIT_2ROWS_FONT5X7);		// 0b00111000	// 1. Function set: 8-bit interface data (DL = 1), 2-line display (N = 1), 5 x 7 dot character font (F = 0)
     dcc:	88 e3       	ldi	r24, 0x38	; 56
     dce:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_ENTRY_MODE_INC_NOSHIFT);	// 0b00000110	// 2. Entry mode set: Increment by 1 (I/D = 1), No shift (S = 0)
     dd2:	86 e0       	ldi	r24, 0x06	; 6
     dd4:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_MOVE_FIRST);								// 3.
     dd8:	82 e0       	ldi	r24, 0x02	; 2
     dda:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 4. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     dde:	81 e0       	ldi	r24, 0x01	; 1
     de0:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
     de4:	80 ec       	ldi	r24, 0xC0	; 192
     de6:	92 e1       	ldi	r25, 0x12	; 18
     de8:	01 97       	sbiw	r24, 0x01	; 1
     dea:	f1 f7       	brne	.-4      	; 0xde8 <LCD_INIT+0x1c>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
//	LCD_COMMAND(LCD_ON_BLINK_CURSOR);			// 0b00001111	// 5. Display on/off control: Display on (D = 1), Cursor on (C = 1), Blinking on (B = 1)
//	_delay_us(40);	// 37 uS	// comment for simulation
//	LCD_COMMAND(LCD_OFF);										// 5. Display off
}
     dec:	08 95       	ret

00000dee <LCD_DATA_STRING>:

/*********************************************************
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
     dee:	fc 01       	movw	r30, r24
     df0:	28 ea       	ldi	r18, 0xA8	; 168
     df2:	32 e0       	ldi	r19, 0x02	; 2
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     df4:	40 e9       	ldi	r20, 0x90	; 144
     df6:	51 e0       	ldi	r21, 0x01	; 1
     df8:	1d c0       	rjmp	.+58     	; 0xe34 <LCD_DATA_STRING+0x46>
     dfa:	90 e0       	ldi	r25, 0x00	; 0
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     dfc:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     dfe:	87 ff       	sbrs	r24, 7
     e00:	02 c0       	rjmp	.+4      	; 0xe06 <LCD_DATA_STRING+0x18>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     e02:	d8 9a       	sbi	0x1b, 0	; 27
     e04:	01 c0       	rjmp	.+2      	; 0xe08 <LCD_DATA_STRING+0x1a>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     e06:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     e08:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     e0a:	9f 5f       	subi	r25, 0xFF	; 255
     e0c:	98 30       	cpi	r25, 0x08	; 8
     e0e:	11 f0       	breq	.+4      	; 0xe14 <LCD_DATA_STRING+0x26>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     e10:	88 0f       	add	r24, r24
     e12:	f4 cf       	rjmp	.-24     	; 0xdfc <LCD_DATA_STRING+0xe>
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;
     e14:	31 96       	adiw	r30, 0x01	; 1
			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     e16:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     e18:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     e1a:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     e1c:	da 98       	cbi	0x1b, 2	; 27
     e1e:	c9 01       	movw	r24, r18
     e20:	01 97       	sbiw	r24, 0x01	; 1
     e22:	f1 f7       	brne	.-4      	; 0xe20 <LCD_DATA_STRING+0x32>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     e24:	da 9a       	sbi	0x1b, 2	; 27
     e26:	c9 01       	movw	r24, r18
     e28:	01 97       	sbiw	r24, 0x01	; 1
     e2a:	f1 f7       	brne	.-4      	; 0xe28 <LCD_DATA_STRING+0x3a>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     e2c:	db 98       	cbi	0x1b, 3	; 27
     e2e:	ca 01       	movw	r24, r20
     e30:	01 97       	sbiw	r24, 0x01	; 1
     e32:	f1 f7       	brne	.-4      	; 0xe30 <LCD_DATA_STRING+0x42>
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     e34:	80 81       	ld	r24, Z
     e36:	88 23       	and	r24, r24
     e38:	01 f7       	brne	.-64     	; 0xdfa <LCD_DATA_STRING+0xc>
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}
}
     e3a:	08 95       	ret

00000e3c <LCD_CGRAM_CUSTOM_SYMBOLS>:
	 { 0x0E, 0x1B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F },	// Battery Charging  80%	// addr40-47
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
     e3c:	cf 93       	push	r28
     e3e:	df 93       	push	r29
	for(rows=0; rows<7; rows++)
     e40:	10 92 5e 07 	sts	0x075E, r1
     e44:	10 92 5d 07 	sts	0x075D, r1
     e48:	25 c0       	rjmp	.+74     	; 0xe94 <LCD_CGRAM_CUSTOM_SYMBOLS+0x58>
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
     e4a:	08 96       	adiw	r24, 0x08	; 8
     e4c:	88 0f       	add	r24, r24
     e4e:	88 0f       	add	r24, r24
     e50:	88 0f       	add	r24, r24
     e52:	0e 94 43 06 	call	0xc86	; 0xc86 <LCD_EXECUTE_COMMAND>
     e56:	c0 e0       	ldi	r28, 0x00	; 0
     e58:	d0 e0       	ldi	r29, 0x00	; 0
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
     e5a:	e0 91 5d 07 	lds	r30, 0x075D
     e5e:	f0 91 5e 07 	lds	r31, 0x075E
     e62:	83 e0       	ldi	r24, 0x03	; 3
     e64:	ee 0f       	add	r30, r30
     e66:	ff 1f       	adc	r31, r31
     e68:	8a 95       	dec	r24
     e6a:	e1 f7       	brne	.-8      	; 0xe64 <LCD_CGRAM_CUSTOM_SYMBOLS+0x28>
     e6c:	ec 0f       	add	r30, r28
     e6e:	fd 1f       	adc	r31, r29
     e70:	e9 59       	subi	r30, 0x99	; 153
     e72:	f9 4f       	sbci	r31, 0xF9	; 249
     e74:	80 81       	ld	r24, Z
     e76:	0e 94 93 06 	call	0xd26	; 0xd26 <LCD_EXECUTE_DATA_ONE>
void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
     e7a:	21 96       	adiw	r28, 0x01	; 1
     e7c:	c8 30       	cpi	r28, 0x08	; 8
     e7e:	d1 05       	cpc	r29, r1
     e80:	61 f7       	brne	.-40     	; 0xe5a <LCD_CGRAM_CUSTOM_SYMBOLS+0x1e>
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
     e82:	80 91 5d 07 	lds	r24, 0x075D
     e86:	90 91 5e 07 	lds	r25, 0x075E
     e8a:	01 96       	adiw	r24, 0x01	; 1
     e8c:	90 93 5e 07 	sts	0x075E, r25
     e90:	80 93 5d 07 	sts	0x075D, r24
     e94:	80 91 5d 07 	lds	r24, 0x075D
     e98:	90 91 5e 07 	lds	r25, 0x075E
     e9c:	87 30       	cpi	r24, 0x07	; 7
     e9e:	91 05       	cpc	r25, r1
     ea0:	a4 f2       	brlt	.-88     	; 0xe4a <LCD_CGRAM_CUSTOM_SYMBOLS+0xe>
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
		}
	}
}
     ea2:	df 91       	pop	r29
     ea4:	cf 91       	pop	r28
     ea6:	08 95       	ret

00000ea8 <LCD_DATA_ULONG>:
/****************************************************************
** WRITE/TRANSMIT MORE DATA UNSIGNED LONG BYTES TO LCD DISPLAY **
****************************************************************/
// USE THIS: lcdDataULong( (unsigned long)k + 1 );
void LCD_DATA_ULONG(unsigned long data)		// void lcdDataULong(const unsigned long data)
{
     ea8:	df 93       	push	r29
     eaa:	cf 93       	push	r28
     eac:	cd b7       	in	r28, 0x3d	; 61
     eae:	de b7       	in	r29, 0x3e	; 62
     eb0:	2a 97       	sbiw	r28, 0x0a	; 10
     eb2:	0f b6       	in	r0, 0x3f	; 63
     eb4:	f8 94       	cli
     eb6:	de bf       	out	0x3e, r29	; 62
     eb8:	0f be       	out	0x3f, r0	; 63
     eba:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ultoa(data, buffer, 10));	// 10 -> DECIMAL
     ebc:	ae 01       	movw	r20, r28
     ebe:	4f 5f       	subi	r20, 0xFF	; 255
     ec0:	5f 4f       	sbci	r21, 0xFF	; 255
     ec2:	2a e0       	ldi	r18, 0x0A	; 10
     ec4:	30 e0       	ldi	r19, 0x00	; 0
     ec6:	0e 94 66 0b 	call	0x16cc	; 0x16cc <ultoa>
     eca:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
}
     ece:	2a 96       	adiw	r28, 0x0a	; 10
     ed0:	0f b6       	in	r0, 0x3f	; 63
     ed2:	f8 94       	cli
     ed4:	de bf       	out	0x3e, r29	; 62
     ed6:	0f be       	out	0x3f, r0	; 63
     ed8:	cd bf       	out	0x3d, r28	; 61
     eda:	cf 91       	pop	r28
     edc:	df 91       	pop	r29
     ede:	08 95       	ret

00000ee0 <LCD_DATA_LONG>:
/*******************************************************
** WRITE/TRANSMIT MORE DATA LONG BYTES TO LCD DISPLAY **
*******************************************************/
// USE THIS: lcdDataLong( (long)k + 1 );
void LCD_DATA_LONG(long data)		// void lcdDataLong(const long data)
{
     ee0:	df 93       	push	r29
     ee2:	cf 93       	push	r28
     ee4:	cd b7       	in	r28, 0x3d	; 61
     ee6:	de b7       	in	r29, 0x3e	; 62
     ee8:	2a 97       	sbiw	r28, 0x0a	; 10
     eea:	0f b6       	in	r0, 0x3f	; 63
     eec:	f8 94       	cli
     eee:	de bf       	out	0x3e, r29	; 62
     ef0:	0f be       	out	0x3f, r0	; 63
     ef2:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ltoa(data, buffer, 10));	// 10 -> DECIMAL
     ef4:	ae 01       	movw	r20, r28
     ef6:	4f 5f       	subi	r20, 0xFF	; 255
     ef8:	5f 4f       	sbci	r21, 0xFF	; 255
     efa:	2a e0       	ldi	r18, 0x0A	; 10
     efc:	30 e0       	ldi	r19, 0x00	; 0
     efe:	0e 94 32 0b 	call	0x1664	; 0x1664 <ltoa>
     f02:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
}
     f06:	2a 96       	adiw	r28, 0x0a	; 10
     f08:	0f b6       	in	r0, 0x3f	; 63
     f0a:	f8 94       	cli
     f0c:	de bf       	out	0x3e, r29	; 62
     f0e:	0f be       	out	0x3f, r0	; 63
     f10:	cd bf       	out	0x3d, r28	; 61
     f12:	cf 91       	pop	r28
     f14:	df 91       	pop	r29
     f16:	08 95       	ret

00000f18 <LCD_DATA_INT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataInt( (int)k + 1 );
void LCD_DATA_INT(int data)		// void lcdDataInt(const int data)
{
     f18:	df 93       	push	r29
     f1a:	cf 93       	push	r28
     f1c:	cd b7       	in	r28, 0x3d	; 61
     f1e:	de b7       	in	r29, 0x3e	; 62
     f20:	2a 97       	sbiw	r28, 0x0a	; 10
     f22:	0f b6       	in	r0, 0x3f	; 63
     f24:	f8 94       	cli
     f26:	de bf       	out	0x3e, r29	; 62
     f28:	0f be       	out	0x3f, r0	; 63
     f2a:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(itoa(data, buffer, 10));	// 10 -> DECIMAL
     f2c:	be 01       	movw	r22, r28
     f2e:	6f 5f       	subi	r22, 0xFF	; 255
     f30:	7f 4f       	sbci	r23, 0xFF	; 255
     f32:	4a e0       	ldi	r20, 0x0A	; 10
     f34:	50 e0       	ldi	r21, 0x00	; 0
     f36:	0e 94 11 0b 	call	0x1622	; 0x1622 <itoa>
     f3a:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
}
     f3e:	2a 96       	adiw	r28, 0x0a	; 10
     f40:	0f b6       	in	r0, 0x3f	; 63
     f42:	f8 94       	cli
     f44:	de bf       	out	0x3e, r29	; 62
     f46:	0f be       	out	0x3f, r0	; 63
     f48:	cd bf       	out	0x3d, r28	; 61
     f4a:	cf 91       	pop	r28
     f4c:	df 91       	pop	r29
     f4e:	08 95       	ret

00000f50 <LCD_DATA_UINT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataUInt( (unsigned int)k + 1 );
void LCD_DATA_UINT(unsigned int data)		// void lcdDataUInt(const unsigned int data)
{
     f50:	df 93       	push	r29
     f52:	cf 93       	push	r28
     f54:	cd b7       	in	r28, 0x3d	; 61
     f56:	de b7       	in	r29, 0x3e	; 62
     f58:	2a 97       	sbiw	r28, 0x0a	; 10
     f5a:	0f b6       	in	r0, 0x3f	; 63
     f5c:	f8 94       	cli
     f5e:	de bf       	out	0x3e, r29	; 62
     f60:	0f be       	out	0x3f, r0	; 63
     f62:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(utoa(data, buffer, 10));	// 10 -> DECIMAL
     f64:	be 01       	movw	r22, r28
     f66:	6f 5f       	subi	r22, 0xFF	; 255
     f68:	7f 4f       	sbci	r23, 0xFF	; 255
     f6a:	4a e0       	ldi	r20, 0x0A	; 10
     f6c:	50 e0       	ldi	r21, 0x00	; 0
     f6e:	0e 94 8b 0b 	call	0x1716	; 0x1716 <utoa>
     f72:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
}
     f76:	2a 96       	adiw	r28, 0x0a	; 10
     f78:	0f b6       	in	r0, 0x3f	; 63
     f7a:	f8 94       	cli
     f7c:	de bf       	out	0x3e, r29	; 62
     f7e:	0f be       	out	0x3f, r0	; 63
     f80:	cd bf       	out	0x3d, r28	; 61
     f82:	cf 91       	pop	r28
     f84:	df 91       	pop	r29
     f86:	08 95       	ret

00000f88 <PGA2310_Volume_Update>:

/*************************************
** DEFINITION PGA2310 VOLUME UPDATE **
*************************************/
void PGA2310_Volume_Update(unsigned char pgaVolumeLeft, unsigned char pgaVolumeRight)
{
     f88:	0f 93       	push	r16
     f8a:	1f 93       	push	r17
     f8c:	18 2f       	mov	r17, r24
     f8e:	06 2f       	mov	r16, r22
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
     f90:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
     f92:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
     f96:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     f98:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
     f9a:	81 2f       	mov	r24, r17
     f9c:	60 2f       	mov	r22, r16
     f9e:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
     fa2:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA7 - /SS ENABLE
     fa4:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
     fa6:	81 2f       	mov	r24, r17
     fa8:	60 2f       	mov	r22, r16
     faa:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
     fae:	df 9a       	sbi	0x1b, 7	; 27

//	return SUCCESS;
}
     fb0:	1f 91       	pop	r17
     fb2:	0f 91       	pop	r16
     fb4:	08 95       	ret

00000fb6 <pga2310_init>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_init()
{
	spi_init();
     fb6:	0e 94 cf 08 	call	0x119e	; 0x119e <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
     fba:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     fbc:	80 e0       	ldi	r24, 0x00	; 0
     fbe:	60 e0       	ldi	r22, 0x00	; 0
     fc0:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
     fc4:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     fc6:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     fc8:	80 e0       	ldi	r24, 0x00	; 0
     fca:	60 e0       	ldi	r22, 0x00	; 0
     fcc:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
     fd0:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     fd2:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     fd4:	80 e0       	ldi	r24, 0x00	; 0
     fd6:	60 e0       	ldi	r22, 0x00	; 0
     fd8:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
     fdc:	df 9a       	sbi	0x1b, 7	; 27
}
     fde:	08 95       	ret

00000fe0 <pga2310_reset>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_reset()
{
	spi_init();
     fe0:	0e 94 cf 08 	call	0x119e	; 0x119e <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
     fe4:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     fe6:	80 e0       	ldi	r24, 0x00	; 0
     fe8:	60 e0       	ldi	r22, 0x00	; 0
     fea:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
     fee:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     ff0:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     ff2:	80 e0       	ldi	r24, 0x00	; 0
     ff4:	60 e0       	ldi	r22, 0x00	; 0
     ff6:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
     ffa:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     ffc:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     ffe:	80 e0       	ldi	r24, 0x00	; 0
    1000:	60 e0       	ldi	r22, 0x00	; 0
    1002:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    1006:	df 9a       	sbi	0x1b, 7	; 27
}
    1008:	08 95       	ret

0000100a <uart_transmit>:

/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
    100a:	ac 01       	movw	r20, r24
    100c:	20 e0       	ldi	r18, 0x00	; 0
    100e:	30 e0       	ldi	r19, 0x00	; 0
    1010:	09 c0       	rjmp	.+18     	; 0x1024 <uart_transmit+0x1a>
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		//UDR = uart_data[count_ns];
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    1012:	5d 9b       	sbis	0x0b, 5	; 11
    1014:	fe cf       	rjmp	.-4      	; 0x1012 <uart_transmit+0x8>
		{
		}
		UDR = uart_data[count_ns];
    1016:	fa 01       	movw	r30, r20
    1018:	e2 0f       	add	r30, r18
    101a:	f3 1f       	adc	r31, r19
    101c:	80 81       	ld	r24, Z
    101e:	8c b9       	out	0x0c, r24	; 12
/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
    1020:	2f 5f       	subi	r18, 0xFF	; 255
    1022:	3f 4f       	sbci	r19, 0xFF	; 255
    1024:	26 17       	cp	r18, r22
    1026:	37 07       	cpc	r19, r23
    1028:	a4 f3       	brlt	.-24     	; 0x1012 <uart_transmit+0x8>
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
		{
		}
		UDR = uart_data[count_ns];
	}
}
    102a:	08 95       	ret

0000102c <uart_transmit_one>:
/***************************************
** TRANSMIT/SEND 1 BYTE OF UART/USART **
***************************************/
void uart_transmit_one(unsigned char uart_data)
{
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    102c:	5d 9b       	sbis	0x0b, 5	; 11
    102e:	fe cf       	rjmp	.-4      	; 0x102c <uart_transmit_one>
	{
	}
	UDR = uart_data;
    1030:	8c b9       	out	0x0c, r24	; 12
}
    1032:	08 95       	ret

00001034 <uart_transmit_DEC_to_BCD>:

/*****************************************************************		// NOT FINISHED
** TRANSMIT/SEND 1 BYTE CONVERTED FROM DEC TO BCD OF UART/USART **		// NOT FINISHED
*****************************************************************/		// NOT FINISHED
void uart_transmit_DEC_to_BCD(unsigned char dec_to_bcd_data)
{// pravi se preobrazuvane ot DEC to BCD i preobrazuvane za izvejdane na parviq simvol s filtar
    1034:	98 2f       	mov	r25, r24
	
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    1036:	5d 9b       	sbis	0x0b, 5	; 11
    1038:	fe cf       	rjmp	.-4      	; 0x1036 <uart_transmit_DEC_to_BCD+0x2>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data>>4));
    103a:	89 2f       	mov	r24, r25
    103c:	82 95       	swap	r24
    103e:	8f 70       	andi	r24, 0x0F	; 15
    1040:	80 5d       	subi	r24, 0xD0	; 208
    1042:	8c b9       	out	0x0c, r24	; 12

	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    1044:	5d 9b       	sbis	0x0b, 5	; 11
    1046:	fe cf       	rjmp	.-4      	; 0x1044 <uart_transmit_DEC_to_BCD+0x10>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data & 0x0F));
    1048:	9f 70       	andi	r25, 0x0F	; 15
    104a:	90 5d       	subi	r25, 0xD0	; 208
    104c:	9c b9       	out	0x0c, r25	; 12
	byte bcdToDec(byte val)
	{
  		return ( (val/16*10) + (val%16) );
	}
*/
}
    104e:	08 95       	ret

00001050 <transmitUart>:
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
    1050:	5d 9b       	sbis	0x0b, 5	; 11
    1052:	fe cf       	rjmp	.-4      	; 0x1050 <transmitUart>
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
    1054:	8c b9       	out	0x0c, r24	; 12
}
    1056:	08 95       	ret

00001058 <transmitUartString>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
    1058:	fc 01       	movw	r30, r24
    105a:	04 c0       	rjmp	.+8      	; 0x1064 <transmitUartString+0xc>
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
    105c:	5d 9b       	sbis	0x0b, 5	; 11
    105e:	fe cf       	rjmp	.-4      	; 0x105c <transmitUartString+0x4>
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
	{
		transmitUart(*data++);
    1060:	31 96       	adiw	r30, 0x01	; 1
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
    1062:	8c b9       	out	0x0c, r24	; 12
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
    1064:	80 81       	ld	r24, Z
    1066:	88 23       	and	r24, r24
    1068:	c9 f7       	brne	.-14     	; 0x105c <transmitUartString+0x4>
	{
		transmitUart(*data++);
	}
}
    106a:	08 95       	ret

0000106c <receiveUart>:
/**************************************************		// NOT FINISHED
** RECEIVE/READ unsigned char BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
unsigned char receiveUart(void)
{
	while (!(UCSRA & (1<<RXC)))
    106c:	5f 9b       	sbis	0x0b, 7	; 11
    106e:	fe cf       	rjmp	.-4      	; 0x106c <receiveUart>
	{};							/* Wait for data to be received */
	return UDR;					/* Get and return received data from buffer */
    1070:	8c b1       	in	r24, 0x0c	; 12
}
    1072:	08 95       	ret

00001074 <transmitUartLong>:
/******************************************		// NOT FINISHED
** TRANSMIT/SEND long BYTE OF UART/USART **		// NOT FINISHED
******************************************/		// NOT FINISHED
// USE THIS: transmitUartLong( (long)k + 1 );
void transmitUartLong(long data)		// void transmitUartLong(const long data)
{
    1074:	df 93       	push	r29
    1076:	cf 93       	push	r28
    1078:	cd b7       	in	r28, 0x3d	; 61
    107a:	de b7       	in	r29, 0x3e	; 62
    107c:	2a 97       	sbiw	r28, 0x0a	; 10
    107e:	0f b6       	in	r0, 0x3f	; 63
    1080:	f8 94       	cli
    1082:	de bf       	out	0x3e, r29	; 62
    1084:	0f be       	out	0x3f, r0	; 63
    1086:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ltoa(data, buffer, 10));		// 10 -> DECIMAL
    1088:	ae 01       	movw	r20, r28
    108a:	4f 5f       	subi	r20, 0xFF	; 255
    108c:	5f 4f       	sbci	r21, 0xFF	; 255
    108e:	2a e0       	ldi	r18, 0x0A	; 10
    1090:	30 e0       	ldi	r19, 0x00	; 0
    1092:	0e 94 32 0b 	call	0x1664	; 0x1664 <ltoa>
    1096:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
}
    109a:	2a 96       	adiw	r28, 0x0a	; 10
    109c:	0f b6       	in	r0, 0x3f	; 63
    109e:	f8 94       	cli
    10a0:	de bf       	out	0x3e, r29	; 62
    10a2:	0f be       	out	0x3f, r0	; 63
    10a4:	cd bf       	out	0x3d, r28	; 61
    10a6:	cf 91       	pop	r28
    10a8:	df 91       	pop	r29
    10aa:	08 95       	ret

000010ac <transmitUartULong>:
/***************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned long BYTE OF UART/USART **		// NOT FINISHED
***************************************************/		// NOT FINISHED
// USE THIS: transmitUartULong( (unsigned long)k + 1 );
void transmitUartULong(unsigned long data)		// void transmitUartULong(const unsigned long data)
{
    10ac:	df 93       	push	r29
    10ae:	cf 93       	push	r28
    10b0:	cd b7       	in	r28, 0x3d	; 61
    10b2:	de b7       	in	r29, 0x3e	; 62
    10b4:	2a 97       	sbiw	r28, 0x0a	; 10
    10b6:	0f b6       	in	r0, 0x3f	; 63
    10b8:	f8 94       	cli
    10ba:	de bf       	out	0x3e, r29	; 62
    10bc:	0f be       	out	0x3f, r0	; 63
    10be:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ultoa(data, buffer, 10));		// 10 -> DECIMAL
    10c0:	ae 01       	movw	r20, r28
    10c2:	4f 5f       	subi	r20, 0xFF	; 255
    10c4:	5f 4f       	sbci	r21, 0xFF	; 255
    10c6:	2a e0       	ldi	r18, 0x0A	; 10
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	0e 94 66 0b 	call	0x16cc	; 0x16cc <ultoa>
    10ce:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
}
    10d2:	2a 96       	adiw	r28, 0x0a	; 10
    10d4:	0f b6       	in	r0, 0x3f	; 63
    10d6:	f8 94       	cli
    10d8:	de bf       	out	0x3e, r29	; 62
    10da:	0f be       	out	0x3f, r0	; 63
    10dc:	cd bf       	out	0x3d, r28	; 61
    10de:	cf 91       	pop	r28
    10e0:	df 91       	pop	r29
    10e2:	08 95       	ret

000010e4 <transmitUartInt>:
/*****************************************		// NOT FINISHED
** TRANSMIT/SEND int BYTE OF UART/USART **		// NOT FINISHED
*****************************************/		// NOT FINISHED
// USE THIS: transmitUartInt( (int)k + 1 );
void transmitUartInt(int data)		// void transmitUartInt(const int data)
{
    10e4:	df 93       	push	r29
    10e6:	cf 93       	push	r28
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
    10ec:	2a 97       	sbiw	r28, 0x0a	; 10
    10ee:	0f b6       	in	r0, 0x3f	; 63
    10f0:	f8 94       	cli
    10f2:	de bf       	out	0x3e, r29	; 62
    10f4:	0f be       	out	0x3f, r0	; 63
    10f6:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(itoa(data, buffer, 10));		// 10 -> DECIMAL
    10f8:	be 01       	movw	r22, r28
    10fa:	6f 5f       	subi	r22, 0xFF	; 255
    10fc:	7f 4f       	sbci	r23, 0xFF	; 255
    10fe:	4a e0       	ldi	r20, 0x0A	; 10
    1100:	50 e0       	ldi	r21, 0x00	; 0
    1102:	0e 94 11 0b 	call	0x1622	; 0x1622 <itoa>
    1106:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
}
    110a:	2a 96       	adiw	r28, 0x0a	; 10
    110c:	0f b6       	in	r0, 0x3f	; 63
    110e:	f8 94       	cli
    1110:	de bf       	out	0x3e, r29	; 62
    1112:	0f be       	out	0x3f, r0	; 63
    1114:	cd bf       	out	0x3d, r28	; 61
    1116:	cf 91       	pop	r28
    1118:	df 91       	pop	r29
    111a:	08 95       	ret

0000111c <transmitUartUInt>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned int BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: transmitUartUInt( (unsigned int)k + 1 );
void transmitUartUInt(unsigned int data)		// void transmitUartUInt(const unsigned int data)
{
    111c:	df 93       	push	r29
    111e:	cf 93       	push	r28
    1120:	cd b7       	in	r28, 0x3d	; 61
    1122:	de b7       	in	r29, 0x3e	; 62
    1124:	2a 97       	sbiw	r28, 0x0a	; 10
    1126:	0f b6       	in	r0, 0x3f	; 63
    1128:	f8 94       	cli
    112a:	de bf       	out	0x3e, r29	; 62
    112c:	0f be       	out	0x3f, r0	; 63
    112e:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(utoa(data, buffer, 10));		// 10 -> DECIMAL
    1130:	be 01       	movw	r22, r28
    1132:	6f 5f       	subi	r22, 0xFF	; 255
    1134:	7f 4f       	sbci	r23, 0xFF	; 255
    1136:	4a e0       	ldi	r20, 0x0A	; 10
    1138:	50 e0       	ldi	r21, 0x00	; 0
    113a:	0e 94 8b 0b 	call	0x1716	; 0x1716 <utoa>
    113e:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
}
    1142:	2a 96       	adiw	r28, 0x0a	; 10
    1144:	0f b6       	in	r0, 0x3f	; 63
    1146:	f8 94       	cli
    1148:	de bf       	out	0x3e, r29	; 62
    114a:	0f be       	out	0x3f, r0	; 63
    114c:	cd bf       	out	0x3d, r28	; 61
    114e:	cf 91       	pop	r28
    1150:	df 91       	pop	r29
    1152:	08 95       	ret

00001154 <uart_init>:
{
	switch(F_CPU)
	{
		case 16000000UL:
		{
			UBRRL = 103;	// Baudrate: 9600; (Error = 0.2%; 16MHz)
    1154:	87 e6       	ldi	r24, 0x67	; 103
    1156:	89 b9       	out	0x09, r24	; 9
			UBRRH = 0;
    1158:	10 bc       	out	0x20, r1	; 32
		{
			break;
		}
	}
#ifdef DEBUG_SETTING
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
    115a:	8c e0       	ldi	r24, 0x0C	; 12
    115c:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 2								// and next is update volume lcd information
    1160:	84 ed       	ldi	r24, 0xD4	; 212
    1162:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LCD_COMMAND>
	LCD_DATA_STRING("Freq: ");		// 20 symbols			
    1166:	8f e9       	ldi	r24, 0x9F	; 159
    1168:	96 e0       	ldi	r25, 0x06	; 6
    116a:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
	LCD_DATA_ULONG(F_CPU);			// 20 symbols
    116e:	60 e0       	ldi	r22, 0x00	; 0
    1170:	74 e2       	ldi	r23, 0x24	; 36
    1172:	84 ef       	ldi	r24, 0xF4	; 244
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	0e 94 54 07 	call	0xea8	; 0xea8 <LCD_DATA_ULONG>
	LCD_DATA_STRING(" MHz");		// 20 symbols
    117a:	86 ea       	ldi	r24, 0xA6	; 166
    117c:	96 e0       	ldi	r25, 0x06	; 6
    117e:	0e 94 f7 06 	call	0xdee	; 0xdee <LCD_DATA_STRING>
#endif
	// Razpoznavane na baudrate (skorost): 1. Izprashta se byte. 2. Poluchava se byte. 3. Sravnqva se polucheniq byte == izprateniq byte. // This is LOOP TX->RX
	// 4. Ako byte pri sravnqvaneto e edin i sasht to skorostta e izbranata v momenta, ako byte e razlichen - da se probva sas sledvashta baudrate.

	UCSRC = 0b10000110;		// URSEL = 1 (Accessing to UBRRH or UCSRC, is read as zero when reading UBRRH. The URSEL must be zero when writing the UBRRH.); UMSEL = 0 (Asynchronous Operation); UPM1 = 0, UPM0 = 0 (Parity Mode Disabled); USBS = 0 (1-Stop Bit); UCSZ2 = 0, UCSZ1 = 1, UCSZ0 = 1 (8-DataBits); UCPOL = 0 Polarity TX & RX (Rising XCK Edge -> Transmitted Data Changed (Output of TxDPin), Falling XCK Edge -> Received Data Sampled (Input on RxDPin))
    1182:	86 e8       	ldi	r24, 0x86	; 134
    1184:	80 bd       	out	0x20, r24	; 32
	UCSRB = 0b00001000;		// Enable only TXEN	- Transmitting Uart/Usart	// UCSRB = 0b10011000;		// Enable TXEN,RXEN,RXCIE	Transmitting and Receiving Uart/Usart
    1186:	88 e0       	ldi	r24, 0x08	; 8
    1188:	8a b9       	out	0x0a, r24	; 10
	UDR = 0b00000000;		// INITIALIZATION NULL OF UART DATA
    118a:	1c b8       	out	0x0c, r1	; 12

#ifdef DEBUG_INFO
	transmitUartString("\r\n");
    118c:	8b ea       	ldi	r24, 0xAB	; 171
    118e:	96 e0       	ldi	r25, 0x06	; 6
    1190:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
#endif
#if DEBUG_SETTING
	transmitUartString("[UART INFO] Serial Port Settings - Baud rate: 9600, Data bits: 8 bits, Stop bits: 1 bit, Parity: None, Flow control: None or XON/XOFF\r\n");
    1194:	8e ea       	ldi	r24, 0xAE	; 174
    1196:	96 e0       	ldi	r25, 0x06	; 6
    1198:	0e 94 2c 08 	call	0x1058	; 0x1058 <transmitUartString>
#endif
}
    119c:	08 95       	ret

0000119e <spi_init>:
/**************************
** INITIZLIZATION OF SPI **
***************************/
void spi_init()
{
	SPSR = (0<<SPIF)|(0<<WCOL)|(0<<SPI2X);
    119e:	1e b8       	out	0x0e, r1	; 14
//	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);			//0b01010010	// SPR1   = 1 - 16 000 000 / 64  = 250 000 = 250kHz  // KOMENTAR ZARADI SIMULACIQTA - PROTEUS BLOKIRANE ZARADI BIT V REGISTAR
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz	 // KAKVA KOMBINACIQ OT 4-te BITa VODI DO RAZBLOKIRANETO ???
    11a0:	83 e5       	ldi	r24, 0x53	; 83
    11a2:	8d b9       	out	0x0d, r24	; 13
	SPDR = 0b00000000;
    11a4:	1f b8       	out	0x0f, r1	; 15

	PGA2310_U8_SPI_CS_high();	// /SS - DISABLE
	PGA2310_U8_SPI(0b00000000, 0b00000000);
	*/

	SPCR = (0<<SPE);
    11a6:	1d b8       	out	0x0d, r1	; 13
}
    11a8:	08 95       	ret

000011aa <spi_start>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    11aa:	83 e5       	ldi	r24, 0x53	; 83
    11ac:	8d b9       	out	0x0d, r24	; 13
}
    11ae:	08 95       	ret

000011b0 <spi_stop>:
/**************************************
** DEFINITION SPI FUNCTION STOP ONLY **
**************************************/
void spi_stop()
{
	SPCR = (0<<SPE);
    11b0:	1d b8       	out	0x0d, r1	; 13
}
    11b2:	08 95       	ret

000011b4 <spi_write_one_byte>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    11b4:	93 e5       	ldi	r25, 0x53	; 83
    11b6:	9d b9       	out	0x0d, r25	; 13
void spi_write_one_byte(unsigned char data)	// void PGA2310_U7_SPI(byte volume_left, byte volume_right)	//PGA2310_U7_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data;				//volume_right;
    11b8:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    11ba:	77 9b       	sbis	0x0e, 7	; 14
    11bc:	fe cf       	rjmp	.-4      	; 0x11ba <spi_write_one_byte+0x6>
	{
	}
}
    11be:	08 95       	ret

000011c0 <spi_write_two_bytes>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    11c0:	93 e5       	ldi	r25, 0x53	; 83
    11c2:	9d b9       	out	0x0d, r25	; 13
void spi_write_two_bytes(unsigned char data1, unsigned char data2)	// void PGA2310_U6_SPI(byte volume_left, byte volume_right)	//PGA2310_U6_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data1;				//volume_left;
    11c4:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    11c6:	77 9b       	sbis	0x0e, 7	; 14
    11c8:	fe cf       	rjmp	.-4      	; 0x11c6 <spi_write_two_bytes+0x6>
	{
	}

//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data2;				//volume_right;
    11ca:	6f b9       	out	0x0f, r22	; 15
	while(!(SPSR & (1<<SPIF)))
    11cc:	77 9b       	sbis	0x0e, 7	; 14
    11ce:	fe cf       	rjmp	.-4      	; 0x11cc <spi_write_two_bytes+0xc>
	{
	}
}
    11d0:	08 95       	ret

000011d2 <spi_write_more_bytes>:

/*********************************************
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
    11d2:	fc 01       	movw	r30, r24
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    11d4:	93 e5       	ldi	r25, 0x53	; 83
    11d6:	06 c0       	rjmp	.+12     	; 0x11e4 <spi_write_more_bytes+0x12>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    11d8:	31 96       	adiw	r30, 0x01	; 1
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    11da:	9d b9       	out	0x0d, r25	; 13
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
	{
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
		spi_start();
		SPDR = *data;			//volume_left;
    11dc:	80 81       	ld	r24, Z
    11de:	8f b9       	out	0x0f, r24	; 15
		while(!(SPSR & (1<<SPIF)))
    11e0:	77 9b       	sbis	0x0e, 7	; 14
    11e2:	fe cf       	rjmp	.-4      	; 0x11e0 <spi_write_more_bytes+0xe>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    11e4:	80 81       	ld	r24, Z
    11e6:	88 23       	and	r24, r24
    11e8:	b9 f7       	brne	.-18     	; 0x11d8 <spi_write_more_bytes+0x6>
		SPDR = *data;			//volume_left;
		while(!(SPSR & (1<<SPIF)))
		{
		}
	}
}
    11ea:	08 95       	ret

000011ec <spi_read_more_bytes>:
unsigned char spi_read_more_bytes()	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
	unsigned char data = 0b00000000;
	//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data;			//volume_left;
    11ec:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF)))
    11ee:	77 9b       	sbis	0x0e, 7	; 14
    11f0:	fe cf       	rjmp	.-4      	; 0x11ee <spi_read_more_bytes+0x2>
	{
	}
	return data;
}
    11f2:	80 e0       	ldi	r24, 0x00	; 0
    11f4:	08 95       	ret

000011f6 <decToBcd>:

/**************************************************************
**** CONVERT NORMAL DECIMAL NUMBERS TO BINARY CODED DECIMAL ***
**************************************************************/
unsigned char decToBcd(unsigned char val)
{
    11f6:	48 2f       	mov	r20, r24
    11f8:	6a e0       	ldi	r22, 0x0A	; 10
    11fa:	0e 94 de 0a 	call	0x15bc	; 0x15bc <__udivmodqi4>
    11fe:	28 2f       	mov	r18, r24
    1200:	30 e0       	ldi	r19, 0x00	; 0
    1202:	84 e0       	ldi	r24, 0x04	; 4
    1204:	22 0f       	add	r18, r18
    1206:	33 1f       	adc	r19, r19
    1208:	8a 95       	dec	r24
    120a:	e1 f7       	brne	.-8      	; 0x1204 <decToBcd+0xe>
    120c:	84 2f       	mov	r24, r20
    120e:	0e 94 de 0a 	call	0x15bc	; 0x15bc <__udivmodqi4>
	return ( (val/10*16) + (val%10) );	// Get DEC format -> convert DEC to HEX
}
    1212:	89 2f       	mov	r24, r25
    1214:	82 0f       	add	r24, r18
    1216:	08 95       	ret

00001218 <bcdToDec>:

/**************************************************************
**** CONVERT BINARY CODED DECIMAL TO NORMAL DECIMAL NUMBERS ***
**************************************************************/
unsigned char bcdToDec(unsigned char val)
{
    1218:	28 2f       	mov	r18, r24
    121a:	22 95       	swap	r18
    121c:	2f 70       	andi	r18, 0x0F	; 15
    121e:	9a e0       	ldi	r25, 0x0A	; 10
    1220:	29 9f       	mul	r18, r25
    1222:	90 01       	movw	r18, r0
    1224:	11 24       	eor	r1, r1
    1226:	8f 70       	andi	r24, 0x0F	; 15
	return ( (val/16*10) + (val%16) );	// Get HEX format -> convert HEX to DEC
}
    1228:	82 0f       	add	r24, r18
    122a:	08 95       	ret

0000122c <shiftRightOutLsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    122c:	a0 9a       	sbi	0x14, 0	; 20
    122e:	94 e4       	ldi	r25, 0x44	; 68
    1230:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regALSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1232:	90 ff       	sbrs	r25, 0
    1234:	02 c0       	rjmp	.+4      	; 0x123a <shiftRightOutLsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v LSB
    1236:	a8 9a       	sbi	0x15, 0	; 21
    1238:	01 c0       	rjmp	.+2      	; 0x123c <shiftRightOutLsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
    123a:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    123c:	8f 5f       	subi	r24, 0xFF	; 255
    123e:	88 30       	cpi	r24, 0x08	; 8
    1240:	11 f0       	breq	.+4      	; 0x1246 <shiftRightOutLsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
		}
		
		regALSB = regALSB >> 1;	// shiftvane na >> nadqsno
    1242:	96 95       	lsr	r25
    1244:	f6 cf       	rjmp	.-20     	; 0x1232 <shiftRightOutLsbFirst+0x6>
    1246:	08 95       	ret

00001248 <shiftLeftOutMsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    1248:	a0 9a       	sbi	0x14, 0	; 20
    124a:	94 e4       	ldi	r25, 0x44	; 68
    124c:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regAMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
    124e:	97 ff       	sbrs	r25, 7
    1250:	02 c0       	rjmp	.+4      	; 0x1256 <shiftLeftOutMsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v MSB
    1252:	a8 9a       	sbi	0x15, 0	; 21
    1254:	01 c0       	rjmp	.+2      	; 0x1258 <shiftLeftOutMsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
    1256:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1258:	8f 5f       	subi	r24, 0xFF	; 255
    125a:	88 30       	cpi	r24, 0x08	; 8
    125c:	11 f0       	breq	.+4      	; 0x1262 <shiftLeftOutMsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
		}
		
		regAMSB = regAMSB << 1;	// shiftvane na << nalqvo
    125e:	99 0f       	add	r25, r25
    1260:	f6 cf       	rjmp	.-20     	; 0x124e <shiftLeftOutMsbFirst+0x6>
    1262:	08 95       	ret

00001264 <shiftRightInLsbFirst>:
void shiftRightInLsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    1264:	a0 98       	cbi	0x14, 0	; 20
    1266:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
    1268:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    126a:	8f 5f       	subi	r24, 0xFF	; 255
    126c:	88 30       	cpi	r24, 0x08	; 8
    126e:	e1 f7       	brne	.-8      	; 0x1268 <shiftRightInLsbFirst+0x4>
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
	}

}
    1270:	08 95       	ret

00001272 <shiftLeftInMsbFirst>:
void shiftLeftInMsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    1272:	a0 98       	cbi	0x14, 0	; 20
    1274:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
    1276:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1278:	8f 5f       	subi	r24, 0xFF	; 255
    127a:	88 30       	cpi	r24, 0x08	; 8
    127c:	e1 f7       	brne	.-8      	; 0x1276 <shiftLeftInMsbFirst+0x4>
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
	}

}
    127e:	08 95       	ret

00001280 <delay_ms>:

/*************************************************************
*********** FUNCTION SOFTWARE DELAY IN MILISECONDS ***********
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
    1280:	40 e0       	ldi	r20, 0x00	; 0
    1282:	50 e0       	ldi	r21, 0x00	; 0
    1284:	0b c0       	rjmp	.+22     	; 0x129c <delay_ms+0x1c>
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1286:	20 e0       	ldi	r18, 0x00	; 0
    1288:	30 e0       	ldi	r19, 0x00	; 0
	{
		for(j=0;j<100;j++)
		{
		  asm("nop");
    128a:	00 00       	nop
		  asm("nop");
    128c:	00 00       	nop
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
	{
		for(j=0;j<100;j++)
    128e:	2f 5f       	subi	r18, 0xFF	; 255
    1290:	3f 4f       	sbci	r19, 0xFF	; 255
    1292:	24 36       	cpi	r18, 0x64	; 100
    1294:	31 05       	cpc	r19, r1
    1296:	c9 f7       	brne	.-14     	; 0x128a <delay_ms+0xa>
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1298:	4f 5f       	subi	r20, 0xFF	; 255
    129a:	5f 4f       	sbci	r21, 0xFF	; 255
    129c:	48 17       	cp	r20, r24
    129e:	59 07       	cpc	r21, r25
    12a0:	94 f3       	brlt	.-28     	; 0x1286 <delay_ms+0x6>
		{
		  asm("nop");
		  asm("nop");
		}
	}
}
    12a2:	08 95       	ret

000012a4 <rotaryEncoderNikBarzakov>:
** READ/SCAN ROTARY ENCODER OF NIK BARZAKOV **
*********************************************/
char rotaryEncoderNikBarzakov()
{
	char tempEncoder = 0;
	if((ENCODER_A_low()) && (ENCODER_B_low()))			// A0, B0
    12a4:	9d 99       	sbic	0x13, 5	; 19
    12a6:	0e c0       	rjmp	.+28     	; 0x12c4 <rotaryEncoderNikBarzakov+0x20>
    12a8:	9c 99       	sbic	0x13, 4	; 19
    12aa:	0c c0       	rjmp	.+24     	; 0x12c4 <rotaryEncoderNikBarzakov+0x20>
    12ac:	88 ec       	ldi	r24, 0xC8	; 200
    12ae:	90 e0       	ldi	r25, 0x00	; 0
    12b0:	01 97       	sbiw	r24, 0x01	; 1
    12b2:	f1 f7       	brne	.-4      	; 0x12b0 <rotaryEncoderNikBarzakov+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_high()) && (ENCODER_B_low()))		// A1, B0
    12b4:	9d 9b       	sbis	0x13, 5	; 19
    12b6:	14 c0       	rjmp	.+40     	; 0x12e0 <rotaryEncoderNikBarzakov+0x3c>
    12b8:	83 b3       	in	r24, 0x13	; 19
    12ba:	82 95       	swap	r24
    12bc:	8f 70       	andi	r24, 0x0F	; 15
    12be:	80 95       	com	r24
    12c0:	81 70       	andi	r24, 0x01	; 1
    12c2:	08 95       	ret
// VOLUME UP
			tempEncoder = 1;	//	tempEncoder++;
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}
	}
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    12c4:	9d 9b       	sbis	0x13, 5	; 19
    12c6:	0c c0       	rjmp	.+24     	; 0x12e0 <rotaryEncoderNikBarzakov+0x3c>
    12c8:	9c 99       	sbic	0x13, 4	; 19
    12ca:	0a c0       	rjmp	.+20     	; 0x12e0 <rotaryEncoderNikBarzakov+0x3c>
    12cc:	88 ec       	ldi	r24, 0xC8	; 200
    12ce:	90 e0       	ldi	r25, 0x00	; 0
    12d0:	01 97       	sbiw	r24, 0x01	; 1
    12d2:	f1 f7       	brne	.-4      	; 0x12d0 <rotaryEncoderNikBarzakov+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    12d4:	9d 99       	sbic	0x13, 5	; 19
    12d6:	04 c0       	rjmp	.+8      	; 0x12e0 <rotaryEncoderNikBarzakov+0x3c>
    12d8:	9c 99       	sbic	0x13, 4	; 19
    12da:	02 c0       	rjmp	.+4      	; 0x12e0 <rotaryEncoderNikBarzakov+0x3c>
    12dc:	8f ef       	ldi	r24, 0xFF	; 255
    12de:	08 95       	ret
    12e0:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    12e2:	08 95       	ret

000012e4 <rotaryEncoderVer1>:
** READ/SCAN ROTARY ENCODER VERSION 1 / MODEL 1 **
*************************************************/
char rotaryEncoderVer1()	// Check imediate now bits in PIN register.
{
	char tempEncoder = 0;							// A1, B1
	if((ENCODER_A_low()) && (ENCODER_B_high()))			// A0, B1
    12e4:	9d 99       	sbic	0x13, 5	; 19
    12e6:	0e c0       	rjmp	.+28     	; 0x1304 <rotaryEncoderVer1+0x20>
    12e8:	9c 9b       	sbis	0x13, 4	; 19
    12ea:	0c c0       	rjmp	.+24     	; 0x1304 <rotaryEncoderVer1+0x20>
    12ec:	88 ec       	ldi	r24, 0xC8	; 200
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	01 97       	sbiw	r24, 0x01	; 1
    12f2:	f1 f7       	brne	.-4      	; 0x12f0 <rotaryEncoderVer1+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    12f4:	9d 99       	sbic	0x13, 5	; 19
    12f6:	14 c0       	rjmp	.+40     	; 0x1320 <rotaryEncoderVer1+0x3c>
    12f8:	83 b3       	in	r24, 0x13	; 19
    12fa:	82 95       	swap	r24
    12fc:	8f 70       	andi	r24, 0x0F	; 15
    12fe:	80 95       	com	r24
    1300:	81 70       	andi	r24, 0x01	; 1
    1302:	08 95       	ret
//			PORTD = volumeMassive[volumeIndex];
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}

	}													// A1. B1
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    1304:	9d 9b       	sbis	0x13, 5	; 19
    1306:	0c c0       	rjmp	.+24     	; 0x1320 <rotaryEncoderVer1+0x3c>
    1308:	9c 99       	sbic	0x13, 4	; 19
    130a:	0a c0       	rjmp	.+20     	; 0x1320 <rotaryEncoderVer1+0x3c>
    130c:	88 ec       	ldi	r24, 0xC8	; 200
    130e:	90 e0       	ldi	r25, 0x00	; 0
    1310:	01 97       	sbiw	r24, 0x01	; 1
    1312:	f1 f7       	brne	.-4      	; 0x1310 <rotaryEncoderVer1+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    1314:	9d 99       	sbic	0x13, 5	; 19
    1316:	04 c0       	rjmp	.+8      	; 0x1320 <rotaryEncoderVer1+0x3c>
    1318:	9c 99       	sbic	0x13, 4	; 19
    131a:	02 c0       	rjmp	.+4      	; 0x1320 <rotaryEncoderVer1+0x3c>
    131c:	8f ef       	ldi	r24, 0xFF	; 255
    131e:	08 95       	ret
    1320:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    1322:	08 95       	ret

00001324 <rotaryEncoderVer2>:
    1324:	88 ec       	ldi	r24, 0xC8	; 200
    1326:	90 e0       	ldi	r25, 0x00	; 0
    1328:	fc 01       	movw	r30, r24
    132a:	31 97       	sbiw	r30, 0x01	; 1
    132c:	f1 f7       	brne	.-4      	; 0x132a <rotaryEncoderVer2+0x6>
    132e:	fc 01       	movw	r30, r24
    1330:	31 97       	sbiw	r30, 0x01	; 1
    1332:	f1 f7       	brne	.-4      	; 0x1330 <rotaryEncoderVer2+0xc>
    1334:	01 97       	sbiw	r24, 0x01	; 1
    1336:	f1 f7       	brne	.-4      	; 0x1334 <rotaryEncoderVer2+0x10>
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    1338:	80 e0       	ldi	r24, 0x00	; 0
    133a:	08 95       	ret

0000133c <RELAYS_IN_INIT>:
/*********************************************
** INITIZLIZATION OF SHIFT REGISTER 74HC595 **
*********************************************/
void RELAYS_IN_INIT()
{
}
    133c:	08 95       	ret

0000133e <RELAYS_OUT_INIT>:

void RELAYS_OUT_INIT()
{
}
    133e:	08 95       	ret

00001340 <RELAYS_IN_CHOOSE>:

/****************************************************************************************************************
** DEFINITION RELAYS IN FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS IN **
****************************************************************************************************************/
void RELAYS_IN_CHOOSE(unsigned char rel_in)	// HELP: RELAYS_IN_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    1340:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELIN_SCK_low();
    1342:	ae 98       	cbi	0x15, 6	; 21

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1344:	80 ff       	sbrs	r24, 0
    1346:	02 c0       	rjmp	.+4      	; 0x134c <RELAYS_IN_CHOOSE+0xc>
		{
			RELIN_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    1348:	af 9a       	sbi	0x15, 7	; 21
    134a:	01 c0       	rjmp	.+2      	; 0x134e <RELAYS_IN_CHOOSE+0xe>
		}
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    134c:	af 98       	cbi	0x15, 7	; 21
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELIN_SCK_high();
    134e:	ae 9a       	sbi	0x15, 6	; 21
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1350:	9f 5f       	subi	r25, 0xFF	; 255
    1352:	98 30       	cpi	r25, 0x08	; 8
    1354:	11 f0       	breq	.+4      	; 0x135a <RELAYS_IN_CHOOSE+0x1a>
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    1356:	86 95       	lsr	r24
    1358:	f4 cf       	rjmp	.-24     	; 0x1342 <RELAYS_IN_CHOOSE+0x2>

		RELIN_SCK_high();
	}

	RELIN_RCK_low();
    135a:	ab 98       	cbi	0x15, 3	; 21
    135c:	88 ea       	ldi	r24, 0xA8	; 168
    135e:	92 e0       	ldi	r25, 0x02	; 2
    1360:	fc 01       	movw	r30, r24
    1362:	31 97       	sbiw	r30, 0x01	; 1
    1364:	f1 f7       	brne	.-4      	; 0x1362 <RELAYS_IN_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELIN_RCK_high();
    1366:	ab 9a       	sbi	0x15, 3	; 21
    1368:	01 97       	sbiw	r24, 0x01	; 1
    136a:	f1 f7       	brne	.-4      	; 0x1368 <RELAYS_IN_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    136c:	08 95       	ret

0000136e <relays_in1_2ch>:

void relays_in1_2ch()
{
	RELAYS_IN_CHOOSE(0b00100000);	// RELE 1
    136e:	80 e2       	ldi	r24, 0x20	; 32
    1370:	0e 94 a0 09 	call	0x1340	; 0x1340 <RELAYS_IN_CHOOSE>
}
    1374:	08 95       	ret

00001376 <relays_in1_6ch>:

void relays_in1_6ch()
{
	RELAYS_IN_CHOOSE(0b01100001);	// RELE 1,2,3
    1376:	81 e6       	ldi	r24, 0x61	; 97
    1378:	0e 94 a0 09 	call	0x1340	; 0x1340 <RELAYS_IN_CHOOSE>
}
    137c:	08 95       	ret

0000137e <relays_in2_2ch>:

void relays_in2_2ch()
{
	RELAYS_IN_CHOOSE(0b00001010);	// RELE 4,5
    137e:	8a e0       	ldi	r24, 0x0A	; 10
    1380:	0e 94 a0 09 	call	0x1340	; 0x1340 <RELAYS_IN_CHOOSE>
}
    1384:	08 95       	ret

00001386 <relays_in2_6ch>:

void relays_in2_6ch()
{
	RELAYS_IN_CHOOSE(0b10011010);	// RELE 4,5,6,7
    1386:	8a e9       	ldi	r24, 0x9A	; 154
    1388:	0e 94 a0 09 	call	0x1340	; 0x1340 <RELAYS_IN_CHOOSE>
}
    138c:	08 95       	ret

0000138e <relays_in3_2ch>:

void relays_in3_2ch()
{
	RELAYS_IN_CHOOSE(0b00001100);	// RELE 8,5
    138e:	8c e0       	ldi	r24, 0x0C	; 12
    1390:	0e 94 a0 09 	call	0x1340	; 0x1340 <RELAYS_IN_CHOOSE>
}
    1394:	08 95       	ret

00001396 <relays_in3_6ch>:

void relays_in3_6ch()
{
	RELAYS_IN_CHOOSE(0b10011100);	// RELE 8,5,6,7
    1396:	8c e9       	ldi	r24, 0x9C	; 156
    1398:	0e 94 a0 09 	call	0x1340	; 0x1340 <RELAYS_IN_CHOOSE>
}
    139c:	08 95       	ret

0000139e <relays_in_off>:

void relays_in_off()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    139e:	80 e0       	ldi	r24, 0x00	; 0
    13a0:	0e 94 a0 09 	call	0x1340	; 0x1340 <RELAYS_IN_CHOOSE>
}
    13a4:	08 95       	ret

000013a6 <relays_in_init>:

void relays_in_init()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    13a6:	80 e0       	ldi	r24, 0x00	; 0
    13a8:	0e 94 a0 09 	call	0x1340	; 0x1340 <RELAYS_IN_CHOOSE>
}
    13ac:	08 95       	ret

000013ae <RELAYS_OUT_CHOOSE>:
/******************************************************************************************************************
** DEFINITION RELAYS OUT FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS OUT **
******************************************************************************************************************/
void RELAYS_OUT_CHOOSE(unsigned char rel_out)	// HELP: RELAYS_OUT_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    13ae:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELOUT_SCK_low();
    13b0:	96 98       	cbi	0x12, 6	; 18

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    13b2:	80 ff       	sbrs	r24, 0
    13b4:	02 c0       	rjmp	.+4      	; 0x13ba <RELAYS_OUT_CHOOSE+0xc>
		{
			RELOUT_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    13b6:	c4 9a       	sbi	0x18, 4	; 24
    13b8:	01 c0       	rjmp	.+2      	; 0x13bc <RELAYS_OUT_CHOOSE+0xe>
		}
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    13ba:	c4 98       	cbi	0x18, 4	; 24
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELOUT_SCK_high();
    13bc:	96 9a       	sbi	0x12, 6	; 18
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    13be:	9f 5f       	subi	r25, 0xFF	; 255
    13c0:	98 30       	cpi	r25, 0x08	; 8
    13c2:	11 f0       	breq	.+4      	; 0x13c8 <RELAYS_OUT_CHOOSE+0x1a>
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    13c4:	86 95       	lsr	r24
    13c6:	f4 cf       	rjmp	.-24     	; 0x13b0 <RELAYS_OUT_CHOOSE+0x2>

		RELOUT_SCK_high();
	}

	RELOUT_RCK_low();
    13c8:	97 98       	cbi	0x12, 7	; 18
    13ca:	88 ea       	ldi	r24, 0xA8	; 168
    13cc:	92 e0       	ldi	r25, 0x02	; 2
    13ce:	fc 01       	movw	r30, r24
    13d0:	31 97       	sbiw	r30, 0x01	; 1
    13d2:	f1 f7       	brne	.-4      	; 0x13d0 <RELAYS_OUT_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELOUT_RCK_high();
    13d4:	97 9a       	sbi	0x12, 7	; 18
    13d6:	01 97       	sbiw	r24, 0x01	; 1
    13d8:	f1 f7       	brne	.-4      	; 0x13d6 <RELAYS_OUT_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    13da:	08 95       	ret

000013dc <relays_out_1ch>:

void relays_out_1ch()
{
	RELAYS_OUT_CHOOSE(0b10000000);	// RELE 1
    13dc:	80 e8       	ldi	r24, 0x80	; 128
    13de:	0e 94 d7 09 	call	0x13ae	; 0x13ae <RELAYS_OUT_CHOOSE>
}
    13e2:	08 95       	ret

000013e4 <relays_out_6ch>:

void relays_out_6ch()
{
	RELAYS_OUT_CHOOSE(0b11111100);	// RELE 1,2,3,4,5,6
    13e4:	8c ef       	ldi	r24, 0xFC	; 252
    13e6:	0e 94 d7 09 	call	0x13ae	; 0x13ae <RELAYS_OUT_CHOOSE>
}
    13ea:	08 95       	ret

000013ec <relays_out_off>:
void relays_out_off()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    13ec:	80 e0       	ldi	r24, 0x00	; 0
    13ee:	0e 94 d7 09 	call	0x13ae	; 0x13ae <RELAYS_OUT_CHOOSE>
}
    13f2:	08 95       	ret

000013f4 <relays_out_init>:
void relays_out_init()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    13f4:	80 e0       	ldi	r24, 0x00	; 0
    13f6:	0e 94 d7 09 	call	0x13ae	; 0x13ae <RELAYS_OUT_CHOOSE>
}
    13fa:	08 95       	ret

000013fc <GetSIRC12>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    13fc:	10 92 52 07 	sts	0x0752, r1
    1400:	10 92 57 07 	sts	0x0757, r1

	while(irPin);				//wait for it to be low
    1404:	82 99       	sbic	0x10, 2	; 16
    1406:	fe cf       	rjmp	.-4      	; 0x1404 <GetSIRC12+0x8>
    1408:	20 e0       	ldi	r18, 0x00	; 0
    140a:	40 e2       	ldi	r20, 0x20	; 32
    140c:	53 e0       	ldi	r21, 0x03	; 3
    140e:	04 c0       	rjmp	.+8      	; 0x1418 <GetSIRC12+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    1410:	2f 5f       	subi	r18, 0xFF	; 255
    1412:	ca 01       	movw	r24, r20
    1414:	01 97       	sbiw	r24, 0x01	; 1
    1416:	f1 f7       	brne	.-4      	; 0x1414 <GetSIRC12+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    1418:	82 9b       	sbis	0x10, 2	; 16
    141a:	fa cf       	rjmp	.-12     	; 0x1410 <GetSIRC12+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    141c:	2b 50       	subi	r18, 0x0B	; 11
    141e:	23 30       	cpi	r18, 0x03	; 3
    1420:	70 f5       	brcc	.+92     	; 0x147e <GetSIRC12+0x82>
	{
		return;		//goto StartLook;
    1422:	40 e0       	ldi	r20, 0x00	; 0
    1424:	30 e0       	ldi	r19, 0x00	; 0
    1426:	60 e2       	ldi	r22, 0x20	; 32
    1428:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    142a:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    142c:	82 99       	sbic	0x10, 2	; 16
    142e:	fe cf       	rjmp	.-4      	; 0x142c <GetSIRC12+0x30>
    1430:	20 e0       	ldi	r18, 0x00	; 0
    1432:	04 c0       	rjmp	.+8      	; 0x143c <GetSIRC12+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    1434:	2f 5f       	subi	r18, 0xFF	; 255
    1436:	cb 01       	movw	r24, r22
    1438:	01 97       	sbiw	r24, 0x01	; 1
    143a:	f1 f7       	brne	.-4      	; 0x1438 <GetSIRC12+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    143c:	82 9b       	sbis	0x10, 2	; 16
    143e:	fa cf       	rjmp	.-12     	; 0x1434 <GetSIRC12+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1440:	26 30       	cpi	r18, 0x06	; 6
    1442:	08 f0       	brcs	.+2      	; 0x1446 <GetSIRC12+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    1444:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    1446:	4f 5f       	subi	r20, 0xFF	; 255
    1448:	47 30       	cpi	r20, 0x07	; 7
    144a:	79 f7       	brne	.-34     	; 0x142a <GetSIRC12+0x2e>
    144c:	30 93 52 07 	sts	0x0752, r19
    1450:	40 e0       	ldi	r20, 0x00	; 0
    1452:	30 e0       	ldi	r19, 0x00	; 0
    1454:	60 e2       	ldi	r22, 0x20	; 32
    1456:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1458:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    145a:	82 99       	sbic	0x10, 2	; 16
    145c:	fe cf       	rjmp	.-4      	; 0x145a <GetSIRC12+0x5e>
    145e:	20 e0       	ldi	r18, 0x00	; 0
    1460:	04 c0       	rjmp	.+8      	; 0x146a <GetSIRC12+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1462:	2f 5f       	subi	r18, 0xFF	; 255
    1464:	cb 01       	movw	r24, r22
    1466:	01 97       	sbiw	r24, 0x01	; 1
    1468:	f1 f7       	brne	.-4      	; 0x1466 <GetSIRC12+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    146a:	82 9b       	sbis	0x10, 2	; 16
    146c:	fa cf       	rjmp	.-12     	; 0x1462 <GetSIRC12+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    146e:	26 30       	cpi	r18, 0x06	; 6
    1470:	08 f0       	brcs	.+2      	; 0x1474 <GetSIRC12+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1472:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
    1474:	4f 5f       	subi	r20, 0xFF	; 255
    1476:	45 30       	cpi	r20, 0x05	; 5
    1478:	79 f7       	brne	.-34     	; 0x1458 <GetSIRC12+0x5c>
    147a:	30 93 57 07 	sts	0x0757, r19
    147e:	08 95       	ret

00001480 <GetSIRC15>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    1480:	10 92 52 07 	sts	0x0752, r1
    1484:	10 92 57 07 	sts	0x0757, r1

	while(irPin);				//wait for it to be low
    1488:	82 99       	sbic	0x10, 2	; 16
    148a:	fe cf       	rjmp	.-4      	; 0x1488 <GetSIRC15+0x8>
    148c:	20 e0       	ldi	r18, 0x00	; 0
    148e:	40 e2       	ldi	r20, 0x20	; 32
    1490:	53 e0       	ldi	r21, 0x03	; 3
    1492:	04 c0       	rjmp	.+8      	; 0x149c <GetSIRC15+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    1494:	2f 5f       	subi	r18, 0xFF	; 255
    1496:	ca 01       	movw	r24, r20
    1498:	01 97       	sbiw	r24, 0x01	; 1
    149a:	f1 f7       	brne	.-4      	; 0x1498 <GetSIRC15+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    149c:	82 9b       	sbis	0x10, 2	; 16
    149e:	fa cf       	rjmp	.-12     	; 0x1494 <GetSIRC15+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    14a0:	2b 50       	subi	r18, 0x0B	; 11
    14a2:	23 30       	cpi	r18, 0x03	; 3
    14a4:	70 f5       	brcc	.+92     	; 0x1502 <GetSIRC15+0x82>
	{
		return;		//goto StartLook;
    14a6:	40 e0       	ldi	r20, 0x00	; 0
    14a8:	30 e0       	ldi	r19, 0x00	; 0
    14aa:	60 e2       	ldi	r22, 0x20	; 32
    14ac:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    14ae:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    14b0:	82 99       	sbic	0x10, 2	; 16
    14b2:	fe cf       	rjmp	.-4      	; 0x14b0 <GetSIRC15+0x30>
    14b4:	20 e0       	ldi	r18, 0x00	; 0
    14b6:	04 c0       	rjmp	.+8      	; 0x14c0 <GetSIRC15+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    14b8:	2f 5f       	subi	r18, 0xFF	; 255
    14ba:	cb 01       	movw	r24, r22
    14bc:	01 97       	sbiw	r24, 0x01	; 1
    14be:	f1 f7       	brne	.-4      	; 0x14bc <GetSIRC15+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    14c0:	82 9b       	sbis	0x10, 2	; 16
    14c2:	fa cf       	rjmp	.-12     	; 0x14b8 <GetSIRC15+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    14c4:	26 30       	cpi	r18, 0x06	; 6
    14c6:	08 f0       	brcs	.+2      	; 0x14ca <GetSIRC15+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    14c8:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    14ca:	4f 5f       	subi	r20, 0xFF	; 255
    14cc:	47 30       	cpi	r20, 0x07	; 7
    14ce:	79 f7       	brne	.-34     	; 0x14ae <GetSIRC15+0x2e>
    14d0:	30 93 52 07 	sts	0x0752, r19
    14d4:	40 e0       	ldi	r20, 0x00	; 0
    14d6:	30 e0       	ldi	r19, 0x00	; 0
    14d8:	60 e2       	ldi	r22, 0x20	; 32
    14da:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    14dc:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    14de:	82 99       	sbic	0x10, 2	; 16
    14e0:	fe cf       	rjmp	.-4      	; 0x14de <GetSIRC15+0x5e>
    14e2:	20 e0       	ldi	r18, 0x00	; 0
    14e4:	04 c0       	rjmp	.+8      	; 0x14ee <GetSIRC15+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    14e6:	2f 5f       	subi	r18, 0xFF	; 255
    14e8:	cb 01       	movw	r24, r22
    14ea:	01 97       	sbiw	r24, 0x01	; 1
    14ec:	f1 f7       	brne	.-4      	; 0x14ea <GetSIRC15+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    14ee:	82 9b       	sbis	0x10, 2	; 16
    14f0:	fa cf       	rjmp	.-12     	; 0x14e6 <GetSIRC15+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    14f2:	26 30       	cpi	r18, 0x06	; 6
    14f4:	08 f0       	brcs	.+2      	; 0x14f8 <GetSIRC15+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    14f6:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
    14f8:	4f 5f       	subi	r20, 0xFF	; 255
    14fa:	48 30       	cpi	r20, 0x08	; 8
    14fc:	79 f7       	brne	.-34     	; 0x14dc <GetSIRC15+0x5c>
    14fe:	30 93 57 07 	sts	0x0757, r19
    1502:	08 95       	ret

00001504 <GetSIRC20>:
{
	char x;
	char lTime;

//StartLook:
	irExtended = irAddress = irCommand = 0;
    1504:	10 92 52 07 	sts	0x0752, r1
    1508:	10 92 57 07 	sts	0x0757, r1
    150c:	10 92 59 07 	sts	0x0759, r1

	while(irPin);				//wait for it to be low
    1510:	82 99       	sbic	0x10, 2	; 16
    1512:	fe cf       	rjmp	.-4      	; 0x1510 <GetSIRC20+0xc>
    1514:	20 e0       	ldi	r18, 0x00	; 0
    1516:	40 e2       	ldi	r20, 0x20	; 32
    1518:	53 e0       	ldi	r21, 0x03	; 3
    151a:	04 c0       	rjmp	.+8      	; 0x1524 <GetSIRC20+0x20>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    151c:	2f 5f       	subi	r18, 0xFF	; 255
    151e:	ca 01       	movw	r24, r20
    1520:	01 97       	sbiw	r24, 0x01	; 1
    1522:	f1 f7       	brne	.-4      	; 0x1520 <GetSIRC20+0x1c>
	irExtended = irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    1524:	82 9b       	sbis	0x10, 2	; 16
    1526:	fa cf       	rjmp	.-12     	; 0x151c <GetSIRC20+0x18>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1528:	2b 50       	subi	r18, 0x0B	; 11
    152a:	23 30       	cpi	r18, 0x03	; 3
    152c:	08 f0       	brcs	.+2      	; 0x1530 <GetSIRC20+0x2c>
    152e:	45 c0       	rjmp	.+138    	; 0x15ba <GetSIRC20+0xb6>
	{
		return;		//goto StartLook;
    1530:	40 e0       	ldi	r20, 0x00	; 0
    1532:	30 e0       	ldi	r19, 0x00	; 0
    1534:	60 e2       	ldi	r22, 0x20	; 32
    1536:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1538:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    153a:	82 99       	sbic	0x10, 2	; 16
    153c:	fe cf       	rjmp	.-4      	; 0x153a <GetSIRC20+0x36>
    153e:	20 e0       	ldi	r18, 0x00	; 0
    1540:	04 c0       	rjmp	.+8      	; 0x154a <GetSIRC20+0x46>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    1542:	2f 5f       	subi	r18, 0xFF	; 255
    1544:	cb 01       	movw	r24, r22
    1546:	01 97       	sbiw	r24, 0x01	; 1
    1548:	f1 f7       	brne	.-4      	; 0x1546 <GetSIRC20+0x42>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    154a:	82 9b       	sbis	0x10, 2	; 16
    154c:	fa cf       	rjmp	.-12     	; 0x1542 <GetSIRC20+0x3e>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    154e:	26 30       	cpi	r18, 0x06	; 6
    1550:	08 f0       	brcs	.+2      	; 0x1554 <GetSIRC20+0x50>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    1552:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    1554:	4f 5f       	subi	r20, 0xFF	; 255
    1556:	47 30       	cpi	r20, 0x07	; 7
    1558:	79 f7       	brne	.-34     	; 0x1538 <GetSIRC20+0x34>
    155a:	30 93 52 07 	sts	0x0752, r19
    155e:	40 e0       	ldi	r20, 0x00	; 0
    1560:	30 e0       	ldi	r19, 0x00	; 0
    1562:	60 e2       	ldi	r22, 0x20	; 32
    1564:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1566:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1568:	82 99       	sbic	0x10, 2	; 16
    156a:	fe cf       	rjmp	.-4      	; 0x1568 <GetSIRC20+0x64>
    156c:	20 e0       	ldi	r18, 0x00	; 0
    156e:	04 c0       	rjmp	.+8      	; 0x1578 <GetSIRC20+0x74>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1570:	2f 5f       	subi	r18, 0xFF	; 255
    1572:	cb 01       	movw	r24, r22
    1574:	01 97       	sbiw	r24, 0x01	; 1
    1576:	f1 f7       	brne	.-4      	; 0x1574 <GetSIRC20+0x70>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1578:	82 9b       	sbis	0x10, 2	; 16
    157a:	fa cf       	rjmp	.-12     	; 0x1570 <GetSIRC20+0x6c>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    157c:	26 30       	cpi	r18, 0x06	; 6
    157e:	08 f0       	brcs	.+2      	; 0x1582 <GetSIRC20+0x7e>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1580:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
    1582:	4f 5f       	subi	r20, 0xFF	; 255
    1584:	45 30       	cpi	r20, 0x05	; 5
    1586:	79 f7       	brne	.-34     	; 0x1566 <GetSIRC20+0x62>
    1588:	30 93 57 07 	sts	0x0757, r19
    158c:	40 e0       	ldi	r20, 0x00	; 0
    158e:	30 e0       	ldi	r19, 0x00	; 0
    1590:	60 e2       	ldi	r22, 0x20	; 32
    1592:	73 e0       	ldi	r23, 0x03	; 3
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
		{
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1594:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1596:	82 99       	sbic	0x10, 2	; 16
    1598:	fe cf       	rjmp	.-4      	; 0x1596 <GetSIRC20+0x92>
    159a:	20 e0       	ldi	r18, 0x00	; 0
    159c:	04 c0       	rjmp	.+8      	; 0x15a6 <GetSIRC20+0xa2>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    159e:	2f 5f       	subi	r18, 0xFF	; 255
    15a0:	cb 01       	movw	r24, r22
    15a2:	01 97       	sbiw	r24, 0x01	; 1
    15a4:	f1 f7       	brne	.-4      	; 0x15a2 <GetSIRC20+0x9e>
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    15a6:	82 9b       	sbis	0x10, 2	; 16
    15a8:	fa cf       	rjmp	.-12     	; 0x159e <GetSIRC20+0x9a>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    15aa:	26 30       	cpi	r18, 0x06	; 6
    15ac:	08 f0       	brcs	.+2      	; 0x15b0 <GetSIRC20+0xac>
				irExtended |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    15ae:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
    15b0:	4f 5f       	subi	r20, 0xFF	; 255
    15b2:	48 30       	cpi	r20, 0x08	; 8
    15b4:	79 f7       	brne	.-34     	; 0x1594 <GetSIRC20+0x90>
    15b6:	30 93 59 07 	sts	0x0759, r19
    15ba:	08 95       	ret

000015bc <__udivmodqi4>:
    15bc:	99 1b       	sub	r25, r25
    15be:	79 e0       	ldi	r23, 0x09	; 9
    15c0:	04 c0       	rjmp	.+8      	; 0x15ca <__udivmodqi4_ep>

000015c2 <__udivmodqi4_loop>:
    15c2:	99 1f       	adc	r25, r25
    15c4:	96 17       	cp	r25, r22
    15c6:	08 f0       	brcs	.+2      	; 0x15ca <__udivmodqi4_ep>
    15c8:	96 1b       	sub	r25, r22

000015ca <__udivmodqi4_ep>:
    15ca:	88 1f       	adc	r24, r24
    15cc:	7a 95       	dec	r23
    15ce:	c9 f7       	brne	.-14     	; 0x15c2 <__udivmodqi4_loop>
    15d0:	80 95       	com	r24
    15d2:	08 95       	ret

000015d4 <__divmodhi4>:
    15d4:	97 fb       	bst	r25, 7
    15d6:	09 2e       	mov	r0, r25
    15d8:	07 26       	eor	r0, r23
    15da:	0a d0       	rcall	.+20     	; 0x15f0 <__divmodhi4_neg1>
    15dc:	77 fd       	sbrc	r23, 7
    15de:	04 d0       	rcall	.+8      	; 0x15e8 <__divmodhi4_neg2>
    15e0:	0c d0       	rcall	.+24     	; 0x15fa <__udivmodhi4>
    15e2:	06 d0       	rcall	.+12     	; 0x15f0 <__divmodhi4_neg1>
    15e4:	00 20       	and	r0, r0
    15e6:	1a f4       	brpl	.+6      	; 0x15ee <__divmodhi4_exit>

000015e8 <__divmodhi4_neg2>:
    15e8:	70 95       	com	r23
    15ea:	61 95       	neg	r22
    15ec:	7f 4f       	sbci	r23, 0xFF	; 255

000015ee <__divmodhi4_exit>:
    15ee:	08 95       	ret

000015f0 <__divmodhi4_neg1>:
    15f0:	f6 f7       	brtc	.-4      	; 0x15ee <__divmodhi4_exit>
    15f2:	90 95       	com	r25
    15f4:	81 95       	neg	r24
    15f6:	9f 4f       	sbci	r25, 0xFF	; 255
    15f8:	08 95       	ret

000015fa <__udivmodhi4>:
    15fa:	aa 1b       	sub	r26, r26
    15fc:	bb 1b       	sub	r27, r27
    15fe:	51 e1       	ldi	r21, 0x11	; 17
    1600:	07 c0       	rjmp	.+14     	; 0x1610 <__udivmodhi4_ep>

00001602 <__udivmodhi4_loop>:
    1602:	aa 1f       	adc	r26, r26
    1604:	bb 1f       	adc	r27, r27
    1606:	a6 17       	cp	r26, r22
    1608:	b7 07       	cpc	r27, r23
    160a:	10 f0       	brcs	.+4      	; 0x1610 <__udivmodhi4_ep>
    160c:	a6 1b       	sub	r26, r22
    160e:	b7 0b       	sbc	r27, r23

00001610 <__udivmodhi4_ep>:
    1610:	88 1f       	adc	r24, r24
    1612:	99 1f       	adc	r25, r25
    1614:	5a 95       	dec	r21
    1616:	a9 f7       	brne	.-22     	; 0x1602 <__udivmodhi4_loop>
    1618:	80 95       	com	r24
    161a:	90 95       	com	r25
    161c:	bc 01       	movw	r22, r24
    161e:	cd 01       	movw	r24, r26
    1620:	08 95       	ret

00001622 <itoa>:
    1622:	fb 01       	movw	r30, r22
    1624:	9f 01       	movw	r18, r30
    1626:	e8 94       	clt
    1628:	42 30       	cpi	r20, 0x02	; 2
    162a:	c4 f0       	brlt	.+48     	; 0x165c <itoa+0x3a>
    162c:	45 32       	cpi	r20, 0x25	; 37
    162e:	b4 f4       	brge	.+44     	; 0x165c <itoa+0x3a>
    1630:	4a 30       	cpi	r20, 0x0A	; 10
    1632:	29 f4       	brne	.+10     	; 0x163e <itoa+0x1c>
    1634:	97 fb       	bst	r25, 7
    1636:	1e f4       	brtc	.+6      	; 0x163e <itoa+0x1c>
    1638:	90 95       	com	r25
    163a:	81 95       	neg	r24
    163c:	9f 4f       	sbci	r25, 0xFF	; 255
    163e:	64 2f       	mov	r22, r20
    1640:	77 27       	eor	r23, r23
    1642:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <__udivmodhi4>
    1646:	80 5d       	subi	r24, 0xD0	; 208
    1648:	8a 33       	cpi	r24, 0x3A	; 58
    164a:	0c f0       	brlt	.+2      	; 0x164e <itoa+0x2c>
    164c:	89 5d       	subi	r24, 0xD9	; 217
    164e:	81 93       	st	Z+, r24
    1650:	cb 01       	movw	r24, r22
    1652:	00 97       	sbiw	r24, 0x00	; 0
    1654:	a1 f7       	brne	.-24     	; 0x163e <itoa+0x1c>
    1656:	16 f4       	brtc	.+4      	; 0x165c <itoa+0x3a>
    1658:	5d e2       	ldi	r21, 0x2D	; 45
    165a:	51 93       	st	Z+, r21
    165c:	10 82       	st	Z, r1
    165e:	c9 01       	movw	r24, r18
    1660:	0c 94 a1 0b 	jmp	0x1742	; 0x1742 <strrev>

00001664 <ltoa>:
    1664:	fa 01       	movw	r30, r20
    1666:	cf 93       	push	r28
    1668:	ff 93       	push	r31
    166a:	ef 93       	push	r30
    166c:	22 30       	cpi	r18, 0x02	; 2
    166e:	44 f1       	brlt	.+80     	; 0x16c0 <ltoa+0x5c>
    1670:	25 32       	cpi	r18, 0x25	; 37
    1672:	34 f5       	brge	.+76     	; 0x16c0 <ltoa+0x5c>
    1674:	c2 2f       	mov	r28, r18
    1676:	e8 94       	clt
    1678:	ca 30       	cpi	r28, 0x0A	; 10
    167a:	49 f4       	brne	.+18     	; 0x168e <ltoa+0x2a>
    167c:	97 fb       	bst	r25, 7
    167e:	3e f4       	brtc	.+14     	; 0x168e <ltoa+0x2a>
    1680:	90 95       	com	r25
    1682:	80 95       	com	r24
    1684:	70 95       	com	r23
    1686:	61 95       	neg	r22
    1688:	7f 4f       	sbci	r23, 0xFF	; 255
    168a:	8f 4f       	sbci	r24, 0xFF	; 255
    168c:	9f 4f       	sbci	r25, 0xFF	; 255
    168e:	2c 2f       	mov	r18, r28
    1690:	33 27       	eor	r19, r19
    1692:	44 27       	eor	r20, r20
    1694:	55 27       	eor	r21, r21
    1696:	ff 93       	push	r31
    1698:	ef 93       	push	r30
    169a:	0e 94 b1 0b 	call	0x1762	; 0x1762 <__udivmodsi4>
    169e:	ef 91       	pop	r30
    16a0:	ff 91       	pop	r31
    16a2:	60 5d       	subi	r22, 0xD0	; 208
    16a4:	6a 33       	cpi	r22, 0x3A	; 58
    16a6:	0c f0       	brlt	.+2      	; 0x16aa <ltoa+0x46>
    16a8:	69 5d       	subi	r22, 0xD9	; 217
    16aa:	61 93       	st	Z+, r22
    16ac:	b9 01       	movw	r22, r18
    16ae:	ca 01       	movw	r24, r20
    16b0:	60 50       	subi	r22, 0x00	; 0
    16b2:	70 40       	sbci	r23, 0x00	; 0
    16b4:	80 40       	sbci	r24, 0x00	; 0
    16b6:	90 40       	sbci	r25, 0x00	; 0
    16b8:	51 f7       	brne	.-44     	; 0x168e <ltoa+0x2a>
    16ba:	16 f4       	brtc	.+4      	; 0x16c0 <ltoa+0x5c>
    16bc:	cd e2       	ldi	r28, 0x2D	; 45
    16be:	c1 93       	st	Z+, r28
    16c0:	10 82       	st	Z, r1
    16c2:	8f 91       	pop	r24
    16c4:	9f 91       	pop	r25
    16c6:	cf 91       	pop	r28
    16c8:	0c 94 a1 0b 	jmp	0x1742	; 0x1742 <strrev>

000016cc <ultoa>:
    16cc:	fa 01       	movw	r30, r20
    16ce:	cf 93       	push	r28
    16d0:	ff 93       	push	r31
    16d2:	ef 93       	push	r30
    16d4:	22 30       	cpi	r18, 0x02	; 2
    16d6:	cc f0       	brlt	.+50     	; 0x170a <ultoa+0x3e>
    16d8:	25 32       	cpi	r18, 0x25	; 37
    16da:	bc f4       	brge	.+46     	; 0x170a <ultoa+0x3e>
    16dc:	c2 2f       	mov	r28, r18
    16de:	2c 2f       	mov	r18, r28
    16e0:	33 27       	eor	r19, r19
    16e2:	44 27       	eor	r20, r20
    16e4:	55 27       	eor	r21, r21
    16e6:	ff 93       	push	r31
    16e8:	ef 93       	push	r30
    16ea:	0e 94 b1 0b 	call	0x1762	; 0x1762 <__udivmodsi4>
    16ee:	ef 91       	pop	r30
    16f0:	ff 91       	pop	r31
    16f2:	60 5d       	subi	r22, 0xD0	; 208
    16f4:	6a 33       	cpi	r22, 0x3A	; 58
    16f6:	0c f0       	brlt	.+2      	; 0x16fa <ultoa+0x2e>
    16f8:	69 5d       	subi	r22, 0xD9	; 217
    16fa:	61 93       	st	Z+, r22
    16fc:	b9 01       	movw	r22, r18
    16fe:	ca 01       	movw	r24, r20
    1700:	60 50       	subi	r22, 0x00	; 0
    1702:	70 40       	sbci	r23, 0x00	; 0
    1704:	80 40       	sbci	r24, 0x00	; 0
    1706:	90 40       	sbci	r25, 0x00	; 0
    1708:	51 f7       	brne	.-44     	; 0x16de <ultoa+0x12>
    170a:	10 82       	st	Z, r1
    170c:	8f 91       	pop	r24
    170e:	9f 91       	pop	r25
    1710:	cf 91       	pop	r28
    1712:	0c 94 a1 0b 	jmp	0x1742	; 0x1742 <strrev>

00001716 <utoa>:
    1716:	fb 01       	movw	r30, r22
    1718:	9f 01       	movw	r18, r30
    171a:	42 30       	cpi	r20, 0x02	; 2
    171c:	74 f0       	brlt	.+28     	; 0x173a <utoa+0x24>
    171e:	45 32       	cpi	r20, 0x25	; 37
    1720:	64 f4       	brge	.+24     	; 0x173a <utoa+0x24>
    1722:	64 2f       	mov	r22, r20
    1724:	77 27       	eor	r23, r23
    1726:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <__udivmodhi4>
    172a:	80 5d       	subi	r24, 0xD0	; 208
    172c:	8a 33       	cpi	r24, 0x3A	; 58
    172e:	0c f0       	brlt	.+2      	; 0x1732 <utoa+0x1c>
    1730:	89 5d       	subi	r24, 0xD9	; 217
    1732:	81 93       	st	Z+, r24
    1734:	cb 01       	movw	r24, r22
    1736:	00 97       	sbiw	r24, 0x00	; 0
    1738:	a1 f7       	brne	.-24     	; 0x1722 <utoa+0xc>
    173a:	10 82       	st	Z, r1
    173c:	c9 01       	movw	r24, r18
    173e:	0c 94 a1 0b 	jmp	0x1742	; 0x1742 <strrev>

00001742 <strrev>:
    1742:	dc 01       	movw	r26, r24
    1744:	fc 01       	movw	r30, r24
    1746:	67 2f       	mov	r22, r23
    1748:	71 91       	ld	r23, Z+
    174a:	77 23       	and	r23, r23
    174c:	e1 f7       	brne	.-8      	; 0x1746 <strrev+0x4>
    174e:	32 97       	sbiw	r30, 0x02	; 2
    1750:	04 c0       	rjmp	.+8      	; 0x175a <strrev+0x18>
    1752:	7c 91       	ld	r23, X
    1754:	6d 93       	st	X+, r22
    1756:	70 83       	st	Z, r23
    1758:	62 91       	ld	r22, -Z
    175a:	ae 17       	cp	r26, r30
    175c:	bf 07       	cpc	r27, r31
    175e:	c8 f3       	brcs	.-14     	; 0x1752 <strrev+0x10>
    1760:	08 95       	ret

00001762 <__udivmodsi4>:
    1762:	a1 e2       	ldi	r26, 0x21	; 33
    1764:	1a 2e       	mov	r1, r26
    1766:	aa 1b       	sub	r26, r26
    1768:	bb 1b       	sub	r27, r27
    176a:	fd 01       	movw	r30, r26
    176c:	0d c0       	rjmp	.+26     	; 0x1788 <__udivmodsi4_ep>

0000176e <__udivmodsi4_loop>:
    176e:	aa 1f       	adc	r26, r26
    1770:	bb 1f       	adc	r27, r27
    1772:	ee 1f       	adc	r30, r30
    1774:	ff 1f       	adc	r31, r31
    1776:	a2 17       	cp	r26, r18
    1778:	b3 07       	cpc	r27, r19
    177a:	e4 07       	cpc	r30, r20
    177c:	f5 07       	cpc	r31, r21
    177e:	20 f0       	brcs	.+8      	; 0x1788 <__udivmodsi4_ep>
    1780:	a2 1b       	sub	r26, r18
    1782:	b3 0b       	sbc	r27, r19
    1784:	e4 0b       	sbc	r30, r20
    1786:	f5 0b       	sbc	r31, r21

00001788 <__udivmodsi4_ep>:
    1788:	66 1f       	adc	r22, r22
    178a:	77 1f       	adc	r23, r23
    178c:	88 1f       	adc	r24, r24
    178e:	99 1f       	adc	r25, r25
    1790:	1a 94       	dec	r1
    1792:	69 f7       	brne	.-38     	; 0x176e <__udivmodsi4_loop>
    1794:	60 95       	com	r22
    1796:	70 95       	com	r23
    1798:	80 95       	com	r24
    179a:	90 95       	com	r25
    179c:	9b 01       	movw	r18, r22
    179e:	ac 01       	movw	r20, r24
    17a0:	bd 01       	movw	r22, r26
    17a2:	cf 01       	movw	r24, r30
    17a4:	08 95       	ret

000017a6 <_exit>:
    17a6:	f8 94       	cli

000017a8 <__stop_program>:
    17a8:	ff cf       	rjmp	.-2      	; 0x17a8 <__stop_program>
