
ATmega32A_GCC_DigitalControlAudioSystem_pLibs.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001882  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000724  00800060  00001882  00001916  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002b  00800784  00800784  0000203a  2**0
                  ALLOC
  3 .debug_aranges 00000180  00000000  00000000  0000203a  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000a54  00000000  00000000  000021ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002f1d  00000000  00000000  00002c0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d5e  00000000  00000000  00005b2b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002b0d  00000000  00000000  00006889  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007d0  00000000  00000000  00009398  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000b76  00000000  00000000  00009b68  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000e1e  00000000  00000000  0000a6de  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000798  00000000  00000000  0000b4fc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 69 05 	jmp	0xad2	; 0xad2 <__vector_1>
       8:	0c 94 97 00 	jmp	0x12e	; 0x12e <__vector_2>
       c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__vector_3>
      10:	0c 94 ab 00 	jmp	0x156	; 0x156 <__vector_4>
      14:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	17 e0       	ldi	r17, 0x07	; 7
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e8       	ldi	r30, 0x82	; 130
      68:	f8 e1       	ldi	r31, 0x18	; 24
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 38       	cpi	r26, 0x84	; 132
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a4 e8       	ldi	r26, 0x84	; 132
      7a:	b7 e0       	ldi	r27, 0x07	; 7
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 3a       	cpi	r26, 0xAF	; 175
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 94 04 	call	0x928	; 0x928 <main>
      8a:	0c 94 3f 0c 	jmp	0x187e	; 0x187e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <port_init>:
*****************************************/
void port_init(void)
{	

// PORT A connections
	DDRA  = 0b11111111;		//  PA7:U8/PGA2310,CS; PA6:U7/PGA2310,CS; PA5:CON2LCD,RS; PA4:CON2LCD,RW; PA3:CON2LCD,E; PA2:U2/74HC595,RCLK(LCD); PA1:U2/74HC595,SCLK(LCD); PA0:U2/74HC595,DATA(LCD);
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	8a bb       	out	0x1a, r24	; 26
	PORTA = 0b00000000;		//	Interfaces: NOT USED. PULLUP DISABLE in PORTA.
      96:	1b ba       	out	0x1b, r1	; 27

// PORT B connections
	DDRB  = 0b10111000;		//  PB7:U6,U7,U8/PGA2310,SCLK; PB6:U6,U7,U8/PGA2310,SDO(CON33,36,39); PB5:U6,U7,U8/PGA2310,SDI; PB4:U12/74HC595,DATA(REL_OUT); PB3:U6/PGA2310,CS; PB2:CON8/BUTTON,"ESCAPE",INT2; PB1:CON5/BUTTON,"ON/OFF"; PB0:CON14TempSensor/DS18S20,DQ,IN/OUT;
      98:	88 eb       	ldi	r24, 0xB8	; 184
      9a:	87 bb       	out	0x17, r24	; 23
	PORTB = 0b00000111;		//	Interfaces: EXTERNAL INTERRUPT 2; SPI. set pullup to IRTSOP2240 / BUTTON(on/off) / DS18s20.
      9c:	87 e0       	ldi	r24, 0x07	; 7
      9e:	88 bb       	out	0x18, r24	; 24

// PORT C connections
	DDRC  = 0b11001100;		//  PC7:U10/74HC595,DATA(REL_IN); PC6:U10/74HC595,SCLK(REL_IN); PC5:EncoderED1112S,A; PC4:EncoderED1112S,B; PC3:U10/74HC595,RCLK(REL_IN); PC2:Q2/BD237(RELAY_POWER_SUPPLY); PC1:DS1307/24C64,I2C/SDA; PC0:DS1307/24C64,I2C/SCL;
      a0:	8c ec       	ldi	r24, 0xCC	; 204
      a2:	84 bb       	out	0x14, r24	; 20
	PORTC = 0b00000000;		//	Interfaces: I2C. PULLUP DISABLE in PORTC.
      a4:	15 ba       	out	0x15, r1	; 21

// PORT D connections
	DDRD  = 0b11110000;		//  PD7:U12/74HC595,RCLK(REL_OUT); PD6:U12/74HC595,SCLK(REL_OUT); PD5:Q1/BD237(FAN_CONTROL_PWM); PD4:LED5/"ON/OFF AUDIO SYSTEM"; PD3:CON11/EncoderBUTTON,"MENU/ENTER"/INT1; PD2:CON12/IR/TSOP2240,/INT0; PD1:CON14/MAX232,UART/TXD; PD0:CON14/MAX232,UART/RXD;
      a6:	80 ef       	ldi	r24, 0xF0	; 240
      a8:	81 bb       	out	0x11, r24	; 17
	PORTD = 0b00001100;		//	Interfaces: TIMER1; UART/USART; EXTERNAL INTERRUPT 0, 1. PULLUP DISABLE in PORTD.
      aa:	8c e0       	ldi	r24, 0x0C	; 12
      ac:	82 bb       	out	0x12, r24	; 18
//	DDRD&=~_BV(0);// DDD0 = "0"  (DDD0=DDRD nulev bit) set PORTD pin0 to zero as input
//	PORTD|=_BV(0);// PD0  = "1"  Enable pull up
//	PORTD|=_BV(1);// PD1  = "1"  led
//	DDRD|=_BV(1); // DDD1 = "1"  (DDD1=DDRD parvi bit) set PORTD pin1 to one as output

}
      ae:	08 95       	ret

000000b0 <ext0_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 0 **
*******************************************/
void ext0_intrpt_init(void)
{
	MCUCR = 0b00000010;	// SETUP EXT INT 0, ISC01 = 1, ISC00 = 0: Falling edge on INT0 activates the interrupt; ISC01 = 1, ISC00 = 1: Rising edge on INT0 activates the interrupt;
      b0:	82 e0       	ldi	r24, 0x02	; 2
      b2:	85 bf       	out	0x35, r24	; 53

// IN FUNCTIONS:
//	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
//	GIFR   = 0b01000000;	// Clear INT0 flag.
}
      b4:	08 95       	ret

000000b6 <ext0_intrpt_on>:
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      b6:	80 e4       	ldi	r24, 0x40	; 64
      b8:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      ba:	8a bf       	out	0x3a, r24	; 58
}
      bc:	08 95       	ret

000000be <ext0_intrpt_off>:
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      be:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      c0:	80 e4       	ldi	r24, 0x40	; 64
      c2:	8a bf       	out	0x3a, r24	; 58
}
      c4:	08 95       	ret

000000c6 <ext1_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 1 **
*******************************************/
void ext1_intrpt_init(void)
{
}
      c6:	08 95       	ret

000000c8 <ext2_intrpt_init>:
//	MCUCSR = 0b00000000;	// SETUP EXT INT 2, ISC2 = 0: Falling edge on INT2 activates the interrupt; ISC2 = 1: Rising edge on INT2 activates the interrupt;

// IN FUNCTIONS:
//	GICR   = 0b00100000;	// INT2 = 0: Disable External Interrupt on INT2; INT2 = 1: Enable External Interrupt on INT2;
//	GIFR   = 0b00100000;	// Clear INT2 flag.
}
      c8:	08 95       	ret

000000ca <timer1_init>:
*****************************/
void timer1_init(void)
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  = 0b00000000;	// maskov registar za prekasvaniq
      ca:	19 be       	out	0x39, r1	; 57
	TCNT1H = 0b00000000;
      cc:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
      ce:	1c bc       	out	0x2c, r1	; 44

//	OCR1BH = 100; //20;			// 0   = 0b00000000 (DEC = BIN)	// LED
//	OCR1BL = 100; //20;			// 200 = 0b11001000 (DEC = BIN)	// LED

//	TIMSK = (1 << OCIE1A);
}
      d0:	08 95       	ret

000000d2 <timer2_init>:
/*****************************
** INITIZLIZATION OF TIMER2 **
*****************************/
void timer2_init(void)
{
	SFIOR = 0b00000010;		// Prescaler Reset Timer2 (bit1 –> PSR2)
      d2:	82 e0       	ldi	r24, 0x02	; 2
      d4:	80 bf       	out	0x30, r24	; 48
	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      d6:	81 e8       	ldi	r24, 0x81	; 129
      d8:	85 bd       	out	0x25, r24	; 37
	OCR2 = 0; // FAN PWM ON
      da:	13 bc       	out	0x23, r1	; 35
}
      dc:	08 95       	ret

000000de <timer1_on_speed>:
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      de:	81 ea       	ldi	r24, 0xA1	; 161
      e0:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
      e2:	81 e0       	ldi	r24, 0x01	; 1
      e4:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
      e6:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
      e8:	80 91 3f 07 	lds	r24, 0x073F
      ec:	e0 e4       	ldi	r30, 0x40	; 64
      ee:	f7 e0       	ldi	r31, 0x07	; 7
      f0:	e8 0f       	add	r30, r24
      f2:	f1 1d       	adc	r31, r1
      f4:	80 81       	ld	r24, Z
      f6:	8a bd       	out	0x2a, r24	; 42

// CHANNEL B
//	OCR1BH = 0; // LED PWM ON				// out	OCR1BH, r16		; 0   = 0b00000000 (DEC = BIN)
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}
      f8:	08 95       	ret

000000fa <timer1_off>:

void timer1_off(void)
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
      fa:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
      fc:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
      fe:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     100:	1a bc       	out	0x2a, r1	; 42

//	OCR1BH = 0; // LED PWM OFF
//	OCR1BL = 0; // LED PWM OFF
}
     102:	08 95       	ret

00000104 <fan_pwm_control_speed>:
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     104:	81 ea       	ldi	r24, 0xA1	; 161
     106:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     108:	81 e0       	ldi	r24, 0x01	; 1
     10a:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     10c:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     10e:	80 91 3f 07 	lds	r24, 0x073F
     112:	e0 e4       	ldi	r30, 0x40	; 64
     114:	f7 e0       	ldi	r31, 0x07	; 7
     116:	e8 0f       	add	r30, r24
     118:	f1 1d       	adc	r31, r1
     11a:	80 81       	ld	r24, Z
     11c:	8a bd       	out	0x2a, r24	; 42
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
}
     11e:	08 95       	ret

00000120 <fan_pwm_off>:
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}

void timer1_off(void)
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     120:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     122:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     124:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     126:	1a bc       	out	0x2a, r1	; 42
	timer1_on_speed();
}
void fan_pwm_off(void)
{
	timer1_off();
}
     128:	08 95       	ret

0000012a <timer2_on>:
***************************************/
void timer2_on(void)	// Timer2 On
{
//	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
//	OCR2 = 1; // FAN PWM ON
}
     12a:	08 95       	ret

0000012c <timer2_off>:

void timer2_off(void)	// Timer2 Off
{
//	TCCR2 = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
//	OCR2 = 0; // FAN PWM OFF
}
     12c:	08 95       	ret

0000012e <__vector_2>:

/*****************************************
**** EXTERNAL INTERRUPT 1 VECTOR 02 ******
*****************************************/
ISR(INT1_vect)
{
     12e:	1f 92       	push	r1
     130:	0f 92       	push	r0
     132:	0f b6       	in	r0, 0x3f	; 63
     134:	0f 92       	push	r0
     136:	11 24       	eor	r1, r1
}
     138:	0f 90       	pop	r0
     13a:	0f be       	out	0x3f, r0	; 63
     13c:	0f 90       	pop	r0
     13e:	1f 90       	pop	r1
     140:	18 95       	reti

00000142 <__vector_3>:

/*****************************************
**** EXTERNAL INTERRUPT 2 VECTOR 03 ******
*****************************************/
ISR(INT2_vect)
{
     142:	1f 92       	push	r1
     144:	0f 92       	push	r0
     146:	0f b6       	in	r0, 0x3f	; 63
     148:	0f 92       	push	r0
     14a:	11 24       	eor	r1, r1
}
     14c:	0f 90       	pop	r0
     14e:	0f be       	out	0x3f, r0	; 63
     150:	0f 90       	pop	r0
     152:	1f 90       	pop	r1
     154:	18 95       	reti

00000156 <__vector_4>:

/*****************************************
**** TIMER 2 OUTPUT COMPARE VECTOR 04 ****
*****************************************/
ISR(TIMER2_COMP_vect)
{
     156:	1f 92       	push	r1
     158:	0f 92       	push	r0
     15a:	0f b6       	in	r0, 0x3f	; 63
     15c:	0f 92       	push	r0
     15e:	11 24       	eor	r1, r1
}
     160:	0f 90       	pop	r0
     162:	0f be       	out	0x3f, r0	; 63
     164:	0f 90       	pop	r0
     166:	1f 90       	pop	r1
     168:	18 95       	reti

0000016a <__vector_5>:

/*****************************************
**** TIMER 2 OVERFLOW VECTOR 05 **********
*****************************************/
ISR(TIMER2_OVF_vect)
{
     16a:	1f 92       	push	r1
     16c:	0f 92       	push	r0
     16e:	0f b6       	in	r0, 0x3f	; 63
     170:	0f 92       	push	r0
     172:	11 24       	eor	r1, r1
}
     174:	0f 90       	pop	r0
     176:	0f be       	out	0x3f, r0	; 63
     178:	0f 90       	pop	r0
     17a:	1f 90       	pop	r1
     17c:	18 95       	reti

0000017e <about>:

	return temper;
}

void about(void)
{
     17e:	0f 93       	push	r16
     180:	1f 93       	push	r17
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] =====================================================\r\n");
     182:	00 e6       	ldi	r16, 0x60	; 96
     184:	10 e0       	ldi	r17, 0x00	; 0
     186:	c8 01       	movw	r24, r16
     188:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartString("[UART INFO] \tAuthors and creators: P.Upinov and P.Stoyanov\r\n");
     18c:	84 ea       	ldi	r24, 0xA4	; 164
     18e:	90 e0       	ldi	r25, 0x00	; 0
     190:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartString("[UART INFO] \tDevice name: Digital Control Audio System\r\n");
     194:	81 ee       	ldi	r24, 0xE1	; 225
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartString("[UART INFO] \tFirmware version beta ");
     19c:	8a e1       	ldi	r24, 0x1A	; 26
     19e:	91 e0       	ldi	r25, 0x01	; 1
     1a0:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartInt(FIRMWARE_VERSION);
     1a4:	8e e1       	ldi	r24, 0x1E	; 30
     1a6:	90 e0       	ldi	r25, 0x00	; 0
     1a8:	0e 94 03 09 	call	0x1206	; 0x1206 <transmitUartInt>
		transmitUartString("\r\n");
     1ac:	8e e3       	ldi	r24, 0x3E	; 62
     1ae:	91 e0       	ldi	r25, 0x01	; 1
     1b0:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartString("[UART INFO] =====================================================\r\n");
     1b4:	c8 01       	movw	r24, r16
     1b6:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartString("[UART INFO] Da dobavq upravlenie na:\
     1ba:	81 e4       	ldi	r24, 0x41	; 65
     1bc:	91 e0       	ldi	r25, 0x01	; 1
     1be:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
						\r\n[UART INFO] - FAN smart controlling			\
						\r\n[UART INFO] - DS18S20						\
						\r\n[UART INFO] - RTC							\
						\r\n[UART INFO] - Memory\r\n");
	#endif
}
     1c2:	1f 91       	pop	r17
     1c4:	0f 91       	pop	r16
     1c6:	08 95       	ret

000001c8 <init_all>:
*********************************** START OF APPLICATION ************************************
********************************************************************************************/

void init_all()
{
	port_init();		// IO init and configure all port
     1c8:	0e 94 49 00 	call	0x92	; 0x92 <port_init>
*****************************/
void timer1_init(void)
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  = 0b00000000;	// maskov registar za prekasvaniq
     1cc:	19 be       	out	0x39, r1	; 57
	TCNT1H = 0b00000000;
     1ce:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
     1d0:	1c bc       	out	0x2c, r1	; 44
void init_all()
{
	port_init();		// IO init and configure all port
	timer1_init();		// FAN INIT
//	timer2_init();
	LCD_INIT();			// LCD init and reset all lcd contain
     1d2:	0e 94 6a 07 	call	0xed4	; 0xed4 <LCD_INIT>
	uart_init();		// UART debug init
     1d6:	0e 94 ba 08 	call	0x1174	; 0x1174 <uart_init>
	about();			// Any debug important information
     1da:	0e 94 bf 00 	call	0x17e	; 0x17e <about>

	pga2310_init();		// SPI init and reset all (U6, U7, U8) PGA2310 volume values to null
     1de:	0e 94 5f 08 	call	0x10be	; 0x10be <pga2310_init>
	relays_in_init();	// nujno e daden reset be da bade izkliuche usilvatelq, togava reletata za vhod i izhod (bez power relay) sa ostanali vkliucheni
     1e2:	0e 94 3f 0a 	call	0x147e	; 0x147e <relays_in_init>
	relays_out_init();	// nujno e daden reset be da bade izkliuche usilvatelq, togava reletata za vhod i izhod (bez power relay)sa ostanali vkliucheni
     1e6:	0e 94 66 0a 	call	0x14cc	; 0x14cc <relays_out_init>


}
     1ea:	08 95       	ret

000001ec <temperMeasur>:
	}
	return 0;
}

char temperMeasur(unsigned char byte0, unsigned char byte1, unsigned char byte6, unsigned char byte7)
{
     1ec:	1f 93       	push	r17
	char tC = 0;
	char temper = 0;
	double k = 0;
	double j = 0;

	byte0 = storeTemp [0];
     1ee:	10 91 86 07 	lds	r17, 0x0786
	byte1 = storeTemp [1];
     1f2:	80 91 87 07 	lds	r24, 0x0787
	byte6 = storeTemp [6];
	byte7 = storeTemp [7];

	k = ((byte7 - byte6) / byte7) + 0.25;

	if((byte1 == 0x00) && (byte0 == 0x00))
     1f6:	88 23       	and	r24, r24
     1f8:	61 f5       	brne	.+88     	; 0x252 <temperMeasur+0x66>
     1fa:	11 23       	and	r17, r17
     1fc:	79 f4       	brne	.+30     	; 0x21c <temperMeasur+0x30>
	{
		tC = (byte0/2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     1fe:	85 ef       	ldi	r24, 0xF5	; 245
     200:	91 e0       	ldi	r25, 0x01	; 1
     202:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     206:	80 e0       	ldi	r24, 0x00	; 0
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	0e 94 03 09 	call	0x1206	; 0x1206 <transmitUartInt>
		transmitUartString(".0 C\r\n");			// uart debug information string
     20e:	8f e0       	ldi	r24, 0x0F	; 15
     210:	92 e0       	ldi	r25, 0x02	; 2
     212:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     216:	80 e0       	ldi	r24, 0x00	; 0
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	13 c0       	rjmp	.+38     	; 0x242 <temperMeasur+0x56>
	LCD_DATA_STRING(".0 C");		//
	}
	else if((byte1 == 0x00) && (byte0 != 0x00))
	{
		transmitUartString("+");
     21c:	8b e1       	ldi	r24, 0x1B	; 27
     21e:	92 e0       	ldi	r25, 0x02	; 2
     220:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		tC = (byte0/2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     224:	85 ef       	ldi	r24, 0xF5	; 245
     226:	91 e0       	ldi	r25, 0x01	; 1
     228:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     22c:	16 95       	lsr	r17
     22e:	81 2f       	mov	r24, r17
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	0e 94 03 09 	call	0x1206	; 0x1206 <transmitUartInt>
		transmitUartString(".0 C\r\n");			// uart debug information string
     236:	8f e0       	ldi	r24, 0x0F	; 15
     238:	92 e0       	ldi	r25, 0x02	; 2
     23a:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     23e:	81 2f       	mov	r24, r17
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	0e 94 10 08 	call	0x1020	; 0x1020 <LCD_DATA_INT>
	LCD_DATA_STRING(".0 C");		//
     246:	86 e1       	ldi	r24, 0x16	; 22
     248:	92 e0       	ldi	r25, 0x02	; 2
     24a:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
     24e:	80 e0       	ldi	r24, 0x00	; 0
     250:	1b c0       	rjmp	.+54     	; 0x288 <temperMeasur+0x9c>
	}
	else if((byte1 == 0xFF) && (byte0 != 0x00))
     252:	8f 3f       	cpi	r24, 0xFF	; 255
     254:	a1 f4       	brne	.+40     	; 0x27e <temperMeasur+0x92>
     256:	11 23       	and	r17, r17
     258:	91 f0       	breq	.+36     	; 0x27e <temperMeasur+0x92>
	{
		transmitUartString("-");
     25a:	8d e1       	ldi	r24, 0x1D	; 29
     25c:	92 e0       	ldi	r25, 0x02	; 2
     25e:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
//		tC = ((byte0 - 255.5) / 2);		// ne e dobre obraboteno za otricatelni chisla
		tC = ((byte0 - 255) / 2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     262:	85 ef       	ldi	r24, 0xF5	; 245
     264:	91 e0       	ldi	r25, 0x01	; 1
     266:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     26a:	81 2f       	mov	r24, r17
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	8f 5f       	subi	r24, 0xFF	; 255
     270:	90 40       	sbci	r25, 0x00	; 0
     272:	62 e0       	ldi	r22, 0x02	; 2
     274:	70 e0       	ldi	r23, 0x00	; 0
     276:	0e 94 56 0b 	call	0x16ac	; 0x16ac <__divmodhi4>
     27a:	16 2f       	mov	r17, r22
     27c:	d8 cf       	rjmp	.-80     	; 0x22e <temperMeasur+0x42>
	}
	else
	{
		//lcdDataString("ERROR!");	// ERROR not return to display!!!!
	#ifdef DEBUG_ERROR
		transmitUartString("[UART ERROR] ERROR TEMPERATURE\r\n");		// uart debug information string
     27e:	8f e1       	ldi	r24, 0x1F	; 31
     280:	92 e0       	ldi	r25, 0x02	; 2
     282:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
     286:	81 e0       	ldi	r24, 0x01	; 1
	#endif
		return 1;
	}

	return temper;
}
     288:	1f 91       	pop	r17
     28a:	08 95       	ret

0000028c <oneWireRight>:
	}
	return 0;
}

unsigned char oneWireRight()
{
     28c:	cf 93       	push	r28
     28e:	df 93       	push	r29
	unsigned char i;

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
     290:	80 e4       	ldi	r24, 0x40	; 64
     292:	92 e0       	ldi	r25, 0x02	; 2
     294:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     298:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <reset>
     29c:	88 23       	and	r24, r24
     29e:	09 f4       	brne	.+2      	; 0x2a2 <oneWireRight+0x16>
     2a0:	4d c0       	rjmp	.+154    	; 0x33c <oneWireRight+0xb0>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     2a2:	85 e5       	ldi	r24, 0x55	; 85
     2a4:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		// 64-bit ROM CODE
		write_byte(0x10);	// Byte 0
     2a8:	80 e1       	ldi	r24, 0x10	; 16
     2aa:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0x6D);	// Byte 1
     2ae:	8d e6       	ldi	r24, 0x6D	; 109
     2b0:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0xF4);	// Byte 2
     2b4:	84 ef       	ldi	r24, 0xF4	; 244
     2b6:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0x8F);	// Byte 3
     2ba:	8f e8       	ldi	r24, 0x8F	; 143
     2bc:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0x02);	// Byte 4
     2c0:	82 e0       	ldi	r24, 0x02	; 2
     2c2:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0x08);	// Byte 5
     2c6:	88 e0       	ldi	r24, 0x08	; 8
     2c8:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0x00);	// Byte 6
     2cc:	80 e0       	ldi	r24, 0x00	; 0
     2ce:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0xB1);	// Byte 7
     2d2:	81 eb       	ldi	r24, 0xB1	; 177
     2d4:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		// 64-bit ROM CODE

		write_byte(0x44);	// Master issues Convert T command.
     2d8:	84 e4       	ldi	r24, 0x44	; 68
     2da:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     2de:	0e 94 78 06 	call	0xcf0	; 0xcf0 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     2e2:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <reset>
     2e6:	88 23       	and	r24, r24
     2e8:	49 f1       	breq	.+82     	; 0x33c <oneWireRight+0xb0>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     2ea:	85 e5       	ldi	r24, 0x55	; 85
     2ec:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			// 64-bit ROM CODE
			write_byte(0x10);	// Byte 0
     2f0:	80 e1       	ldi	r24, 0x10	; 16
     2f2:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0x6D);	// Byte 1
     2f6:	8d e6       	ldi	r24, 0x6D	; 109
     2f8:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0xF4);	// Byte 2
     2fc:	84 ef       	ldi	r24, 0xF4	; 244
     2fe:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0x8F);	// Byte 3
     302:	8f e8       	ldi	r24, 0x8F	; 143
     304:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0x02);	// Byte 4
     308:	82 e0       	ldi	r24, 0x02	; 2
     30a:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0x08);	// Byte 5
     30e:	88 e0       	ldi	r24, 0x08	; 8
     310:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0x00);	// Byte 6
     314:	80 e0       	ldi	r24, 0x00	; 0
     316:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0xB1);	// Byte 7
     31a:	81 eb       	ldi	r24, 0xB1	; 177
     31c:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
     320:	8e eb       	ldi	r24, 0xBE	; 190
     322:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
     326:	c6 e8       	ldi	r28, 0x86	; 134
     328:	d7 e0       	ldi	r29, 0x07	; 7
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     32a:	0e 94 28 06 	call	0xc50	; 0xc50 <read_byte>
     32e:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     330:	87 e0       	ldi	r24, 0x07	; 7
     332:	cf 38       	cpi	r28, 0x8F	; 143
     334:	d8 07       	cpc	r29, r24
     336:	c9 f7       	brne	.-14     	; 0x32a <oneWireRight+0x9e>
     338:	81 e0       	ldi	r24, 0x01	; 1
     33a:	01 c0       	rjmp	.+2      	; 0x33e <oneWireRight+0xb2>
     33c:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     33e:	df 91       	pop	r29
     340:	cf 91       	pop	r28
     342:	08 95       	ret

00000344 <oneWireLeft>:

/*******************************************
**** 1-WIRE DS18x20 Temperature Sensors ****
*******************************************/
unsigned char oneWireLeft()
{
     344:	cf 93       	push	r28
     346:	df 93       	push	r29
	unsigned char i;

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
     348:	81 e8       	ldi	r24, 0x81	; 129
     34a:	92 e0       	ldi	r25, 0x02	; 2
     34c:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     350:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <reset>
     354:	88 23       	and	r24, r24
     356:	09 f4       	brne	.+2      	; 0x35a <oneWireLeft+0x16>
     358:	4d c0       	rjmp	.+154    	; 0x3f4 <oneWireLeft+0xb0>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     35a:	85 e5       	ldi	r24, 0x55	; 85
     35c:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		// 64-bit ROM CODE
		write_byte(0x10);	// Byte 0
     360:	80 e1       	ldi	r24, 0x10	; 16
     362:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0xDB);	// Byte 1
     366:	8b ed       	ldi	r24, 0xDB	; 219
     368:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0x09);	// Byte 2
     36c:	89 e0       	ldi	r24, 0x09	; 9
     36e:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0xA5);	// Byte 3
     372:	85 ea       	ldi	r24, 0xA5	; 165
     374:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0x01);	// Byte 4
     378:	81 e0       	ldi	r24, 0x01	; 1
     37a:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0x08);	// Byte 5
     37e:	88 e0       	ldi	r24, 0x08	; 8
     380:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0x00);	// Byte 6
     384:	80 e0       	ldi	r24, 0x00	; 0
     386:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0xC1);	// Byte 7
     38a:	81 ec       	ldi	r24, 0xC1	; 193
     38c:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		// 64-bit ROM CODE

		write_byte(0x44);	// Master issues Convert T command.
     390:	84 e4       	ldi	r24, 0x44	; 68
     392:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     396:	0e 94 78 06 	call	0xcf0	; 0xcf0 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     39a:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <reset>
     39e:	88 23       	and	r24, r24
     3a0:	49 f1       	breq	.+82     	; 0x3f4 <oneWireLeft+0xb0>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     3a2:	85 e5       	ldi	r24, 0x55	; 85
     3a4:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			// 64-bit ROM CODE
			write_byte(0x10);	// Byte 0
     3a8:	80 e1       	ldi	r24, 0x10	; 16
     3aa:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0xDB);	// Byte 1
     3ae:	8b ed       	ldi	r24, 0xDB	; 219
     3b0:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0x09);	// Byte 2
     3b4:	89 e0       	ldi	r24, 0x09	; 9
     3b6:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0xA5);	// Byte 3
     3ba:	85 ea       	ldi	r24, 0xA5	; 165
     3bc:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0x01);	// Byte 4
     3c0:	81 e0       	ldi	r24, 0x01	; 1
     3c2:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0x08);	// Byte 5
     3c6:	88 e0       	ldi	r24, 0x08	; 8
     3c8:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0x00);	// Byte 6
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0xC1);	// Byte 7
     3d2:	81 ec       	ldi	r24, 0xC1	; 193
     3d4:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
     3d8:	8e eb       	ldi	r24, 0xBE	; 190
     3da:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
     3de:	c6 e8       	ldi	r28, 0x86	; 134
     3e0:	d7 e0       	ldi	r29, 0x07	; 7
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     3e2:	0e 94 28 06 	call	0xc50	; 0xc50 <read_byte>
     3e6:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     3e8:	87 e0       	ldi	r24, 0x07	; 7
     3ea:	cf 38       	cpi	r28, 0x8F	; 143
     3ec:	d8 07       	cpc	r29, r24
     3ee:	c9 f7       	brne	.-14     	; 0x3e2 <oneWireLeft+0x9e>
     3f0:	81 e0       	ldi	r24, 0x01	; 1
     3f2:	01 c0       	rjmp	.+2      	; 0x3f6 <oneWireLeft+0xb2>
     3f4:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     3f6:	df 91       	pop	r29
     3f8:	cf 91       	pop	r28
     3fa:	08 95       	ret

000003fc <temperature>:

/*****************************
**** TEMPERATURE FUNCTION ****
*****************************/
void temperature()
{
     3fc:	cf 93       	push	r28
     3fe:	df 93       	push	r29
	unsigned char i;
//	LED_low_DISPLAYLED_high();
//	LCD_INIT();								// LCD INITIZLIZATION
	LCD_CLEAR_CONTAIN();
     400:	0e 94 62 07 	call	0xec4	; 0xec4 <LCD_CLEAR_CONTAIN>

	LCD_COMMAND(LCD_SELECT_1ROW);	// select row 1
     404:	80 e0       	ldi	r24, 0x00	; 0
     406:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
	LCD_DATA_STRING("     TEMERATURE     ");		//
     40a:	81 ec       	ldi	r24, 0xC1	; 193
     40c:	92 e0       	ldi	r25, 0x02	; 2
     40e:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
     412:	80 ec       	ldi	r24, 0xC0	; 192
     414:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
	LCD_DATA_STRING("LEFT  SENSOR: ");				//
     418:	86 ed       	ldi	r24, 0xD6	; 214
     41a:	92 e0       	ldi	r25, 0x02	; 2
     41c:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>

	oneWireLeft();
     420:	0e 94 a2 01 	call	0x344	; 0x344 <oneWireLeft>
     424:	c0 e0       	ldi	r28, 0x00	; 0
     426:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] byte ");
     428:	85 ee       	ldi	r24, 0xE5	; 229
     42a:	92 e0       	ldi	r25, 0x02	; 2
     42c:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartInt(i);
     430:	ce 01       	movw	r24, r28
     432:	0e 94 03 09 	call	0x1206	; 0x1206 <transmitUartInt>
		transmitUartString(" : ");
     436:	87 ef       	ldi	r24, 0xF7	; 247
     438:	92 e0       	ldi	r25, 0x02	; 2
     43a:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartInt(storeTemp[i]);
     43e:	fe 01       	movw	r30, r28
     440:	ea 57       	subi	r30, 0x7A	; 122
     442:	f8 4f       	sbci	r31, 0xF8	; 248
     444:	80 81       	ld	r24, Z
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	0e 94 03 09 	call	0x1206	; 0x1206 <transmitUartInt>
		transmitUartString("\r\n");
     44c:	8e e3       	ldi	r24, 0x3E	; 62
     44e:	91 e0       	ldi	r25, 0x01	; 1
     450:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
     454:	21 96       	adiw	r28, 0x01	; 1
	LCD_DATA_STRING("     TEMERATURE     ");		//
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
	LCD_DATA_STRING("LEFT  SENSOR: ");				//

	oneWireLeft();
	for(i=0; i<9; i++)
     456:	c9 30       	cpi	r28, 0x09	; 9
     458:	d1 05       	cpc	r29, r1
     45a:	31 f7       	brne	.-52     	; 0x428 <temperature+0x2c>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     45c:	80 91 a3 07 	lds	r24, 0x07A3
     460:	60 91 9f 07 	lds	r22, 0x079F
     464:	40 91 9e 07 	lds	r20, 0x079E
     468:	20 91 9b 07 	lds	r18, 0x079B
     46c:	0e 94 f6 00 	call	0x1ec	; 0x1ec <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
     470:	84 e9       	ldi	r24, 0x94	; 148
     472:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
     476:	8b ef       	ldi	r24, 0xFB	; 251
     478:	92 e0       	ldi	r25, 0x02	; 2
     47a:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
	oneWireRight();
     47e:	0e 94 46 01 	call	0x28c	; 0x28c <oneWireRight>
     482:	c0 e0       	ldi	r28, 0x00	; 0
     484:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] byte ");
     486:	85 ee       	ldi	r24, 0xE5	; 229
     488:	92 e0       	ldi	r25, 0x02	; 2
     48a:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartInt(i);
     48e:	ce 01       	movw	r24, r28
     490:	0e 94 03 09 	call	0x1206	; 0x1206 <transmitUartInt>
		transmitUartString(" : ");
     494:	87 ef       	ldi	r24, 0xF7	; 247
     496:	92 e0       	ldi	r25, 0x02	; 2
     498:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartInt(storeTemp[i]);
     49c:	fe 01       	movw	r30, r28
     49e:	ea 57       	subi	r30, 0x7A	; 122
     4a0:	f8 4f       	sbci	r31, 0xF8	; 248
     4a2:	80 81       	ld	r24, Z
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	0e 94 03 09 	call	0x1206	; 0x1206 <transmitUartInt>
		transmitUartString("\r\n");
     4aa:	8e e3       	ldi	r24, 0x3E	; 62
     4ac:	91 e0       	ldi	r25, 0x01	; 1
     4ae:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
     4b2:	21 96       	adiw	r28, 0x01	; 1
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
	oneWireRight();
	for(i=0; i<9; i++)
     4b4:	c9 30       	cpi	r28, 0x09	; 9
     4b6:	d1 05       	cpc	r29, r1
     4b8:	31 f7       	brne	.-52     	; 0x486 <temperature+0x8a>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     4ba:	80 91 a3 07 	lds	r24, 0x07A3
     4be:	60 91 9f 07 	lds	r22, 0x079F
     4c2:	40 91 9e 07 	lds	r20, 0x079E
     4c6:	20 91 9b 07 	lds	r18, 0x079B
     4ca:	0e 94 f6 00 	call	0x1ec	; 0x1ec <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
     4ce:	84 ed       	ldi	r24, 0xD4	; 212
     4d0:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
	LCD_DATA_STRING("             DS18x20");		//
     4d4:	8a e0       	ldi	r24, 0x0A	; 10
     4d6:	93 e0       	ldi	r25, 0x03	; 3
     4d8:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
}
     4dc:	df 91       	pop	r29
     4de:	cf 91       	pop	r28
     4e0:	08 95       	ret

000004e2 <commonEncoder>:
**********************************************/
void commonEncoder(void)	// not finished
{
	static signed char saveValue = 0;	// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!! static ???
	signed char temp = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     4e2:	0e 94 be 09 	call	0x137c	; 0x137c <rotaryEncoderNikBarzakov>
	if(0==temp)
     4e6:	88 23       	and	r24, r24
     4e8:	09 f4       	brne	.+2      	; 0x4ec <commonEncoder+0xa>
     4ea:	4f c0       	rjmp	.+158    	; 0x58a <commonEncoder+0xa8>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     4ec:	8f 3f       	cpi	r24, 0xFF	; 255
     4ee:	41 f5       	brne	.+80     	; 0x540 <commonEncoder+0x5e>
	{
		// encoder is decrement
		if(saveValue < -127)
     4f0:	80 91 90 07 	lds	r24, 0x0790
     4f4:	80 38       	cpi	r24, 0x80	; 128
     4f6:	11 f4       	brne	.+4      	; 0x4fc <commonEncoder+0x1a>
		{
			saveValue = 127;	// SIGNED CHAR MIN VALUE = -127
     4f8:	8f e7       	ldi	r24, 0x7F	; 127
     4fa:	01 c0       	rjmp	.+2      	; 0x4fe <commonEncoder+0x1c>
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     4fc:	81 50       	subi	r24, 0x01	; 1
     4fe:	80 93 90 07 	sts	0x0790, r24
//			fanSpeedStep [FAN_LIMIT_POSITIONS]
		}
// LCD PRINT VALUE
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     502:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     504:	8c e0       	ldi	r24, 0x0C	; 12
     506:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     50a:	84 ed       	ldi	r24, 0xD4	; 212
     50c:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
		if (saveValue > 99)
     510:	80 91 90 07 	lds	r24, 0x0790
     514:	84 36       	cpi	r24, 0x64	; 100
     516:	1c f0       	brlt	.+6      	; 0x51e <commonEncoder+0x3c>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     518:	8f e1       	ldi	r24, 0x1F	; 31
     51a:	93 e0       	ldi	r25, 0x03	; 3
     51c:	07 c0       	rjmp	.+14     	; 0x52c <commonEncoder+0x4a>
		}
		else if (saveValue > 9)
     51e:	8a 30       	cpi	r24, 0x0A	; 10
     520:	1c f0       	brlt	.+6      	; 0x528 <commonEncoder+0x46>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     522:	88 e2       	ldi	r24, 0x28	; 40
     524:	93 e0       	ldi	r25, 0x03	; 3
     526:	02 c0       	rjmp	.+4      	; 0x52c <commonEncoder+0x4a>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     528:	82 e3       	ldi	r24, 0x32	; 50
     52a:	93 e0       	ldi	r25, 0x03	; 3
     52c:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     530:	80 91 90 07 	lds	r24, 0x0790
     534:	99 27       	eor	r25, r25
     536:	87 fd       	sbrc	r24, 7
     538:	90 95       	com	r25
     53a:	0e 94 10 08 	call	0x1020	; 0x1020 <LCD_DATA_INT>
     53e:	08 95       	ret
	}
	else if(1==temp)
     540:	81 30       	cpi	r24, 0x01	; 1
     542:	19 f5       	brne	.+70     	; 0x58a <commonEncoder+0xa8>
		{
			saveValue = 128;	// SIGNED CHAR MAX VALUE = +128
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     544:	80 91 90 07 	lds	r24, 0x0790
     548:	8f 5f       	subi	r24, 0xFF	; 255
     54a:	80 93 90 07 	sts	0x0790, r24
		}

	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     54e:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     550:	8c e0       	ldi	r24, 0x0C	; 12
     552:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     556:	84 ed       	ldi	r24, 0xD4	; 212
     558:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
		if (saveValue > 99)
     55c:	80 91 90 07 	lds	r24, 0x0790
     560:	84 36       	cpi	r24, 0x64	; 100
     562:	1c f0       	brlt	.+6      	; 0x56a <commonEncoder+0x88>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     564:	8f e1       	ldi	r24, 0x1F	; 31
     566:	93 e0       	ldi	r25, 0x03	; 3
     568:	07 c0       	rjmp	.+14     	; 0x578 <commonEncoder+0x96>
		}
		else if (saveValue > 9)
     56a:	8a 30       	cpi	r24, 0x0A	; 10
     56c:	1c f0       	brlt	.+6      	; 0x574 <commonEncoder+0x92>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     56e:	88 e2       	ldi	r24, 0x28	; 40
     570:	93 e0       	ldi	r25, 0x03	; 3
     572:	02 c0       	rjmp	.+4      	; 0x578 <commonEncoder+0x96>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     574:	82 e3       	ldi	r24, 0x32	; 50
     576:	93 e0       	ldi	r25, 0x03	; 3
     578:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     57c:	80 91 90 07 	lds	r24, 0x0790
     580:	99 27       	eor	r25, r25
     582:	87 fd       	sbrc	r24, 7
     584:	90 95       	com	r25
     586:	0e 94 10 08 	call	0x1020	; 0x1020 <LCD_DATA_INT>
     58a:	08 95       	ret

0000058c <volumeUpdate>:
/*************************************
**** VOLUME UPDATE and LCD UPDATE ****
*************************************/
void volumeUpdate(void)
{
	PGA2310_Volume_Update(volumeValue[volumeIndex], volumeValue[volumeIndex]);	// update volume value on all channels
     58c:	e0 91 85 07 	lds	r30, 0x0785
     590:	f0 e0       	ldi	r31, 0x00	; 0
     592:	e5 5d       	subi	r30, 0xD5	; 213
     594:	f8 4f       	sbci	r31, 0xF8	; 248
     596:	60 81       	ld	r22, Z
     598:	86 2f       	mov	r24, r22
     59a:	0e 94 48 08 	call	0x1090	; 0x1090 <PGA2310_Volume_Update>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     59e:	84 ed       	ldi	r24, 0xD4	; 212
     5a0:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
//		LCD_DATA_STRING("Volume: ");	// 20 symbols
	if (volumeIndex > 9)
     5a4:	80 91 85 07 	lds	r24, 0x0785
     5a8:	8a 30       	cpi	r24, 0x0A	; 10
     5aa:	18 f0       	brcs	.+6      	; 0x5b2 <volumeUpdate+0x26>
	{
		LCD_DATA_STRING("Volume: ");	// 20 symbols
     5ac:	8f e1       	ldi	r24, 0x1F	; 31
     5ae:	93 e0       	ldi	r25, 0x03	; 3
     5b0:	02 c0       	rjmp	.+4      	; 0x5b6 <volumeUpdate+0x2a>
	}
	else
	{
		LCD_DATA_STRING("Volume: 0");	// 20 symbols
     5b2:	88 e2       	ldi	r24, 0x28	; 40
     5b4:	93 e0       	ldi	r25, 0x03	; 3
     5b6:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
	}
	LCD_DATA_INT(volumeIndex);			// 20 symbols
     5ba:	80 91 85 07 	lds	r24, 0x0785
     5be:	90 e0       	ldi	r25, 0x00	; 0
     5c0:	0e 94 10 08 	call	0x1020	; 0x1020 <LCD_DATA_INT>
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Volume: ");		// uart debug information string
     5c4:	8d e3       	ldi	r24, 0x3D	; 61
     5c6:	93 e0       	ldi	r25, 0x03	; 3
     5c8:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartInt(volumeIndex);		// uart debug information string 
     5cc:	80 91 85 07 	lds	r24, 0x0785
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	0e 94 03 09 	call	0x1206	; 0x1206 <transmitUartInt>
		transmitUartString("\r\n");			// uart debug information string
     5d6:	8e e3       	ldi	r24, 0x3E	; 62
     5d8:	91 e0       	ldi	r25, 0x01	; 1
     5da:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
}
     5de:	08 95       	ret

000005e0 <volumeMute>:
/************************************
**** VOLUME MUTE/UNMUTE FUNCTION ****
************************************/
void volumeMute(void)
{
	if(flagStatusBits->flagMute == 0)
     5e0:	e0 91 a1 07 	lds	r30, 0x07A1
     5e4:	f0 91 a2 07 	lds	r31, 0x07A2
     5e8:	80 81       	ld	r24, Z
     5ea:	81 fd       	sbrc	r24, 1
     5ec:	0c c0       	rjmp	.+24     	; 0x606 <volumeMute+0x26>
	{
		volumeBuffer = volumeIndex;		// strore volume volue
     5ee:	80 91 85 07 	lds	r24, 0x0785
     5f2:	80 93 84 07 	sts	0x0784, r24
		volumeIndex = VOLUME_MUTE;		// MUTE ON
     5f6:	10 92 85 07 	sts	0x0785, r1
		flagStatusBits->flagMute = 1;	// MUTE ON
     5fa:	80 81       	ld	r24, Z
     5fc:	82 60       	ori	r24, 0x02	; 2
     5fe:	80 83       	st	Z, r24
		#ifdef DEBUG_INFO
			transmitUartString("[UART INFO] Volume mute is on\r\n");
     600:	82 e5       	ldi	r24, 0x52	; 82
     602:	93 e0       	ldi	r25, 0x03	; 3
     604:	0b c0       	rjmp	.+22     	; 0x61c <volumeMute+0x3c>
		#endif
	}
	else
	{
		volumeIndex = volumeBuffer;		// MUTE OFF
     606:	80 91 84 07 	lds	r24, 0x0784
     60a:	80 93 85 07 	sts	0x0785, r24
		volumeBuffer = VOLUME_MUTE;		// clear volume volue
     60e:	10 92 84 07 	sts	0x0784, r1
		flagStatusBits->flagMute = 0;	// MUTE OFF
     612:	80 81       	ld	r24, Z
     614:	8d 7f       	andi	r24, 0xFD	; 253
     616:	80 83       	st	Z, r24
		#ifdef DEBUG_INFO
			transmitUartString("[UART INFO] Volume mute is off\r\n");
     618:	82 e7       	ldi	r24, 0x72	; 114
     61a:	93 e0       	ldi	r25, 0x03	; 3
     61c:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		#endif
	}
	volumeUpdate();
     620:	0e 94 c6 02 	call	0x58c	; 0x58c <volumeUpdate>
}
     624:	08 95       	ret

00000626 <volumeProcessRemote>:
/********************************************
**** VOLUME PROCESS FUNCTION FROM REMOTE ****
********************************************/
void volumeProcessRemote(signed char temp)
{
	if(-1==temp)
     626:	8f 3f       	cpi	r24, 0xFF	; 255
     628:	69 f4       	brne	.+26     	; 0x644 <volumeProcessRemote+0x1e>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     62a:	80 91 85 07 	lds	r24, 0x0785
     62e:	88 23       	and	r24, r24
     630:	19 f4       	brne	.+6      	; 0x638 <volumeProcessRemote+0x12>
		{
			volumeIndex = VOLUME_MUTE;
     632:	10 92 85 07 	sts	0x0785, r1
     636:	03 c0       	rjmp	.+6      	; 0x63e <volumeProcessRemote+0x18>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     638:	81 50       	subi	r24, 0x01	; 1
     63a:	80 93 85 07 	sts	0x0785, r24
		}
		volumeUpdate();
     63e:	0e 94 c6 02 	call	0x58c	; 0x58c <volumeUpdate>
     642:	08 95       	ret
	}
	else if(1==temp)
     644:	81 30       	cpi	r24, 0x01	; 1
     646:	59 f4       	brne	.+22     	; 0x65e <volumeProcessRemote+0x38>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     648:	80 91 85 07 	lds	r24, 0x0785
     64c:	83 31       	cpi	r24, 0x13	; 19
     64e:	10 f0       	brcs	.+4      	; 0x654 <volumeProcessRemote+0x2e>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     650:	83 e1       	ldi	r24, 0x13	; 19
     652:	01 c0       	rjmp	.+2      	; 0x656 <volumeProcessRemote+0x30>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     654:	8f 5f       	subi	r24, 0xFF	; 255
     656:	80 93 85 07 	sts	0x0785, r24
		}
		volumeUpdate();
     65a:	0e 94 c6 02 	call	0x58c	; 0x58c <volumeUpdate>
     65e:	08 95       	ret

00000660 <volumeProcess>:
**** VOLUME PROCESS FUNCTION FROM ENCODER ****
*********************************************/
void volumeProcess(void)
{
	signed char temp = 0;//, tempEnc = 0, tempRem = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     660:	0e 94 be 09 	call	0x137c	; 0x137c <rotaryEncoderNikBarzakov>
	if(0==temp)
     664:	88 23       	and	r24, r24
     666:	e1 f0       	breq	.+56     	; 0x6a0 <volumeProcess+0x40>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     668:	8f 3f       	cpi	r24, 0xFF	; 255
     66a:	69 f4       	brne	.+26     	; 0x686 <volumeProcess+0x26>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     66c:	80 91 85 07 	lds	r24, 0x0785
     670:	88 23       	and	r24, r24
     672:	19 f4       	brne	.+6      	; 0x67a <volumeProcess+0x1a>
		{
			volumeIndex = VOLUME_MUTE;
     674:	10 92 85 07 	sts	0x0785, r1
     678:	03 c0       	rjmp	.+6      	; 0x680 <volumeProcess+0x20>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     67a:	81 50       	subi	r24, 0x01	; 1
     67c:	80 93 85 07 	sts	0x0785, r24
		}
		volumeUpdate();
     680:	0e 94 c6 02 	call	0x58c	; 0x58c <volumeUpdate>
     684:	08 95       	ret
	}
	else if(1==temp)
     686:	81 30       	cpi	r24, 0x01	; 1
     688:	59 f4       	brne	.+22     	; 0x6a0 <volumeProcess+0x40>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     68a:	80 91 85 07 	lds	r24, 0x0785
     68e:	83 31       	cpi	r24, 0x13	; 19
     690:	10 f0       	brcs	.+4      	; 0x696 <volumeProcess+0x36>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     692:	83 e1       	ldi	r24, 0x13	; 19
     694:	01 c0       	rjmp	.+2      	; 0x698 <volumeProcess+0x38>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     696:	8f 5f       	subi	r24, 0xFF	; 255
     698:	80 93 85 07 	sts	0x0785, r24
		}
		volumeUpdate();
     69c:	0e 94 c6 02 	call	0x58c	; 0x58c <volumeUpdate>
     6a0:	08 95       	ret

000006a2 <ampliferOff>:
/*********************
**** AMPLIFER OFF ****
*********************/
void ampliferOff(void)
{
	flagStatusBits->flagPower = 0;		// flag for amplifer off
     6a2:	e0 91 a1 07 	lds	r30, 0x07A1
     6a6:	f0 91 a2 07 	lds	r31, 0x07A2
     6aa:	80 81       	ld	r24, Z
     6ac:	8e 7f       	andi	r24, 0xFE	; 254
     6ae:	80 83       	st	Z, r24

	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     6b0:	80 e0       	ldi	r24, 0x00	; 0
     6b2:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer Off    ");	// 20 symbols
     6b6:	83 e9       	ldi	r24, 0x93	; 147
     6b8:	93 e0       	ldi	r25, 0x03	; 3
     6ba:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>

	LCD_COMMAND(LCD_OFF);						// LCD ON without CURSOR
     6be:	88 e0       	ldi	r24, 0x08	; 8
     6c0:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>

//			FAN_low();		// PORTD5 - FAN OFF (logic "0")  NON PWM, NON TIMER1

// RELAYS OFF FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays out for all 6 channels\r\n");		// uart debug information string
     6c4:	88 ea       	ldi	r24, 0xA8	; 168
     6c6:	93 e0       	ldi	r25, 0x03	; 3
     6c8:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
	relays_out_off();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     6cc:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <relays_out_off>
     6d0:	88 e5       	ldi	r24, 0x58	; 88
     6d2:	9b e1       	ldi	r25, 0x1B	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     6d4:	20 e9       	ldi	r18, 0x90	; 144
     6d6:	31 e0       	ldi	r19, 0x01	; 1
     6d8:	f9 01       	movw	r30, r18
     6da:	31 97       	sbiw	r30, 0x01	; 1
     6dc:	f1 f7       	brne	.-4      	; 0x6da <ampliferOff+0x38>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6de:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     6e0:	d9 f7       	brne	.-10     	; 0x6d8 <ampliferOff+0x36>
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays in for all 6 channels\r\n");		// uart debug information string
     6e2:	86 ee       	ldi	r24, 0xE6	; 230
     6e4:	93 e0       	ldi	r25, 0x03	; 3
     6e6:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
	relays_in_off();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     6ea:	0e 94 3b 0a 	call	0x1476	; 0x1476 <relays_in_off>
     6ee:	88 e5       	ldi	r24, 0x58	; 88
     6f0:	9b e1       	ldi	r25, 0x1B	; 27
     6f2:	20 e9       	ldi	r18, 0x90	; 144
     6f4:	31 e0       	ldi	r19, 0x01	; 1
     6f6:	f9 01       	movw	r30, r18
     6f8:	31 97       	sbiw	r30, 0x01	; 1
     6fa:	f1 f7       	brne	.-4      	; 0x6f8 <ampliferOff+0x56>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6fc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     6fe:	d9 f7       	brne	.-10     	; 0x6f6 <ampliferOff+0x54>
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays for power 220V\r\n");		// uart debug information string
     700:	83 e2       	ldi	r24, 0x23	; 35
     702:	94 e0       	ldi	r25, 0x04	; 4
     704:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
	REL_POWER_low();// RELAY POWER OFF				// PESHO COMMENT 14.08.2015, 21:10
     708:	aa 98       	cbi	0x15, 2	; 21

// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan is off\r\n");
     70a:	89 e5       	ldi	r24, 0x59	; 89
     70c:	94 e0       	ldi	r25, 0x04	; 4
     70e:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}

void timer1_off(void)
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     712:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     714:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     716:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     718:	1a bc       	out	0x2a, r1	; 42
		transmitUartString("[UART INFO] Fan is off\r\n");
	#endif
	fan_pwm_off();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1

// FANS FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();
     71a:	0e 94 62 07 	call	0xec4	; 0xec4 <LCD_CLEAR_CONTAIN>
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display off and status led on\r\n");
     71e:	82 e7       	ldi	r24, 0x72	; 114
     720:	94 e0       	ldi	r25, 0x04	; 4
     722:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif

// LED ON FUNC
	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     726:	94 9a       	sbi	0x12, 4	; 18

// UART MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Amplifer is off\r\n");
     728:	8e e9       	ldi	r24, 0x9E	; 158
     72a:	94 e0       	ldi	r25, 0x04	; 4
     72c:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
     730:	88 e8       	ldi	r24, 0x88	; 136
     732:	93 e1       	ldi	r25, 0x13	; 19
     734:	20 e9       	ldi	r18, 0x90	; 144
     736:	31 e0       	ldi	r19, 0x01	; 1
     738:	f9 01       	movw	r30, r18
     73a:	31 97       	sbiw	r30, 0x01	; 1
     73c:	f1 f7       	brne	.-4      	; 0x73a <ampliferOff+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     73e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     740:	d9 f7       	brne	.-10     	; 0x738 <ampliferOff+0x96>
	#endif

	_delay_ms(500);	// izchakvane pri natiskane za izkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton
}
     742:	08 95       	ret

00000744 <ampliferOn>:
/********************
**** AMPLIFER ON ****
********************/
void ampliferOn(void)
{
	flagStatusBits->flagPower = 1;		// flag for amplifer on
     744:	e0 91 a1 07 	lds	r30, 0x07A1
     748:	f0 91 a2 07 	lds	r31, 0x07A2
     74c:	80 81       	ld	r24, Z
     74e:	81 60       	ori	r24, 0x01	; 1
     750:	80 83       	st	Z, r24

// UART MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Amplifer is on\r\n");
     752:	8c eb       	ldi	r24, 0xBC	; 188
     754:	94 e0       	ldi	r25, 0x04	; 4
     756:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display on and status led off\r\n");
     75a:	89 ed       	ldi	r24, 0xD9	; 217
     75c:	94 e0       	ldi	r25, 0x04	; 4
     75e:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif

// LED OFF FUNC
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     762:	94 98       	cbi	0x12, 4	; 18

// LCD FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();						// clear all contain on display
     764:	0e 94 62 07 	call	0xec4	; 0xec4 <LCD_CLEAR_CONTAIN>
	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     768:	80 e0       	ldi	r24, 0x00	; 0
     76a:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer On     ");	// 20 symbols
     76e:	85 e0       	ldi	r24, 0x05	; 5
     770:	95 e0       	ldi	r25, 0x05	; 5
     772:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);				// select row 2
     776:	80 ec       	ldi	r24, 0xC0	; 192
     778:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
	LCD_DATA_STRING("P.UPINOV  P.STOYANOV");	// 20 symbols //	LCD_EXECUTE_DATA("P.UPINOV  P.STOYANOV",20);	// char "DATA", int 13 of chars of "DATA"
     77c:	8a e1       	ldi	r24, 0x1A	; 26
     77e:	95 e0       	ldi	r25, 0x05	; 5
     780:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     784:	8c e0       	ldi	r24, 0x0C	; 12
     786:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>

// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan is on\r\n");
     78a:	8f e2       	ldi	r24, 0x2F	; 47
     78c:	95 e0       	ldi	r25, 0x05	; 5
     78e:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartString("[UART INFO] Fan rotation with max speed\r\n");
     792:	87 e4       	ldi	r24, 0x47	; 71
     794:	95 e0       	ldi	r25, 0x05	; 5
     796:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartString("[UART INFO] Fan is always on, it isn't sensitive to temperature, because DS18S20 is disabling\r\n");
     79a:	81 e7       	ldi	r24, 0x71	; 113
     79c:	95 e0       	ldi	r25, 0x05	; 5
     79e:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
//	FAN_high();			// PORTD5 - FAN ON (logic "1")	NON PWM, NON TIMER1	
	fanSpeed = FAN_SPEED_MAX;	// amplifer run with max fan speed
     7a2:	87 e0       	ldi	r24, 0x07	; 7
     7a4:	80 93 3f 07 	sts	0x073F, r24
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     7a8:	81 ea       	ldi	r24, 0xA1	; 161
     7aa:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     7ac:	81 e0       	ldi	r24, 0x01	; 1
     7ae:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     7b0:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     7b2:	80 91 47 07 	lds	r24, 0x0747
     7b6:	8a bd       	out	0x2a, r24	; 42
	fanSpeed = FAN_SPEED_MAX;	// amplifer run with max fan speed
	fan_pwm_control_speed();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1

// RELAYS ON FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays for power 220V\r\n");		// uart debug information string
     7b8:	81 ed       	ldi	r24, 0xD1	; 209
     7ba:	95 e0       	ldi	r25, 0x05	; 5
     7bc:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
	REL_POWER_high();// RELAY POWER ON TRAFs		// PESHO COMMENT 14.08.2015, 21:10
     7c0:	aa 9a       	sbi	0x15, 2	; 21
     7c2:	80 e4       	ldi	r24, 0x40	; 64
     7c4:	9c e9       	ldi	r25, 0x9C	; 156
     7c6:	20 e9       	ldi	r18, 0x90	; 144
     7c8:	31 e0       	ldi	r19, 0x01	; 1
     7ca:	f9 01       	movw	r30, r18
     7cc:	31 97       	sbiw	r30, 0x01	; 1
     7ce:	f1 f7       	brne	.-4      	; 0x7cc <ampliferOn+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7d0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7d2:	d9 f7       	brne	.-10     	; 0x7ca <ampliferOn+0x86>
	_delay_ms(4000);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays in for all 6 channels\r\n");		// uart debug information string
     7d4:	86 e0       	ldi	r24, 0x06	; 6
     7d6:	96 e0       	ldi	r25, 0x06	; 6
     7d8:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
	relays_in1_6ch();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     7dc:	0e 94 27 0a 	call	0x144e	; 0x144e <relays_in1_6ch>
     7e0:	88 e5       	ldi	r24, 0x58	; 88
     7e2:	9b e1       	ldi	r25, 0x1B	; 27
     7e4:	20 e9       	ldi	r18, 0x90	; 144
     7e6:	31 e0       	ldi	r19, 0x01	; 1
     7e8:	f9 01       	movw	r30, r18
     7ea:	31 97       	sbiw	r30, 0x01	; 1
     7ec:	f1 f7       	brne	.-4      	; 0x7ea <ampliferOn+0xa6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7ee:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7f0:	d9 f7       	brne	.-10     	; 0x7e8 <ampliferOn+0xa4>
	_delay_ms(700);									// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays out for all 6 channels\r\n");		// uart debug information string
     7f2:	82 e4       	ldi	r24, 0x42	; 66
     7f4:	96 e0       	ldi	r25, 0x06	; 6
     7f6:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif
	relays_out_6ch();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     7fa:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <relays_out_6ch>
     7fe:	80 e1       	ldi	r24, 0x10	; 16
     800:	97 e2       	ldi	r25, 0x27	; 39
     802:	20 e9       	ldi	r18, 0x90	; 144
     804:	31 e0       	ldi	r19, 0x01	; 1
     806:	f9 01       	movw	r30, r18
     808:	31 97       	sbiw	r30, 0x01	; 1
     80a:	f1 f7       	brne	.-4      	; 0x808 <ampliferOn+0xc4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     80c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     80e:	d9 f7       	brne	.-10     	; 0x806 <ampliferOn+0xc2>
	_delay_ms(1000);	// izchakvane pri natiskane za vkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton

// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan rotation with min speed\r\n");
     810:	8f e7       	ldi	r24, 0x7F	; 127
     812:	96 e0       	ldi	r25, 0x06	; 6
     814:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
		transmitUartString("[UART INFO] Fan manual controlling with remote menu up to speed step up and menu down button to speed step down\r\n");
     818:	89 ea       	ldi	r24, 0xA9	; 169
     81a:	96 e0       	ldi	r25, 0x06	; 6
     81c:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
	#endif	
	fanSpeed = FAN_SPEED_MIN;	// amplifer works with min fan speed
     820:	81 e0       	ldi	r24, 0x01	; 1
     822:	80 93 3f 07 	sts	0x073F, r24
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     826:	91 ea       	ldi	r25, 0xA1	; 161
     828:	9f bd       	out	0x2f, r25	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     82a:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     82c:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     82e:	80 91 41 07 	lds	r24, 0x0741
     832:	8a bd       	out	0x2a, r24	; 42
		transmitUartString("[UART INFO] Fan rotation with min speed\r\n");
		transmitUartString("[UART INFO] Fan manual controlling with remote menu up to speed step up and menu down button to speed step down\r\n");
	#endif	
	fanSpeed = FAN_SPEED_MIN;	// amplifer works with min fan speed
	fan_pwm_control_speed();
}
     834:	08 95       	ret

00000836 <buttons_press>:


}

void buttons_press()
{
     836:	cf 93       	push	r28
     838:	df 93       	push	r29
	flagStatusBits = &fSB;
     83a:	89 ea       	ldi	r24, 0xA9	; 169
     83c:	97 e0       	ldi	r25, 0x07	; 7
     83e:	90 93 a2 07 	sts	0x07A2, r25
     842:	80 93 a1 07 	sts	0x07A1, r24
	flagStatusBits->flagPower=0;	// inicializirane s nuli, no nai veroqtno poradi tova che e globalna stru
     846:	80 91 a9 07 	lds	r24, 0x07A9
	flagStatusBits->flagMute=0;		// inicializirane
     84a:	8c 7f       	andi	r24, 0xFC	; 252
     84c:	80 93 a9 07 	sts	0x07A9, r24
     850:	c0 e9       	ldi	r28, 0x90	; 144
     852:	d1 e0       	ldi	r29, 0x01	; 1
		LCD_DATA_INT(flagStatusBits->flagMute);		// 20 symbols
	_delay_ms(2000);
*/
	while(1)
	{
		if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)	// obj ptr flagStatusBtnRegister from struct flagStatusBtnOnOff
     854:	b1 99       	sbic	0x16, 1	; 22
     856:	0a c0       	rjmp	.+20     	; 0x86c <__stack+0xd>
     858:	e0 91 a1 07 	lds	r30, 0x07A1
     85c:	f0 91 a2 07 	lds	r31, 0x07A2
     860:	80 81       	ld	r24, Z
     862:	80 fd       	sbrc	r24, 0
     864:	03 c0       	rjmp	.+6      	; 0x86c <__stack+0xd>
		{
//			flagStatusBits->flagPower = 1;			// filter za buton ON
			ampliferOn();
     866:	0e 94 a2 03 	call	0x744	; 0x744 <ampliferOn>
     86a:	f4 cf       	rjmp	.-24     	; 0x854 <buttons_press+0x1e>
//			_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
		}
		else if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     86c:	b1 99       	sbic	0x16, 1	; 22
     86e:	0a c0       	rjmp	.+20     	; 0x884 <__stack+0x25>
     870:	e0 91 a1 07 	lds	r30, 0x07A1
     874:	f0 91 a2 07 	lds	r31, 0x07A2
     878:	80 81       	ld	r24, Z
     87a:	80 ff       	sbrs	r24, 0
     87c:	03 c0       	rjmp	.+6      	; 0x884 <__stack+0x25>
		{
//			flagStatusBits->flagPower = 0;			// filter za buton OFF
			ampliferOff();
     87e:	0e 94 51 03 	call	0x6a2	; 0x6a2 <ampliferOff>
     882:	e8 cf       	rjmp	.-48     	; 0x854 <buttons_press+0x1e>
		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     884:	b2 99       	sbic	0x16, 2	; 22
     886:	11 c0       	rjmp	.+34     	; 0x8aa <__stack+0x4b>
     888:	e0 91 a1 07 	lds	r30, 0x07A1
     88c:	f0 91 a2 07 	lds	r31, 0x07A2
     890:	80 81       	ld	r24, Z
     892:	80 ff       	sbrs	r24, 0
     894:	0a c0       	rjmp	.+20     	; 0x8aa <__stack+0x4b>
		{
//			LCD_DATA_STRING("PRESSED BTN ESCAPE  ");	// 20 symbols
//			LCD_COMMAND(LCD_ON);
			LCD_CLEAR_CONTAIN();
     896:	0e 94 62 07 	call	0xec4	; 0xec4 <LCD_CLEAR_CONTAIN>
     89a:	88 e8       	ldi	r24, 0x88	; 136
     89c:	93 e1       	ldi	r25, 0x13	; 19
     89e:	fe 01       	movw	r30, r28
     8a0:	31 97       	sbiw	r30, 0x01	; 1
     8a2:	f1 f7       	brne	.-4      	; 0x8a0 <__stack+0x41>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8a4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8a6:	d9 f7       	brne	.-10     	; 0x89e <__stack+0x3f>
     8a8:	d5 cf       	rjmp	.-86     	; 0x854 <buttons_press+0x1e>
			_delay_ms(500);
//			volumeUp();
//			_delay_ms(200);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     8aa:	83 99       	sbic	0x10, 3	; 16
     8ac:	0f c0       	rjmp	.+30     	; 0x8cc <__stack+0x6d>
     8ae:	e0 91 a1 07 	lds	r30, 0x07A1
     8b2:	f0 91 a2 07 	lds	r31, 0x07A2
     8b6:	80 81       	ld	r24, Z
     8b8:	80 ff       	sbrs	r24, 0
     8ba:	08 c0       	rjmp	.+16     	; 0x8cc <__stack+0x6d>
     8bc:	88 e8       	ldi	r24, 0x88	; 136
     8be:	93 e1       	ldi	r25, 0x13	; 19
     8c0:	fe 01       	movw	r30, r28
     8c2:	31 97       	sbiw	r30, 0x01	; 1
     8c4:	f1 f7       	brne	.-4      	; 0x8c2 <__stack+0x63>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8c6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8c8:	d9 f7       	brne	.-10     	; 0x8c0 <__stack+0x61>
     8ca:	c4 cf       	rjmp	.-120    	; 0x854 <buttons_press+0x1e>
			_delay_ms(500);
//			volumeDown();
//			_delay_ms(200);

		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     8cc:	b2 99       	sbic	0x16, 2	; 22
     8ce:	0f c0       	rjmp	.+30     	; 0x8ee <__stack+0x8f>
     8d0:	e0 91 a1 07 	lds	r30, 0x07A1
     8d4:	f0 91 a2 07 	lds	r31, 0x07A2
     8d8:	80 81       	ld	r24, Z
     8da:	80 fd       	sbrc	r24, 0
     8dc:	08 c0       	rjmp	.+16     	; 0x8ee <__stack+0x8f>
     8de:	88 e8       	ldi	r24, 0x88	; 136
     8e0:	93 e1       	ldi	r25, 0x13	; 19
     8e2:	fe 01       	movw	r30, r28
     8e4:	31 97       	sbiw	r30, 0x01	; 1
     8e6:	f1 f7       	brne	.-4      	; 0x8e4 <__stack+0x85>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8e8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8ea:	d9 f7       	brne	.-10     	; 0x8e2 <__stack+0x83>
     8ec:	b3 cf       	rjmp	.-154    	; 0x854 <buttons_press+0x1e>
//			LCD_COMMAND(LCD_ON);
			_delay_ms(500);
//			setupMode();
//			_delay_ms(1000);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     8ee:	83 99       	sbic	0x10, 3	; 16
     8f0:	11 c0       	rjmp	.+34     	; 0x914 <__stack+0xb5>
     8f2:	e0 91 a1 07 	lds	r30, 0x07A1
     8f6:	f0 91 a2 07 	lds	r31, 0x07A2
     8fa:	80 81       	ld	r24, Z
     8fc:	80 fd       	sbrc	r24, 0
     8fe:	0a c0       	rjmp	.+20     	; 0x914 <__stack+0xb5>
		{
			temperature();
     900:	0e 94 fe 01 	call	0x3fc	; 0x3fc <temperature>
     904:	88 e8       	ldi	r24, 0x88	; 136
     906:	93 e1       	ldi	r25, 0x13	; 19
     908:	fe 01       	movw	r30, r28
     90a:	31 97       	sbiw	r30, 0x01	; 1
     90c:	f1 f7       	brne	.-4      	; 0x90a <__stack+0xab>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     90e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     910:	d9 f7       	brne	.-10     	; 0x908 <__stack+0xa9>
     912:	a0 cf       	rjmp	.-192    	; 0x854 <buttons_press+0x1e>
//			LCD_COMMAND(LCD_OFF);
			_delay_ms(500);
//			about();
//			_delay_ms(1000);
		}
		else if(flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     914:	e0 91 a1 07 	lds	r30, 0x07A1
     918:	f0 91 a2 07 	lds	r31, 0x07A2
     91c:	80 81       	ld	r24, Z
     91e:	80 ff       	sbrs	r24, 0
     920:	99 cf       	rjmp	.-206    	; 0x854 <buttons_press+0x1e>
		{
			volumeProcess();
     922:	0e 94 30 03 	call	0x660	; 0x660 <volumeProcess>
     926:	96 cf       	rjmp	.-212    	; 0x854 <buttons_press+0x1e>

00000928 <main>:
******************************** START OF MAIN APPLICATION **********************************
********************************************************************************************/

int main(void)
{
	init_all();				// inicializacia na vsichko
     928:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <init_all>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     92c:	80 e4       	ldi	r24, 0x40	; 64
     92e:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     930:	8a bf       	out	0x3a, r24	; 58
{
	init_all();				// inicializacia na vsichko
	ext0_intrpt_on();		// ENABLE interrupts to access IR DETECTION as call to function "IR_DECODER()" for -> SONY IR REMOTE
//	ext2_intrpt_on();

	sei();							// file "avr/interrupt.h"
     932:	78 94       	sei
//	SREG = (1<<I);

	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     934:	94 9a       	sbi	0x12, 4	; 18
	while(1)
	{		
		buttons_press();	// izchakvane za natiskane na buton
     936:	0e 94 1b 04 	call	0x836	; 0x836 <buttons_press>
     93a:	fd cf       	rjmp	.-6      	; 0x936 <main+0xe>

0000093c <irDecode>:
************************************/
void irDecode(void)
{
//	byte byteSS0, byteSS1, byteMM0, byteMM1, byteHH0, byteHH1, byteDD0, byteDD1, byteMont0, byteMont1, byteYY0, byteYY1; // variables for convert DEC to BCD for LCD and UART for Time and Date

	GetSIRC12();
     93c:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <GetSIRC12>
	if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 0)		// IR POWER -> ON
     940:	90 91 a5 07 	lds	r25, 0x07A5
     944:	91 30       	cpi	r25, 0x01	; 1
     946:	29 f4       	brne	.+10     	; 0x952 <irDecode+0x16>
     948:	80 91 a0 07 	lds	r24, 0x07A0
     94c:	85 31       	cpi	r24, 0x15	; 21
     94e:	99 f4       	brne	.+38     	; 0x976 <irDecode+0x3a>
     950:	06 c0       	rjmp	.+12     	; 0x95e <irDecode+0x22>
     952:	94 30       	cpi	r25, 0x04	; 4
     954:	29 f5       	brne	.+74     	; 0x9a0 <irDecode+0x64>
     956:	80 91 a0 07 	lds	r24, 0x07A0
     95a:	8d 30       	cpi	r24, 0x0D	; 13
     95c:	99 f4       	brne	.+38     	; 0x984 <irDecode+0x48>
     95e:	e0 91 a1 07 	lds	r30, 0x07A1
     962:	f0 91 a2 07 	lds	r31, 0x07A2
     966:	80 81       	ld	r24, Z
     968:	80 fd       	sbrc	r24, 0
     96a:	03 c0       	rjmp	.+6      	; 0x972 <irDecode+0x36>
	{		
		ampliferOn();
     96c:	0e 94 a2 03 	call	0x744	; 0x744 <ampliferOn>
     970:	a6 c0       	rjmp	.+332    	; 0xabe <irDecode+0x182>
//		_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 1)	// IR POWER -> OFF
     972:	91 30       	cpi	r25, 0x01	; 1
     974:	29 f4       	brne	.+10     	; 0x980 <irDecode+0x44>
     976:	80 91 a0 07 	lds	r24, 0x07A0
     97a:	85 31       	cpi	r24, 0x15	; 21
     97c:	b1 f4       	brne	.+44     	; 0x9aa <irDecode+0x6e>
     97e:	06 c0       	rjmp	.+12     	; 0x98c <irDecode+0x50>
     980:	94 30       	cpi	r25, 0x04	; 4
     982:	71 f4       	brne	.+28     	; 0x9a0 <irDecode+0x64>
     984:	80 91 a0 07 	lds	r24, 0x07A0
     988:	8d 30       	cpi	r24, 0x0D	; 13
     98a:	79 f4       	brne	.+30     	; 0x9aa <irDecode+0x6e>
     98c:	e0 91 a1 07 	lds	r30, 0x07A1
     990:	f0 91 a2 07 	lds	r31, 0x07A2
     994:	80 81       	ld	r24, Z
     996:	80 ff       	sbrs	r24, 0
     998:	03 c0       	rjmp	.+6      	; 0x9a0 <irDecode+0x64>
	{
		ampliferOff();
     99a:	0e 94 51 03 	call	0x6a2	; 0x6a2 <ampliferOff>
     99e:	8f c0       	rjmp	.+286    	; 0xabe <irDecode+0x182>
//		flagPower = 0;			// filter za buton OFF
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLUP)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME UP"
     9a0:	91 30       	cpi	r25, 0x01	; 1
     9a2:	19 f0       	breq	.+6      	; 0x9aa <irDecode+0x6e>
     9a4:	94 30       	cpi	r25, 0x04	; 4
     9a6:	09 f0       	breq	.+2      	; 0x9aa <irDecode+0x6e>
     9a8:	8a c0       	rjmp	.+276    	; 0xabe <irDecode+0x182>
     9aa:	20 91 a0 07 	lds	r18, 0x07A0
     9ae:	22 31       	cpi	r18, 0x12	; 18
     9b0:	49 f4       	brne	.+18     	; 0x9c4 <irDecode+0x88>
     9b2:	e0 91 a1 07 	lds	r30, 0x07A1
     9b6:	f0 91 a2 07 	lds	r31, 0x07A2
     9ba:	80 81       	ld	r24, Z
     9bc:	80 ff       	sbrs	r24, 0
     9be:	02 c0       	rjmp	.+4      	; 0x9c4 <irDecode+0x88>
	{	// VOLUME UP
		volumeProcessRemote(REMOTE_VOLUME_UP);
     9c0:	81 e0       	ldi	r24, 0x01	; 1
     9c2:	0f c0       	rjmp	.+30     	; 0x9e2 <irDecode+0xa6>
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLDN)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME DOWN"
     9c4:	91 30       	cpi	r25, 0x01	; 1
     9c6:	19 f0       	breq	.+6      	; 0x9ce <irDecode+0x92>
     9c8:	94 30       	cpi	r25, 0x04	; 4
     9ca:	09 f0       	breq	.+2      	; 0x9ce <irDecode+0x92>
     9cc:	78 c0       	rjmp	.+240    	; 0xabe <irDecode+0x182>
     9ce:	23 31       	cpi	r18, 0x13	; 19
     9d0:	59 f4       	brne	.+22     	; 0x9e8 <irDecode+0xac>
     9d2:	e0 91 a1 07 	lds	r30, 0x07A1
     9d6:	f0 91 a2 07 	lds	r31, 0x07A2
     9da:	80 81       	ld	r24, Z
     9dc:	80 ff       	sbrs	r24, 0
     9de:	04 c0       	rjmp	.+8      	; 0x9e8 <irDecode+0xac>
	{	// VOLUME DOWN
		volumeProcessRemote(REMOTE_VOLUME_DOWN);
     9e0:	8f ef       	ldi	r24, 0xFF	; 255
     9e2:	0e 94 13 03 	call	0x626	; 0x626 <volumeProcessRemote>
     9e6:	6b c0       	rjmp	.+214    	; 0xabe <irDecode+0x182>
//		break;
	}

	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_ATT)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     9e8:	91 30       	cpi	r25, 0x01	; 1
     9ea:	19 f0       	breq	.+6      	; 0x9f2 <irDecode+0xb6>
     9ec:	94 30       	cpi	r25, 0x04	; 4
     9ee:	09 f0       	breq	.+2      	; 0x9f2 <irDecode+0xb6>
     9f0:	66 c0       	rjmp	.+204    	; 0xabe <irDecode+0x182>
     9f2:	24 31       	cpi	r18, 0x14	; 20
     9f4:	51 f4       	brne	.+20     	; 0xa0a <irDecode+0xce>
     9f6:	e0 91 a1 07 	lds	r30, 0x07A1
     9fa:	f0 91 a2 07 	lds	r31, 0x07A2
     9fe:	80 81       	ld	r24, Z
     a00:	80 ff       	sbrs	r24, 0
     a02:	03 c0       	rjmp	.+6      	; 0xa0a <irDecode+0xce>
	{	// MUTE
		volumeMute();
     a04:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <volumeMute>
     a08:	5a c0       	rjmp	.+180    	; 0xabe <irDecode+0x182>
//		break;
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_DOWN)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     a0a:	94 30       	cpi	r25, 0x04	; 4
     a0c:	09 f0       	breq	.+2      	; 0xa10 <irDecode+0xd4>
     a0e:	57 c0       	rjmp	.+174    	; 0xabe <irDecode+0x182>
     a10:	22 33       	cpi	r18, 0x32	; 50
     a12:	81 f4       	brne	.+32     	; 0xa34 <irDecode+0xf8>
     a14:	e0 91 a1 07 	lds	r30, 0x07A1
     a18:	f0 91 a2 07 	lds	r31, 0x07A2
     a1c:	80 81       	ld	r24, Z
     a1e:	80 ff       	sbrs	r24, 0
     a20:	4e c0       	rjmp	.+156    	; 0xabe <irDecode+0x182>
	{	// FAN STEP UP
		if(fanSpeed < FAN_SPEED_ABSOLUTE_MIN + 1)//0)
     a22:	80 91 3f 07 	lds	r24, 0x073F
     a26:	88 23       	and	r24, r24
     a28:	19 f4       	brne	.+6      	; 0xa30 <irDecode+0xf4>
		{
			fanSpeed = FAN_SPEED_ABSOLUTE_MIN;	//0;	// 0-7
     a2a:	10 92 3f 07 	sts	0x073F, r1
     a2e:	14 c0       	rjmp	.+40     	; 0xa58 <irDecode+0x11c>
		}
		else
		{
			fanSpeed--;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     a30:	81 50       	subi	r24, 0x01	; 1
     a32:	10 c0       	rjmp	.+32     	; 0xa54 <irDecode+0x118>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
		LCD_DATA_STRING(" or ");
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
		fan_pwm_control_speed();
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_UP)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     a34:	23 33       	cpi	r18, 0x33	; 51
     a36:	b1 f5       	brne	.+108    	; 0xaa4 <irDecode+0x168>
     a38:	e0 91 a1 07 	lds	r30, 0x07A1
     a3c:	f0 91 a2 07 	lds	r31, 0x07A2
     a40:	80 81       	ld	r24, Z
     a42:	80 ff       	sbrs	r24, 0
     a44:	3c c0       	rjmp	.+120    	; 0xabe <irDecode+0x182>
	{	// FAN STEP DOWN
		if(fanSpeed > FAN_LIMIT_POSITIONS - 2)//7)
     a46:	80 91 3f 07 	lds	r24, 0x073F
     a4a:	87 30       	cpi	r24, 0x07	; 7
     a4c:	10 f0       	brcs	.+4      	; 0xa52 <irDecode+0x116>
		{
			fanSpeed = FAN_LIMIT_POSITIONS - 1;	//7;	// 0-7
     a4e:	87 e0       	ldi	r24, 0x07	; 7
     a50:	01 c0       	rjmp	.+2      	; 0xa54 <irDecode+0x118>
		}
		else
		{
			fanSpeed++;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     a52:	8f 5f       	subi	r24, 0xFF	; 255
     a54:	80 93 3f 07 	sts	0x073F, r24
		}
//		fanSpeedStep [fanSpeed];// = { 0x00, 100, 125, 150, 175, 200, 225, 250 };
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     a58:	84 ed       	ldi	r24, 0xD4	; 212
     a5a:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
		LCD_DATA_STRING("Fan Step: ");	// 20 symbols			
     a5e:	8b e1       	ldi	r24, 0x1B	; 27
     a60:	97 e0       	ldi	r25, 0x07	; 7
     a62:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
     a66:	80 91 3f 07 	lds	r24, 0x073F
     a6a:	90 e0       	ldi	r25, 0x00	; 0
     a6c:	0e 94 10 08 	call	0x1020	; 0x1020 <LCD_DATA_INT>
		LCD_DATA_STRING(" or ");
     a70:	86 e2       	ldi	r24, 0x26	; 38
     a72:	97 e0       	ldi	r25, 0x07	; 7
     a74:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
     a78:	e0 91 3f 07 	lds	r30, 0x073F
     a7c:	f0 e0       	ldi	r31, 0x00	; 0
     a7e:	e0 5c       	subi	r30, 0xC0	; 192
     a80:	f8 4f       	sbci	r31, 0xF8	; 248
     a82:	80 81       	ld	r24, Z
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	0e 94 10 08 	call	0x1020	; 0x1020 <LCD_DATA_INT>
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     a8a:	81 ea       	ldi	r24, 0xA1	; 161
     a8c:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     a8e:	81 e0       	ldi	r24, 0x01	; 1
     a90:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     a92:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     a94:	e0 91 3f 07 	lds	r30, 0x073F
     a98:	f0 e0       	ldi	r31, 0x00	; 0
     a9a:	e0 5c       	subi	r30, 0xC0	; 192
     a9c:	f8 4f       	sbci	r31, 0xF8	; 248
     a9e:	80 81       	ld	r24, Z
     aa0:	8a bd       	out	0x2a, r24	; 42
     aa2:	0d c0       	rjmp	.+26     	; 0xabe <irDecode+0x182>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
		LCD_DATA_STRING(" or ");
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
		fan_pwm_control_speed();
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_SCRL)) && (flagStatusBits->flagPower == 0 || flagStatusBits->flagPower == 1))						// Sony CarAudio IR Remote Device - "SCRL" -> TEMPERATURE
     aa4:	23 32       	cpi	r18, 0x23	; 35
     aa6:	59 f4       	brne	.+22     	; 0xabe <irDecode+0x182>
	{
		temperature();
     aa8:	0e 94 fe 01 	call	0x3fc	; 0x3fc <temperature>
     aac:	80 ed       	ldi	r24, 0xD0	; 208
     aae:	97 e0       	ldi	r25, 0x07	; 7
     ab0:	20 e9       	ldi	r18, 0x90	; 144
     ab2:	31 e0       	ldi	r19, 0x01	; 1
     ab4:	f9 01       	movw	r30, r18
     ab6:	31 97       	sbiw	r30, 0x01	; 1
     ab8:	f1 f7       	brne	.-4      	; 0xab6 <irDecode+0x17a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     aba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     abc:	d9 f7       	brne	.-10     	; 0xab4 <irDecode+0x178>
     abe:	80 ed       	ldi	r24, 0xD0	; 208
     ac0:	97 e0       	ldi	r25, 0x07	; 7
     ac2:	20 e9       	ldi	r18, 0x90	; 144
     ac4:	31 e0       	ldi	r19, 0x01	; 1
     ac6:	f9 01       	movw	r30, r18
     ac8:	31 97       	sbiw	r30, 0x01	; 1
     aca:	f1 f7       	brne	.-4      	; 0xac8 <irDecode+0x18c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     acc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     ace:	d9 f7       	brne	.-10     	; 0xac6 <irDecode+0x18a>
	else
	{
		// DO NOTING
	}
	_delay_ms(200);
}
     ad0:	08 95       	ret

00000ad2 <__vector_1>:

/*****************************************
**** EXTERNAL INTERRUPT 0 VECTOR 01 ******
*****************************************/
ISR(INT0_vect)
{
     ad2:	1f 92       	push	r1
     ad4:	0f 92       	push	r0
     ad6:	0f b6       	in	r0, 0x3f	; 63
     ad8:	0f 92       	push	r0
     ada:	11 24       	eor	r1, r1
     adc:	2f 93       	push	r18
     ade:	3f 93       	push	r19
     ae0:	4f 93       	push	r20
     ae2:	5f 93       	push	r21
     ae4:	6f 93       	push	r22
     ae6:	7f 93       	push	r23
     ae8:	8f 93       	push	r24
     aea:	9f 93       	push	r25
     aec:	af 93       	push	r26
     aee:	bf 93       	push	r27
     af0:	ef 93       	push	r30
     af2:	ff 93       	push	r31
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     af4:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     af6:	80 e4       	ldi	r24, 0x40	; 64
     af8:	8a bf       	out	0x3a, r24	; 58
	ext0_intrpt_off();	// DISABLE new IR DETECTION

// LOGIC CHECK BEGIN
// VERIFY PRESSED IR BUTTON and switch to low line of IR pin PD2
	unsigned char low_level = 0;
    if(irPin == 0)
     afa:	82 99       	sbic	0x10, 2	; 16
     afc:	0b c0       	rjmp	.+22     	; 0xb14 <__vector_1+0x42>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     afe:	8a e0       	ldi	r24, 0x0A	; 10
     b00:	98 2f       	mov	r25, r24
     b02:	9a 95       	dec	r25
     b04:	f1 f7       	brne	.-4      	; 0xb02 <__vector_1+0x30>
     b06:	98 2f       	mov	r25, r24
     b08:	9a 95       	dec	r25
     b0a:	f1 f7       	brne	.-4      	; 0xb08 <__vector_1+0x36>
     b0c:	8a 95       	dec	r24
     b0e:	f1 f7       	brne	.-4      	; 0xb0c <__vector_1+0x3a>
			_delay_us(2);	//2uS delay
		}

		if(low_level == 3)
		{
			irDecode();
     b10:	0e 94 9e 04 	call	0x93c	; 0x93c <irDecode>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     b14:	80 e4       	ldi	r24, 0x40	; 64
     b16:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     b18:	8a bf       	out	0x3a, r24	; 58
		}
    }
// LOGIC CHECK END

	ext0_intrpt_on();	// ENABLE new IR DETECTION
}
     b1a:	ff 91       	pop	r31
     b1c:	ef 91       	pop	r30
     b1e:	bf 91       	pop	r27
     b20:	af 91       	pop	r26
     b22:	9f 91       	pop	r25
     b24:	8f 91       	pop	r24
     b26:	7f 91       	pop	r23
     b28:	6f 91       	pop	r22
     b2a:	5f 91       	pop	r21
     b2c:	4f 91       	pop	r20
     b2e:	3f 91       	pop	r19
     b30:	2f 91       	pop	r18
     b32:	0f 90       	pop	r0
     b34:	0f be       	out	0x3f, r0	; 63
     b36:	0f 90       	pop	r0
     b38:	1f 90       	pop	r1
     b3a:	18 95       	reti

00000b3c <eeprom_24c64_read>:
	// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
	// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !
	
	byte eepromReceiveByte0, eepromReceiveByte1, eepromReceiveByte2, eepromReceiveByte3, eepromReceiveByte4, eepromReceiveByte5;
// EEPROM READ
	i2c_start();
     b3c:	0e 94 ac 06 	call	0xd58	; 0xd58 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);		// EEPROM 24C64 ADDRESS ACCESS WRITE
     b40:	80 ea       	ldi	r24, 0xA0	; 160
     b42:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     b46:	80 e0       	ldi	r24, 0x00	; 0
     b48:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b4c:	80 e0       	ldi	r24, 0x00	; 0
     b4e:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>

	i2c_start();
     b52:	0e 94 ac 06 	call	0xd58	; 0xd58 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_READ);		// EEPROM 24C64 ADDRESS ACCESS READ
     b56:	81 ea       	ldi	r24, 0xA1	; 161
     b58:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
	eepromReceiveByte0	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b5c:	80 e0       	ldi	r24, 0x00	; 0
     b5e:	0e 94 bc 06 	call	0xd78	; 0xd78 <i2c_read>
	eepromReceiveByte1	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b62:	80 e0       	ldi	r24, 0x00	; 0
     b64:	0e 94 bc 06 	call	0xd78	; 0xd78 <i2c_read>
	eepromReceiveByte2	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b68:	80 e0       	ldi	r24, 0x00	; 0
     b6a:	0e 94 bc 06 	call	0xd78	; 0xd78 <i2c_read>
	eepromReceiveByte3	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b6e:	80 e0       	ldi	r24, 0x00	; 0
     b70:	0e 94 bc 06 	call	0xd78	; 0xd78 <i2c_read>
	eepromReceiveByte4	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b74:	80 e0       	ldi	r24, 0x00	; 0
     b76:	0e 94 bc 06 	call	0xd78	; 0xd78 <i2c_read>
	eepromReceiveByte5	= i2c_read(1);				// EEPROM DATA READ BYTE	// i2c_read(1) parametar razlichen ot 0 spira komunikaciqta NACK
     b7a:	81 e0       	ldi	r24, 0x01	; 1
     b7c:	0e 94 bc 06 	call	0xd78	; 0xd78 <i2c_read>
	i2c_stop();
     b80:	0e 94 b2 06 	call	0xd64	; 0xd64 <i2c_stop>
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte2);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte3);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte4);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte5);
*/
}
     b84:	08 95       	ret

00000b86 <eeprom_24c64_write>:
// Za da se vijda tova koeto se e zapisalo v pametta, a ne ot tozi bibliotechen fail !!!!!!!!!
// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !

// EEPROM WRITE
	i2c_start();
     b86:	0e 94 ac 06 	call	0xd58	; 0xd58 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     b8a:	80 ea       	ldi	r24, 0xA0	; 160
     b8c:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     b90:	80 e0       	ldi	r24, 0x00	; 0
     b92:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b96:	80 e0       	ldi	r24, 0x00	; 0
     b98:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
// Write data
	i2c_write(0x30);	// Data is stored: 0x30 - '0'
     b9c:	80 e3       	ldi	r24, 0x30	; 48
     b9e:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
	i2c_write(0x31);	// Data is stored: 0x31 - '1'
     ba2:	81 e3       	ldi	r24, 0x31	; 49
     ba4:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
	i2c_write(0x32);	// Data is stored: 0x32 - '2'
     ba8:	82 e3       	ldi	r24, 0x32	; 50
     baa:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
	i2c_write(0x33);	// Data is stored: 0x33 - '3'
     bae:	83 e3       	ldi	r24, 0x33	; 51
     bb0:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
	i2c_write(0x34);	// Data is stored: 0x34 - '4'
     bb4:	84 e3       	ldi	r24, 0x34	; 52
     bb6:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
	i2c_stop();
     bba:	0e 94 b2 06 	call	0xd64	; 0xd64 <i2c_stop>
}
     bbe:	08 95       	ret

00000bc0 <eeprom_24c64_reset>:

/*************************************
** RESET AND ZERO FILL EEPROM 24C64 **
*************************************/
void eeprom_24c64_reset()
{
     bc0:	cf 93       	push	r28
     bc2:	df 93       	push	r29
	unsigned int i;	// 16 bits
// EEPROM WRITE
	i2c_start();
     bc4:	0e 94 ac 06 	call	0xd58	; 0xd58 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     bc8:	80 ea       	ldi	r24, 0xA0	; 160
     bca:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     bce:	80 e0       	ldi	r24, 0x00	; 0
     bd0:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     bd4:	80 e0       	ldi	r24, 0x00	; 0
     bd6:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
     bda:	c0 e0       	ldi	r28, 0x00	; 0
     bdc:	d0 e0       	ldi	r29, 0x00	; 0
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
     bde:	80 e0       	ldi	r24, 0x00	; 0
     be0:	0e 94 b5 06 	call	0xd6a	; 0xd6a <i2c_write>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
     be4:	21 96       	adiw	r28, 0x01	; 1
     be6:	8f e1       	ldi	r24, 0x1F	; 31
     be8:	cf 3f       	cpi	r28, 0xFF	; 255
     bea:	d8 07       	cpc	r29, r24
     bec:	c1 f7       	brne	.-16     	; 0xbde <eeprom_24c64_reset+0x1e>
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
	}
	i2c_stop();
     bee:	0e 94 b2 06 	call	0xd64	; 0xd64 <i2c_stop>
}
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	08 95       	ret

00000bf8 <reset>:
}
*/

unsigned char reset(void)
{
    DDRx |= (1<<Px);            //Ausgang
     bf8:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     bfa:	c0 98       	cbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     bfc:	80 e8       	ldi	r24, 0x80	; 128
     bfe:	97 e0       	ldi	r25, 0x07	; 7
     c00:	01 97       	sbiw	r24, 0x01	; 1
     c02:	f1 f7       	brne	.-4      	; 0xc00 <reset+0x8>
    _delay_us(480);
	DDRx &= ~(1<<Px);
     c04:	b8 98       	cbi	0x17, 0	; 23
     c06:	80 e4       	ldi	r24, 0x40	; 64
     c08:	91 e0       	ldi	r25, 0x01	; 1
     c0a:	01 97       	sbiw	r24, 0x01	; 1
     c0c:	f1 f7       	brne	.-4      	; 0xc0a <reset+0x12>
    _delay_us(80);
	if(!(PINx & (1<<Px)))     //Prüfe Slave-Antwort
     c0e:	b0 9b       	sbis	0x16, 0	; 22
     c10:	02 c0       	rjmp	.+4      	; 0xc16 <reset+0x1e>
     c12:	80 e0       	ldi	r24, 0x00	; 0
     c14:	08 95       	ret
     c16:	88 e0       	ldi	r24, 0x08	; 8
     c18:	97 e0       	ldi	r25, 0x07	; 7
     c1a:	01 97       	sbiw	r24, 0x01	; 1
     c1c:	f1 f7       	brne	.-4      	; 0xc1a <reset+0x22>
     c1e:	81 e0       	ldi	r24, 0x01	; 1
	}
    else
	{
        return 0;
	}
}
     c20:	08 95       	ret

00000c22 <read_bit>:

unsigned char read_bit(void)
{
    DDRx |= (1<<Px);            //Ausgang
     c22:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     c24:	c0 98       	cbi	0x18, 0	; 24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     c26:	85 e0       	ldi	r24, 0x05	; 5
     c28:	8a 95       	dec	r24
     c2a:	f1 f7       	brne	.-4      	; 0xc28 <read_bit+0x6>
    _delay_us(1);
	DDRx &= ~(1<<Px);
     c2c:	b8 98       	cbi	0x17, 0	; 23
     c2e:	80 e4       	ldi	r24, 0x40	; 64
     c30:	8a 95       	dec	r24
     c32:	f1 f7       	brne	.-4      	; 0xc30 <read_bit+0xe>
    _delay_us(12);
    if(!(PINx & (1<<Px)))       //Abtastung innerhalb von 15µs
     c34:	86 b3       	in	r24, 0x16	; 22
	}
	else
    {
		return 1;
	}
}
     c36:	81 70       	andi	r24, 0x01	; 1
     c38:	08 95       	ret

00000c3a <write_bit>:

void write_bit(unsigned char bitval)    //kann 0 oder 1 sein
{
    DDRx |= (1<<Px);            //Ausgang
     c3a:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     c3c:	c0 98       	cbi	0x18, 0	; 24
    if(bitval)
     c3e:	81 11       	cpse	r24, r1
	{
        PORTx |= (1<<Px);      //H-Pegel
     c40:	c0 9a       	sbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c42:	88 eb       	ldi	r24, 0xB8	; 184
     c44:	91 e0       	ldi	r25, 0x01	; 1
     c46:	01 97       	sbiw	r24, 0x01	; 1
     c48:	f1 f7       	brne	.-4      	; 0xc46 <write_bit+0xc>
    }
	_delay_us(110);        
    DDRx &= ~(1<<Px);
     c4a:	b8 98       	cbi	0x17, 0	; 23
    PORTx &= ~(1<<Px);
     c4c:	c0 98       	cbi	0x18, 0	; 24
}
     c4e:	08 95       	ret

00000c50 <read_byte>:

unsigned char read_byte(void)
{
     c50:	cf 92       	push	r12
     c52:	df 92       	push	r13
     c54:	ef 92       	push	r14
     c56:	ff 92       	push	r15
     c58:	1f 93       	push	r17
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
     c5e:	10 e0       	ldi	r17, 0x00	; 0
     c60:	c0 e0       	ldi	r28, 0x00	; 0
     c62:	d0 e0       	ldi	r29, 0x00	; 0
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
		{
            byte |= (1<<i);
     c64:	91 e0       	ldi	r25, 0x01	; 1
     c66:	c9 2e       	mov	r12, r25
     c68:	d1 2c       	mov	r13, r1
     c6a:	80 ee       	ldi	r24, 0xE0	; 224
     c6c:	e8 2e       	mov	r14, r24
     c6e:	81 e0       	ldi	r24, 0x01	; 1
     c70:	f8 2e       	mov	r15, r24
unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
     c72:	0e 94 11 06 	call	0xc22	; 0xc22 <read_bit>
     c76:	88 23       	and	r24, r24
     c78:	41 f0       	breq	.+16     	; 0xc8a <read_byte+0x3a>
		{
            byte |= (1<<i);
     c7a:	c6 01       	movw	r24, r12
     c7c:	0c 2e       	mov	r0, r28
     c7e:	02 c0       	rjmp	.+4      	; 0xc84 <read_byte+0x34>
     c80:	88 0f       	add	r24, r24
     c82:	99 1f       	adc	r25, r25
     c84:	0a 94       	dec	r0
     c86:	e2 f7       	brpl	.-8      	; 0xc80 <read_byte+0x30>
     c88:	18 2b       	or	r17, r24
     c8a:	c7 01       	movw	r24, r14
     c8c:	01 97       	sbiw	r24, 0x01	; 1
     c8e:	f1 f7       	brne	.-4      	; 0xc8c <read_byte+0x3c>
     c90:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
     c92:	c8 30       	cpi	r28, 0x08	; 8
     c94:	d1 05       	cpc	r29, r1
     c96:	69 f7       	brne	.-38     	; 0xc72 <read_byte+0x22>
            byte |= (1<<i);
		}
        _delay_us(120);
    }
    return byte;
}
     c98:	81 2f       	mov	r24, r17
     c9a:	df 91       	pop	r29
     c9c:	cf 91       	pop	r28
     c9e:	1f 91       	pop	r17
     ca0:	ff 90       	pop	r15
     ca2:	ef 90       	pop	r14
     ca4:	df 90       	pop	r13
     ca6:	cf 90       	pop	r12
     ca8:	08 95       	ret

00000caa <write_byte>:

void write_byte(unsigned char byte)
{
     caa:	0f 93       	push	r16
     cac:	1f 93       	push	r17
     cae:	cf 93       	push	r28
     cb0:	df 93       	push	r29
     cb2:	c0 e0       	ldi	r28, 0x00	; 0
     cb4:	d0 e0       	ldi	r29, 0x00	; 0
    for(unsigned char i=0; i<8; i++)
	{
        if(byte & (1<<i))
     cb6:	08 2f       	mov	r16, r24
     cb8:	10 e0       	ldi	r17, 0x00	; 0
     cba:	c8 01       	movw	r24, r16
     cbc:	0c 2e       	mov	r0, r28
     cbe:	02 c0       	rjmp	.+4      	; 0xcc4 <write_byte+0x1a>
     cc0:	95 95       	asr	r25
     cc2:	87 95       	ror	r24
     cc4:	0a 94       	dec	r0
     cc6:	e2 f7       	brpl	.-8      	; 0xcc0 <write_byte+0x16>
     cc8:	80 ff       	sbrs	r24, 0
     cca:	02 c0       	rjmp	.+4      	; 0xcd0 <write_byte+0x26>
		{
			write_bit(1);
     ccc:	81 e0       	ldi	r24, 0x01	; 1
     cce:	01 c0       	rjmp	.+2      	; 0xcd2 <write_byte+0x28>
		}
        else
		{
            write_bit(0);
     cd0:	80 e0       	ldi	r24, 0x00	; 0
     cd2:	0e 94 1d 06 	call	0xc3a	; 0xc3a <write_bit>
     cd6:	21 96       	adiw	r28, 0x01	; 1
    return byte;
}

void write_byte(unsigned char byte)
{
    for(unsigned char i=0; i<8; i++)
     cd8:	c8 30       	cpi	r28, 0x08	; 8
     cda:	d1 05       	cpc	r29, r1
     cdc:	71 f7       	brne	.-36     	; 0xcba <write_byte+0x10>
     cde:	80 ee       	ldi	r24, 0xE0	; 224
     ce0:	91 e0       	ldi	r25, 0x01	; 1
     ce2:	01 97       	sbiw	r24, 0x01	; 1
     ce4:	f1 f7       	brne	.-4      	; 0xce2 <write_byte+0x38>
		{
            write_bit(0);
		}
	}
    _delay_us(120);
}  
     ce6:	df 91       	pop	r29
     ce8:	cf 91       	pop	r28
     cea:	1f 91       	pop	r17
     cec:	0f 91       	pop	r16
     cee:	08 95       	ret

00000cf0 <wait_ready>:
	return 0;
}

void wait_ready(void)
{
	while(!(read_bit()));
     cf0:	0e 94 11 06 	call	0xc22	; 0xc22 <read_bit>
     cf4:	88 23       	and	r24, r24
     cf6:	e1 f3       	breq	.-8      	; 0xcf0 <wait_ready>
}
     cf8:	08 95       	ret

00000cfa <read_scratchpad>:
	}
    _delay_us(120);
}  

unsigned char read_scratchpad(void)
{
     cfa:	cf 93       	push	r28
     cfc:	df 93       	push	r29

	if(reset())
     cfe:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <reset>
     d02:	88 23       	and	r24, r24
     d04:	e9 f0       	breq	.+58     	; 0xd40 <read_scratchpad+0x46>
	{
		write_byte(0xCC);
     d06:	8c ec       	ldi	r24, 0xCC	; 204
     d08:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		write_byte(0x44);
     d0c:	84 e4       	ldi	r24, 0x44	; 68
     d0e:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
		wait_ready();
     d12:	0e 94 78 06 	call	0xcf0	; 0xcf0 <wait_ready>
		if(reset())
     d16:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <reset>
     d1a:	88 23       	and	r24, r24
     d1c:	89 f0       	breq	.+34     	; 0xd40 <read_scratchpad+0x46>
		{
			write_byte(0xCC);
     d1e:	8c ec       	ldi	r24, 0xCC	; 204
     d20:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
			write_byte(0xBE);
     d24:	8e eb       	ldi	r24, 0xBE	; 190
     d26:	0e 94 55 06 	call	0xcaa	; 0xcaa <write_byte>
     d2a:	c1 e9       	ldi	r28, 0x91	; 145
     d2c:	d7 e0       	ldi	r29, 0x07	; 7
			for(unsigned char i=0; i<9; i++)
			{
				scratchpad [i] = read_byte();
     d2e:	0e 94 28 06 	call	0xc50	; 0xc50 <read_byte>
     d32:	89 93       	st	Y+, r24
		wait_ready();
		if(reset())
		{
			write_byte(0xCC);
			write_byte(0xBE);
			for(unsigned char i=0; i<9; i++)
     d34:	87 e0       	ldi	r24, 0x07	; 7
     d36:	ca 39       	cpi	r28, 0x9A	; 154
     d38:	d8 07       	cpc	r29, r24
     d3a:	c9 f7       	brne	.-14     	; 0xd2e <read_scratchpad+0x34>
     d3c:	81 e0       	ldi	r24, 0x01	; 1
     d3e:	01 c0       	rjmp	.+2      	; 0xd42 <read_scratchpad+0x48>
     d40:	80 e0       	ldi	r24, 0x00	; 0
			}
			return 1;
		}
	}
	return 0;
}
     d42:	df 91       	pop	r29
     d44:	cf 91       	pop	r28
     d46:	08 95       	ret

00000d48 <i2c_init>:
|== TWPS = 1 => (4^TWPS)= 4  // TWSR = (0<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx01 => TWSR = 1 (DEC) => 4^1 =  4 =|
|== TWPS = 2 => (4^TWPS)=16  // TWSR = (1<<TWPS1)|(0<<TWPS0) => TWSR = 0bxxxxxx10 => TWSR = 2 (DEC) => 4^2 = 16 =|
|== TWPS = 3 => (4^TWPS)=64  // TWSR = (1<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx11 => TWSR = 3 (DEC) => 4^3 = 64 =|
|===============================================================================================================*/

	TWBR = 0b00010010;	// HEX=0x12	or DEC=18	// FCPU = 16 000 000 |-> SCL = 16000000 / (16+(2*TWBR*(4^TWPS)) = 16000000 / (16+(2*18*(4))) = 16000000 / 160 = 100 000 Hz = 100 kHz
     d48:	82 e1       	ldi	r24, 0x12	; 18
     d4a:	80 b9       	out	0x00, r24	; 0
	TWSR = (0<<TWPS1)|(1<<TWPS0);	// SCL = 16 000 000 / 64  = 250 000 = 250kHz
     d4c:	81 e0       	ldi	r24, 0x01	; 1
     d4e:	81 b9       	out	0x01, r24	; 1
	TWCR = (1<<TWEN);	//	TWCR = 0x04; // TWCR = (x<<TWINT)|(x<<TWEA)|(x<<TWSTA)|(x<<TWSTO)|(x<<TWEN)|(x<<TWIE);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz
     d50:	84 e0       	ldi	r24, 0x04	; 4
     d52:	86 bf       	out	0x36, r24	; 54
	TWDR = 0b00000000;
     d54:	13 b8       	out	0x03, r1	; 3
}
     d56:	08 95       	ret

00000d58 <i2c_start>:
/*****************************************
** START CONDITION OF I2C COMMUNICATION **
*****************************************/
void i2c_start(void)
{
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     d58:	84 ea       	ldi	r24, 0xA4	; 164
     d5a:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     d5c:	06 b6       	in	r0, 0x36	; 54
     d5e:	07 fe       	sbrs	r0, 7
     d60:	fd cf       	rjmp	.-6      	; 0xd5c <i2c_start+0x4>
	{
	}
}
     d62:	08 95       	ret

00000d64 <i2c_stop>:
/****************************************
** STOP CONDITION OF I2C COMMUNICATION **
****************************************/
void i2c_stop()
{
	TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     d64:	84 e9       	ldi	r24, 0x94	; 148
     d66:	86 bf       	out	0x36, r24	; 54
}
     d68:	08 95       	ret

00000d6a <i2c_write>:
/*******************************************
** WRITE/SEND 1 BYTE OF I2C COMMUNICATION **
*******************************************/
void i2c_write(unsigned char data)
{
	TWDR = data;
     d6a:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT)|(1<<TWEN);
     d6c:	84 e8       	ldi	r24, 0x84	; 132
     d6e:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     d70:	06 b6       	in	r0, 0x36	; 54
     d72:	07 fe       	sbrs	r0, 7
     d74:	fd cf       	rjmp	.-6      	; 0xd70 <i2c_write+0x6>
	{
	}
}
     d76:	08 95       	ret

00000d78 <i2c_read>:
/**********************************************
** READ/RECEIVE BYTE(S) OF I2C COMMUNICATION **
**********************************************/
unsigned char i2c_read(unsigned char isLast)
{
	if(isLast == 0 )
     d78:	88 23       	and	r24, r24
     d7a:	11 f4       	brne	.+4      	; 0xd80 <i2c_read+0x8>
	{
		TWCR = (1<<TWINT)|(1<<TWEA)|(1<<TWEN);	// to next receive byte
     d7c:	84 ec       	ldi	r24, 0xC4	; 196
     d7e:	01 c0       	rjmp	.+2      	; 0xd82 <i2c_read+0xa>
	}
	else
	{
		TWCR = (1<<TWINT)|(1<<TWEN);			// to end of communication
     d80:	84 e8       	ldi	r24, 0x84	; 132
     d82:	86 bf       	out	0x36, r24	; 54
	}
	
	while((TWCR & (1<<TWINT)) == 0)
     d84:	06 b6       	in	r0, 0x36	; 54
     d86:	07 fe       	sbrs	r0, 7
     d88:	fd cf       	rjmp	.-6      	; 0xd84 <i2c_read+0xc>
	{
	}
	return TWDR;
     d8a:	83 b1       	in	r24, 0x03	; 3
}
     d8c:	08 95       	ret

00000d8e <LCD_EXECUTE_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_EXECUTE_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     d8e:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     d90:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     d92:	87 ff       	sbrs	r24, 7
     d94:	02 c0       	rjmp	.+4      	; 0xd9a <LCD_EXECUTE_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     d96:	d8 9a       	sbi	0x1b, 0	; 27
     d98:	01 c0       	rjmp	.+2      	; 0xd9c <LCD_EXECUTE_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     d9a:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     d9c:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     d9e:	9f 5f       	subi	r25, 0xFF	; 255
     da0:	98 30       	cpi	r25, 0x08	; 8
     da2:	11 f0       	breq	.+4      	; 0xda8 <LCD_EXECUTE_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     da4:	88 0f       	add	r24, r24
     da6:	f4 cf       	rjmp	.-24     	; 0xd90 <LCD_EXECUTE_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     da8:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     daa:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     dac:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     dae:	da 98       	cbi	0x1b, 2	; 27
     db0:	88 ea       	ldi	r24, 0xA8	; 168
     db2:	92 e0       	ldi	r25, 0x02	; 2
     db4:	fc 01       	movw	r30, r24
     db6:	31 97       	sbiw	r30, 0x01	; 1
     db8:	f1 f7       	brne	.-4      	; 0xdb6 <LCD_EXECUTE_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     dba:	da 9a       	sbi	0x1b, 2	; 27
     dbc:	01 97       	sbiw	r24, 0x01	; 1
     dbe:	f1 f7       	brne	.-4      	; 0xdbc <LCD_EXECUTE_COMMAND+0x2e>
	LCD_REGSELECT_low();	// RS = 0
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);			//rcall 180 us
*/
	LCD_ENABLE_low();		// EN = 0
     dc0:	db 98       	cbi	0x1b, 3	; 27
     dc2:	80 e9       	ldi	r24, 0x90	; 144
     dc4:	91 e0       	ldi	r25, 0x01	; 1
     dc6:	01 97       	sbiw	r24, 0x01	; 1
     dc8:	f1 f7       	brne	.-4      	; 0xdc6 <LCD_EXECUTE_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us

}
     dca:	08 95       	ret

00000dcc <LCD_EXECUTE_DATA>:

/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
     dd0:	40 e0       	ldi	r20, 0x00	; 0
     dd2:	50 e0       	ldi	r21, 0x00	; 0
     dd4:	a8 ea       	ldi	r26, 0xA8	; 168
     dd6:	b2 e0       	ldi	r27, 0x02	; 2
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];
     dd8:	c0 e9       	ldi	r28, 0x90	; 144
     dda:	d1 e0       	ldi	r29, 0x01	; 1
     ddc:	22 c0       	rjmp	.+68     	; 0xe22 <LCD_EXECUTE_DATA+0x56>
     dde:	fc 01       	movw	r30, r24
     de0:	e4 0f       	add	r30, r20
     de2:	f5 1f       	adc	r31, r21
     de4:	e0 81       	ld	r30, Z
     de6:	20 e0       	ldi	r18, 0x00	; 0

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     de8:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     dea:	e7 ff       	sbrs	r30, 7
     dec:	02 c0       	rjmp	.+4      	; 0xdf2 <LCD_EXECUTE_DATA+0x26>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     dee:	d8 9a       	sbi	0x1b, 0	; 27
     df0:	01 c0       	rjmp	.+2      	; 0xdf4 <LCD_EXECUTE_DATA+0x28>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     df2:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     df4:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     df6:	2f 5f       	subi	r18, 0xFF	; 255
     df8:	28 30       	cpi	r18, 0x08	; 8
     dfa:	11 f0       	breq	.+4      	; 0xe00 <LCD_EXECUTE_DATA+0x34>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     dfc:	ee 0f       	add	r30, r30
     dfe:	f4 cf       	rjmp	.-24     	; 0xde8 <LCD_EXECUTE_DATA+0x1c>
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     e00:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     e02:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     e04:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     e06:	da 98       	cbi	0x1b, 2	; 27
     e08:	fd 01       	movw	r30, r26
     e0a:	31 97       	sbiw	r30, 0x01	; 1
     e0c:	f1 f7       	brne	.-4      	; 0xe0a <LCD_EXECUTE_DATA+0x3e>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     e0e:	da 9a       	sbi	0x1b, 2	; 27
     e10:	fd 01       	movw	r30, r26
     e12:	31 97       	sbiw	r30, 0x01	; 1
     e14:	f1 f7       	brne	.-4      	; 0xe12 <LCD_EXECUTE_DATA+0x46>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     e16:	db 98       	cbi	0x1b, 3	; 27
     e18:	fe 01       	movw	r30, r28
     e1a:	31 97       	sbiw	r30, 0x01	; 1
     e1c:	f1 f7       	brne	.-4      	; 0xe1a <LCD_EXECUTE_DATA+0x4e>
/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
     e1e:	4f 5f       	subi	r20, 0xFF	; 255
     e20:	5f 4f       	sbci	r21, 0xFF	; 255
     e22:	46 17       	cp	r20, r22
     e24:	57 07       	cpc	r21, r23
     e26:	dc f2       	brlt	.-74     	; 0xdde <LCD_EXECUTE_DATA+0x12>
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}

//	LCD_EXECUTE_DATA_LAST();	// flush -> posleden simvol ili gore v cikala count_ns < numsymbols+1 ili count_ns <= numsymbols
}
     e28:	df 91       	pop	r29
     e2a:	cf 91       	pop	r28
     e2c:	08 95       	ret

00000e2e <LCD_EXECUTE_DATA_ONE>:

/************************************************
** WRITE/TRANSMIT ONE DATA BYTE TO LCD DISPLAY **
************************************************/
void LCD_EXECUTE_DATA_ONE(unsigned char data)	// HELP: LCD_EXECUTE_DATA(unsigned char data_byte_symbols) // LCD shift left out, msb is first
{
     e2e:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     e30:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     e32:	87 ff       	sbrs	r24, 7
     e34:	02 c0       	rjmp	.+4      	; 0xe3a <LCD_EXECUTE_DATA_ONE+0xc>
		{
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     e36:	d8 9a       	sbi	0x1b, 0	; 27
     e38:	01 c0       	rjmp	.+2      	; 0xe3c <LCD_EXECUTE_DATA_ONE+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     e3a:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     e3c:	d9 9a       	sbi	0x1b, 1	; 27
{
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     e3e:	9f 5f       	subi	r25, 0xFF	; 255
     e40:	98 30       	cpi	r25, 0x08	; 8
     e42:	11 f0       	breq	.+4      	; 0xe48 <LCD_EXECUTE_DATA_ONE+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     e44:	88 0f       	add	r24, r24
     e46:	f4 cf       	rjmp	.-24     	; 0xe30 <LCD_EXECUTE_DATA_ONE+0x2>
	}
//update from down comment
	LCD_REGSELECT_high();	// RS = 1
     e48:	dd 9a       	sbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     e4a:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     e4c:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment

	LCD_RCK_low();
     e4e:	da 98       	cbi	0x1b, 2	; 27
     e50:	88 ea       	ldi	r24, 0xA8	; 168
     e52:	92 e0       	ldi	r25, 0x02	; 2
     e54:	fc 01       	movw	r30, r24
     e56:	31 97       	sbiw	r30, 0x01	; 1
     e58:	f1 f7       	brne	.-4      	; 0xe56 <LCD_EXECUTE_DATA_ONE+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     e5a:	da 9a       	sbi	0x1b, 2	; 27
     e5c:	01 97       	sbiw	r24, 0x01	; 1
     e5e:	f1 f7       	brne	.-4      	; 0xe5c <LCD_EXECUTE_DATA_ONE+0x2e>
	LCD_REGSELECT_high();	// RS = 1
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);
*/
	LCD_ENABLE_low();		// EN = 0
     e60:	db 98       	cbi	0x1b, 3	; 27
     e62:	80 e9       	ldi	r24, 0x90	; 144
     e64:	91 e0       	ldi	r25, 0x01	; 1
     e66:	01 97       	sbiw	r24, 0x01	; 1
     e68:	f1 f7       	brne	.-4      	; 0xe66 <LCD_EXECUTE_DATA_ONE+0x38>
	_delay_us(100);
}
     e6a:	08 95       	ret

00000e6c <LCD_EXECUTE_DATA_LAST>:
/*****************************************************************************
** WRITE/TRANSMIT LAST DATA BYTE TO LCD DISPLAY AND FLUSH SN74HC595 BUFFER  **
*****************************************************************************/
void LCD_EXECUTE_DATA_LAST()	// flush -> izchistvane na bufer - prinuditelno izpisvane na posleden simvol
{
	LCD_ENABLE_low();
     e6c:	db 98       	cbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     e6e:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     e70:	dd 9a       	sbi	0x1b, 5	; 27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     e72:	85 ed       	ldi	r24, 0xD5	; 213
     e74:	98 2f       	mov	r25, r24
     e76:	9a 95       	dec	r25
     e78:	f1 f7       	brne	.-4      	; 0xe76 <LCD_EXECUTE_DATA_LAST+0xa>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
	LCD_ENABLE_high();
     e7a:	db 9a       	sbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     e7c:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     e7e:	dd 9a       	sbi	0x1b, 5	; 27
     e80:	8a 95       	dec	r24
     e82:	f1 f7       	brne	.-4      	; 0xe80 <LCD_EXECUTE_DATA_LAST+0x14>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
}
     e84:	08 95       	ret

00000e86 <LCD_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     e86:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     e88:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     e8a:	87 ff       	sbrs	r24, 7
     e8c:	02 c0       	rjmp	.+4      	; 0xe92 <LCD_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     e8e:	d8 9a       	sbi	0x1b, 0	; 27
     e90:	01 c0       	rjmp	.+2      	; 0xe94 <LCD_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     e92:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     e94:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     e96:	9f 5f       	subi	r25, 0xFF	; 255
     e98:	98 30       	cpi	r25, 0x08	; 8
     e9a:	11 f0       	breq	.+4      	; 0xea0 <LCD_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     e9c:	88 0f       	add	r24, r24
     e9e:	f4 cf       	rjmp	.-24     	; 0xe88 <LCD_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     ea0:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     ea2:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     ea4:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     ea6:	da 98       	cbi	0x1b, 2	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     ea8:	88 ea       	ldi	r24, 0xA8	; 168
     eaa:	92 e0       	ldi	r25, 0x02	; 2
     eac:	fc 01       	movw	r30, r24
     eae:	31 97       	sbiw	r30, 0x01	; 1
     eb0:	f1 f7       	brne	.-4      	; 0xeae <LCD_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     eb2:	da 9a       	sbi	0x1b, 2	; 27
     eb4:	01 97       	sbiw	r24, 0x01	; 1
     eb6:	f1 f7       	brne	.-4      	; 0xeb4 <LCD_COMMAND+0x2e>
	_delay_us(170);			//rcall 180 us

	LCD_ENABLE_low();		// EN = 0
     eb8:	db 98       	cbi	0x1b, 3	; 27
     eba:	80 e9       	ldi	r24, 0x90	; 144
     ebc:	91 e0       	ldi	r25, 0x01	; 1
     ebe:	01 97       	sbiw	r24, 0x01	; 1
     ec0:	f1 f7       	brne	.-4      	; 0xebe <LCD_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us
}
     ec2:	08 95       	ret

00000ec4 <LCD_CLEAR_CONTAIN>:
/**************************************
** CLEAR ALL CONTAINS ON LCD DISPLAY **
**************************************/
void LCD_CLEAR_CONTAIN()
{
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 1. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     ec4:	81 e0       	ldi	r24, 0x01	; 1
     ec6:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
     eca:	80 ec       	ldi	r24, 0xC0	; 192
     ecc:	92 e1       	ldi	r25, 0x12	; 18
     ece:	01 97       	sbiw	r24, 0x01	; 1
     ed0:	f1 f7       	brne	.-4      	; 0xece <LCD_CLEAR_CONTAIN+0xa>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
}
     ed2:	08 95       	ret

00000ed4 <LCD_INIT>:
/**********************************
** INITIZLIZATION OF LCD DISPLAY **
**********************************/
void LCD_INIT()
{
	LCD_COMMAND(LCD_8BIT_2ROWS_FONT5X7);		// 0b00111000	// 1. Function set: 8-bit interface data (DL = 1), 2-line display (N = 1), 5 x 7 dot character font (F = 0)
     ed4:	88 e3       	ldi	r24, 0x38	; 56
     ed6:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_ENTRY_MODE_INC_NOSHIFT);	// 0b00000110	// 2. Entry mode set: Increment by 1 (I/D = 1), No shift (S = 0)
     eda:	86 e0       	ldi	r24, 0x06	; 6
     edc:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_MOVE_FIRST);								// 3.
     ee0:	82 e0       	ldi	r24, 0x02	; 2
     ee2:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 4. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     ee6:	81 e0       	ldi	r24, 0x01	; 1
     ee8:	0e 94 43 07 	call	0xe86	; 0xe86 <LCD_COMMAND>
     eec:	80 ec       	ldi	r24, 0xC0	; 192
     eee:	92 e1       	ldi	r25, 0x12	; 18
     ef0:	01 97       	sbiw	r24, 0x01	; 1
     ef2:	f1 f7       	brne	.-4      	; 0xef0 <LCD_INIT+0x1c>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
//	LCD_COMMAND(LCD_ON_BLINK_CURSOR);			// 0b00001111	// 5. Display on/off control: Display on (D = 1), Cursor on (C = 1), Blinking on (B = 1)
//	_delay_us(40);	// 37 uS	// comment for simulation
//	LCD_COMMAND(LCD_OFF);										// 5. Display off
}
     ef4:	08 95       	ret

00000ef6 <LCD_DATA_STRING>:

/*********************************************************
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
     ef6:	fc 01       	movw	r30, r24
     ef8:	28 ea       	ldi	r18, 0xA8	; 168
     efa:	32 e0       	ldi	r19, 0x02	; 2
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     efc:	40 e9       	ldi	r20, 0x90	; 144
     efe:	51 e0       	ldi	r21, 0x01	; 1
     f00:	1d c0       	rjmp	.+58     	; 0xf3c <LCD_DATA_STRING+0x46>
     f02:	90 e0       	ldi	r25, 0x00	; 0
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     f04:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     f06:	87 ff       	sbrs	r24, 7
     f08:	02 c0       	rjmp	.+4      	; 0xf0e <LCD_DATA_STRING+0x18>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     f0a:	d8 9a       	sbi	0x1b, 0	; 27
     f0c:	01 c0       	rjmp	.+2      	; 0xf10 <LCD_DATA_STRING+0x1a>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     f0e:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     f10:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     f12:	9f 5f       	subi	r25, 0xFF	; 255
     f14:	98 30       	cpi	r25, 0x08	; 8
     f16:	11 f0       	breq	.+4      	; 0xf1c <LCD_DATA_STRING+0x26>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     f18:	88 0f       	add	r24, r24
     f1a:	f4 cf       	rjmp	.-24     	; 0xf04 <LCD_DATA_STRING+0xe>
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;
     f1c:	31 96       	adiw	r30, 0x01	; 1
			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     f1e:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     f20:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     f22:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     f24:	da 98       	cbi	0x1b, 2	; 27
     f26:	c9 01       	movw	r24, r18
     f28:	01 97       	sbiw	r24, 0x01	; 1
     f2a:	f1 f7       	brne	.-4      	; 0xf28 <LCD_DATA_STRING+0x32>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     f2c:	da 9a       	sbi	0x1b, 2	; 27
     f2e:	c9 01       	movw	r24, r18
     f30:	01 97       	sbiw	r24, 0x01	; 1
     f32:	f1 f7       	brne	.-4      	; 0xf30 <LCD_DATA_STRING+0x3a>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     f34:	db 98       	cbi	0x1b, 3	; 27
     f36:	ca 01       	movw	r24, r20
     f38:	01 97       	sbiw	r24, 0x01	; 1
     f3a:	f1 f7       	brne	.-4      	; 0xf38 <LCD_DATA_STRING+0x42>
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     f3c:	80 81       	ld	r24, Z
     f3e:	88 23       	and	r24, r24
     f40:	01 f7       	brne	.-64     	; 0xf02 <LCD_DATA_STRING+0xc>
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}
}
     f42:	08 95       	ret

00000f44 <LCD_CGRAM_CUSTOM_SYMBOLS>:
	 { 0x0E, 0x1B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F },	// Battery Charging  80%	// addr40-47
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
     f44:	cf 93       	push	r28
     f46:	df 93       	push	r29
	for(rows=0; rows<7; rows++)
     f48:	10 92 ac 07 	sts	0x07AC, r1
     f4c:	10 92 ab 07 	sts	0x07AB, r1
     f50:	25 c0       	rjmp	.+74     	; 0xf9c <LCD_CGRAM_CUSTOM_SYMBOLS+0x58>
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
     f52:	08 96       	adiw	r24, 0x08	; 8
     f54:	88 0f       	add	r24, r24
     f56:	88 0f       	add	r24, r24
     f58:	88 0f       	add	r24, r24
     f5a:	0e 94 c7 06 	call	0xd8e	; 0xd8e <LCD_EXECUTE_COMMAND>
     f5e:	c0 e0       	ldi	r28, 0x00	; 0
     f60:	d0 e0       	ldi	r29, 0x00	; 0
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
     f62:	e0 91 ab 07 	lds	r30, 0x07AB
     f66:	f0 91 ac 07 	lds	r31, 0x07AC
     f6a:	83 e0       	ldi	r24, 0x03	; 3
     f6c:	ee 0f       	add	r30, r30
     f6e:	ff 1f       	adc	r31, r31
     f70:	8a 95       	dec	r24
     f72:	e1 f7       	brne	.-8      	; 0xf6c <LCD_CGRAM_CUSTOM_SYMBOLS+0x28>
     f74:	ec 0f       	add	r30, r28
     f76:	fd 1f       	adc	r31, r29
     f78:	e8 5b       	subi	r30, 0xB8	; 184
     f7a:	f8 4f       	sbci	r31, 0xF8	; 248
     f7c:	80 81       	ld	r24, Z
     f7e:	0e 94 17 07 	call	0xe2e	; 0xe2e <LCD_EXECUTE_DATA_ONE>
void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
     f82:	21 96       	adiw	r28, 0x01	; 1
     f84:	c8 30       	cpi	r28, 0x08	; 8
     f86:	d1 05       	cpc	r29, r1
     f88:	61 f7       	brne	.-40     	; 0xf62 <LCD_CGRAM_CUSTOM_SYMBOLS+0x1e>
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
     f8a:	80 91 ab 07 	lds	r24, 0x07AB
     f8e:	90 91 ac 07 	lds	r25, 0x07AC
     f92:	01 96       	adiw	r24, 0x01	; 1
     f94:	90 93 ac 07 	sts	0x07AC, r25
     f98:	80 93 ab 07 	sts	0x07AB, r24
     f9c:	80 91 ab 07 	lds	r24, 0x07AB
     fa0:	90 91 ac 07 	lds	r25, 0x07AC
     fa4:	87 30       	cpi	r24, 0x07	; 7
     fa6:	91 05       	cpc	r25, r1
     fa8:	a4 f2       	brlt	.-88     	; 0xf52 <LCD_CGRAM_CUSTOM_SYMBOLS+0xe>
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
		}
	}
}
     faa:	df 91       	pop	r29
     fac:	cf 91       	pop	r28
     fae:	08 95       	ret

00000fb0 <LCD_DATA_ULONG>:
/****************************************************************
** WRITE/TRANSMIT MORE DATA UNSIGNED LONG BYTES TO LCD DISPLAY **
****************************************************************/
// USE THIS: lcdDataULong( (unsigned long)k + 1 );
void LCD_DATA_ULONG(unsigned long data)		// void lcdDataULong(const unsigned long data)
{
     fb0:	df 93       	push	r29
     fb2:	cf 93       	push	r28
     fb4:	cd b7       	in	r28, 0x3d	; 61
     fb6:	de b7       	in	r29, 0x3e	; 62
     fb8:	2a 97       	sbiw	r28, 0x0a	; 10
     fba:	0f b6       	in	r0, 0x3f	; 63
     fbc:	f8 94       	cli
     fbe:	de bf       	out	0x3e, r29	; 62
     fc0:	0f be       	out	0x3f, r0	; 63
     fc2:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ultoa(data, buffer, 10));	// 10 -> DECIMAL
     fc4:	ae 01       	movw	r20, r28
     fc6:	4f 5f       	subi	r20, 0xFF	; 255
     fc8:	5f 4f       	sbci	r21, 0xFF	; 255
     fca:	2a e0       	ldi	r18, 0x0A	; 10
     fcc:	30 e0       	ldi	r19, 0x00	; 0
     fce:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <ultoa>
     fd2:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
}
     fd6:	2a 96       	adiw	r28, 0x0a	; 10
     fd8:	0f b6       	in	r0, 0x3f	; 63
     fda:	f8 94       	cli
     fdc:	de bf       	out	0x3e, r29	; 62
     fde:	0f be       	out	0x3f, r0	; 63
     fe0:	cd bf       	out	0x3d, r28	; 61
     fe2:	cf 91       	pop	r28
     fe4:	df 91       	pop	r29
     fe6:	08 95       	ret

00000fe8 <LCD_DATA_LONG>:
/*******************************************************
** WRITE/TRANSMIT MORE DATA LONG BYTES TO LCD DISPLAY **
*******************************************************/
// USE THIS: lcdDataLong( (long)k + 1 );
void LCD_DATA_LONG(long data)		// void lcdDataLong(const long data)
{
     fe8:	df 93       	push	r29
     fea:	cf 93       	push	r28
     fec:	cd b7       	in	r28, 0x3d	; 61
     fee:	de b7       	in	r29, 0x3e	; 62
     ff0:	2a 97       	sbiw	r28, 0x0a	; 10
     ff2:	0f b6       	in	r0, 0x3f	; 63
     ff4:	f8 94       	cli
     ff6:	de bf       	out	0x3e, r29	; 62
     ff8:	0f be       	out	0x3f, r0	; 63
     ffa:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ltoa(data, buffer, 10));	// 10 -> DECIMAL
     ffc:	ae 01       	movw	r20, r28
     ffe:	4f 5f       	subi	r20, 0xFF	; 255
    1000:	5f 4f       	sbci	r21, 0xFF	; 255
    1002:	2a e0       	ldi	r18, 0x0A	; 10
    1004:	30 e0       	ldi	r19, 0x00	; 0
    1006:	0e 94 9e 0b 	call	0x173c	; 0x173c <ltoa>
    100a:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
}
    100e:	2a 96       	adiw	r28, 0x0a	; 10
    1010:	0f b6       	in	r0, 0x3f	; 63
    1012:	f8 94       	cli
    1014:	de bf       	out	0x3e, r29	; 62
    1016:	0f be       	out	0x3f, r0	; 63
    1018:	cd bf       	out	0x3d, r28	; 61
    101a:	cf 91       	pop	r28
    101c:	df 91       	pop	r29
    101e:	08 95       	ret

00001020 <LCD_DATA_INT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataInt( (int)k + 1 );
void LCD_DATA_INT(int data)		// void lcdDataInt(const int data)
{
    1020:	df 93       	push	r29
    1022:	cf 93       	push	r28
    1024:	cd b7       	in	r28, 0x3d	; 61
    1026:	de b7       	in	r29, 0x3e	; 62
    1028:	2a 97       	sbiw	r28, 0x0a	; 10
    102a:	0f b6       	in	r0, 0x3f	; 63
    102c:	f8 94       	cli
    102e:	de bf       	out	0x3e, r29	; 62
    1030:	0f be       	out	0x3f, r0	; 63
    1032:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(itoa(data, buffer, 10));	// 10 -> DECIMAL
    1034:	be 01       	movw	r22, r28
    1036:	6f 5f       	subi	r22, 0xFF	; 255
    1038:	7f 4f       	sbci	r23, 0xFF	; 255
    103a:	4a e0       	ldi	r20, 0x0A	; 10
    103c:	50 e0       	ldi	r21, 0x00	; 0
    103e:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <itoa>
    1042:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
}
    1046:	2a 96       	adiw	r28, 0x0a	; 10
    1048:	0f b6       	in	r0, 0x3f	; 63
    104a:	f8 94       	cli
    104c:	de bf       	out	0x3e, r29	; 62
    104e:	0f be       	out	0x3f, r0	; 63
    1050:	cd bf       	out	0x3d, r28	; 61
    1052:	cf 91       	pop	r28
    1054:	df 91       	pop	r29
    1056:	08 95       	ret

00001058 <LCD_DATA_UINT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataUInt( (unsigned int)k + 1 );
void LCD_DATA_UINT(unsigned int data)		// void lcdDataUInt(const unsigned int data)
{
    1058:	df 93       	push	r29
    105a:	cf 93       	push	r28
    105c:	cd b7       	in	r28, 0x3d	; 61
    105e:	de b7       	in	r29, 0x3e	; 62
    1060:	2a 97       	sbiw	r28, 0x0a	; 10
    1062:	0f b6       	in	r0, 0x3f	; 63
    1064:	f8 94       	cli
    1066:	de bf       	out	0x3e, r29	; 62
    1068:	0f be       	out	0x3f, r0	; 63
    106a:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(utoa(data, buffer, 10));	// 10 -> DECIMAL
    106c:	be 01       	movw	r22, r28
    106e:	6f 5f       	subi	r22, 0xFF	; 255
    1070:	7f 4f       	sbci	r23, 0xFF	; 255
    1072:	4a e0       	ldi	r20, 0x0A	; 10
    1074:	50 e0       	ldi	r21, 0x00	; 0
    1076:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <utoa>
    107a:	0e 94 7b 07 	call	0xef6	; 0xef6 <LCD_DATA_STRING>
}
    107e:	2a 96       	adiw	r28, 0x0a	; 10
    1080:	0f b6       	in	r0, 0x3f	; 63
    1082:	f8 94       	cli
    1084:	de bf       	out	0x3e, r29	; 62
    1086:	0f be       	out	0x3f, r0	; 63
    1088:	cd bf       	out	0x3d, r28	; 61
    108a:	cf 91       	pop	r28
    108c:	df 91       	pop	r29
    108e:	08 95       	ret

00001090 <PGA2310_Volume_Update>:

/*************************************
** DEFINITION PGA2310 VOLUME UPDATE **
*************************************/
void PGA2310_Volume_Update(unsigned char pgaVolumeLeft, unsigned char pgaVolumeRight)
{
    1090:	0f 93       	push	r16
    1092:	1f 93       	push	r17
    1094:	18 2f       	mov	r17, r24
    1096:	06 2f       	mov	r16, r22
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    1098:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    109a:	0e 94 4c 09 	call	0x1298	; 0x1298 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    109e:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    10a0:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    10a2:	81 2f       	mov	r24, r17
    10a4:	60 2f       	mov	r22, r16
    10a6:	0e 94 4c 09 	call	0x1298	; 0x1298 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    10aa:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA7 - /SS ENABLE
    10ac:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    10ae:	81 2f       	mov	r24, r17
    10b0:	60 2f       	mov	r22, r16
    10b2:	0e 94 4c 09 	call	0x1298	; 0x1298 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    10b6:	df 9a       	sbi	0x1b, 7	; 27

//	return SUCCESS;
}
    10b8:	1f 91       	pop	r17
    10ba:	0f 91       	pop	r16
    10bc:	08 95       	ret

000010be <pga2310_init>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_init()
{
	spi_init();
    10be:	0e 94 3b 09 	call	0x1276	; 0x1276 <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    10c2:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    10c4:	80 e0       	ldi	r24, 0x00	; 0
    10c6:	60 e0       	ldi	r22, 0x00	; 0
    10c8:	0e 94 4c 09 	call	0x1298	; 0x1298 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    10cc:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    10ce:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    10d0:	80 e0       	ldi	r24, 0x00	; 0
    10d2:	60 e0       	ldi	r22, 0x00	; 0
    10d4:	0e 94 4c 09 	call	0x1298	; 0x1298 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    10d8:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    10da:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    10dc:	80 e0       	ldi	r24, 0x00	; 0
    10de:	60 e0       	ldi	r22, 0x00	; 0
    10e0:	0e 94 4c 09 	call	0x1298	; 0x1298 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    10e4:	df 9a       	sbi	0x1b, 7	; 27
}
    10e6:	08 95       	ret

000010e8 <pga2310_reset>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_reset()
{
	spi_init();
    10e8:	0e 94 3b 09 	call	0x1276	; 0x1276 <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    10ec:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    10ee:	80 e0       	ldi	r24, 0x00	; 0
    10f0:	60 e0       	ldi	r22, 0x00	; 0
    10f2:	0e 94 4c 09 	call	0x1298	; 0x1298 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    10f6:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    10f8:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    10fa:	80 e0       	ldi	r24, 0x00	; 0
    10fc:	60 e0       	ldi	r22, 0x00	; 0
    10fe:	0e 94 4c 09 	call	0x1298	; 0x1298 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    1102:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1104:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1106:	80 e0       	ldi	r24, 0x00	; 0
    1108:	60 e0       	ldi	r22, 0x00	; 0
    110a:	0e 94 4c 09 	call	0x1298	; 0x1298 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    110e:	df 9a       	sbi	0x1b, 7	; 27
}
    1110:	08 95       	ret

00001112 <uart_transmit>:

/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
    1112:	ac 01       	movw	r20, r24
    1114:	20 e0       	ldi	r18, 0x00	; 0
    1116:	30 e0       	ldi	r19, 0x00	; 0
    1118:	09 c0       	rjmp	.+18     	; 0x112c <uart_transmit+0x1a>
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		//UDR = uart_data[count_ns];
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    111a:	5d 9b       	sbis	0x0b, 5	; 11
    111c:	fe cf       	rjmp	.-4      	; 0x111a <uart_transmit+0x8>
		{
		}
		UDR = uart_data[count_ns];
    111e:	fa 01       	movw	r30, r20
    1120:	e2 0f       	add	r30, r18
    1122:	f3 1f       	adc	r31, r19
    1124:	80 81       	ld	r24, Z
    1126:	8c b9       	out	0x0c, r24	; 12
/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
    1128:	2f 5f       	subi	r18, 0xFF	; 255
    112a:	3f 4f       	sbci	r19, 0xFF	; 255
    112c:	26 17       	cp	r18, r22
    112e:	37 07       	cpc	r19, r23
    1130:	a4 f3       	brlt	.-24     	; 0x111a <uart_transmit+0x8>
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
		{
		}
		UDR = uart_data[count_ns];
	}
}
    1132:	08 95       	ret

00001134 <uart_transmit_one>:
/***************************************
** TRANSMIT/SEND 1 BYTE OF UART/USART **
***************************************/
void uart_transmit_one(unsigned char uart_data)
{
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    1134:	5d 9b       	sbis	0x0b, 5	; 11
    1136:	fe cf       	rjmp	.-4      	; 0x1134 <uart_transmit_one>
	{
	}
	UDR = uart_data;
    1138:	8c b9       	out	0x0c, r24	; 12
}
    113a:	08 95       	ret

0000113c <uart_transmit_DEC_to_BCD>:

/*****************************************************************		// NOT FINISHED
** TRANSMIT/SEND 1 BYTE CONVERTED FROM DEC TO BCD OF UART/USART **		// NOT FINISHED
*****************************************************************/		// NOT FINISHED
void uart_transmit_DEC_to_BCD(unsigned char dec_to_bcd_data)
{// pravi se preobrazuvane ot DEC to BCD i preobrazuvane za izvejdane na parviq simvol s filtar
    113c:	98 2f       	mov	r25, r24
	
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    113e:	5d 9b       	sbis	0x0b, 5	; 11
    1140:	fe cf       	rjmp	.-4      	; 0x113e <uart_transmit_DEC_to_BCD+0x2>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data>>4));
    1142:	89 2f       	mov	r24, r25
    1144:	82 95       	swap	r24
    1146:	8f 70       	andi	r24, 0x0F	; 15
    1148:	80 5d       	subi	r24, 0xD0	; 208
    114a:	8c b9       	out	0x0c, r24	; 12

	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    114c:	5d 9b       	sbis	0x0b, 5	; 11
    114e:	fe cf       	rjmp	.-4      	; 0x114c <uart_transmit_DEC_to_BCD+0x10>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data & 0x0F));
    1150:	9f 70       	andi	r25, 0x0F	; 15
    1152:	90 5d       	subi	r25, 0xD0	; 208
    1154:	9c b9       	out	0x0c, r25	; 12
	byte bcdToDec(byte val)
	{
  		return ( (val/16*10) + (val%16) );
	}
*/
}
    1156:	08 95       	ret

00001158 <transmitUart>:
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
    1158:	5d 9b       	sbis	0x0b, 5	; 11
    115a:	fe cf       	rjmp	.-4      	; 0x1158 <transmitUart>
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
    115c:	8c b9       	out	0x0c, r24	; 12
}
    115e:	08 95       	ret

00001160 <transmitUartString>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
    1160:	fc 01       	movw	r30, r24
    1162:	04 c0       	rjmp	.+8      	; 0x116c <transmitUartString+0xc>
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
    1164:	5d 9b       	sbis	0x0b, 5	; 11
    1166:	fe cf       	rjmp	.-4      	; 0x1164 <transmitUartString+0x4>
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
	{
		transmitUart(*data++);
    1168:	31 96       	adiw	r30, 0x01	; 1
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
    116a:	8c b9       	out	0x0c, r24	; 12
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
    116c:	80 81       	ld	r24, Z
    116e:	88 23       	and	r24, r24
    1170:	c9 f7       	brne	.-14     	; 0x1164 <transmitUartString+0x4>
	{
		transmitUart(*data++);
	}
}
    1172:	08 95       	ret

00001174 <uart_init>:
{
	switch(F_CPU)
	{
		case 16000000UL:
		{
			UBRRL = 103;	// Baudrate: 9600; (Error = 0.2%; 16MHz)
    1174:	87 e6       	ldi	r24, 0x67	; 103
    1176:	89 b9       	out	0x09, r24	; 9
			UBRRH = 0;
    1178:	10 bc       	out	0x20, r1	; 32
	LCD_DATA_STRING(" MHz");		// 20 symbols
#endif
	// Razpoznavane na baudrate (skorost): 1. Izprashta se byte. 2. Poluchava se byte. 3. Sravnqva se polucheniq byte == izprateniq byte. // This is LOOP TX->RX
	// 4. Ako byte pri sravnqvaneto e edin i sasht to skorostta e izbranata v momenta, ako byte e razlichen - da se probva sas sledvashta baudrate.

	UCSRC = 0b10000110;		// URSEL = 1 (Accessing to UBRRH or UCSRC, is read as zero when reading UBRRH. The URSEL must be zero when writing the UBRRH.); UMSEL = 0 (Asynchronous Operation); UPM1 = 0, UPM0 = 0 (Parity Mode Disabled); USBS = 0 (1-Stop Bit); UCSZ2 = 0, UCSZ1 = 1, UCSZ0 = 1 (8-DataBits); UCPOL = 0 Polarity TX & RX (Rising XCK Edge -> Transmitted Data Changed (Output of TxDPin), Falling XCK Edge -> Received Data Sampled (Input on RxDPin))
    117a:	86 e8       	ldi	r24, 0x86	; 134
    117c:	80 bd       	out	0x20, r24	; 32
	UCSRB = 0b00001000;		// Enable only TXEN	- Transmitting Uart/Usart	// UCSRB = 0b10011000;		// Enable TXEN,RXEN,RXCIE	Transmitting and Receiving Uart/Usart
    117e:	88 e0       	ldi	r24, 0x08	; 8
    1180:	8a b9       	out	0x0a, r24	; 10
	UDR = 0b00000000;		// INITIALIZATION NULL OF UART DATA
    1182:	1c b8       	out	0x0c, r1	; 12

#ifdef DEBUG_INFO
	transmitUartString("\r\n");
    1184:	80 e8       	ldi	r24, 0x80	; 128
    1186:	97 e0       	ldi	r25, 0x07	; 7
    1188:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
#endif
#if DEBUG_SETTING
	transmitUartString("[UART INFO] Serial Port Settings - Baud rate: 9600, Data bits: 8 bits, Stop bits: 1 bit, Parity: None, Flow control: None or XON/XOFF\r\n");
#endif
}
    118c:	08 95       	ret

0000118e <receiveUart>:
/**************************************************		// NOT FINISHED
** RECEIVE/READ unsigned char BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
unsigned char receiveUart(void)
{
	while (!(UCSRA & (1<<RXC)))
    118e:	5f 9b       	sbis	0x0b, 7	; 11
    1190:	fe cf       	rjmp	.-4      	; 0x118e <receiveUart>
	{};							/* Wait for data to be received */
	return UDR;					/* Get and return received data from buffer */
    1192:	8c b1       	in	r24, 0x0c	; 12
}
    1194:	08 95       	ret

00001196 <transmitUartLong>:
/******************************************		// NOT FINISHED
** TRANSMIT/SEND long BYTE OF UART/USART **		// NOT FINISHED
******************************************/		// NOT FINISHED
// USE THIS: transmitUartLong( (long)k + 1 );
void transmitUartLong(long data)		// void transmitUartLong(const long data)
{
    1196:	df 93       	push	r29
    1198:	cf 93       	push	r28
    119a:	cd b7       	in	r28, 0x3d	; 61
    119c:	de b7       	in	r29, 0x3e	; 62
    119e:	2a 97       	sbiw	r28, 0x0a	; 10
    11a0:	0f b6       	in	r0, 0x3f	; 63
    11a2:	f8 94       	cli
    11a4:	de bf       	out	0x3e, r29	; 62
    11a6:	0f be       	out	0x3f, r0	; 63
    11a8:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ltoa(data, buffer, 10));		// 10 -> DECIMAL
    11aa:	ae 01       	movw	r20, r28
    11ac:	4f 5f       	subi	r20, 0xFF	; 255
    11ae:	5f 4f       	sbci	r21, 0xFF	; 255
    11b0:	2a e0       	ldi	r18, 0x0A	; 10
    11b2:	30 e0       	ldi	r19, 0x00	; 0
    11b4:	0e 94 9e 0b 	call	0x173c	; 0x173c <ltoa>
    11b8:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
}
    11bc:	2a 96       	adiw	r28, 0x0a	; 10
    11be:	0f b6       	in	r0, 0x3f	; 63
    11c0:	f8 94       	cli
    11c2:	de bf       	out	0x3e, r29	; 62
    11c4:	0f be       	out	0x3f, r0	; 63
    11c6:	cd bf       	out	0x3d, r28	; 61
    11c8:	cf 91       	pop	r28
    11ca:	df 91       	pop	r29
    11cc:	08 95       	ret

000011ce <transmitUartULong>:
/***************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned long BYTE OF UART/USART **		// NOT FINISHED
***************************************************/		// NOT FINISHED
// USE THIS: transmitUartULong( (unsigned long)k + 1 );
void transmitUartULong(unsigned long data)		// void transmitUartULong(const unsigned long data)
{
    11ce:	df 93       	push	r29
    11d0:	cf 93       	push	r28
    11d2:	cd b7       	in	r28, 0x3d	; 61
    11d4:	de b7       	in	r29, 0x3e	; 62
    11d6:	2a 97       	sbiw	r28, 0x0a	; 10
    11d8:	0f b6       	in	r0, 0x3f	; 63
    11da:	f8 94       	cli
    11dc:	de bf       	out	0x3e, r29	; 62
    11de:	0f be       	out	0x3f, r0	; 63
    11e0:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ultoa(data, buffer, 10));		// 10 -> DECIMAL
    11e2:	ae 01       	movw	r20, r28
    11e4:	4f 5f       	subi	r20, 0xFF	; 255
    11e6:	5f 4f       	sbci	r21, 0xFF	; 255
    11e8:	2a e0       	ldi	r18, 0x0A	; 10
    11ea:	30 e0       	ldi	r19, 0x00	; 0
    11ec:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <ultoa>
    11f0:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
}
    11f4:	2a 96       	adiw	r28, 0x0a	; 10
    11f6:	0f b6       	in	r0, 0x3f	; 63
    11f8:	f8 94       	cli
    11fa:	de bf       	out	0x3e, r29	; 62
    11fc:	0f be       	out	0x3f, r0	; 63
    11fe:	cd bf       	out	0x3d, r28	; 61
    1200:	cf 91       	pop	r28
    1202:	df 91       	pop	r29
    1204:	08 95       	ret

00001206 <transmitUartInt>:
/*****************************************		// NOT FINISHED
** TRANSMIT/SEND int BYTE OF UART/USART **		// NOT FINISHED
*****************************************/		// NOT FINISHED
// USE THIS: transmitUartInt( (int)k + 1 );
void transmitUartInt(int data)		// void transmitUartInt(const int data)
{
    1206:	df 93       	push	r29
    1208:	cf 93       	push	r28
    120a:	cd b7       	in	r28, 0x3d	; 61
    120c:	de b7       	in	r29, 0x3e	; 62
    120e:	2a 97       	sbiw	r28, 0x0a	; 10
    1210:	0f b6       	in	r0, 0x3f	; 63
    1212:	f8 94       	cli
    1214:	de bf       	out	0x3e, r29	; 62
    1216:	0f be       	out	0x3f, r0	; 63
    1218:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(itoa(data, buffer, 10));		// 10 -> DECIMAL
    121a:	be 01       	movw	r22, r28
    121c:	6f 5f       	subi	r22, 0xFF	; 255
    121e:	7f 4f       	sbci	r23, 0xFF	; 255
    1220:	4a e0       	ldi	r20, 0x0A	; 10
    1222:	50 e0       	ldi	r21, 0x00	; 0
    1224:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <itoa>
    1228:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
}
    122c:	2a 96       	adiw	r28, 0x0a	; 10
    122e:	0f b6       	in	r0, 0x3f	; 63
    1230:	f8 94       	cli
    1232:	de bf       	out	0x3e, r29	; 62
    1234:	0f be       	out	0x3f, r0	; 63
    1236:	cd bf       	out	0x3d, r28	; 61
    1238:	cf 91       	pop	r28
    123a:	df 91       	pop	r29
    123c:	08 95       	ret

0000123e <transmitUartUInt>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned int BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: transmitUartUInt( (unsigned int)k + 1 );
void transmitUartUInt(unsigned int data)		// void transmitUartUInt(const unsigned int data)
{
    123e:	df 93       	push	r29
    1240:	cf 93       	push	r28
    1242:	cd b7       	in	r28, 0x3d	; 61
    1244:	de b7       	in	r29, 0x3e	; 62
    1246:	2a 97       	sbiw	r28, 0x0a	; 10
    1248:	0f b6       	in	r0, 0x3f	; 63
    124a:	f8 94       	cli
    124c:	de bf       	out	0x3e, r29	; 62
    124e:	0f be       	out	0x3f, r0	; 63
    1250:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(utoa(data, buffer, 10));		// 10 -> DECIMAL
    1252:	be 01       	movw	r22, r28
    1254:	6f 5f       	subi	r22, 0xFF	; 255
    1256:	7f 4f       	sbci	r23, 0xFF	; 255
    1258:	4a e0       	ldi	r20, 0x0A	; 10
    125a:	50 e0       	ldi	r21, 0x00	; 0
    125c:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <utoa>
    1260:	0e 94 b0 08 	call	0x1160	; 0x1160 <transmitUartString>
}
    1264:	2a 96       	adiw	r28, 0x0a	; 10
    1266:	0f b6       	in	r0, 0x3f	; 63
    1268:	f8 94       	cli
    126a:	de bf       	out	0x3e, r29	; 62
    126c:	0f be       	out	0x3f, r0	; 63
    126e:	cd bf       	out	0x3d, r28	; 61
    1270:	cf 91       	pop	r28
    1272:	df 91       	pop	r29
    1274:	08 95       	ret

00001276 <spi_init>:
/**************************
** INITIZLIZATION OF SPI **
***************************/
void spi_init()
{
	SPSR = (0<<SPIF)|(0<<WCOL)|(0<<SPI2X);
    1276:	1e b8       	out	0x0e, r1	; 14
//	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);			//0b01010010	// SPR1   = 1 - 16 000 000 / 64  = 250 000 = 250kHz  // KOMENTAR ZARADI SIMULACIQTA - PROTEUS BLOKIRANE ZARADI BIT V REGISTAR
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz	 // KAKVA KOMBINACIQ OT 4-te BITa VODI DO RAZBLOKIRANETO ???
    1278:	83 e5       	ldi	r24, 0x53	; 83
    127a:	8d b9       	out	0x0d, r24	; 13
	SPDR = 0b00000000;
    127c:	1f b8       	out	0x0f, r1	; 15

	PGA2310_U8_SPI_CS_high();	// /SS - DISABLE
	PGA2310_U8_SPI(0b00000000, 0b00000000);
	*/

	SPCR = (0<<SPE);
    127e:	1d b8       	out	0x0d, r1	; 13
}
    1280:	08 95       	ret

00001282 <spi_start>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1282:	83 e5       	ldi	r24, 0x53	; 83
    1284:	8d b9       	out	0x0d, r24	; 13
}
    1286:	08 95       	ret

00001288 <spi_stop>:
/**************************************
** DEFINITION SPI FUNCTION STOP ONLY **
**************************************/
void spi_stop()
{
	SPCR = (0<<SPE);
    1288:	1d b8       	out	0x0d, r1	; 13
}
    128a:	08 95       	ret

0000128c <spi_write_one_byte>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    128c:	93 e5       	ldi	r25, 0x53	; 83
    128e:	9d b9       	out	0x0d, r25	; 13
void spi_write_one_byte(unsigned char data)	// void PGA2310_U7_SPI(byte volume_left, byte volume_right)	//PGA2310_U7_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data;				//volume_right;
    1290:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    1292:	77 9b       	sbis	0x0e, 7	; 14
    1294:	fe cf       	rjmp	.-4      	; 0x1292 <spi_write_one_byte+0x6>
	{
	}
}
    1296:	08 95       	ret

00001298 <spi_write_two_bytes>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1298:	93 e5       	ldi	r25, 0x53	; 83
    129a:	9d b9       	out	0x0d, r25	; 13
void spi_write_two_bytes(unsigned char data1, unsigned char data2)	// void PGA2310_U6_SPI(byte volume_left, byte volume_right)	//PGA2310_U6_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data1;				//volume_left;
    129c:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    129e:	77 9b       	sbis	0x0e, 7	; 14
    12a0:	fe cf       	rjmp	.-4      	; 0x129e <spi_write_two_bytes+0x6>
	{
	}

//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data2;				//volume_right;
    12a2:	6f b9       	out	0x0f, r22	; 15
	while(!(SPSR & (1<<SPIF)))
    12a4:	77 9b       	sbis	0x0e, 7	; 14
    12a6:	fe cf       	rjmp	.-4      	; 0x12a4 <spi_write_two_bytes+0xc>
	{
	}
}
    12a8:	08 95       	ret

000012aa <spi_write_more_bytes>:

/*********************************************
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
    12aa:	fc 01       	movw	r30, r24
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    12ac:	93 e5       	ldi	r25, 0x53	; 83
    12ae:	06 c0       	rjmp	.+12     	; 0x12bc <spi_write_more_bytes+0x12>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    12b0:	31 96       	adiw	r30, 0x01	; 1
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    12b2:	9d b9       	out	0x0d, r25	; 13
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
	{
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
		spi_start();
		SPDR = *data;			//volume_left;
    12b4:	80 81       	ld	r24, Z
    12b6:	8f b9       	out	0x0f, r24	; 15
		while(!(SPSR & (1<<SPIF)))
    12b8:	77 9b       	sbis	0x0e, 7	; 14
    12ba:	fe cf       	rjmp	.-4      	; 0x12b8 <spi_write_more_bytes+0xe>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    12bc:	80 81       	ld	r24, Z
    12be:	88 23       	and	r24, r24
    12c0:	b9 f7       	brne	.-18     	; 0x12b0 <spi_write_more_bytes+0x6>
		SPDR = *data;			//volume_left;
		while(!(SPSR & (1<<SPIF)))
		{
		}
	}
}
    12c2:	08 95       	ret

000012c4 <spi_read_more_bytes>:
unsigned char spi_read_more_bytes()	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
	unsigned char data = 0b00000000;
	//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data;			//volume_left;
    12c4:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF)))
    12c6:	77 9b       	sbis	0x0e, 7	; 14
    12c8:	fe cf       	rjmp	.-4      	; 0x12c6 <spi_read_more_bytes+0x2>
	{
	}
	return data;
}
    12ca:	80 e0       	ldi	r24, 0x00	; 0
    12cc:	08 95       	ret

000012ce <decToBcd>:

/**************************************************************
**** CONVERT NORMAL DECIMAL NUMBERS TO BINARY CODED DECIMAL ***
**************************************************************/
unsigned char decToBcd(unsigned char val)
{
    12ce:	48 2f       	mov	r20, r24
    12d0:	6a e0       	ldi	r22, 0x0A	; 10
    12d2:	0e 94 4a 0b 	call	0x1694	; 0x1694 <__udivmodqi4>
    12d6:	28 2f       	mov	r18, r24
    12d8:	30 e0       	ldi	r19, 0x00	; 0
    12da:	84 e0       	ldi	r24, 0x04	; 4
    12dc:	22 0f       	add	r18, r18
    12de:	33 1f       	adc	r19, r19
    12e0:	8a 95       	dec	r24
    12e2:	e1 f7       	brne	.-8      	; 0x12dc <decToBcd+0xe>
    12e4:	84 2f       	mov	r24, r20
    12e6:	0e 94 4a 0b 	call	0x1694	; 0x1694 <__udivmodqi4>
	return ( (val/10*16) + (val%10) );	// Get DEC format -> convert DEC to HEX
}
    12ea:	89 2f       	mov	r24, r25
    12ec:	82 0f       	add	r24, r18
    12ee:	08 95       	ret

000012f0 <bcdToDec>:

/**************************************************************
**** CONVERT BINARY CODED DECIMAL TO NORMAL DECIMAL NUMBERS ***
**************************************************************/
unsigned char bcdToDec(unsigned char val)
{
    12f0:	28 2f       	mov	r18, r24
    12f2:	22 95       	swap	r18
    12f4:	2f 70       	andi	r18, 0x0F	; 15
    12f6:	9a e0       	ldi	r25, 0x0A	; 10
    12f8:	29 9f       	mul	r18, r25
    12fa:	90 01       	movw	r18, r0
    12fc:	11 24       	eor	r1, r1
    12fe:	8f 70       	andi	r24, 0x0F	; 15
	return ( (val/16*10) + (val%16) );	// Get HEX format -> convert HEX to DEC
}
    1300:	82 0f       	add	r24, r18
    1302:	08 95       	ret

00001304 <shiftRightOutLsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    1304:	a0 9a       	sbi	0x14, 0	; 20
    1306:	94 e4       	ldi	r25, 0x44	; 68
    1308:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regALSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    130a:	90 ff       	sbrs	r25, 0
    130c:	02 c0       	rjmp	.+4      	; 0x1312 <shiftRightOutLsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v LSB
    130e:	a8 9a       	sbi	0x15, 0	; 21
    1310:	01 c0       	rjmp	.+2      	; 0x1314 <shiftRightOutLsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
    1312:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1314:	8f 5f       	subi	r24, 0xFF	; 255
    1316:	88 30       	cpi	r24, 0x08	; 8
    1318:	11 f0       	breq	.+4      	; 0x131e <shiftRightOutLsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
		}
		
		regALSB = regALSB >> 1;	// shiftvane na >> nadqsno
    131a:	96 95       	lsr	r25
    131c:	f6 cf       	rjmp	.-20     	; 0x130a <shiftRightOutLsbFirst+0x6>
    131e:	08 95       	ret

00001320 <shiftLeftOutMsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    1320:	a0 9a       	sbi	0x14, 0	; 20
    1322:	94 e4       	ldi	r25, 0x44	; 68
    1324:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regAMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
    1326:	97 ff       	sbrs	r25, 7
    1328:	02 c0       	rjmp	.+4      	; 0x132e <shiftLeftOutMsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v MSB
    132a:	a8 9a       	sbi	0x15, 0	; 21
    132c:	01 c0       	rjmp	.+2      	; 0x1330 <shiftLeftOutMsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
    132e:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1330:	8f 5f       	subi	r24, 0xFF	; 255
    1332:	88 30       	cpi	r24, 0x08	; 8
    1334:	11 f0       	breq	.+4      	; 0x133a <shiftLeftOutMsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
		}
		
		regAMSB = regAMSB << 1;	// shiftvane na << nalqvo
    1336:	99 0f       	add	r25, r25
    1338:	f6 cf       	rjmp	.-20     	; 0x1326 <shiftLeftOutMsbFirst+0x6>
    133a:	08 95       	ret

0000133c <shiftRightInLsbFirst>:
void shiftRightInLsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    133c:	a0 98       	cbi	0x14, 0	; 20
    133e:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
    1340:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1342:	8f 5f       	subi	r24, 0xFF	; 255
    1344:	88 30       	cpi	r24, 0x08	; 8
    1346:	e1 f7       	brne	.-8      	; 0x1340 <shiftRightInLsbFirst+0x4>
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
	}

}
    1348:	08 95       	ret

0000134a <shiftLeftInMsbFirst>:
void shiftLeftInMsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    134a:	a0 98       	cbi	0x14, 0	; 20
    134c:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
    134e:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1350:	8f 5f       	subi	r24, 0xFF	; 255
    1352:	88 30       	cpi	r24, 0x08	; 8
    1354:	e1 f7       	brne	.-8      	; 0x134e <shiftLeftInMsbFirst+0x4>
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
	}

}
    1356:	08 95       	ret

00001358 <delay_ms>:

/*************************************************************
*********** FUNCTION SOFTWARE DELAY IN MILISECONDS ***********
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
    1358:	40 e0       	ldi	r20, 0x00	; 0
    135a:	50 e0       	ldi	r21, 0x00	; 0
    135c:	0b c0       	rjmp	.+22     	; 0x1374 <delay_ms+0x1c>
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    135e:	20 e0       	ldi	r18, 0x00	; 0
    1360:	30 e0       	ldi	r19, 0x00	; 0
	{
		for(j=0;j<100;j++)
		{
		  asm("nop");
    1362:	00 00       	nop
		  asm("nop");
    1364:	00 00       	nop
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
	{
		for(j=0;j<100;j++)
    1366:	2f 5f       	subi	r18, 0xFF	; 255
    1368:	3f 4f       	sbci	r19, 0xFF	; 255
    136a:	24 36       	cpi	r18, 0x64	; 100
    136c:	31 05       	cpc	r19, r1
    136e:	c9 f7       	brne	.-14     	; 0x1362 <delay_ms+0xa>
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1370:	4f 5f       	subi	r20, 0xFF	; 255
    1372:	5f 4f       	sbci	r21, 0xFF	; 255
    1374:	48 17       	cp	r20, r24
    1376:	59 07       	cpc	r21, r25
    1378:	94 f3       	brlt	.-28     	; 0x135e <delay_ms+0x6>
		{
		  asm("nop");
		  asm("nop");
		}
	}
}
    137a:	08 95       	ret

0000137c <rotaryEncoderNikBarzakov>:
** READ/SCAN ROTARY ENCODER OF NIK BARZAKOV **
*********************************************/
char rotaryEncoderNikBarzakov()
{
	char tempEncoder = 0;
	if((ENCODER_A_low()) && (ENCODER_B_low()))			// A0, B0
    137c:	9d 99       	sbic	0x13, 5	; 19
    137e:	0e c0       	rjmp	.+28     	; 0x139c <rotaryEncoderNikBarzakov+0x20>
    1380:	9c 99       	sbic	0x13, 4	; 19
    1382:	0c c0       	rjmp	.+24     	; 0x139c <rotaryEncoderNikBarzakov+0x20>
    1384:	88 ec       	ldi	r24, 0xC8	; 200
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	01 97       	sbiw	r24, 0x01	; 1
    138a:	f1 f7       	brne	.-4      	; 0x1388 <rotaryEncoderNikBarzakov+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_high()) && (ENCODER_B_low()))		// A1, B0
    138c:	9d 9b       	sbis	0x13, 5	; 19
    138e:	14 c0       	rjmp	.+40     	; 0x13b8 <rotaryEncoderNikBarzakov+0x3c>
    1390:	83 b3       	in	r24, 0x13	; 19
    1392:	82 95       	swap	r24
    1394:	8f 70       	andi	r24, 0x0F	; 15
    1396:	80 95       	com	r24
    1398:	81 70       	andi	r24, 0x01	; 1
    139a:	08 95       	ret
// VOLUME UP
			tempEncoder = 1;	//	tempEncoder++;
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}
	}
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    139c:	9d 9b       	sbis	0x13, 5	; 19
    139e:	0c c0       	rjmp	.+24     	; 0x13b8 <rotaryEncoderNikBarzakov+0x3c>
    13a0:	9c 99       	sbic	0x13, 4	; 19
    13a2:	0a c0       	rjmp	.+20     	; 0x13b8 <rotaryEncoderNikBarzakov+0x3c>
    13a4:	88 ec       	ldi	r24, 0xC8	; 200
    13a6:	90 e0       	ldi	r25, 0x00	; 0
    13a8:	01 97       	sbiw	r24, 0x01	; 1
    13aa:	f1 f7       	brne	.-4      	; 0x13a8 <rotaryEncoderNikBarzakov+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    13ac:	9d 99       	sbic	0x13, 5	; 19
    13ae:	04 c0       	rjmp	.+8      	; 0x13b8 <rotaryEncoderNikBarzakov+0x3c>
    13b0:	9c 99       	sbic	0x13, 4	; 19
    13b2:	02 c0       	rjmp	.+4      	; 0x13b8 <rotaryEncoderNikBarzakov+0x3c>
    13b4:	8f ef       	ldi	r24, 0xFF	; 255
    13b6:	08 95       	ret
    13b8:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    13ba:	08 95       	ret

000013bc <rotaryEncoderVer1>:
** READ/SCAN ROTARY ENCODER VERSION 1 / MODEL 1 **
*************************************************/
char rotaryEncoderVer1()	// Check imediate now bits in PIN register.
{
	char tempEncoder = 0;							// A1, B1
	if((ENCODER_A_low()) && (ENCODER_B_high()))			// A0, B1
    13bc:	9d 99       	sbic	0x13, 5	; 19
    13be:	0e c0       	rjmp	.+28     	; 0x13dc <rotaryEncoderVer1+0x20>
    13c0:	9c 9b       	sbis	0x13, 4	; 19
    13c2:	0c c0       	rjmp	.+24     	; 0x13dc <rotaryEncoderVer1+0x20>
    13c4:	88 ec       	ldi	r24, 0xC8	; 200
    13c6:	90 e0       	ldi	r25, 0x00	; 0
    13c8:	01 97       	sbiw	r24, 0x01	; 1
    13ca:	f1 f7       	brne	.-4      	; 0x13c8 <rotaryEncoderVer1+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    13cc:	9d 99       	sbic	0x13, 5	; 19
    13ce:	14 c0       	rjmp	.+40     	; 0x13f8 <rotaryEncoderVer1+0x3c>
    13d0:	83 b3       	in	r24, 0x13	; 19
    13d2:	82 95       	swap	r24
    13d4:	8f 70       	andi	r24, 0x0F	; 15
    13d6:	80 95       	com	r24
    13d8:	81 70       	andi	r24, 0x01	; 1
    13da:	08 95       	ret
//			PORTD = volumeMassive[volumeIndex];
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}

	}													// A1. B1
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    13dc:	9d 9b       	sbis	0x13, 5	; 19
    13de:	0c c0       	rjmp	.+24     	; 0x13f8 <rotaryEncoderVer1+0x3c>
    13e0:	9c 99       	sbic	0x13, 4	; 19
    13e2:	0a c0       	rjmp	.+20     	; 0x13f8 <rotaryEncoderVer1+0x3c>
    13e4:	88 ec       	ldi	r24, 0xC8	; 200
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	01 97       	sbiw	r24, 0x01	; 1
    13ea:	f1 f7       	brne	.-4      	; 0x13e8 <rotaryEncoderVer1+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    13ec:	9d 99       	sbic	0x13, 5	; 19
    13ee:	04 c0       	rjmp	.+8      	; 0x13f8 <rotaryEncoderVer1+0x3c>
    13f0:	9c 99       	sbic	0x13, 4	; 19
    13f2:	02 c0       	rjmp	.+4      	; 0x13f8 <rotaryEncoderVer1+0x3c>
    13f4:	8f ef       	ldi	r24, 0xFF	; 255
    13f6:	08 95       	ret
    13f8:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    13fa:	08 95       	ret

000013fc <rotaryEncoderVer2>:
    13fc:	88 ec       	ldi	r24, 0xC8	; 200
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	fc 01       	movw	r30, r24
    1402:	31 97       	sbiw	r30, 0x01	; 1
    1404:	f1 f7       	brne	.-4      	; 0x1402 <rotaryEncoderVer2+0x6>
    1406:	fc 01       	movw	r30, r24
    1408:	31 97       	sbiw	r30, 0x01	; 1
    140a:	f1 f7       	brne	.-4      	; 0x1408 <rotaryEncoderVer2+0xc>
    140c:	01 97       	sbiw	r24, 0x01	; 1
    140e:	f1 f7       	brne	.-4      	; 0x140c <rotaryEncoderVer2+0x10>
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    1410:	80 e0       	ldi	r24, 0x00	; 0
    1412:	08 95       	ret

00001414 <RELAYS_IN_INIT>:
/*********************************************
** INITIZLIZATION OF SHIFT REGISTER 74HC595 **
*********************************************/
void RELAYS_IN_INIT()
{
}
    1414:	08 95       	ret

00001416 <RELAYS_OUT_INIT>:

void RELAYS_OUT_INIT()
{
}
    1416:	08 95       	ret

00001418 <RELAYS_IN_CHOOSE>:

/****************************************************************************************************************
** DEFINITION RELAYS IN FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS IN **
****************************************************************************************************************/
void RELAYS_IN_CHOOSE(unsigned char rel_in)	// HELP: RELAYS_IN_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    1418:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELIN_SCK_low();
    141a:	ae 98       	cbi	0x15, 6	; 21

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    141c:	80 ff       	sbrs	r24, 0
    141e:	02 c0       	rjmp	.+4      	; 0x1424 <RELAYS_IN_CHOOSE+0xc>
		{
			RELIN_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    1420:	af 9a       	sbi	0x15, 7	; 21
    1422:	01 c0       	rjmp	.+2      	; 0x1426 <RELAYS_IN_CHOOSE+0xe>
		}
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    1424:	af 98       	cbi	0x15, 7	; 21
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELIN_SCK_high();
    1426:	ae 9a       	sbi	0x15, 6	; 21
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1428:	9f 5f       	subi	r25, 0xFF	; 255
    142a:	98 30       	cpi	r25, 0x08	; 8
    142c:	11 f0       	breq	.+4      	; 0x1432 <RELAYS_IN_CHOOSE+0x1a>
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    142e:	86 95       	lsr	r24
    1430:	f4 cf       	rjmp	.-24     	; 0x141a <RELAYS_IN_CHOOSE+0x2>

		RELIN_SCK_high();
	}

	RELIN_RCK_low();
    1432:	ab 98       	cbi	0x15, 3	; 21
    1434:	88 ea       	ldi	r24, 0xA8	; 168
    1436:	92 e0       	ldi	r25, 0x02	; 2
    1438:	fc 01       	movw	r30, r24
    143a:	31 97       	sbiw	r30, 0x01	; 1
    143c:	f1 f7       	brne	.-4      	; 0x143a <RELAYS_IN_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELIN_RCK_high();
    143e:	ab 9a       	sbi	0x15, 3	; 21
    1440:	01 97       	sbiw	r24, 0x01	; 1
    1442:	f1 f7       	brne	.-4      	; 0x1440 <RELAYS_IN_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    1444:	08 95       	ret

00001446 <relays_in1_2ch>:

void relays_in1_2ch()
{
	RELAYS_IN_CHOOSE(0b00100000);	// RELE 1
    1446:	80 e2       	ldi	r24, 0x20	; 32
    1448:	0e 94 0c 0a 	call	0x1418	; 0x1418 <RELAYS_IN_CHOOSE>
}
    144c:	08 95       	ret

0000144e <relays_in1_6ch>:

void relays_in1_6ch()
{
	RELAYS_IN_CHOOSE(0b01100001);	// RELE 1,2,3
    144e:	81 e6       	ldi	r24, 0x61	; 97
    1450:	0e 94 0c 0a 	call	0x1418	; 0x1418 <RELAYS_IN_CHOOSE>
}
    1454:	08 95       	ret

00001456 <relays_in2_2ch>:

void relays_in2_2ch()
{
	RELAYS_IN_CHOOSE(0b00001010);	// RELE 4,5
    1456:	8a e0       	ldi	r24, 0x0A	; 10
    1458:	0e 94 0c 0a 	call	0x1418	; 0x1418 <RELAYS_IN_CHOOSE>
}
    145c:	08 95       	ret

0000145e <relays_in2_6ch>:

void relays_in2_6ch()
{
	RELAYS_IN_CHOOSE(0b10011010);	// RELE 4,5,6,7
    145e:	8a e9       	ldi	r24, 0x9A	; 154
    1460:	0e 94 0c 0a 	call	0x1418	; 0x1418 <RELAYS_IN_CHOOSE>
}
    1464:	08 95       	ret

00001466 <relays_in3_2ch>:

void relays_in3_2ch()
{
	RELAYS_IN_CHOOSE(0b00001100);	// RELE 8,5
    1466:	8c e0       	ldi	r24, 0x0C	; 12
    1468:	0e 94 0c 0a 	call	0x1418	; 0x1418 <RELAYS_IN_CHOOSE>
}
    146c:	08 95       	ret

0000146e <relays_in3_6ch>:

void relays_in3_6ch()
{
	RELAYS_IN_CHOOSE(0b10011100);	// RELE 8,5,6,7
    146e:	8c e9       	ldi	r24, 0x9C	; 156
    1470:	0e 94 0c 0a 	call	0x1418	; 0x1418 <RELAYS_IN_CHOOSE>
}
    1474:	08 95       	ret

00001476 <relays_in_off>:

void relays_in_off()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    1476:	80 e0       	ldi	r24, 0x00	; 0
    1478:	0e 94 0c 0a 	call	0x1418	; 0x1418 <RELAYS_IN_CHOOSE>
}
    147c:	08 95       	ret

0000147e <relays_in_init>:

void relays_in_init()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    147e:	80 e0       	ldi	r24, 0x00	; 0
    1480:	0e 94 0c 0a 	call	0x1418	; 0x1418 <RELAYS_IN_CHOOSE>
}
    1484:	08 95       	ret

00001486 <RELAYS_OUT_CHOOSE>:
/******************************************************************************************************************
** DEFINITION RELAYS OUT FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS OUT **
******************************************************************************************************************/
void RELAYS_OUT_CHOOSE(unsigned char rel_out)	// HELP: RELAYS_OUT_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    1486:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELOUT_SCK_low();
    1488:	96 98       	cbi	0x12, 6	; 18

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    148a:	80 ff       	sbrs	r24, 0
    148c:	02 c0       	rjmp	.+4      	; 0x1492 <RELAYS_OUT_CHOOSE+0xc>
		{
			RELOUT_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    148e:	c4 9a       	sbi	0x18, 4	; 24
    1490:	01 c0       	rjmp	.+2      	; 0x1494 <RELAYS_OUT_CHOOSE+0xe>
		}
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    1492:	c4 98       	cbi	0x18, 4	; 24
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELOUT_SCK_high();
    1494:	96 9a       	sbi	0x12, 6	; 18
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1496:	9f 5f       	subi	r25, 0xFF	; 255
    1498:	98 30       	cpi	r25, 0x08	; 8
    149a:	11 f0       	breq	.+4      	; 0x14a0 <RELAYS_OUT_CHOOSE+0x1a>
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    149c:	86 95       	lsr	r24
    149e:	f4 cf       	rjmp	.-24     	; 0x1488 <RELAYS_OUT_CHOOSE+0x2>

		RELOUT_SCK_high();
	}

	RELOUT_RCK_low();
    14a0:	97 98       	cbi	0x12, 7	; 18
    14a2:	88 ea       	ldi	r24, 0xA8	; 168
    14a4:	92 e0       	ldi	r25, 0x02	; 2
    14a6:	fc 01       	movw	r30, r24
    14a8:	31 97       	sbiw	r30, 0x01	; 1
    14aa:	f1 f7       	brne	.-4      	; 0x14a8 <RELAYS_OUT_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELOUT_RCK_high();
    14ac:	97 9a       	sbi	0x12, 7	; 18
    14ae:	01 97       	sbiw	r24, 0x01	; 1
    14b0:	f1 f7       	brne	.-4      	; 0x14ae <RELAYS_OUT_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    14b2:	08 95       	ret

000014b4 <relays_out_1ch>:

void relays_out_1ch()
{
	RELAYS_OUT_CHOOSE(0b10000000);	// RELE 1
    14b4:	80 e8       	ldi	r24, 0x80	; 128
    14b6:	0e 94 43 0a 	call	0x1486	; 0x1486 <RELAYS_OUT_CHOOSE>
}
    14ba:	08 95       	ret

000014bc <relays_out_6ch>:

void relays_out_6ch()
{
	RELAYS_OUT_CHOOSE(0b11111100);	// RELE 1,2,3,4,5,6
    14bc:	8c ef       	ldi	r24, 0xFC	; 252
    14be:	0e 94 43 0a 	call	0x1486	; 0x1486 <RELAYS_OUT_CHOOSE>
}
    14c2:	08 95       	ret

000014c4 <relays_out_off>:
void relays_out_off()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    14c4:	80 e0       	ldi	r24, 0x00	; 0
    14c6:	0e 94 43 0a 	call	0x1486	; 0x1486 <RELAYS_OUT_CHOOSE>
}
    14ca:	08 95       	ret

000014cc <relays_out_init>:
void relays_out_init()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    14cc:	80 e0       	ldi	r24, 0x00	; 0
    14ce:	0e 94 43 0a 	call	0x1486	; 0x1486 <RELAYS_OUT_CHOOSE>
}
    14d2:	08 95       	ret

000014d4 <GetSIRC12>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    14d4:	10 92 a0 07 	sts	0x07A0, r1
    14d8:	10 92 a5 07 	sts	0x07A5, r1

	while(irPin);				//wait for it to be low
    14dc:	82 99       	sbic	0x10, 2	; 16
    14de:	fe cf       	rjmp	.-4      	; 0x14dc <GetSIRC12+0x8>
    14e0:	20 e0       	ldi	r18, 0x00	; 0
    14e2:	40 e2       	ldi	r20, 0x20	; 32
    14e4:	53 e0       	ldi	r21, 0x03	; 3
    14e6:	04 c0       	rjmp	.+8      	; 0x14f0 <GetSIRC12+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    14e8:	2f 5f       	subi	r18, 0xFF	; 255
    14ea:	ca 01       	movw	r24, r20
    14ec:	01 97       	sbiw	r24, 0x01	; 1
    14ee:	f1 f7       	brne	.-4      	; 0x14ec <GetSIRC12+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    14f0:	82 9b       	sbis	0x10, 2	; 16
    14f2:	fa cf       	rjmp	.-12     	; 0x14e8 <GetSIRC12+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    14f4:	2b 50       	subi	r18, 0x0B	; 11
    14f6:	23 30       	cpi	r18, 0x03	; 3
    14f8:	70 f5       	brcc	.+92     	; 0x1556 <GetSIRC12+0x82>
	{
		return;		//goto StartLook;
    14fa:	40 e0       	ldi	r20, 0x00	; 0
    14fc:	30 e0       	ldi	r19, 0x00	; 0
    14fe:	60 e2       	ldi	r22, 0x20	; 32
    1500:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1502:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1504:	82 99       	sbic	0x10, 2	; 16
    1506:	fe cf       	rjmp	.-4      	; 0x1504 <GetSIRC12+0x30>
    1508:	20 e0       	ldi	r18, 0x00	; 0
    150a:	04 c0       	rjmp	.+8      	; 0x1514 <GetSIRC12+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    150c:	2f 5f       	subi	r18, 0xFF	; 255
    150e:	cb 01       	movw	r24, r22
    1510:	01 97       	sbiw	r24, 0x01	; 1
    1512:	f1 f7       	brne	.-4      	; 0x1510 <GetSIRC12+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1514:	82 9b       	sbis	0x10, 2	; 16
    1516:	fa cf       	rjmp	.-12     	; 0x150c <GetSIRC12+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1518:	26 30       	cpi	r18, 0x06	; 6
    151a:	08 f0       	brcs	.+2      	; 0x151e <GetSIRC12+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    151c:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    151e:	4f 5f       	subi	r20, 0xFF	; 255
    1520:	47 30       	cpi	r20, 0x07	; 7
    1522:	79 f7       	brne	.-34     	; 0x1502 <GetSIRC12+0x2e>
    1524:	30 93 a0 07 	sts	0x07A0, r19
    1528:	40 e0       	ldi	r20, 0x00	; 0
    152a:	30 e0       	ldi	r19, 0x00	; 0
    152c:	60 e2       	ldi	r22, 0x20	; 32
    152e:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1530:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1532:	82 99       	sbic	0x10, 2	; 16
    1534:	fe cf       	rjmp	.-4      	; 0x1532 <GetSIRC12+0x5e>
    1536:	20 e0       	ldi	r18, 0x00	; 0
    1538:	04 c0       	rjmp	.+8      	; 0x1542 <GetSIRC12+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    153a:	2f 5f       	subi	r18, 0xFF	; 255
    153c:	cb 01       	movw	r24, r22
    153e:	01 97       	sbiw	r24, 0x01	; 1
    1540:	f1 f7       	brne	.-4      	; 0x153e <GetSIRC12+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1542:	82 9b       	sbis	0x10, 2	; 16
    1544:	fa cf       	rjmp	.-12     	; 0x153a <GetSIRC12+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1546:	26 30       	cpi	r18, 0x06	; 6
    1548:	08 f0       	brcs	.+2      	; 0x154c <GetSIRC12+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    154a:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
    154c:	4f 5f       	subi	r20, 0xFF	; 255
    154e:	45 30       	cpi	r20, 0x05	; 5
    1550:	79 f7       	brne	.-34     	; 0x1530 <GetSIRC12+0x5c>
    1552:	30 93 a5 07 	sts	0x07A5, r19
    1556:	08 95       	ret

00001558 <GetSIRC15>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    1558:	10 92 a0 07 	sts	0x07A0, r1
    155c:	10 92 a5 07 	sts	0x07A5, r1

	while(irPin);				//wait for it to be low
    1560:	82 99       	sbic	0x10, 2	; 16
    1562:	fe cf       	rjmp	.-4      	; 0x1560 <GetSIRC15+0x8>
    1564:	20 e0       	ldi	r18, 0x00	; 0
    1566:	40 e2       	ldi	r20, 0x20	; 32
    1568:	53 e0       	ldi	r21, 0x03	; 3
    156a:	04 c0       	rjmp	.+8      	; 0x1574 <GetSIRC15+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    156c:	2f 5f       	subi	r18, 0xFF	; 255
    156e:	ca 01       	movw	r24, r20
    1570:	01 97       	sbiw	r24, 0x01	; 1
    1572:	f1 f7       	brne	.-4      	; 0x1570 <GetSIRC15+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    1574:	82 9b       	sbis	0x10, 2	; 16
    1576:	fa cf       	rjmp	.-12     	; 0x156c <GetSIRC15+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1578:	2b 50       	subi	r18, 0x0B	; 11
    157a:	23 30       	cpi	r18, 0x03	; 3
    157c:	70 f5       	brcc	.+92     	; 0x15da <GetSIRC15+0x82>
	{
		return;		//goto StartLook;
    157e:	40 e0       	ldi	r20, 0x00	; 0
    1580:	30 e0       	ldi	r19, 0x00	; 0
    1582:	60 e2       	ldi	r22, 0x20	; 32
    1584:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1586:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1588:	82 99       	sbic	0x10, 2	; 16
    158a:	fe cf       	rjmp	.-4      	; 0x1588 <GetSIRC15+0x30>
    158c:	20 e0       	ldi	r18, 0x00	; 0
    158e:	04 c0       	rjmp	.+8      	; 0x1598 <GetSIRC15+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    1590:	2f 5f       	subi	r18, 0xFF	; 255
    1592:	cb 01       	movw	r24, r22
    1594:	01 97       	sbiw	r24, 0x01	; 1
    1596:	f1 f7       	brne	.-4      	; 0x1594 <GetSIRC15+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1598:	82 9b       	sbis	0x10, 2	; 16
    159a:	fa cf       	rjmp	.-12     	; 0x1590 <GetSIRC15+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    159c:	26 30       	cpi	r18, 0x06	; 6
    159e:	08 f0       	brcs	.+2      	; 0x15a2 <GetSIRC15+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    15a0:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    15a2:	4f 5f       	subi	r20, 0xFF	; 255
    15a4:	47 30       	cpi	r20, 0x07	; 7
    15a6:	79 f7       	brne	.-34     	; 0x1586 <GetSIRC15+0x2e>
    15a8:	30 93 a0 07 	sts	0x07A0, r19
    15ac:	40 e0       	ldi	r20, 0x00	; 0
    15ae:	30 e0       	ldi	r19, 0x00	; 0
    15b0:	60 e2       	ldi	r22, 0x20	; 32
    15b2:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    15b4:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    15b6:	82 99       	sbic	0x10, 2	; 16
    15b8:	fe cf       	rjmp	.-4      	; 0x15b6 <GetSIRC15+0x5e>
    15ba:	20 e0       	ldi	r18, 0x00	; 0
    15bc:	04 c0       	rjmp	.+8      	; 0x15c6 <GetSIRC15+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    15be:	2f 5f       	subi	r18, 0xFF	; 255
    15c0:	cb 01       	movw	r24, r22
    15c2:	01 97       	sbiw	r24, 0x01	; 1
    15c4:	f1 f7       	brne	.-4      	; 0x15c2 <GetSIRC15+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    15c6:	82 9b       	sbis	0x10, 2	; 16
    15c8:	fa cf       	rjmp	.-12     	; 0x15be <GetSIRC15+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    15ca:	26 30       	cpi	r18, 0x06	; 6
    15cc:	08 f0       	brcs	.+2      	; 0x15d0 <GetSIRC15+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    15ce:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
    15d0:	4f 5f       	subi	r20, 0xFF	; 255
    15d2:	48 30       	cpi	r20, 0x08	; 8
    15d4:	79 f7       	brne	.-34     	; 0x15b4 <GetSIRC15+0x5c>
    15d6:	30 93 a5 07 	sts	0x07A5, r19
    15da:	08 95       	ret

000015dc <GetSIRC20>:
{
	char x;
	char lTime;

//StartLook:
	irExtended = irAddress = irCommand = 0;
    15dc:	10 92 a0 07 	sts	0x07A0, r1
    15e0:	10 92 a5 07 	sts	0x07A5, r1
    15e4:	10 92 a7 07 	sts	0x07A7, r1

	while(irPin);				//wait for it to be low
    15e8:	82 99       	sbic	0x10, 2	; 16
    15ea:	fe cf       	rjmp	.-4      	; 0x15e8 <GetSIRC20+0xc>
    15ec:	20 e0       	ldi	r18, 0x00	; 0
    15ee:	40 e2       	ldi	r20, 0x20	; 32
    15f0:	53 e0       	ldi	r21, 0x03	; 3
    15f2:	04 c0       	rjmp	.+8      	; 0x15fc <GetSIRC20+0x20>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    15f4:	2f 5f       	subi	r18, 0xFF	; 255
    15f6:	ca 01       	movw	r24, r20
    15f8:	01 97       	sbiw	r24, 0x01	; 1
    15fa:	f1 f7       	brne	.-4      	; 0x15f8 <GetSIRC20+0x1c>
	irExtended = irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    15fc:	82 9b       	sbis	0x10, 2	; 16
    15fe:	fa cf       	rjmp	.-12     	; 0x15f4 <GetSIRC20+0x18>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1600:	2b 50       	subi	r18, 0x0B	; 11
    1602:	23 30       	cpi	r18, 0x03	; 3
    1604:	08 f0       	brcs	.+2      	; 0x1608 <GetSIRC20+0x2c>
    1606:	45 c0       	rjmp	.+138    	; 0x1692 <GetSIRC20+0xb6>
	{
		return;		//goto StartLook;
    1608:	40 e0       	ldi	r20, 0x00	; 0
    160a:	30 e0       	ldi	r19, 0x00	; 0
    160c:	60 e2       	ldi	r22, 0x20	; 32
    160e:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1610:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1612:	82 99       	sbic	0x10, 2	; 16
    1614:	fe cf       	rjmp	.-4      	; 0x1612 <GetSIRC20+0x36>
    1616:	20 e0       	ldi	r18, 0x00	; 0
    1618:	04 c0       	rjmp	.+8      	; 0x1622 <GetSIRC20+0x46>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    161a:	2f 5f       	subi	r18, 0xFF	; 255
    161c:	cb 01       	movw	r24, r22
    161e:	01 97       	sbiw	r24, 0x01	; 1
    1620:	f1 f7       	brne	.-4      	; 0x161e <GetSIRC20+0x42>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1622:	82 9b       	sbis	0x10, 2	; 16
    1624:	fa cf       	rjmp	.-12     	; 0x161a <GetSIRC20+0x3e>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1626:	26 30       	cpi	r18, 0x06	; 6
    1628:	08 f0       	brcs	.+2      	; 0x162c <GetSIRC20+0x50>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    162a:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    162c:	4f 5f       	subi	r20, 0xFF	; 255
    162e:	47 30       	cpi	r20, 0x07	; 7
    1630:	79 f7       	brne	.-34     	; 0x1610 <GetSIRC20+0x34>
    1632:	30 93 a0 07 	sts	0x07A0, r19
    1636:	40 e0       	ldi	r20, 0x00	; 0
    1638:	30 e0       	ldi	r19, 0x00	; 0
    163a:	60 e2       	ldi	r22, 0x20	; 32
    163c:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    163e:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1640:	82 99       	sbic	0x10, 2	; 16
    1642:	fe cf       	rjmp	.-4      	; 0x1640 <GetSIRC20+0x64>
    1644:	20 e0       	ldi	r18, 0x00	; 0
    1646:	04 c0       	rjmp	.+8      	; 0x1650 <GetSIRC20+0x74>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1648:	2f 5f       	subi	r18, 0xFF	; 255
    164a:	cb 01       	movw	r24, r22
    164c:	01 97       	sbiw	r24, 0x01	; 1
    164e:	f1 f7       	brne	.-4      	; 0x164c <GetSIRC20+0x70>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1650:	82 9b       	sbis	0x10, 2	; 16
    1652:	fa cf       	rjmp	.-12     	; 0x1648 <GetSIRC20+0x6c>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1654:	26 30       	cpi	r18, 0x06	; 6
    1656:	08 f0       	brcs	.+2      	; 0x165a <GetSIRC20+0x7e>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1658:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
    165a:	4f 5f       	subi	r20, 0xFF	; 255
    165c:	45 30       	cpi	r20, 0x05	; 5
    165e:	79 f7       	brne	.-34     	; 0x163e <GetSIRC20+0x62>
    1660:	30 93 a5 07 	sts	0x07A5, r19
    1664:	40 e0       	ldi	r20, 0x00	; 0
    1666:	30 e0       	ldi	r19, 0x00	; 0
    1668:	60 e2       	ldi	r22, 0x20	; 32
    166a:	73 e0       	ldi	r23, 0x03	; 3
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
		{
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1
    166c:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    166e:	82 99       	sbic	0x10, 2	; 16
    1670:	fe cf       	rjmp	.-4      	; 0x166e <GetSIRC20+0x92>
    1672:	20 e0       	ldi	r18, 0x00	; 0
    1674:	04 c0       	rjmp	.+8      	; 0x167e <GetSIRC20+0xa2>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1676:	2f 5f       	subi	r18, 0xFF	; 255
    1678:	cb 01       	movw	r24, r22
    167a:	01 97       	sbiw	r24, 0x01	; 1
    167c:	f1 f7       	brne	.-4      	; 0x167a <GetSIRC20+0x9e>
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    167e:	82 9b       	sbis	0x10, 2	; 16
    1680:	fa cf       	rjmp	.-12     	; 0x1676 <GetSIRC20+0x9a>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1682:	26 30       	cpi	r18, 0x06	; 6
    1684:	08 f0       	brcs	.+2      	; 0x1688 <GetSIRC20+0xac>
				irExtended |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1686:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
    1688:	4f 5f       	subi	r20, 0xFF	; 255
    168a:	48 30       	cpi	r20, 0x08	; 8
    168c:	79 f7       	brne	.-34     	; 0x166c <GetSIRC20+0x90>
    168e:	30 93 a7 07 	sts	0x07A7, r19
    1692:	08 95       	ret

00001694 <__udivmodqi4>:
    1694:	99 1b       	sub	r25, r25
    1696:	79 e0       	ldi	r23, 0x09	; 9
    1698:	04 c0       	rjmp	.+8      	; 0x16a2 <__udivmodqi4_ep>

0000169a <__udivmodqi4_loop>:
    169a:	99 1f       	adc	r25, r25
    169c:	96 17       	cp	r25, r22
    169e:	08 f0       	brcs	.+2      	; 0x16a2 <__udivmodqi4_ep>
    16a0:	96 1b       	sub	r25, r22

000016a2 <__udivmodqi4_ep>:
    16a2:	88 1f       	adc	r24, r24
    16a4:	7a 95       	dec	r23
    16a6:	c9 f7       	brne	.-14     	; 0x169a <__udivmodqi4_loop>
    16a8:	80 95       	com	r24
    16aa:	08 95       	ret

000016ac <__divmodhi4>:
    16ac:	97 fb       	bst	r25, 7
    16ae:	09 2e       	mov	r0, r25
    16b0:	07 26       	eor	r0, r23
    16b2:	0a d0       	rcall	.+20     	; 0x16c8 <__divmodhi4_neg1>
    16b4:	77 fd       	sbrc	r23, 7
    16b6:	04 d0       	rcall	.+8      	; 0x16c0 <__divmodhi4_neg2>
    16b8:	0c d0       	rcall	.+24     	; 0x16d2 <__udivmodhi4>
    16ba:	06 d0       	rcall	.+12     	; 0x16c8 <__divmodhi4_neg1>
    16bc:	00 20       	and	r0, r0
    16be:	1a f4       	brpl	.+6      	; 0x16c6 <__divmodhi4_exit>

000016c0 <__divmodhi4_neg2>:
    16c0:	70 95       	com	r23
    16c2:	61 95       	neg	r22
    16c4:	7f 4f       	sbci	r23, 0xFF	; 255

000016c6 <__divmodhi4_exit>:
    16c6:	08 95       	ret

000016c8 <__divmodhi4_neg1>:
    16c8:	f6 f7       	brtc	.-4      	; 0x16c6 <__divmodhi4_exit>
    16ca:	90 95       	com	r25
    16cc:	81 95       	neg	r24
    16ce:	9f 4f       	sbci	r25, 0xFF	; 255
    16d0:	08 95       	ret

000016d2 <__udivmodhi4>:
    16d2:	aa 1b       	sub	r26, r26
    16d4:	bb 1b       	sub	r27, r27
    16d6:	51 e1       	ldi	r21, 0x11	; 17
    16d8:	07 c0       	rjmp	.+14     	; 0x16e8 <__udivmodhi4_ep>

000016da <__udivmodhi4_loop>:
    16da:	aa 1f       	adc	r26, r26
    16dc:	bb 1f       	adc	r27, r27
    16de:	a6 17       	cp	r26, r22
    16e0:	b7 07       	cpc	r27, r23
    16e2:	10 f0       	brcs	.+4      	; 0x16e8 <__udivmodhi4_ep>
    16e4:	a6 1b       	sub	r26, r22
    16e6:	b7 0b       	sbc	r27, r23

000016e8 <__udivmodhi4_ep>:
    16e8:	88 1f       	adc	r24, r24
    16ea:	99 1f       	adc	r25, r25
    16ec:	5a 95       	dec	r21
    16ee:	a9 f7       	brne	.-22     	; 0x16da <__udivmodhi4_loop>
    16f0:	80 95       	com	r24
    16f2:	90 95       	com	r25
    16f4:	bc 01       	movw	r22, r24
    16f6:	cd 01       	movw	r24, r26
    16f8:	08 95       	ret

000016fa <itoa>:
    16fa:	fb 01       	movw	r30, r22
    16fc:	9f 01       	movw	r18, r30
    16fe:	e8 94       	clt
    1700:	42 30       	cpi	r20, 0x02	; 2
    1702:	c4 f0       	brlt	.+48     	; 0x1734 <itoa+0x3a>
    1704:	45 32       	cpi	r20, 0x25	; 37
    1706:	b4 f4       	brge	.+44     	; 0x1734 <itoa+0x3a>
    1708:	4a 30       	cpi	r20, 0x0A	; 10
    170a:	29 f4       	brne	.+10     	; 0x1716 <itoa+0x1c>
    170c:	97 fb       	bst	r25, 7
    170e:	1e f4       	brtc	.+6      	; 0x1716 <itoa+0x1c>
    1710:	90 95       	com	r25
    1712:	81 95       	neg	r24
    1714:	9f 4f       	sbci	r25, 0xFF	; 255
    1716:	64 2f       	mov	r22, r20
    1718:	77 27       	eor	r23, r23
    171a:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <__udivmodhi4>
    171e:	80 5d       	subi	r24, 0xD0	; 208
    1720:	8a 33       	cpi	r24, 0x3A	; 58
    1722:	0c f0       	brlt	.+2      	; 0x1726 <itoa+0x2c>
    1724:	89 5d       	subi	r24, 0xD9	; 217
    1726:	81 93       	st	Z+, r24
    1728:	cb 01       	movw	r24, r22
    172a:	00 97       	sbiw	r24, 0x00	; 0
    172c:	a1 f7       	brne	.-24     	; 0x1716 <itoa+0x1c>
    172e:	16 f4       	brtc	.+4      	; 0x1734 <itoa+0x3a>
    1730:	5d e2       	ldi	r21, 0x2D	; 45
    1732:	51 93       	st	Z+, r21
    1734:	10 82       	st	Z, r1
    1736:	c9 01       	movw	r24, r18
    1738:	0c 94 0d 0c 	jmp	0x181a	; 0x181a <strrev>

0000173c <ltoa>:
    173c:	fa 01       	movw	r30, r20
    173e:	cf 93       	push	r28
    1740:	ff 93       	push	r31
    1742:	ef 93       	push	r30
    1744:	22 30       	cpi	r18, 0x02	; 2
    1746:	44 f1       	brlt	.+80     	; 0x1798 <ltoa+0x5c>
    1748:	25 32       	cpi	r18, 0x25	; 37
    174a:	34 f5       	brge	.+76     	; 0x1798 <ltoa+0x5c>
    174c:	c2 2f       	mov	r28, r18
    174e:	e8 94       	clt
    1750:	ca 30       	cpi	r28, 0x0A	; 10
    1752:	49 f4       	brne	.+18     	; 0x1766 <ltoa+0x2a>
    1754:	97 fb       	bst	r25, 7
    1756:	3e f4       	brtc	.+14     	; 0x1766 <ltoa+0x2a>
    1758:	90 95       	com	r25
    175a:	80 95       	com	r24
    175c:	70 95       	com	r23
    175e:	61 95       	neg	r22
    1760:	7f 4f       	sbci	r23, 0xFF	; 255
    1762:	8f 4f       	sbci	r24, 0xFF	; 255
    1764:	9f 4f       	sbci	r25, 0xFF	; 255
    1766:	2c 2f       	mov	r18, r28
    1768:	33 27       	eor	r19, r19
    176a:	44 27       	eor	r20, r20
    176c:	55 27       	eor	r21, r21
    176e:	ff 93       	push	r31
    1770:	ef 93       	push	r30
    1772:	0e 94 1d 0c 	call	0x183a	; 0x183a <__udivmodsi4>
    1776:	ef 91       	pop	r30
    1778:	ff 91       	pop	r31
    177a:	60 5d       	subi	r22, 0xD0	; 208
    177c:	6a 33       	cpi	r22, 0x3A	; 58
    177e:	0c f0       	brlt	.+2      	; 0x1782 <ltoa+0x46>
    1780:	69 5d       	subi	r22, 0xD9	; 217
    1782:	61 93       	st	Z+, r22
    1784:	b9 01       	movw	r22, r18
    1786:	ca 01       	movw	r24, r20
    1788:	60 50       	subi	r22, 0x00	; 0
    178a:	70 40       	sbci	r23, 0x00	; 0
    178c:	80 40       	sbci	r24, 0x00	; 0
    178e:	90 40       	sbci	r25, 0x00	; 0
    1790:	51 f7       	brne	.-44     	; 0x1766 <ltoa+0x2a>
    1792:	16 f4       	brtc	.+4      	; 0x1798 <ltoa+0x5c>
    1794:	cd e2       	ldi	r28, 0x2D	; 45
    1796:	c1 93       	st	Z+, r28
    1798:	10 82       	st	Z, r1
    179a:	8f 91       	pop	r24
    179c:	9f 91       	pop	r25
    179e:	cf 91       	pop	r28
    17a0:	0c 94 0d 0c 	jmp	0x181a	; 0x181a <strrev>

000017a4 <ultoa>:
    17a4:	fa 01       	movw	r30, r20
    17a6:	cf 93       	push	r28
    17a8:	ff 93       	push	r31
    17aa:	ef 93       	push	r30
    17ac:	22 30       	cpi	r18, 0x02	; 2
    17ae:	cc f0       	brlt	.+50     	; 0x17e2 <ultoa+0x3e>
    17b0:	25 32       	cpi	r18, 0x25	; 37
    17b2:	bc f4       	brge	.+46     	; 0x17e2 <ultoa+0x3e>
    17b4:	c2 2f       	mov	r28, r18
    17b6:	2c 2f       	mov	r18, r28
    17b8:	33 27       	eor	r19, r19
    17ba:	44 27       	eor	r20, r20
    17bc:	55 27       	eor	r21, r21
    17be:	ff 93       	push	r31
    17c0:	ef 93       	push	r30
    17c2:	0e 94 1d 0c 	call	0x183a	; 0x183a <__udivmodsi4>
    17c6:	ef 91       	pop	r30
    17c8:	ff 91       	pop	r31
    17ca:	60 5d       	subi	r22, 0xD0	; 208
    17cc:	6a 33       	cpi	r22, 0x3A	; 58
    17ce:	0c f0       	brlt	.+2      	; 0x17d2 <ultoa+0x2e>
    17d0:	69 5d       	subi	r22, 0xD9	; 217
    17d2:	61 93       	st	Z+, r22
    17d4:	b9 01       	movw	r22, r18
    17d6:	ca 01       	movw	r24, r20
    17d8:	60 50       	subi	r22, 0x00	; 0
    17da:	70 40       	sbci	r23, 0x00	; 0
    17dc:	80 40       	sbci	r24, 0x00	; 0
    17de:	90 40       	sbci	r25, 0x00	; 0
    17e0:	51 f7       	brne	.-44     	; 0x17b6 <ultoa+0x12>
    17e2:	10 82       	st	Z, r1
    17e4:	8f 91       	pop	r24
    17e6:	9f 91       	pop	r25
    17e8:	cf 91       	pop	r28
    17ea:	0c 94 0d 0c 	jmp	0x181a	; 0x181a <strrev>

000017ee <utoa>:
    17ee:	fb 01       	movw	r30, r22
    17f0:	9f 01       	movw	r18, r30
    17f2:	42 30       	cpi	r20, 0x02	; 2
    17f4:	74 f0       	brlt	.+28     	; 0x1812 <utoa+0x24>
    17f6:	45 32       	cpi	r20, 0x25	; 37
    17f8:	64 f4       	brge	.+24     	; 0x1812 <utoa+0x24>
    17fa:	64 2f       	mov	r22, r20
    17fc:	77 27       	eor	r23, r23
    17fe:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <__udivmodhi4>
    1802:	80 5d       	subi	r24, 0xD0	; 208
    1804:	8a 33       	cpi	r24, 0x3A	; 58
    1806:	0c f0       	brlt	.+2      	; 0x180a <utoa+0x1c>
    1808:	89 5d       	subi	r24, 0xD9	; 217
    180a:	81 93       	st	Z+, r24
    180c:	cb 01       	movw	r24, r22
    180e:	00 97       	sbiw	r24, 0x00	; 0
    1810:	a1 f7       	brne	.-24     	; 0x17fa <utoa+0xc>
    1812:	10 82       	st	Z, r1
    1814:	c9 01       	movw	r24, r18
    1816:	0c 94 0d 0c 	jmp	0x181a	; 0x181a <strrev>

0000181a <strrev>:
    181a:	dc 01       	movw	r26, r24
    181c:	fc 01       	movw	r30, r24
    181e:	67 2f       	mov	r22, r23
    1820:	71 91       	ld	r23, Z+
    1822:	77 23       	and	r23, r23
    1824:	e1 f7       	brne	.-8      	; 0x181e <strrev+0x4>
    1826:	32 97       	sbiw	r30, 0x02	; 2
    1828:	04 c0       	rjmp	.+8      	; 0x1832 <strrev+0x18>
    182a:	7c 91       	ld	r23, X
    182c:	6d 93       	st	X+, r22
    182e:	70 83       	st	Z, r23
    1830:	62 91       	ld	r22, -Z
    1832:	ae 17       	cp	r26, r30
    1834:	bf 07       	cpc	r27, r31
    1836:	c8 f3       	brcs	.-14     	; 0x182a <strrev+0x10>
    1838:	08 95       	ret

0000183a <__udivmodsi4>:
    183a:	a1 e2       	ldi	r26, 0x21	; 33
    183c:	1a 2e       	mov	r1, r26
    183e:	aa 1b       	sub	r26, r26
    1840:	bb 1b       	sub	r27, r27
    1842:	fd 01       	movw	r30, r26
    1844:	0d c0       	rjmp	.+26     	; 0x1860 <__udivmodsi4_ep>

00001846 <__udivmodsi4_loop>:
    1846:	aa 1f       	adc	r26, r26
    1848:	bb 1f       	adc	r27, r27
    184a:	ee 1f       	adc	r30, r30
    184c:	ff 1f       	adc	r31, r31
    184e:	a2 17       	cp	r26, r18
    1850:	b3 07       	cpc	r27, r19
    1852:	e4 07       	cpc	r30, r20
    1854:	f5 07       	cpc	r31, r21
    1856:	20 f0       	brcs	.+8      	; 0x1860 <__udivmodsi4_ep>
    1858:	a2 1b       	sub	r26, r18
    185a:	b3 0b       	sbc	r27, r19
    185c:	e4 0b       	sbc	r30, r20
    185e:	f5 0b       	sbc	r31, r21

00001860 <__udivmodsi4_ep>:
    1860:	66 1f       	adc	r22, r22
    1862:	77 1f       	adc	r23, r23
    1864:	88 1f       	adc	r24, r24
    1866:	99 1f       	adc	r25, r25
    1868:	1a 94       	dec	r1
    186a:	69 f7       	brne	.-38     	; 0x1846 <__udivmodsi4_loop>
    186c:	60 95       	com	r22
    186e:	70 95       	com	r23
    1870:	80 95       	com	r24
    1872:	90 95       	com	r25
    1874:	9b 01       	movw	r18, r22
    1876:	ac 01       	movw	r20, r24
    1878:	bd 01       	movw	r22, r26
    187a:	cf 01       	movw	r24, r30
    187c:	08 95       	ret

0000187e <_exit>:
    187e:	f8 94       	cli

00001880 <__stop_program>:
    1880:	ff cf       	rjmp	.-2      	; 0x1880 <__stop_program>
