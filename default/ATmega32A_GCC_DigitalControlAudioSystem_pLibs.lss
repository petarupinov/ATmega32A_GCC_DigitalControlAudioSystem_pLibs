
ATmega32A_GCC_DigitalControlAudioSystem_pLibs.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000183c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000003ec  00800060  0000183c  000018d0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002c  0080044c  0080044c  00001cbc  2**0
                  ALLOC
  3 .stab         00000ef4  00000000  00000000  00001cbc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000014c  00000000  00000000  00002bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00002cfc  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000188  00000000  00000000  00002d0d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00003fa3  00000000  00000000  00002e95  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001137  00000000  00000000  00006e38  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000fc6  00000000  00000000  00007f6f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a1c  00000000  00000000  00008f38  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000cae  00000000  00000000  00009954  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002117  00000000  00000000  0000a602  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000030  00000000  00000000  0000c719  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 7c 04 	jmp	0x8f8	; 0x8f8 <__vector_1>
       8:	0c 94 b2 04 	jmp	0x964	; 0x964 <__vector_2>
       c:	0c 94 bc 04 	jmp	0x978	; 0x978 <__vector_3>
      10:	0c 94 c6 04 	jmp	0x98c	; 0x98c <__vector_4>
      14:	0c 94 ee 04 	jmp	0x9dc	; 0x9dc <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	14 e0       	ldi	r17, 0x04	; 4
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e3       	ldi	r30, 0x3C	; 60
      68:	f8 e1       	ldi	r31, 0x18	; 24
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 34       	cpi	r26, 0x4C	; 76
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	ac e4       	ldi	r26, 0x4C	; 76
      7a:	b4 e0       	ldi	r27, 0x04	; 4
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 37       	cpi	r26, 0x78	; 120
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 32 0b 	call	0x1664	; 0x1664 <main>
      8a:	0c 94 1c 0c 	jmp	0x1838	; 0x1838 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <port_init>:
*****************************************/
void port_init(void)
{	

// PORT A connections
	DDRA  = 0b11111111;		//  PA7:U8/PGA2310,CS; PA6:U7/PGA2310,CS; PA5:CON2LCD,RS; PA4:CON2LCD,RW; PA3:CON2LCD,E; PA2:U2/74HC595,RCLK(LCD); PA1:U2/74HC595,SCLK(LCD); PA0:U2/74HC595,DATA(LCD);
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	8a bb       	out	0x1a, r24	; 26
	PORTA = 0b00000000;		//	Interfaces: NOT USED. PULLUP DISABLE in PORTA.
      96:	1b ba       	out	0x1b, r1	; 27

// PORT B connections
	DDRB  = 0b10111000;		//  PB7:U6,U7,U8/PGA2310,SCLK; PB6:U6,U7,U8/PGA2310,SDO(CON33,36,39); PB5:U6,U7,U8/PGA2310,SDI; PB4:U12/74HC595,DATA(REL_OUT); PB3:U6/PGA2310,CS; PB2:CON8/BUTTON,"ESCAPE",INT2; PB1:CON5/BUTTON,"ON/OFF"; PB0:CON14TempSensor/DS18S20,DQ,IN/OUT;
      98:	88 eb       	ldi	r24, 0xB8	; 184
      9a:	87 bb       	out	0x17, r24	; 23
	PORTB = 0b00000111;		//	Interfaces: EXTERNAL INTERRUPT 2; SPI. set pullup to IRTSOP2240 / BUTTON(on/off) / DS18s20.
      9c:	87 e0       	ldi	r24, 0x07	; 7
      9e:	88 bb       	out	0x18, r24	; 24

// PORT C connections
	DDRC  = 0b11001100;		//  PC7:U10/74HC595,DATA(REL_IN); PC6:U10/74HC595,SCLK(REL_IN); PC5:EncoderED1112S,A; PC4:EncoderED1112S,B; PC3:U10/74HC595,RCLK(REL_IN); PC2:Q2/BD237(RELAY_POWER_SUPPLY); PC1:DS1307/24C64,I2C/SDA; PC0:DS1307/24C64,I2C/SCL;
      a0:	8c ec       	ldi	r24, 0xCC	; 204
      a2:	84 bb       	out	0x14, r24	; 20
	PORTC = 0b00000000;		//	Interfaces: I2C. PULLUP DISABLE in PORTC.
      a4:	15 ba       	out	0x15, r1	; 21

// PORT D connections
	DDRD  = 0b11110000;		//  PD7:U12/74HC595,RCLK(REL_OUT); PD6:U12/74HC595,SCLK(REL_OUT); PD5:Q1/BD237(FAN_CONTROL_PWM); PD4:LED5/"ON/OFF AUDIO SYSTEM"; PD3:CON11/EncoderBUTTON,"MENU/ENTER"/INT1; PD2:CON12/IR/TSOP2240,/INT0; PD1:CON14/MAX232,UART/TXD; PD0:CON14/MAX232,UART/RXD;
      a6:	80 ef       	ldi	r24, 0xF0	; 240
      a8:	81 bb       	out	0x11, r24	; 17
	PORTD = 0b00001100;		//	Interfaces: TIMER1; UART/USART; EXTERNAL INTERRUPT 0, 1. PULLUP DISABLE in PORTD.
      aa:	8c e0       	ldi	r24, 0x0C	; 12
      ac:	82 bb       	out	0x12, r24	; 18
      ae:	08 95       	ret

000000b0 <ext0_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 0 **
*******************************************/
void ext0_intrpt_init(void)
{
	MCUCR = 0b00000010;	// SETUP EXT INT 0, ISC01 = 1, ISC00 = 0: Falling edge on INT0 activates the interrupt; ISC01 = 1, ISC00 = 1: Rising edge on INT0 activates the interrupt;
      b0:	82 e0       	ldi	r24, 0x02	; 2
      b2:	85 bf       	out	0x35, r24	; 53
      b4:	08 95       	ret

000000b6 <ext0_intrpt_on>:
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR |= 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      b6:	8b b7       	in	r24, 0x3b	; 59
      b8:	80 64       	ori	r24, 0x40	; 64
      ba:	8b bf       	out	0x3b, r24	; 59
	GIFR |= 0b01000000;	// Clear INT0 flag.
      bc:	8a b7       	in	r24, 0x3a	; 58
      be:	80 64       	ori	r24, 0x40	; 64
      c0:	8a bf       	out	0x3a, r24	; 58
      c2:	08 95       	ret

000000c4 <ext0_intrpt_off>:
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR |= 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      c4:	8b b7       	in	r24, 0x3b	; 59
      c6:	8b bf       	out	0x3b, r24	; 59
	GIFR |= 0b01000000;	// Clear INT0 flag.
      c8:	8a b7       	in	r24, 0x3a	; 58
      ca:	80 64       	ori	r24, 0x40	; 64
      cc:	8a bf       	out	0x3a, r24	; 58
      ce:	08 95       	ret

000000d0 <ext1_intrpt_init>:

/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 1 **
*******************************************/
void ext1_intrpt_init(void)
{
      d0:	08 95       	ret

000000d2 <ext2_intrpt_init>:

/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 2 **
*******************************************/
void ext2_intrpt_init(void)
{
      d2:	08 95       	ret

000000d4 <timer1_init>:
*****************************/
void timer1_init(void)
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  |= 0b00000000;	// maskov registar za prekasvaniq
      d4:	89 b7       	in	r24, 0x39	; 57
      d6:	89 bf       	out	0x39, r24	; 57
	TCNT1H = 0b00000000;
      d8:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
      da:	1c bc       	out	0x2c, r1	; 44
      dc:	08 95       	ret

000000de <timer2_init>:
/*****************************
** INITIZLIZATION OF TIMER2 **
*****************************/
void timer2_init(void)
{
	TIMSK |= 0b00000000;		// Disable Internal Interrupts on Timer2
      de:	89 b7       	in	r24, 0x39	; 57
      e0:	89 bf       	out	0x39, r24	; 57
	TCNT2 = 0b00000000;		// Clear Counter Timer2
      e2:	14 bc       	out	0x24, r1	; 36
      e4:	08 95       	ret

000000e6 <timer2Internal_intrpt_off>:
//	SFIOR |= 0b00000010;		// Prescaler Reset Timer2 (bit1 ï¿½> PSR2)
}
void timer2Internal_intrpt_off(void)
{
	TIMSK |= 0b00000000;		// OCIE2 [bit7] = 0: Disable Internal Interrupt on Timer2CompareMatch; OCIE2 [bit7] = 1: Enable Internal Interrupt on Timer2CompareMatch;
      e6:	89 b7       	in	r24, 0x39	; 57
      e8:	89 bf       	out	0x39, r24	; 57
	TIFR  |= 0b10000000;		// OCF2  [bit7] = 1: Clear Timer2CompareMatch flag.
      ea:	88 b7       	in	r24, 0x38	; 56
      ec:	80 68       	ori	r24, 0x80	; 128
      ee:	88 bf       	out	0x38, r24	; 56
      f0:	08 95       	ret

000000f2 <timer2Internal_intrpt_on>:
}

void timer2Internal_intrpt_on(void)
{
	TIMSK |= 0b10000000;		// OCIE2 [bit7] = 0: Disable Internal Interrupt on Timer2CompareMatch; OCIE2 [bit7] = 1: Enable Internal Interrupt on Timer2CompareMatch;
      f2:	89 b7       	in	r24, 0x39	; 57
      f4:	80 68       	ori	r24, 0x80	; 128
      f6:	89 bf       	out	0x39, r24	; 57
	TIFR  |= 0b10000000;		// OCF2  [bit7] = 1: Clear Timer2CompareMatch flag.
      f8:	88 b7       	in	r24, 0x38	; 56
      fa:	80 68       	ori	r24, 0x80	; 128
      fc:	88 bf       	out	0x38, r24	; 56
      fe:	08 95       	ret

00000100 <timer1_on_speed>:
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     100:	81 ea       	ldi	r24, 0xA1	; 161
     102:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     104:	81 e0       	ldi	r24, 0x01	; 1
     106:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     108:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     10a:	e0 91 70 00 	lds	r30, 0x0070
     10e:	f0 e0       	ldi	r31, 0x00	; 0
     110:	e8 59       	subi	r30, 0x98	; 152
     112:	ff 4f       	sbci	r31, 0xFF	; 255
     114:	80 81       	ld	r24, Z
     116:	8a bd       	out	0x2a, r24	; 42
     118:	08 95       	ret

0000011a <timer1_off>:
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}

void timer1_off(void)
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     11a:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     11c:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     11e:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     120:	1a bc       	out	0x2a, r1	; 42
     122:	08 95       	ret

00000124 <fan_pwm_control_speed>:
/***********************************
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
     124:	0c 94 80 00 	jmp	0x100	; 0x100 <timer1_on_speed>

00000128 <fan_pwm_off>:
}
void fan_pwm_off(void)
{
	timer1_off();
     128:	0c 94 8d 00 	jmp	0x11a	; 0x11a <timer1_off>

0000012c <timer2_on>:
/***************************************
******** DEFINITIONS OF TIMER 2 ********
***************************************/
void timer2_on(void)	// Timer2 On
{
	TCCR2 = 0b01100001;		// 0b01100001 - WGM20,COM21,CS20 - PWM, Phase correct, No prescaller divide or division by 1
     12c:	81 e6       	ldi	r24, 0x61	; 97
     12e:	85 bd       	out	0x25, r24	; 37
	OCR2 = 100;				// Compare match by Overflow Timer with ~15 times [us]
     130:	84 e6       	ldi	r24, 0x64	; 100
     132:	83 bd       	out	0x23, r24	; 35
     134:	08 95       	ret

00000136 <timer2_off>:
}

void timer2_off(void)	// Timer2 Off
{
	TCCR2 = 0b00000000;		// 0b01100001 - WGM20,COM21,CS20 - PWM, Phase correct, No prescaller divide or division by 1
     136:	15 bc       	out	0x25, r1	; 37
	OCR2 = 0;				// Compare match by Overflow Timer with ~15 times [us]
     138:	13 bc       	out	0x23, r1	; 35
     13a:	08 95       	ret

0000013c <ampliferOn>:
/********************
**** AMPLIFER ON ****
********************/
void ampliferOn(void)
{
	flagStatusBits->flagPower = 1;		// flag for amplifer on
     13c:	e0 91 6a 04 	lds	r30, 0x046A
     140:	f0 91 6b 04 	lds	r31, 0x046B
     144:	80 81       	ld	r24, Z
     146:	81 60       	ori	r24, 0x01	; 1
     148:	80 83       	st	Z, r24
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display on and status led off\r\n");
	#endif

// LED OFF FUNC
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     14a:	94 98       	cbi	0x12, 4	; 18

// LCD FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();						// clear all contain on display
     14c:	0e 94 37 07 	call	0xe6e	; 0xe6e <LCD_CLEAR_CONTAIN>
	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     150:	80 e0       	ldi	r24, 0x00	; 0
     152:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer On     ");	// 20 symbols
     156:	8d ec       	ldi	r24, 0xCD	; 205
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);				// select row 2
     15e:	80 ec       	ldi	r24, 0xC0	; 192
     160:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
	LCD_DATA_STRING("P.UPINOV  P.STOYANOV");	// 20 symbols //	LCD_EXECUTE_DATA("P.UPINOV  P.STOYANOV",20);	// char "DATA", int 13 of chars of "DATA"
     164:	82 ee       	ldi	r24, 0xE2	; 226
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     16c:	8c e0       	ldi	r24, 0x0C	; 12
     16e:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
		transmitUartString("[UART INFO] Fan is on\r\n");
		transmitUartString("[UART INFO] Fan rotation with max speed\r\n");
		transmitUartString("[UART INFO] Fan is always on, it isn't sensitive to temperature, because DS18S20 is disabling\r\n");
	#endif
//	FAN_high();			// PORTD5 - FAN ON (logic "1")	NON PWM, NON TIMER1	
	fanSpeed = FAN_SPEED_MAX;	// amplifer run with max fan speed
     172:	87 e0       	ldi	r24, 0x07	; 7
     174:	80 93 70 00 	sts	0x0070, r24
/***********************************
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
     178:	0e 94 80 00 	call	0x100	; 0x100 <timer1_on_speed>
		transmitUartString("[UART INFO] Fan is always on, it isn't sensitive to temperature, because DS18S20 is disabling\r\n");
	#endif
//	FAN_high();			// PORTD5 - FAN ON (logic "1")	NON PWM, NON TIMER1	
	fanSpeed = FAN_SPEED_MAX;	// amplifer run with max fan speed
	fan_pwm_control_speed();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1
	timer2_on();	// enable auto regular fan by temp sensor
     17c:	0e 94 96 00 	call	0x12c	; 0x12c <timer2_on>

// RELAYS ON FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays for power 220V\r\n");		// uart debug information string
	#endif
	REL_POWER_high();// RELAY POWER ON TRAFs		// PESHO COMMENT 14.08.2015, 21:10
     180:	aa 9a       	sbi	0x15, 2	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     182:	2f ef       	ldi	r18, 0xFF	; 255
     184:	8f e4       	ldi	r24, 0x4F	; 79
     186:	93 ec       	ldi	r25, 0xC3	; 195
     188:	21 50       	subi	r18, 0x01	; 1
     18a:	80 40       	sbci	r24, 0x00	; 0
     18c:	90 40       	sbci	r25, 0x00	; 0
     18e:	e1 f7       	brne	.-8      	; 0x188 <ampliferOn+0x4c>
     190:	00 c0       	rjmp	.+0      	; 0x192 <ampliferOn+0x56>
     192:	00 00       	nop
	_delay_ms(4000);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays in for all 6 channels\r\n");		// uart debug information string
	#endif
	relays_in1_6ch();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     194:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <relays_in1_6ch>
     198:	2f ef       	ldi	r18, 0xFF	; 255
     19a:	8d e2       	ldi	r24, 0x2D	; 45
     19c:	92 e2       	ldi	r25, 0x22	; 34
     19e:	21 50       	subi	r18, 0x01	; 1
     1a0:	80 40       	sbci	r24, 0x00	; 0
     1a2:	90 40       	sbci	r25, 0x00	; 0
     1a4:	e1 f7       	brne	.-8      	; 0x19e <ampliferOn+0x62>
     1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <ampliferOn+0x6c>
     1a8:	00 00       	nop
	_delay_ms(700);									// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays out for all 6 channels\r\n");		// uart debug information string
	#endif
	relays_out_6ch();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     1aa:	0e 94 23 0a 	call	0x1446	; 0x1446 <relays_out_6ch>
     1ae:	2f ef       	ldi	r18, 0xFF	; 255
     1b0:	83 ed       	ldi	r24, 0xD3	; 211
     1b2:	90 e3       	ldi	r25, 0x30	; 48
     1b4:	21 50       	subi	r18, 0x01	; 1
     1b6:	80 40       	sbci	r24, 0x00	; 0
     1b8:	90 40       	sbci	r25, 0x00	; 0
     1ba:	e1 f7       	brne	.-8      	; 0x1b4 <ampliferOn+0x78>
     1bc:	00 c0       	rjmp	.+0      	; 0x1be <ampliferOn+0x82>
     1be:	00 00       	nop
// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan rotation with min speed\r\n");
		transmitUartString("[UART INFO] Fan manual controlling with remote menu up to speed step up and menu down button to speed step down\r\n");
	#endif	
	fanSpeed = FAN_SPEED_MIN;	// amplifer works with min fan speed
     1c0:	81 e0       	ldi	r24, 0x01	; 1
     1c2:	80 93 70 00 	sts	0x0070, r24
/***********************************
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
     1c6:	0c 94 80 00 	jmp	0x100	; 0x100 <timer1_on_speed>

000001ca <ampliferOff>:
/*********************
**** AMPLIFER OFF ****
*********************/
void ampliferOff(void)
{
	flagStatusBits->flagPower = 0;		// flag for amplifer off
     1ca:	e0 91 6a 04 	lds	r30, 0x046A
     1ce:	f0 91 6b 04 	lds	r31, 0x046B
     1d2:	80 81       	ld	r24, Z
     1d4:	8e 7f       	andi	r24, 0xFE	; 254
     1d6:	80 83       	st	Z, r24

	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer Off    ");	// 20 symbols
     1de:	87 ef       	ldi	r24, 0xF7	; 247
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>

	LCD_COMMAND(LCD_OFF);						// LCD ON without CURSOR
     1e6:	88 e0       	ldi	r24, 0x08	; 8
     1e8:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>

// RELAYS OFF FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays out for all 6 channels\r\n");		// uart debug information string
	#endif
	relays_out_off();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     1ec:	0e 94 26 0a 	call	0x144c	; 0x144c <relays_out_off>
     1f0:	2f ef       	ldi	r18, 0xFF	; 255
     1f2:	8d e2       	ldi	r24, 0x2D	; 45
     1f4:	92 e2       	ldi	r25, 0x22	; 34
     1f6:	21 50       	subi	r18, 0x01	; 1
     1f8:	80 40       	sbci	r24, 0x00	; 0
     1fa:	90 40       	sbci	r25, 0x00	; 0
     1fc:	e1 f7       	brne	.-8      	; 0x1f6 <ampliferOff+0x2c>
     1fe:	00 c0       	rjmp	.+0      	; 0x200 <ampliferOff+0x36>
     200:	00 00       	nop
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays in for all 6 channels\r\n");		// uart debug information string
	#endif
	relays_in_off();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     202:	0e 94 00 0a 	call	0x1400	; 0x1400 <relays_in_off>
     206:	2f ef       	ldi	r18, 0xFF	; 255
     208:	8d e2       	ldi	r24, 0x2D	; 45
     20a:	92 e2       	ldi	r25, 0x22	; 34
     20c:	21 50       	subi	r18, 0x01	; 1
     20e:	80 40       	sbci	r24, 0x00	; 0
     210:	90 40       	sbci	r25, 0x00	; 0
     212:	e1 f7       	brne	.-8      	; 0x20c <ampliferOff+0x42>
     214:	00 c0       	rjmp	.+0      	; 0x216 <ampliferOff+0x4c>
     216:	00 00       	nop
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays for power 220V\r\n");		// uart debug information string
	#endif
	REL_POWER_low();// RELAY POWER OFF				// PESHO COMMENT 14.08.2015, 21:10
     218:	aa 98       	cbi	0x15, 2	; 21

// FANS FUNC & MESSAGE
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Fan is off\r\n");
     21a:	8c e0       	ldi	r24, 0x0C	; 12
     21c:	91 e0       	ldi	r25, 0x01	; 1
     21e:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
{
	timer1_on_speed();
}
void fan_pwm_off(void)
{
	timer1_off();
     222:	0e 94 8d 00 	call	0x11a	; 0x11a <timer1_off>
		transmitUartString("[UART INFO] Fan is off\r\n");
	#endif
	fan_pwm_off();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1

// FANS FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();
     226:	0e 94 37 07 	call	0xe6e	; 0xe6e <LCD_CLEAR_CONTAIN>
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display off and status led on\r\n");
	#endif

// LED ON FUNC
	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     22a:	94 9a       	sbi	0x12, 4	; 18
     22c:	2f ef       	ldi	r18, 0xFF	; 255
     22e:	89 e6       	ldi	r24, 0x69	; 105
     230:	98 e1       	ldi	r25, 0x18	; 24
     232:	21 50       	subi	r18, 0x01	; 1
     234:	80 40       	sbci	r24, 0x00	; 0
     236:	90 40       	sbci	r25, 0x00	; 0
     238:	e1 f7       	brne	.-8      	; 0x232 <ampliferOff+0x68>
     23a:	00 c0       	rjmp	.+0      	; 0x23c <ampliferOff+0x72>
     23c:	00 00       	nop
     23e:	08 95       	ret

00000240 <volumeUpdate>:
/*************************************
**** VOLUME UPDATE and LCD UPDATE ****
*************************************/
void volumeUpdate(void)
{
	PGA2310_Volume_Update(volumeValue[volumeIndex], volumeValue[volumeIndex]);	// update volume value on all channels
     240:	e0 91 57 04 	lds	r30, 0x0457
     244:	f0 e0       	ldi	r31, 0x00	; 0
     246:	ef 57       	subi	r30, 0x7F	; 127
     248:	ff 4f       	sbci	r31, 0xFF	; 255
     24a:	80 81       	ld	r24, Z
     24c:	68 2f       	mov	r22, r24
     24e:	0e 94 3b 08 	call	0x1076	; 0x1076 <PGA2310_Volume_Update>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     252:	84 ed       	ldi	r24, 0xD4	; 212
     254:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
//		LCD_DATA_STRING("Volume: ");	// 20 symbols
	if (volumeIndex > 9)
     258:	80 91 57 04 	lds	r24, 0x0457
     25c:	8a 30       	cpi	r24, 0x0A	; 10
     25e:	18 f0       	brcs	.+6      	; 0x266 <volumeUpdate+0x26>
	{
		LCD_DATA_STRING("Volume: ");	// 20 symbols
     260:	8b e3       	ldi	r24, 0x3B	; 59
     262:	91 e0       	ldi	r25, 0x01	; 1
     264:	02 c0       	rjmp	.+4      	; 0x26a <volumeUpdate+0x2a>
	}
	else
	{
		LCD_DATA_STRING("Volume: 0");	// 20 symbols
     266:	85 e2       	ldi	r24, 0x25	; 37
     268:	91 e0       	ldi	r25, 0x01	; 1
     26a:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
	}
	LCD_DATA_INT(volumeIndex);			// 20 symbols
     26e:	80 91 57 04 	lds	r24, 0x0457
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	0e 94 87 07 	call	0xf0e	; 0xf0e <LCD_DATA_INT>
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Volume: ");		// uart debug information string
     278:	8f e2       	ldi	r24, 0x2F	; 47
     27a:	91 e0       	ldi	r25, 0x01	; 1
     27c:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(volumeIndex);		// uart debug information string 
     280:	80 91 57 04 	lds	r24, 0x0457
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString("\r\n");			// uart debug information string
     28a:	88 ee       	ldi	r24, 0xE8	; 232
     28c:	92 e0       	ldi	r25, 0x02	; 2
     28e:	0c 94 7d 08 	jmp	0x10fa	; 0x10fa <transmitUartString>

00000292 <volumeProcess>:
**** VOLUME PROCESS FUNCTION FROM ENCODER ****
*********************************************/
void volumeProcess(void)
{
	signed char temp = 0;//, tempEnc = 0, tempRem = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     292:	0e 94 70 09 	call	0x12e0	; 0x12e0 <rotaryEncoderNikBarzakov>
	if(0==temp)
     296:	88 23       	and	r24, r24
     298:	a9 f0       	breq	.+42     	; 0x2c4 <volumeProcess+0x32>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     29a:	8f 3f       	cpi	r24, 0xFF	; 255
     29c:	49 f4       	brne	.+18     	; 0x2b0 <volumeProcess+0x1e>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     29e:	80 91 57 04 	lds	r24, 0x0457
     2a2:	88 23       	and	r24, r24
     2a4:	19 f0       	breq	.+6      	; 0x2ac <volumeProcess+0x1a>
		{
			volumeIndex = VOLUME_MUTE;
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     2a6:	81 50       	subi	r24, 0x01	; 1
     2a8:	80 93 57 04 	sts	0x0457, r24
		}
		volumeUpdate();
     2ac:	0c 94 20 01 	jmp	0x240	; 0x240 <volumeUpdate>
	}
	else if(1==temp)
     2b0:	81 30       	cpi	r24, 0x01	; 1
     2b2:	41 f4       	brne	.+16     	; 0x2c4 <volumeProcess+0x32>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     2b4:	80 91 57 04 	lds	r24, 0x0457
     2b8:	83 31       	cpi	r24, 0x13	; 19
     2ba:	10 f0       	brcs	.+4      	; 0x2c0 <volumeProcess+0x2e>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     2bc:	83 e1       	ldi	r24, 0x13	; 19
     2be:	f4 cf       	rjmp	.-24     	; 0x2a8 <volumeProcess+0x16>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     2c0:	8f 5f       	subi	r24, 0xFF	; 255
     2c2:	f2 cf       	rjmp	.-28     	; 0x2a8 <volumeProcess+0x16>
     2c4:	08 95       	ret

000002c6 <volumeMute>:
/************************************
**** VOLUME MUTE/UNMUTE FUNCTION ****
************************************/
void volumeMute(void)
{
	if(flagStatusBits->flagMute == 0)
     2c6:	e0 91 6a 04 	lds	r30, 0x046A
     2ca:	f0 91 6b 04 	lds	r31, 0x046B
     2ce:	80 81       	ld	r24, Z
     2d0:	81 fd       	sbrc	r24, 1
     2d2:	09 c0       	rjmp	.+18     	; 0x2e6 <volumeMute+0x20>
	{
		volumeBuffer = volumeIndex;		// strore volume volue
     2d4:	80 91 57 04 	lds	r24, 0x0457
     2d8:	80 93 58 04 	sts	0x0458, r24
		volumeIndex = VOLUME_MUTE;		// MUTE ON
     2dc:	10 92 57 04 	sts	0x0457, r1
		flagStatusBits->flagMute = 1;	// MUTE ON
     2e0:	80 81       	ld	r24, Z
     2e2:	82 60       	ori	r24, 0x02	; 2
     2e4:	08 c0       	rjmp	.+16     	; 0x2f6 <volumeMute+0x30>
			transmitUartString("[UART INFO] Volume mute is on\r\n");
		#endif
	}
	else
	{
		volumeIndex = volumeBuffer;		// MUTE OFF
     2e6:	80 91 58 04 	lds	r24, 0x0458
     2ea:	80 93 57 04 	sts	0x0457, r24
		volumeBuffer = VOLUME_MUTE;		// clear volume volue
     2ee:	10 92 58 04 	sts	0x0458, r1
		flagStatusBits->flagMute = 0;	// MUTE OFF
     2f2:	80 81       	ld	r24, Z
     2f4:	8d 7f       	andi	r24, 0xFD	; 253
     2f6:	80 83       	st	Z, r24
		#ifdef DEBUG_INFO
			transmitUartString("[UART INFO] Volume mute is off\r\n");
		#endif
	}
	volumeUpdate();
     2f8:	0c 94 20 01 	jmp	0x240	; 0x240 <volumeUpdate>

000002fc <volumeProcessRemote>:
/********************************************
**** VOLUME PROCESS FUNCTION FROM REMOTE ****
********************************************/
void volumeProcessRemote(signed char temp)
{
	if(-1==temp)
     2fc:	8f 3f       	cpi	r24, 0xFF	; 255
     2fe:	49 f4       	brne	.+18     	; 0x312 <volumeProcessRemote+0x16>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     300:	80 91 57 04 	lds	r24, 0x0457
     304:	88 23       	and	r24, r24
     306:	19 f0       	breq	.+6      	; 0x30e <volumeProcessRemote+0x12>
		{
			volumeIndex = VOLUME_MUTE;
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     308:	81 50       	subi	r24, 0x01	; 1
     30a:	80 93 57 04 	sts	0x0457, r24
		}
		volumeUpdate();
     30e:	0c 94 20 01 	jmp	0x240	; 0x240 <volumeUpdate>
	}
	else if(1==temp)
     312:	81 30       	cpi	r24, 0x01	; 1
     314:	41 f4       	brne	.+16     	; 0x326 <volumeProcessRemote+0x2a>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     316:	80 91 57 04 	lds	r24, 0x0457
     31a:	83 31       	cpi	r24, 0x13	; 19
     31c:	10 f0       	brcs	.+4      	; 0x322 <volumeProcessRemote+0x26>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     31e:	83 e1       	ldi	r24, 0x13	; 19
     320:	f4 cf       	rjmp	.-24     	; 0x30a <volumeProcessRemote+0xe>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     322:	8f 5f       	subi	r24, 0xFF	; 255
     324:	f2 cf       	rjmp	.-28     	; 0x30a <volumeProcessRemote+0xe>
     326:	08 95       	ret

00000328 <commonEncoder>:
**********************************************/
void commonEncoder(void)	// not finished
{
	static signed char saveValue = 0;	// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!! static ???
	signed char temp = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     328:	0e 94 70 09 	call	0x12e0	; 0x12e0 <rotaryEncoderNikBarzakov>
	if(0==temp)
     32c:	88 23       	and	r24, r24
     32e:	79 f1       	breq	.+94     	; 0x38e <commonEncoder+0x66>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     330:	8f 3f       	cpi	r24, 0xFF	; 255
     332:	41 f4       	brne	.+16     	; 0x344 <commonEncoder+0x1c>
	{
		// encoder is decrement
		if(saveValue < -127)
     334:	80 91 59 04 	lds	r24, 0x0459
     338:	80 38       	cpi	r24, 0x80	; 128
     33a:	11 f4       	brne	.+4      	; 0x340 <commonEncoder+0x18>
		{
			saveValue = 127;	// SIGNED CHAR MIN VALUE = -127
     33c:	8f e7       	ldi	r24, 0x7F	; 127
     33e:	07 c0       	rjmp	.+14     	; 0x34e <commonEncoder+0x26>
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     340:	81 50       	subi	r24, 0x01	; 1
     342:	05 c0       	rjmp	.+10     	; 0x34e <commonEncoder+0x26>
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
	}
	else if(1==temp)
     344:	81 30       	cpi	r24, 0x01	; 1
     346:	19 f5       	brne	.+70     	; 0x38e <commonEncoder+0x66>
		{
			saveValue = 128;	// SIGNED CHAR MAX VALUE = +128
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     348:	80 91 59 04 	lds	r24, 0x0459
     34c:	8f 5f       	subi	r24, 0xFF	; 255
     34e:	80 93 59 04 	sts	0x0459, r24
		}

	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     352:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     354:	8c e0       	ldi	r24, 0x0C	; 12
     356:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     35a:	84 ed       	ldi	r24, 0xD4	; 212
     35c:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
		if (saveValue > 99)
     360:	80 91 59 04 	lds	r24, 0x0459
     364:	84 36       	cpi	r24, 0x64	; 100
     366:	1c f0       	brlt	.+6      	; 0x36e <commonEncoder+0x46>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     368:	8b e3       	ldi	r24, 0x3B	; 59
     36a:	91 e0       	ldi	r25, 0x01	; 1
     36c:	07 c0       	rjmp	.+14     	; 0x37c <commonEncoder+0x54>
		}
		else if (saveValue > 9)
     36e:	8a 30       	cpi	r24, 0x0A	; 10
     370:	1c f0       	brlt	.+6      	; 0x378 <commonEncoder+0x50>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     372:	85 e2       	ldi	r24, 0x25	; 37
     374:	91 e0       	ldi	r25, 0x01	; 1
     376:	02 c0       	rjmp	.+4      	; 0x37c <commonEncoder+0x54>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     378:	84 e4       	ldi	r24, 0x44	; 68
     37a:	91 e0       	ldi	r25, 0x01	; 1
     37c:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     380:	80 91 59 04 	lds	r24, 0x0459
     384:	99 27       	eor	r25, r25
     386:	87 fd       	sbrc	r24, 7
     388:	90 95       	com	r25
     38a:	0c 94 87 07 	jmp	0xf0e	; 0xf0e <LCD_DATA_INT>
     38e:	08 95       	ret

00000390 <oneWireLeft>:

/*******************************************
**** 1-WIRE DS18x20 Temperature Sensors ****
*******************************************/
unsigned char oneWireLeft()
{
     390:	cf 93       	push	r28
     392:	df 93       	push	r29

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT ROMCODE: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     394:	0e 94 ad 05 	call	0xb5a	; 0xb5a <reset>
     398:	81 11       	cpse	r24, r1
     39a:	02 c0       	rjmp	.+4      	; 0x3a0 <oneWireLeft+0x10>
			return 1;
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
     39c:	80 e0       	ldi	r24, 0x00	; 0
     39e:	2e c0       	rjmp	.+92     	; 0x3fc <oneWireLeft+0x6c>
		transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT ROMCODE: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
	{
		write_byte(0x55);	// Master issues Match ROM command.
     3a0:	85 e5       	ldi	r24, 0x55	; 85
     3a2:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
     3a6:	c9 e7       	ldi	r28, 0x79	; 121
     3a8:	d0 e0       	ldi	r29, 0x00	; 0
		for(i=0; i<8; i++)
		{
			write_byte(leftTempSensorRomCode[i]);	// 64-bit ROM CODE
     3aa:	89 91       	ld	r24, Y+
     3ac:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
	{
		write_byte(0x55);	// Master issues Match ROM command.
		for(i=0; i<8; i++)
     3b0:	80 e0       	ldi	r24, 0x00	; 0
     3b2:	c1 38       	cpi	r28, 0x81	; 129
     3b4:	d8 07       	cpc	r29, r24
     3b6:	c9 f7       	brne	.-14     	; 0x3aa <oneWireLeft+0x1a>
		write_byte(0x08);	// Byte 5
		write_byte(0x00);	// Byte 6
		write_byte(0xC1);	// Byte 7
		// 64-bit ROM CODE
*/
		write_byte(0x44);	// Master issues Convert T command.
     3b8:	84 e4       	ldi	r24, 0x44	; 68
     3ba:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     3be:	0e 94 2d 06 	call	0xc5a	; 0xc5a <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     3c2:	0e 94 ad 05 	call	0xb5a	; 0xb5a <reset>
     3c6:	88 23       	and	r24, r24
     3c8:	49 f3       	breq	.-46     	; 0x39c <oneWireLeft+0xc>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     3ca:	85 e5       	ldi	r24, 0x55	; 85
     3cc:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
     3d0:	c9 e7       	ldi	r28, 0x79	; 121
     3d2:	d0 e0       	ldi	r29, 0x00	; 0
			for(i=0; i<8; i++)
			{
				write_byte(leftTempSensorRomCode[i]);	// 64-bit ROM CODE
     3d4:	89 91       	ld	r24, Y+
     3d6:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
		write_byte(0x44);	// Master issues Convert T command.
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
		{
			write_byte(0x55);	// Master issues Match ROM command.
			for(i=0; i<8; i++)
     3da:	80 e0       	ldi	r24, 0x00	; 0
     3dc:	c1 38       	cpi	r28, 0x81	; 129
     3de:	d8 07       	cpc	r29, r24
     3e0:	c9 f7       	brne	.-14     	; 0x3d4 <oneWireLeft+0x44>
			write_byte(0x08);	// Byte 5
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
     3e2:	8e eb       	ldi	r24, 0xBE	; 190
     3e4:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
     3e8:	cd e4       	ldi	r28, 0x4D	; 77
     3ea:	d4 e0       	ldi	r29, 0x04	; 4
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     3ec:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <read_byte>
     3f0:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     3f2:	84 e0       	ldi	r24, 0x04	; 4
     3f4:	c6 35       	cpi	r28, 0x56	; 86
     3f6:	d8 07       	cpc	r29, r24
     3f8:	c9 f7       	brne	.-14     	; 0x3ec <oneWireLeft+0x5c>
     3fa:	81 e0       	ldi	r24, 0x01	; 1
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     3fc:	df 91       	pop	r29
     3fe:	cf 91       	pop	r28
     400:	08 95       	ret

00000402 <oneWireRight>:

unsigned char oneWireRight()
{
     402:	cf 93       	push	r28
     404:	df 93       	push	r29

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT ROMCODE: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     406:	0e 94 ad 05 	call	0xb5a	; 0xb5a <reset>
     40a:	81 11       	cpse	r24, r1
     40c:	02 c0       	rjmp	.+4      	; 0x412 <oneWireRight+0x10>
			return 1;
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
     40e:	80 e0       	ldi	r24, 0x00	; 0
     410:	2e c0       	rjmp	.+92     	; 0x46e <oneWireRight+0x6c>
		transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT ROMCODE: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
	{
		write_byte(0x55);	// Master issues Match ROM command.
     412:	85 e5       	ldi	r24, 0x55	; 85
     414:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
     418:	c1 e7       	ldi	r28, 0x71	; 113
     41a:	d0 e0       	ldi	r29, 0x00	; 0
		for(i=0; i<8; i++)
		{
			write_byte(rightTempSensorRomCode[i]);	// 64-bit ROM CODE
     41c:	89 91       	ld	r24, Y+
     41e:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
	{
		write_byte(0x55);	// Master issues Match ROM command.
		for(i=0; i<8; i++)
     422:	80 e0       	ldi	r24, 0x00	; 0
     424:	c9 37       	cpi	r28, 0x79	; 121
     426:	d8 07       	cpc	r29, r24
     428:	c9 f7       	brne	.-14     	; 0x41c <oneWireRight+0x1a>
		write_byte(0x08);	// Byte 5
		write_byte(0x00);	// Byte 6
		write_byte(0xB1);	// Byte 7
		// 64-bit ROM CODE
*/
		write_byte(0x44);	// Master issues Convert T command.
     42a:	84 e4       	ldi	r24, 0x44	; 68
     42c:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     430:	0e 94 2d 06 	call	0xc5a	; 0xc5a <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     434:	0e 94 ad 05 	call	0xb5a	; 0xb5a <reset>
     438:	88 23       	and	r24, r24
     43a:	49 f3       	breq	.-46     	; 0x40e <oneWireRight+0xc>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     43c:	85 e5       	ldi	r24, 0x55	; 85
     43e:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
     442:	c1 e7       	ldi	r28, 0x71	; 113
     444:	d0 e0       	ldi	r29, 0x00	; 0
			for(i=0; i<8; i++)
			{
				write_byte(rightTempSensorRomCode[i]);	// 64-bit ROM CODE
     446:	89 91       	ld	r24, Y+
     448:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
		write_byte(0x44);	// Master issues Convert T command.
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
		{
			write_byte(0x55);	// Master issues Match ROM command.
			for(i=0; i<8; i++)
     44c:	80 e0       	ldi	r24, 0x00	; 0
     44e:	c9 37       	cpi	r28, 0x79	; 121
     450:	d8 07       	cpc	r29, r24
     452:	c9 f7       	brne	.-14     	; 0x446 <oneWireRight+0x44>
			write_byte(0x08);	// Byte 5
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
     454:	8e eb       	ldi	r24, 0xBE	; 190
     456:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
     45a:	cd e4       	ldi	r28, 0x4D	; 77
     45c:	d4 e0       	ldi	r29, 0x04	; 4
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     45e:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <read_byte>
     462:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     464:	84 e0       	ldi	r24, 0x04	; 4
     466:	c6 35       	cpi	r28, 0x56	; 86
     468:	d8 07       	cpc	r29, r24
     46a:	c9 f7       	brne	.-14     	; 0x45e <oneWireRight+0x5c>
     46c:	81 e0       	ldi	r24, 0x01	; 1
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     46e:	df 91       	pop	r29
     470:	cf 91       	pop	r28
     472:	08 95       	ret

00000474 <temperMeasur>:

char temperMeasur(unsigned char byte0, unsigned char byte1, unsigned char byte6, unsigned char byte7)
{
     474:	0f 93       	push	r16
     476:	1f 93       	push	r17
     478:	cf 93       	push	r28
     47a:	df 93       	push	r29
	char tC = 0;
	char temper = 0;
	double k = 0;
	double j = 0;

	byte0 = storeTemp [0];
     47c:	80 91 4d 04 	lds	r24, 0x044D
	byte1 = storeTemp [1];
     480:	90 91 4e 04 	lds	r25, 0x044E
	byte6 = storeTemp [6];
	byte7 = storeTemp [7];

	k = ((byte7 - byte6) / byte7) + 0.25;

	if((byte1 == 0x00) && (byte0 == 0x00))
     484:	91 11       	cpse	r25, r1
     486:	1d c0       	rjmp	.+58     	; 0x4c2 <temperMeasur+0x4e>
     488:	81 11       	cpse	r24, r1
     48a:	0a c0       	rjmp	.+20     	; 0x4a0 <temperMeasur+0x2c>
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
		transmitUartInt(tC);		// uart debug information string 
		transmitUartString(".0 C\r\n");			// uart debug information string
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     48c:	80 e0       	ldi	r24, 0x00	; 0
     48e:	90 e0       	ldi	r25, 0x00	; 0
     490:	0e 94 87 07 	call	0xf0e	; 0xf0e <LCD_DATA_INT>
	LCD_DATA_STRING(".0 C");		//
     494:	8f e4       	ldi	r24, 0x4F	; 79
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>

	k = ((byte7 - byte6) / byte7) + 0.25;

	if((byte1 == 0x00) && (byte0 == 0x00))
	{
		tC = (byte0/2);
     49c:	80 e0       	ldi	r24, 0x00	; 0
		transmitUartInt(tC);		// uart debug information string 
		transmitUartString(".0 C\r\n");			// uart debug information string
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
	LCD_DATA_STRING(".0 C");		//
     49e:	2c c0       	rjmp	.+88     	; 0x4f8 <temperMeasur+0x84>
	}
	else if((byte1 == 0x00) && (byte0 != 0x00))
	{
//		transmitUartString("+");		// POSITIVE TEMPERATURE
		tC = (byte0/2);
     4a0:	c8 2f       	mov	r28, r24
     4a2:	c6 95       	lsr	r28
		j = tC - k;
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Temperature: +");		// uart debug information string
     4a4:	84 e5       	ldi	r24, 0x54	; 84
     4a6:	91 e0       	ldi	r25, 0x01	; 1
     4a8:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     4ac:	0c 2f       	mov	r16, r28
     4ae:	10 e0       	ldi	r17, 0x00	; 0
     4b0:	c8 01       	movw	r24, r16
     4b2:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString(".0 C\r\n");			// uart debug information string
     4b6:	8f e6       	ldi	r24, 0x6F	; 111
     4b8:	91 e0       	ldi	r25, 0x01	; 1
     4ba:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     4be:	c8 01       	movw	r24, r16
     4c0:	0e c0       	rjmp	.+28     	; 0x4de <temperMeasur+0x6a>
	LCD_DATA_STRING(".0 C");		//
	}
	else if((byte1 == 0xFF) && (byte0 != 0x00))
     4c2:	9f 3f       	cpi	r25, 0xFF	; 255
     4c4:	a1 f4       	brne	.+40     	; 0x4ee <temperMeasur+0x7a>
     4c6:	88 23       	and	r24, r24
     4c8:	91 f0       	breq	.+36     	; 0x4ee <temperMeasur+0x7a>
	{
//		transmitUartString("-");		// NEGATIVE TEMPERATURE
//		tC = ((byte0 - 255.5) / 2);		// ne e dobre obraboteno za otricatelni chisla
		tC = ((byte0 - 255) / 2);
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	8f 5f       	subi	r24, 0xFF	; 255
     4ce:	91 09       	sbc	r25, r1
     4d0:	97 fd       	sbrc	r25, 7
     4d2:	01 96       	adiw	r24, 0x01	; 1
     4d4:	ec 01       	movw	r28, r24
     4d6:	d5 95       	asr	r29
     4d8:	c7 95       	ror	r28
		transmitUartString("[UART INFO] Temperature: -");		// uart debug information string
		transmitUartInt(tC);		// uart debug information string 
		transmitUartString(".0 C\r\n");			// uart debug information string
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     4da:	ce 01       	movw	r24, r28
     4dc:	99 27       	eor	r25, r25
     4de:	0e 94 87 07 	call	0xf0e	; 0xf0e <LCD_DATA_INT>
	LCD_DATA_STRING(".0 C");		//
     4e2:	8f e4       	ldi	r24, 0x4F	; 79
     4e4:	91 e0       	ldi	r25, 0x01	; 1
     4e6:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
	}
	else if((byte1 == 0xFF) && (byte0 != 0x00))
	{
//		transmitUartString("-");		// NEGATIVE TEMPERATURE
//		tC = ((byte0 - 255.5) / 2);		// ne e dobre obraboteno za otricatelni chisla
		tC = ((byte0 - 255) / 2);
     4ea:	8c 2f       	mov	r24, r28
		transmitUartInt(tC);		// uart debug information string 
		transmitUartString(".0 C\r\n");			// uart debug information string
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
	LCD_DATA_STRING(".0 C");		//
     4ec:	05 c0       	rjmp	.+10     	; 0x4f8 <temperMeasur+0x84>
	}
	else
	{
		//lcdDataString("ERROR!");	// ERROR not return to display!!!!
	#ifdef DEBUG_ERROR
		transmitUartString("[UART ERROR] ERROR TEMPERATURE\r\n");		// uart debug information string
     4ee:	86 e7       	ldi	r24, 0x76	; 118
     4f0:	91 e0       	ldi	r25, 0x01	; 1
     4f2:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
	#endif
		return 1;
     4f6:	81 e0       	ldi	r24, 0x01	; 1
	}
	temper = tC;

	return temper;
}
     4f8:	df 91       	pop	r29
     4fa:	cf 91       	pop	r28
     4fc:	1f 91       	pop	r17
     4fe:	0f 91       	pop	r16
     500:	08 95       	ret

00000502 <temperature>:

/*****************************
**** TEMPERATURE FUNCTION ****
*****************************/
void temperature()
{
     502:	0f 93       	push	r16
     504:	1f 93       	push	r17
     506:	cf 93       	push	r28
     508:	df 93       	push	r29
	unsigned char i;
//	LED_low_DISPLAYLED_high();
//	LCD_INIT();								// LCD INITIZLIZATION
	LCD_CLEAR_CONTAIN();
     50a:	0e 94 37 07 	call	0xe6e	; 0xe6e <LCD_CLEAR_CONTAIN>

	LCD_COMMAND(LCD_SELECT_1ROW);	// select row 1
     50e:	80 e0       	ldi	r24, 0x00	; 0
     510:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
	LCD_DATA_STRING("     TEMERATURE     ");		//
     514:	87 e9       	ldi	r24, 0x97	; 151
     516:	91 e0       	ldi	r25, 0x01	; 1
     518:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
     51c:	80 ec       	ldi	r24, 0xC0	; 192
     51e:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
	LCD_DATA_STRING("LEFT  SENSOR: ");				//
     522:	8c ea       	ldi	r24, 0xAC	; 172
     524:	91 e0       	ldi	r25, 0x01	; 1
     526:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>

	oneWireLeft();
     52a:	0e 94 c8 01 	call	0x390	; 0x390 <oneWireLeft>
     52e:	0d e4       	ldi	r16, 0x4D	; 77
     530:	14 e0       	ldi	r17, 0x04	; 4
     532:	c0 e0       	ldi	r28, 0x00	; 0
     534:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] byte ");
     536:	8b eb       	ldi	r24, 0xBB	; 187
     538:	91 e0       	ldi	r25, 0x01	; 1
     53a:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(i);
     53e:	ce 01       	movw	r24, r28
     540:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString(" : ");
     544:	8d ec       	ldi	r24, 0xCD	; 205
     546:	91 e0       	ldi	r25, 0x01	; 1
     548:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(storeTemp[i]);
     54c:	f8 01       	movw	r30, r16
     54e:	81 91       	ld	r24, Z+
     550:	8f 01       	movw	r16, r30
     552:	90 e0       	ldi	r25, 0x00	; 0
     554:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString("\r\n");
     558:	88 ee       	ldi	r24, 0xE8	; 232
     55a:	92 e0       	ldi	r25, 0x02	; 2
     55c:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
     560:	21 96       	adiw	r28, 0x01	; 1
	LCD_DATA_STRING("     TEMERATURE     ");		//
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
	LCD_DATA_STRING("LEFT  SENSOR: ");				//

	oneWireLeft();
	for(i=0; i<9; i++)
     562:	c9 30       	cpi	r28, 0x09	; 9
     564:	d1 05       	cpc	r29, r1
     566:	39 f7       	brne	.-50     	; 0x536 <temperature+0x34>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     568:	20 91 64 04 	lds	r18, 0x0464
     56c:	40 91 67 04 	lds	r20, 0x0467
     570:	60 91 68 04 	lds	r22, 0x0468
     574:	80 91 6c 04 	lds	r24, 0x046C
     578:	0e 94 3a 02 	call	0x474	; 0x474 <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
     57c:	84 e9       	ldi	r24, 0x94	; 148
     57e:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
     582:	81 ed       	ldi	r24, 0xD1	; 209
     584:	91 e0       	ldi	r25, 0x01	; 1
     586:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
	oneWireRight();
     58a:	0e 94 01 02 	call	0x402	; 0x402 <oneWireRight>
     58e:	0d e4       	ldi	r16, 0x4D	; 77
     590:	14 e0       	ldi	r17, 0x04	; 4
     592:	c0 e0       	ldi	r28, 0x00	; 0
     594:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] byte ");
     596:	8b eb       	ldi	r24, 0xBB	; 187
     598:	91 e0       	ldi	r25, 0x01	; 1
     59a:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(i);
     59e:	ce 01       	movw	r24, r28
     5a0:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString(" : ");
     5a4:	8d ec       	ldi	r24, 0xCD	; 205
     5a6:	91 e0       	ldi	r25, 0x01	; 1
     5a8:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(storeTemp[i]);
     5ac:	f8 01       	movw	r30, r16
     5ae:	81 91       	ld	r24, Z+
     5b0:	8f 01       	movw	r16, r30
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString("\r\n");
     5b8:	88 ee       	ldi	r24, 0xE8	; 232
     5ba:	92 e0       	ldi	r25, 0x02	; 2
     5bc:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
     5c0:	21 96       	adiw	r28, 0x01	; 1
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
	oneWireRight();
	for(i=0; i<9; i++)
     5c2:	c9 30       	cpi	r28, 0x09	; 9
     5c4:	d1 05       	cpc	r29, r1
     5c6:	39 f7       	brne	.-50     	; 0x596 <temperature+0x94>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     5c8:	20 91 64 04 	lds	r18, 0x0464
     5cc:	40 91 67 04 	lds	r20, 0x0467
     5d0:	60 91 68 04 	lds	r22, 0x0468
     5d4:	80 91 6c 04 	lds	r24, 0x046C
     5d8:	0e 94 3a 02 	call	0x474	; 0x474 <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
     5dc:	84 ed       	ldi	r24, 0xD4	; 212
     5de:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
	LCD_DATA_STRING("             DS18x20");		//
     5e2:	80 ee       	ldi	r24, 0xE0	; 224
     5e4:	91 e0       	ldi	r25, 0x01	; 1
}
     5e6:	df 91       	pop	r29
     5e8:	cf 91       	pop	r28
     5ea:	1f 91       	pop	r17
     5ec:	0f 91       	pop	r16
	}
	temperMeasur(byte0, byte1, byte6, byte7);
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_STRING("             DS18x20");		//
     5ee:	0c 94 41 07 	jmp	0xe82	; 0xe82 <LCD_DATA_STRING>

000005f2 <irDecode>:
************************************/
void irDecode(void)
{
//	byte byteSS0, byteSS1, byteMM0, byteMM1, byteHH0, byteHH1, byteDD0, byteDD1, byteMont0, byteMont1, byteYY0, byteYY1; // variables for convert DEC to BCD for LCD and UART for Time and Date

	GetSIRC12();
     5f2:	0e 94 2c 0a 	call	0x1458	; 0x1458 <GetSIRC12>
	if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 0)		// IR POWER -> ON
     5f6:	80 91 6e 04 	lds	r24, 0x046E
     5fa:	81 30       	cpi	r24, 0x01	; 1
     5fc:	29 f4       	brne	.+10     	; 0x608 <irDecode+0x16>
     5fe:	90 91 69 04 	lds	r25, 0x0469
     602:	95 31       	cpi	r25, 0x15	; 21
     604:	a1 f4       	brne	.+40     	; 0x62e <irDecode+0x3c>
     606:	07 c0       	rjmp	.+14     	; 0x616 <irDecode+0x24>
     608:	84 30       	cpi	r24, 0x04	; 4
     60a:	09 f0       	breq	.+2      	; 0x60e <irDecode+0x1c>
     60c:	bc c0       	rjmp	.+376    	; 0x786 <irDecode+0x194>
     60e:	90 91 69 04 	lds	r25, 0x0469
     612:	9d 30       	cpi	r25, 0x0D	; 13
     614:	a1 f4       	brne	.+40     	; 0x63e <irDecode+0x4c>
     616:	e0 91 6a 04 	lds	r30, 0x046A
     61a:	f0 91 6b 04 	lds	r31, 0x046B
     61e:	90 81       	ld	r25, Z
     620:	90 fd       	sbrc	r25, 0
     622:	03 c0       	rjmp	.+6      	; 0x62a <irDecode+0x38>
	{		
		ampliferOn();
     624:	0e 94 9e 00 	call	0x13c	; 0x13c <ampliferOn>
     628:	a4 c0       	rjmp	.+328    	; 0x772 <irDecode+0x180>
//		_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 1)	// IR POWER -> OFF
     62a:	81 30       	cpi	r24, 0x01	; 1
     62c:	29 f4       	brne	.+10     	; 0x638 <irDecode+0x46>
     62e:	90 91 69 04 	lds	r25, 0x0469
     632:	95 31       	cpi	r25, 0x15	; 21
     634:	b9 f4       	brne	.+46     	; 0x664 <irDecode+0x72>
     636:	07 c0       	rjmp	.+14     	; 0x646 <irDecode+0x54>
     638:	84 30       	cpi	r24, 0x04	; 4
     63a:	09 f0       	breq	.+2      	; 0x63e <irDecode+0x4c>
     63c:	a4 c0       	rjmp	.+328    	; 0x786 <irDecode+0x194>
     63e:	90 91 69 04 	lds	r25, 0x0469
     642:	9d 30       	cpi	r25, 0x0D	; 13
     644:	79 f4       	brne	.+30     	; 0x664 <irDecode+0x72>
     646:	e0 91 6a 04 	lds	r30, 0x046A
     64a:	f0 91 6b 04 	lds	r31, 0x046B
     64e:	90 81       	ld	r25, Z
     650:	90 ff       	sbrs	r25, 0
     652:	03 c0       	rjmp	.+6      	; 0x65a <irDecode+0x68>
	{
		ampliferOff();
     654:	0e 94 e5 00 	call	0x1ca	; 0x1ca <ampliferOff>
     658:	8c c0       	rjmp	.+280    	; 0x772 <irDecode+0x180>
//		flagPower = 0;			// filter za buton OFF
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLUP)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME UP"
     65a:	81 30       	cpi	r24, 0x01	; 1
     65c:	19 f0       	breq	.+6      	; 0x664 <irDecode+0x72>
     65e:	84 30       	cpi	r24, 0x04	; 4
     660:	09 f0       	breq	.+2      	; 0x664 <irDecode+0x72>
     662:	87 c0       	rjmp	.+270    	; 0x772 <irDecode+0x180>
     664:	90 91 69 04 	lds	r25, 0x0469
     668:	92 31       	cpi	r25, 0x12	; 18
     66a:	99 f4       	brne	.+38     	; 0x692 <irDecode+0xa0>
     66c:	e0 91 6a 04 	lds	r30, 0x046A
     670:	f0 91 6b 04 	lds	r31, 0x046B
     674:	20 81       	ld	r18, Z
     676:	20 ff       	sbrs	r18, 0
     678:	0c c0       	rjmp	.+24     	; 0x692 <irDecode+0xa0>
		volumeUpdate();
	}
	else if(1==temp)
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     67a:	80 91 57 04 	lds	r24, 0x0457
     67e:	83 31       	cpi	r24, 0x13	; 19
     680:	10 f0       	brcs	.+4      	; 0x686 <irDecode+0x94>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     682:	83 e1       	ldi	r24, 0x13	; 19
     684:	01 c0       	rjmp	.+2      	; 0x688 <irDecode+0x96>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     686:	8f 5f       	subi	r24, 0xFF	; 255
     688:	80 93 57 04 	sts	0x0457, r24
		}
		volumeUpdate();
     68c:	0e 94 20 01 	call	0x240	; 0x240 <volumeUpdate>
     690:	70 c0       	rjmp	.+224    	; 0x772 <irDecode+0x180>
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLUP)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME UP"
	{	// VOLUME UP
		volumeProcessRemote(REMOTE_VOLUME_UP);
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLDN)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME DOWN"
     692:	81 30       	cpi	r24, 0x01	; 1
     694:	19 f0       	breq	.+6      	; 0x69c <irDecode+0xaa>
     696:	84 30       	cpi	r24, 0x04	; 4
     698:	09 f0       	breq	.+2      	; 0x69c <irDecode+0xaa>
     69a:	6b c0       	rjmp	.+214    	; 0x772 <irDecode+0x180>
     69c:	93 31       	cpi	r25, 0x13	; 19
     69e:	59 f4       	brne	.+22     	; 0x6b6 <irDecode+0xc4>
     6a0:	e0 91 6a 04 	lds	r30, 0x046A
     6a4:	f0 91 6b 04 	lds	r31, 0x046B
     6a8:	20 81       	ld	r18, Z
     6aa:	20 ff       	sbrs	r18, 0
     6ac:	04 c0       	rjmp	.+8      	; 0x6b6 <irDecode+0xc4>
	{	// VOLUME DOWN
		volumeProcessRemote(REMOTE_VOLUME_DOWN);
     6ae:	8f ef       	ldi	r24, 0xFF	; 255
     6b0:	0e 94 7e 01 	call	0x2fc	; 0x2fc <volumeProcessRemote>
     6b4:	5e c0       	rjmp	.+188    	; 0x772 <irDecode+0x180>
//		break;
	}

	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_ATT)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     6b6:	81 30       	cpi	r24, 0x01	; 1
     6b8:	19 f0       	breq	.+6      	; 0x6c0 <irDecode+0xce>
     6ba:	84 30       	cpi	r24, 0x04	; 4
     6bc:	09 f0       	breq	.+2      	; 0x6c0 <irDecode+0xce>
     6be:	59 c0       	rjmp	.+178    	; 0x772 <irDecode+0x180>
     6c0:	94 31       	cpi	r25, 0x14	; 20
     6c2:	51 f4       	brne	.+20     	; 0x6d8 <irDecode+0xe6>
     6c4:	e0 91 6a 04 	lds	r30, 0x046A
     6c8:	f0 91 6b 04 	lds	r31, 0x046B
     6cc:	80 81       	ld	r24, Z
     6ce:	80 ff       	sbrs	r24, 0
     6d0:	50 c0       	rjmp	.+160    	; 0x772 <irDecode+0x180>
	{	// MUTE
		volumeMute();
     6d2:	0e 94 63 01 	call	0x2c6	; 0x2c6 <volumeMute>
     6d6:	4d c0       	rjmp	.+154    	; 0x772 <irDecode+0x180>
//		break;
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_DOWN)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     6d8:	84 30       	cpi	r24, 0x04	; 4
     6da:	09 f0       	breq	.+2      	; 0x6de <irDecode+0xec>
     6dc:	4a c0       	rjmp	.+148    	; 0x772 <irDecode+0x180>
     6de:	92 33       	cpi	r25, 0x32	; 50
     6e0:	69 f4       	brne	.+26     	; 0x6fc <irDecode+0x10a>
     6e2:	e0 91 6a 04 	lds	r30, 0x046A
     6e6:	f0 91 6b 04 	lds	r31, 0x046B
     6ea:	80 81       	ld	r24, Z
     6ec:	80 ff       	sbrs	r24, 0
     6ee:	41 c0       	rjmp	.+130    	; 0x772 <irDecode+0x180>
	{	// FAN STEP UP
		if(fanSpeed < FAN_SPEED_ABSOLUTE_MIN + 1)//0)
     6f0:	80 91 70 00 	lds	r24, 0x0070
     6f4:	88 23       	and	r24, r24
     6f6:	a1 f0       	breq	.+40     	; 0x720 <irDecode+0x12e>
		{
			fanSpeed = FAN_SPEED_ABSOLUTE_MIN;	//0;	// 0-7
		}
		else
		{
			fanSpeed--;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     6f8:	81 50       	subi	r24, 0x01	; 1
     6fa:	10 c0       	rjmp	.+32     	; 0x71c <irDecode+0x12a>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
		LCD_DATA_STRING(" or ");
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
		fan_pwm_control_speed();
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_UP)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     6fc:	93 33       	cpi	r25, 0x33	; 51
     6fe:	61 f5       	brne	.+88     	; 0x758 <irDecode+0x166>
     700:	e0 91 6a 04 	lds	r30, 0x046A
     704:	f0 91 6b 04 	lds	r31, 0x046B
     708:	80 81       	ld	r24, Z
     70a:	80 ff       	sbrs	r24, 0
     70c:	32 c0       	rjmp	.+100    	; 0x772 <irDecode+0x180>
	{	// FAN STEP DOWN
		if(fanSpeed > FAN_LIMIT_POSITIONS - 2)//7)
     70e:	80 91 70 00 	lds	r24, 0x0070
     712:	87 30       	cpi	r24, 0x07	; 7
     714:	10 f0       	brcs	.+4      	; 0x71a <irDecode+0x128>
		{
			fanSpeed = FAN_LIMIT_POSITIONS - 1;	//7;	// 0-7
     716:	87 e0       	ldi	r24, 0x07	; 7
     718:	01 c0       	rjmp	.+2      	; 0x71c <irDecode+0x12a>
		}
		else
		{
			fanSpeed++;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     71a:	8f 5f       	subi	r24, 0xFF	; 255
     71c:	80 93 70 00 	sts	0x0070, r24
		}
//		fanSpeedStep [fanSpeed];// = { 0x00, 100, 125, 150, 175, 200, 225, 250 };
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     720:	84 ed       	ldi	r24, 0xD4	; 212
     722:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
		LCD_DATA_STRING("Fan Step: ");	// 20 symbols			
     726:	8c e9       	ldi	r24, 0x9C	; 156
     728:	92 e0       	ldi	r25, 0x02	; 2
     72a:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
     72e:	80 91 70 00 	lds	r24, 0x0070
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	0e 94 87 07 	call	0xf0e	; 0xf0e <LCD_DATA_INT>
		LCD_DATA_STRING(" or ");
     738:	85 ef       	ldi	r24, 0xF5	; 245
     73a:	91 e0       	ldi	r25, 0x01	; 1
     73c:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
     740:	e0 91 70 00 	lds	r30, 0x0070
     744:	f0 e0       	ldi	r31, 0x00	; 0
     746:	e8 59       	subi	r30, 0x98	; 152
     748:	ff 4f       	sbci	r31, 0xFF	; 255
     74a:	80 81       	ld	r24, Z
     74c:	90 e0       	ldi	r25, 0x00	; 0
     74e:	0e 94 87 07 	call	0xf0e	; 0xf0e <LCD_DATA_INT>
/***********************************
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
     752:	0e 94 80 00 	call	0x100	; 0x100 <timer1_on_speed>
     756:	0d c0       	rjmp	.+26     	; 0x772 <irDecode+0x180>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
		LCD_DATA_STRING(" or ");
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
		fan_pwm_control_speed();
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_SCRL)) && (flagStatusBits->flagPower == 0 || flagStatusBits->flagPower == 1))						// Sony CarAudio IR Remote Device - "SCRL" -> TEMPERATURE
     758:	93 32       	cpi	r25, 0x23	; 35
     75a:	59 f4       	brne	.+22     	; 0x772 <irDecode+0x180>
	{
		temperature();
     75c:	0e 94 81 02 	call	0x502	; 0x502 <temperature>
     760:	2f ef       	ldi	r18, 0xFF	; 255
     762:	83 ec       	ldi	r24, 0xC3	; 195
     764:	99 e0       	ldi	r25, 0x09	; 9
     766:	21 50       	subi	r18, 0x01	; 1
     768:	80 40       	sbci	r24, 0x00	; 0
     76a:	90 40       	sbci	r25, 0x00	; 0
     76c:	e1 f7       	brne	.-8      	; 0x766 <irDecode+0x174>
     76e:	00 c0       	rjmp	.+0      	; 0x770 <irDecode+0x17e>
     770:	00 00       	nop
     772:	2f ef       	ldi	r18, 0xFF	; 255
     774:	83 ec       	ldi	r24, 0xC3	; 195
     776:	99 e0       	ldi	r25, 0x09	; 9
     778:	21 50       	subi	r18, 0x01	; 1
     77a:	80 40       	sbci	r24, 0x00	; 0
     77c:	90 40       	sbci	r25, 0x00	; 0
     77e:	e1 f7       	brne	.-8      	; 0x778 <irDecode+0x186>
     780:	00 c0       	rjmp	.+0      	; 0x782 <irDecode+0x190>
     782:	00 00       	nop
     784:	08 95       	ret
	{
		ampliferOff();
//		flagPower = 0;			// filter za buton OFF
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLUP)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME UP"
     786:	81 30       	cpi	r24, 0x01	; 1
     788:	a1 f7       	brne	.-24     	; 0x772 <irDecode+0x180>
     78a:	6c cf       	rjmp	.-296    	; 0x664 <irDecode+0x72>

0000078c <autoControlTemperature>:
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_STRING("             DS18x20");		//
}

void autoControlTemperature()
{
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
	unsigned char i;
	char resultL, resultR;

	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Left Temperature Sensor\r\n");
     790:	8a ef       	ldi	r24, 0xFA	; 250
     792:	91 e0       	ldi	r25, 0x01	; 1
     794:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
	#endif
	oneWireLeft();
     798:	0e 94 c8 01 	call	0x390	; 0x390 <oneWireLeft>
	resultL = temperMeasur(byte0, byte1, byte6, byte7);
     79c:	20 91 64 04 	lds	r18, 0x0464
     7a0:	40 91 67 04 	lds	r20, 0x0467
     7a4:	60 91 68 04 	lds	r22, 0x0468
     7a8:	80 91 6c 04 	lds	r24, 0x046C
     7ac:	0e 94 3a 02 	call	0x474	; 0x474 <temperMeasur>
     7b0:	c8 2f       	mov	r28, r24
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] RESULT LEFT Sensor = ");
     7b2:	80 e2       	ldi	r24, 0x20	; 32
     7b4:	92 e0       	ldi	r25, 0x02	; 2
     7b6:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(resultL);
     7ba:	8c 2f       	mov	r24, r28
     7bc:	90 e0       	ldi	r25, 0x00	; 0
     7be:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString("\r\n");
     7c2:	88 ee       	ldi	r24, 0xE8	; 232
     7c4:	92 e0       	ldi	r25, 0x02	; 2
     7c6:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
	#endif

	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Right Temperature Sensor\r\n");
     7ca:	82 e4       	ldi	r24, 0x42	; 66
     7cc:	92 e0       	ldi	r25, 0x02	; 2
     7ce:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
	#endif
	oneWireRight();
     7d2:	0e 94 01 02 	call	0x402	; 0x402 <oneWireRight>
	resultR = temperMeasur(byte0, byte1, byte6, byte7);
     7d6:	20 91 64 04 	lds	r18, 0x0464
     7da:	40 91 67 04 	lds	r20, 0x0467
     7de:	60 91 68 04 	lds	r22, 0x0468
     7e2:	80 91 6c 04 	lds	r24, 0x046C
     7e6:	0e 94 3a 02 	call	0x474	; 0x474 <temperMeasur>
     7ea:	d8 2f       	mov	r29, r24
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] RESULT RIGHT Sensor = ");
     7ec:	89 e6       	ldi	r24, 0x69	; 105
     7ee:	92 e0       	ldi	r25, 0x02	; 2
     7f0:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(resultR);
     7f4:	8d 2f       	mov	r24, r29
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString("\r\n");
     7fc:	88 ee       	ldi	r24, 0xE8	; 232
     7fe:	92 e0       	ldi	r25, 0x02	; 2
     800:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
	#endif
	if((resultL < 20) && (resultR < 20))
     804:	c4 31       	cpi	r28, 0x14	; 20
     806:	28 f4       	brcc	.+10     	; 0x812 <autoControlTemperature+0x86>
     808:	d4 31       	cpi	r29, 0x14	; 20
     80a:	28 f4       	brcc	.+10     	; 0x816 <autoControlTemperature+0x8a>
	{
		fanSpeed = fanSpeedStep [FAN_SPEED_MIN]; // fan value = 100
     80c:	80 91 69 00 	lds	r24, 0x0069
     810:	29 c0       	rjmp	.+82     	; 0x864 <__stack+0x5>
	}
	else if((resultL < 35) && (resultR < 35))
     812:	c3 32       	cpi	r28, 0x23	; 35
     814:	28 f4       	brcc	.+10     	; 0x820 <autoControlTemperature+0x94>
     816:	d3 32       	cpi	r29, 0x23	; 35
     818:	28 f4       	brcc	.+10     	; 0x824 <autoControlTemperature+0x98>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_MIN+1]; // fan value = 125
     81a:	80 91 6a 00 	lds	r24, 0x006A
     81e:	22 c0       	rjmp	.+68     	; 0x864 <__stack+0x5>
	}
	else if((resultL < 40) && (resultR < 40))
     820:	c8 32       	cpi	r28, 0x28	; 40
     822:	28 f4       	brcc	.+10     	; 0x82e <autoControlTemperature+0xa2>
     824:	d8 32       	cpi	r29, 0x28	; 40
     826:	28 f4       	brcc	.+10     	; 0x832 <autoControlTemperature+0xa6>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_MIN+2]; // fan value = 150
     828:	80 91 6b 00 	lds	r24, 0x006B
     82c:	1b c0       	rjmp	.+54     	; 0x864 <__stack+0x5>
	}
	else if((resultL < 50) && (resultR < 50))
     82e:	c2 33       	cpi	r28, 0x32	; 50
     830:	28 f4       	brcc	.+10     	; 0x83c <autoControlTemperature+0xb0>
     832:	d2 33       	cpi	r29, 0x32	; 50
     834:	28 f4       	brcc	.+10     	; 0x840 <autoControlTemperature+0xb4>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_MIN+3]; // fan value = 175
     836:	80 91 6c 00 	lds	r24, 0x006C
     83a:	14 c0       	rjmp	.+40     	; 0x864 <__stack+0x5>
	}
	else if((resultL < 55) && (resultR < 55))
     83c:	c7 33       	cpi	r28, 0x37	; 55
     83e:	28 f4       	brcc	.+10     	; 0x84a <autoControlTemperature+0xbe>
     840:	d7 33       	cpi	r29, 0x37	; 55
     842:	28 f4       	brcc	.+10     	; 0x84e <autoControlTemperature+0xc2>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_MIN+4]; // fan value = 200
     844:	80 91 6d 00 	lds	r24, 0x006D
     848:	0d c0       	rjmp	.+26     	; 0x864 <__stack+0x5>
	}
	else if((resultL < 60) && (resultR < 60))
     84a:	cc 33       	cpi	r28, 0x3C	; 60
     84c:	28 f4       	brcc	.+10     	; 0x858 <autoControlTemperature+0xcc>
     84e:	dc 33       	cpi	r29, 0x3C	; 60
     850:	28 f4       	brcc	.+10     	; 0x85c <autoControlTemperature+0xd0>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_MIN+5]; // fan value = 225
     852:	80 91 6e 00 	lds	r24, 0x006E
     856:	06 c0       	rjmp	.+12     	; 0x864 <__stack+0x5>
	}
	else if((resultL < 65) && (resultR < 65))
     858:	c1 34       	cpi	r28, 0x41	; 65
     85a:	30 f4       	brcc	.+12     	; 0x868 <__stack+0x9>
     85c:	d1 34       	cpi	r29, 0x41	; 65
     85e:	20 f4       	brcc	.+8      	; 0x868 <__stack+0x9>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_MAX]; // fan value = 250
     860:	80 91 6f 00 	lds	r24, 0x006F
     864:	80 93 70 00 	sts	0x0070, r24
	}
	else
	{
	}
	#ifdef DEBUG_ERROR
		transmitUartString("Auto controlled Fan Step: ");
     868:	8c e8       	ldi	r24, 0x8C	; 140
     86a:	92 e0       	ldi	r25, 0x02	; 2
     86c:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(fanSpeed);
     870:	80 91 70 00 	lds	r24, 0x0070
     874:	90 e0       	ldi	r25, 0x00	; 0
     876:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString(" or ");
     87a:	85 ef       	ldi	r24, 0xF5	; 245
     87c:	91 e0       	ldi	r25, 0x01	; 1
     87e:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(fanSpeedStep[fanSpeed]);
     882:	e0 91 70 00 	lds	r30, 0x0070
     886:	f0 e0       	ldi	r31, 0x00	; 0
     888:	e8 59       	subi	r30, 0x98	; 152
     88a:	ff 4f       	sbci	r31, 0xFF	; 255
     88c:	80 81       	ld	r24, Z
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString("\r\n");
     894:	88 ee       	ldi	r24, 0xE8	; 232
     896:	92 e0       	ldi	r25, 0x02	; 2
     898:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
/***********************************
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
     89c:	0e 94 80 00 	call	0x100	; 0x100 <timer1_on_speed>
     8a0:	2f ef       	ldi	r18, 0xFF	; 255
     8a2:	83 ed       	ldi	r24, 0xD3	; 211
     8a4:	90 e3       	ldi	r25, 0x30	; 48
     8a6:	21 50       	subi	r18, 0x01	; 1
     8a8:	80 40       	sbci	r24, 0x00	; 0
     8aa:	90 40       	sbci	r25, 0x00	; 0
     8ac:	e1 f7       	brne	.-8      	; 0x8a6 <__stack+0x47>
     8ae:	00 c0       	rjmp	.+0      	; 0x8b0 <__stack+0x51>
     8b0:	00 00       	nop
		transmitUartInt(fanSpeedStep[fanSpeed]);
		transmitUartString("\r\n");
	#endif
	fan_pwm_control_speed();
	_delay_ms(1000);
}
     8b2:	df 91       	pop	r29
     8b4:	cf 91       	pop	r28
     8b6:	08 95       	ret

000008b8 <about>:
}

void about(void)
{
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] =====================================================\r\n");
     8b8:	87 ea       	ldi	r24, 0xA7	; 167
     8ba:	92 e0       	ldi	r25, 0x02	; 2
     8bc:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartString("[UART INFO] \tAuthors and creators: P.Upinov and P.Stoyanov\r\n");
     8c0:	8b ee       	ldi	r24, 0xEB	; 235
     8c2:	92 e0       	ldi	r25, 0x02	; 2
     8c4:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartString("[UART INFO] \tDevice name: Digital Control Audio System\r\n");
     8c8:	88 e2       	ldi	r24, 0x28	; 40
     8ca:	93 e0       	ldi	r25, 0x03	; 3
     8cc:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartString("[UART INFO] \tFirmware version beta ");
     8d0:	81 e6       	ldi	r24, 0x61	; 97
     8d2:	93 e0       	ldi	r25, 0x03	; 3
     8d4:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartInt(FIRMWARE_VERSION);
     8d8:	80 e2       	ldi	r24, 0x20	; 32
     8da:	90 e0       	ldi	r25, 0x00	; 0
     8dc:	0e 94 a5 08 	call	0x114a	; 0x114a <transmitUartInt>
		transmitUartString("\r\n");
     8e0:	88 ee       	ldi	r24, 0xE8	; 232
     8e2:	92 e0       	ldi	r25, 0x02	; 2
     8e4:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartString("[UART INFO] =====================================================\r\n");
     8e8:	87 ea       	ldi	r24, 0xA7	; 167
     8ea:	92 e0       	ldi	r25, 0x02	; 2
     8ec:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
		transmitUartString("[UART INFO] Da dobavq upravlenie na:\
     8f0:	85 e8       	ldi	r24, 0x85	; 133
     8f2:	93 e0       	ldi	r25, 0x03	; 3
     8f4:	0c 94 7d 08 	jmp	0x10fa	; 0x10fa <transmitUartString>

000008f8 <__vector_1>:

/*****************************************
**** EXTERNAL INTERRUPT 0 VECTOR 01 ******
*****************************************/
ISR(INT0_vect)
{
     8f8:	1f 92       	push	r1
     8fa:	0f 92       	push	r0
     8fc:	0f b6       	in	r0, 0x3f	; 63
     8fe:	0f 92       	push	r0
     900:	11 24       	eor	r1, r1
     902:	2f 93       	push	r18
     904:	3f 93       	push	r19
     906:	4f 93       	push	r20
     908:	5f 93       	push	r21
     90a:	6f 93       	push	r22
     90c:	7f 93       	push	r23
     90e:	8f 93       	push	r24
     910:	9f 93       	push	r25
     912:	af 93       	push	r26
     914:	bf 93       	push	r27
     916:	ef 93       	push	r30
     918:	ff 93       	push	r31
	ext0_intrpt_off();	// DISABLE new IR DETECTION
     91a:	0e 94 62 00 	call	0xc4	; 0xc4 <ext0_intrpt_off>

// LOGIC CHECK BEGIN
// VERIFY PRESSED IR BUTTON and switch to low line of IR pin PD2
	unsigned char low_level = 0;
    if(irPin == 0)
     91e:	82 99       	sbic	0x10, 2	; 16
     920:	0e c0       	rjmp	.+28     	; 0x93e <__vector_1+0x46>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     922:	8a e0       	ldi	r24, 0x0A	; 10
     924:	8a 95       	dec	r24
     926:	f1 f7       	brne	.-4      	; 0x924 <__vector_1+0x2c>
     928:	00 c0       	rjmp	.+0      	; 0x92a <__vector_1+0x32>
     92a:	8a e0       	ldi	r24, 0x0A	; 10
     92c:	8a 95       	dec	r24
     92e:	f1 f7       	brne	.-4      	; 0x92c <__vector_1+0x34>
     930:	00 c0       	rjmp	.+0      	; 0x932 <__vector_1+0x3a>
     932:	8a e0       	ldi	r24, 0x0A	; 10
     934:	8a 95       	dec	r24
     936:	f1 f7       	brne	.-4      	; 0x934 <__vector_1+0x3c>
     938:	00 c0       	rjmp	.+0      	; 0x93a <__vector_1+0x42>
			_delay_us(2);	//2uS delay
		}

		if(low_level == 3)
		{
			irDecode();
     93a:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <irDecode>
		{
		}
    }
// LOGIC CHECK END

	ext0_intrpt_on();	// ENABLE new IR DETECTION
     93e:	0e 94 5b 00 	call	0xb6	; 0xb6 <ext0_intrpt_on>
}
     942:	ff 91       	pop	r31
     944:	ef 91       	pop	r30
     946:	bf 91       	pop	r27
     948:	af 91       	pop	r26
     94a:	9f 91       	pop	r25
     94c:	8f 91       	pop	r24
     94e:	7f 91       	pop	r23
     950:	6f 91       	pop	r22
     952:	5f 91       	pop	r21
     954:	4f 91       	pop	r20
     956:	3f 91       	pop	r19
     958:	2f 91       	pop	r18
     95a:	0f 90       	pop	r0
     95c:	0f be       	out	0x3f, r0	; 63
     95e:	0f 90       	pop	r0
     960:	1f 90       	pop	r1
     962:	18 95       	reti

00000964 <__vector_2>:

/*****************************************
**** EXTERNAL INTERRUPT 1 VECTOR 02 ******
*****************************************/
ISR(INT1_vect)
{
     964:	1f 92       	push	r1
     966:	0f 92       	push	r0
     968:	0f b6       	in	r0, 0x3f	; 63
     96a:	0f 92       	push	r0
     96c:	11 24       	eor	r1, r1
}
     96e:	0f 90       	pop	r0
     970:	0f be       	out	0x3f, r0	; 63
     972:	0f 90       	pop	r0
     974:	1f 90       	pop	r1
     976:	18 95       	reti

00000978 <__vector_3>:

/*****************************************
**** EXTERNAL INTERRUPT 2 VECTOR 03 ******
*****************************************/
ISR(INT2_vect)
{
     978:	1f 92       	push	r1
     97a:	0f 92       	push	r0
     97c:	0f b6       	in	r0, 0x3f	; 63
     97e:	0f 92       	push	r0
     980:	11 24       	eor	r1, r1
}
     982:	0f 90       	pop	r0
     984:	0f be       	out	0x3f, r0	; 63
     986:	0f 90       	pop	r0
     988:	1f 90       	pop	r1
     98a:	18 95       	reti

0000098c <__vector_4>:

/*****************************************
**** TIMER 2 OUTPUT COMPARE VECTOR 04 ****
*****************************************/
ISR(TIMER2_COMP_vect)
{
     98c:	1f 92       	push	r1
     98e:	0f 92       	push	r0
     990:	0f b6       	in	r0, 0x3f	; 63
     992:	0f 92       	push	r0
     994:	11 24       	eor	r1, r1
     996:	2f 93       	push	r18
     998:	3f 93       	push	r19
     99a:	4f 93       	push	r20
     99c:	5f 93       	push	r21
     99e:	6f 93       	push	r22
     9a0:	7f 93       	push	r23
     9a2:	8f 93       	push	r24
     9a4:	9f 93       	push	r25
     9a6:	af 93       	push	r26
     9a8:	bf 93       	push	r27
     9aa:	ef 93       	push	r30
     9ac:	ff 93       	push	r31
	timer2Internal_intrpt_off();	// DISABLE new INTERNAL TIMER 2 INTERRUPT
     9ae:	0e 94 73 00 	call	0xe6	; 0xe6 <timer2Internal_intrpt_off>
// LOGIC CHECK BEGIN
// run measure temperature
	autoControlTemperature();
     9b2:	0e 94 c6 03 	call	0x78c	; 0x78c <autoControlTemperature>
	// set fan value
//	get temperature and set fan falue
// LOGIC CHECK END
	timer2Internal_intrpt_on();		// ENABLE new INTERNAL TIMER 2 INTERRUPT
     9b6:	0e 94 79 00 	call	0xf2	; 0xf2 <timer2Internal_intrpt_on>
}
     9ba:	ff 91       	pop	r31
     9bc:	ef 91       	pop	r30
     9be:	bf 91       	pop	r27
     9c0:	af 91       	pop	r26
     9c2:	9f 91       	pop	r25
     9c4:	8f 91       	pop	r24
     9c6:	7f 91       	pop	r23
     9c8:	6f 91       	pop	r22
     9ca:	5f 91       	pop	r21
     9cc:	4f 91       	pop	r20
     9ce:	3f 91       	pop	r19
     9d0:	2f 91       	pop	r18
     9d2:	0f 90       	pop	r0
     9d4:	0f be       	out	0x3f, r0	; 63
     9d6:	0f 90       	pop	r0
     9d8:	1f 90       	pop	r1
     9da:	18 95       	reti

000009dc <__vector_5>:

/*****************************************
**** TIMER 2 OVERFLOW VECTOR 05 **********
*****************************************/
ISR(TIMER2_OVF_vect)
{
     9dc:	1f 92       	push	r1
     9de:	0f 92       	push	r0
     9e0:	0f b6       	in	r0, 0x3f	; 63
     9e2:	0f 92       	push	r0
     9e4:	11 24       	eor	r1, r1
}
     9e6:	0f 90       	pop	r0
     9e8:	0f be       	out	0x3f, r0	; 63
     9ea:	0f 90       	pop	r0
     9ec:	1f 90       	pop	r1
     9ee:	18 95       	reti

000009f0 <init_all>:
*********************************** START OF APPLICATION ************************************
********************************************************************************************/

void init_all()
{
	port_init();		// IO init and configure all port
     9f0:	0e 94 49 00 	call	0x92	; 0x92 <port_init>
	timer1_init();		// FAN INIT
     9f4:	0e 94 6a 00 	call	0xd4	; 0xd4 <timer1_init>
	timer2_init();		// Auto controlled fan by temperature sensors when timer2 is interrupted
     9f8:	0e 94 6f 00 	call	0xde	; 0xde <timer2_init>
	LCD_INIT();			// LCD init and reset all lcd contain
     9fc:	0e 94 24 07 	call	0xe48	; 0xe48 <LCD_INIT>
	uart_init();		// UART debug init
     a00:	0e 94 52 08 	call	0x10a4	; 0x10a4 <uart_init>
	about();			// Any debug important information
     a04:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <about>

	pga2310_init();		// SPI init and reset all (U6, U7, U8) PGA2310 volume values to null
     a08:	0e 94 26 08 	call	0x104c	; 0x104c <pga2310_init>
	relays_in_init();	// nujno e daden reset be da bade izkliuche usilvatelq, togava reletata za vhod i izhod (bez power relay) sa ostanali vkliucheni
     a0c:	0e 94 03 0a 	call	0x1406	; 0x1406 <relays_in_init>
	relays_out_init();	// nujno e daden reset be da bade izkliuche usilvatelq, togava reletata za vhod i izhod (bez power relay)sa ostanali vkliucheni
     a10:	0c 94 29 0a 	jmp	0x1452	; 0x1452 <relays_out_init>

00000a14 <buttons_press>:

}

void buttons_press()
{
	flagStatusBits = &fSB;
     a14:	82 e7       	ldi	r24, 0x72	; 114
     a16:	94 e0       	ldi	r25, 0x04	; 4
     a18:	90 93 6b 04 	sts	0x046B, r25
     a1c:	80 93 6a 04 	sts	0x046A, r24
	flagStatusBits->flagPower=0;	// inicializirane s nuli, no nai veroqtno poradi tova che e globalna stru
     a20:	80 91 72 04 	lds	r24, 0x0472
	flagStatusBits->flagMute=0;		// inicializirane
     a24:	8e 7f       	andi	r24, 0xFE	; 254
     a26:	8d 7f       	andi	r24, 0xFD	; 253
     a28:	80 93 72 04 	sts	0x0472, r24
     a2c:	e0 91 6a 04 	lds	r30, 0x046A
     a30:	f0 91 6b 04 	lds	r31, 0x046B
		LCD_DATA_INT(flagStatusBits->flagMute);		// 20 symbols
	_delay_ms(2000);
*/
	while(1)
	{
		if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)	// obj ptr flagStatusBtnRegister from struct flagStatusBtnOnOff
     a34:	b1 99       	sbic	0x16, 1	; 22
     a36:	06 c0       	rjmp	.+12     	; 0xa44 <buttons_press+0x30>
     a38:	80 81       	ld	r24, Z
     a3a:	80 fd       	sbrc	r24, 0
     a3c:	03 c0       	rjmp	.+6      	; 0xa44 <buttons_press+0x30>
		{
//			flagStatusBits->flagPower = 1;			// filter za buton ON
			ampliferOn();
     a3e:	0e 94 9e 00 	call	0x13c	; 0x13c <ampliferOn>
     a42:	2f c0       	rjmp	.+94     	; 0xaa2 <buttons_press+0x8e>
//			_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
		}
		else if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     a44:	b1 99       	sbic	0x16, 1	; 22
     a46:	06 c0       	rjmp	.+12     	; 0xa54 <buttons_press+0x40>
     a48:	80 81       	ld	r24, Z
     a4a:	80 ff       	sbrs	r24, 0
     a4c:	03 c0       	rjmp	.+6      	; 0xa54 <buttons_press+0x40>
		{
//			flagStatusBits->flagPower = 0;			// filter za buton OFF
			ampliferOff();
     a4e:	0e 94 e5 00 	call	0x1ca	; 0x1ca <ampliferOff>
     a52:	27 c0       	rjmp	.+78     	; 0xaa2 <buttons_press+0x8e>
		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     a54:	b2 99       	sbic	0x16, 2	; 22
     a56:	06 c0       	rjmp	.+12     	; 0xa64 <buttons_press+0x50>
     a58:	80 81       	ld	r24, Z
     a5a:	80 ff       	sbrs	r24, 0
     a5c:	03 c0       	rjmp	.+6      	; 0xa64 <buttons_press+0x50>
		{
//			LCD_DATA_STRING("PRESSED BTN ESCAPE  ");	// 20 symbols
//			LCD_COMMAND(LCD_ON);
			LCD_CLEAR_CONTAIN();
     a5e:	0e 94 37 07 	call	0xe6e	; 0xe6e <LCD_CLEAR_CONTAIN>
     a62:	11 c0       	rjmp	.+34     	; 0xa86 <buttons_press+0x72>
			_delay_ms(500);
//			volumeUp();
//			_delay_ms(200);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     a64:	83 99       	sbic	0x10, 3	; 16
     a66:	03 c0       	rjmp	.+6      	; 0xa6e <buttons_press+0x5a>
     a68:	80 81       	ld	r24, Z
     a6a:	80 fd       	sbrc	r24, 0
     a6c:	0c c0       	rjmp	.+24     	; 0xa86 <buttons_press+0x72>
			_delay_ms(500);
//			volumeDown();
//			_delay_ms(200);

		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     a6e:	b2 99       	sbic	0x16, 2	; 22
     a70:	03 c0       	rjmp	.+6      	; 0xa78 <buttons_press+0x64>
     a72:	80 81       	ld	r24, Z
     a74:	80 ff       	sbrs	r24, 0
     a76:	07 c0       	rjmp	.+14     	; 0xa86 <buttons_press+0x72>
//			LCD_COMMAND(LCD_ON);
			_delay_ms(500);
//			setupMode();
//			_delay_ms(1000);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     a78:	83 99       	sbic	0x10, 3	; 16
     a7a:	0f c0       	rjmp	.+30     	; 0xa9a <buttons_press+0x86>
     a7c:	80 81       	ld	r24, Z
     a7e:	80 fd       	sbrc	r24, 0
     a80:	0c c0       	rjmp	.+24     	; 0xa9a <buttons_press+0x86>
		{
			temperature();
     a82:	0e 94 81 02 	call	0x502	; 0x502 <temperature>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     a86:	2f ef       	ldi	r18, 0xFF	; 255
     a88:	89 e6       	ldi	r24, 0x69	; 105
     a8a:	98 e1       	ldi	r25, 0x18	; 24
     a8c:	21 50       	subi	r18, 0x01	; 1
     a8e:	80 40       	sbci	r24, 0x00	; 0
     a90:	90 40       	sbci	r25, 0x00	; 0
     a92:	e1 f7       	brne	.-8      	; 0xa8c <buttons_press+0x78>
     a94:	00 c0       	rjmp	.+0      	; 0xa96 <buttons_press+0x82>
     a96:	00 00       	nop
     a98:	04 c0       	rjmp	.+8      	; 0xaa2 <buttons_press+0x8e>
//			LCD_COMMAND(LCD_OFF);
			_delay_ms(500);
//			about();
//			_delay_ms(1000);
		}
		else if(flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     a9a:	80 81       	ld	r24, Z
     a9c:	80 fd       	sbrc	r24, 0
		{
			volumeProcess();
     a9e:	0e 94 49 01 	call	0x292	; 0x292 <volumeProcess>
//			commonEncoder();
		}
		else
		{
		}
		autoControlTemperature();
     aa2:	0e 94 c6 03 	call	0x78c	; 0x78c <autoControlTemperature>
	}
     aa6:	c2 cf       	rjmp	.-124    	; 0xa2c <buttons_press+0x18>

00000aa8 <eeprom_24c64_reset>:

/*************************************
** RESET AND ZERO FILL EEPROM 24C64 **
*************************************/
void eeprom_24c64_reset()
{
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
	unsigned int i;	// 16 bits
// EEPROM WRITE
	i2c_start();
     aac:	0e 94 61 06 	call	0xcc2	; 0xcc2 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     ab0:	80 ea       	ldi	r24, 0xA0	; 160
     ab2:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     ab6:	80 e0       	ldi	r24, 0x00	; 0
     ab8:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     abc:	80 e0       	ldi	r24, 0x00	; 0
     abe:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
     ac2:	cf ef       	ldi	r28, 0xFF	; 255
     ac4:	df e1       	ldi	r29, 0x1F	; 31
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
     ac6:	80 e0       	ldi	r24, 0x00	; 0
     ac8:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
     acc:	21 97       	sbiw	r28, 0x01	; 1
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
     ace:	20 97       	sbiw	r28, 0x00	; 0
     ad0:	d1 f7       	brne	.-12     	; 0xac6 <eeprom_24c64_reset+0x1e>
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
	}
	i2c_stop();
}
     ad2:	df 91       	pop	r29
     ad4:	cf 91       	pop	r28
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
	}
	i2c_stop();
     ad6:	0c 94 67 06 	jmp	0xcce	; 0xcce <i2c_stop>

00000ada <eeprom_24c64_write>:
// Za da se vijda tova koeto se e zapisalo v pametta, a ne ot tozi bibliotechen fail !!!!!!!!!
// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !

// EEPROM WRITE
	i2c_start();
     ada:	0e 94 61 06 	call	0xcc2	; 0xcc2 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     ade:	80 ea       	ldi	r24, 0xA0	; 160
     ae0:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     ae4:	80 e0       	ldi	r24, 0x00	; 0
     ae6:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     aea:	80 e0       	ldi	r24, 0x00	; 0
     aec:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
// Write data
	i2c_write(0x30);	// Data is stored: 0x30 - '0'
     af0:	80 e3       	ldi	r24, 0x30	; 48
     af2:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
	i2c_write(0x31);	// Data is stored: 0x31 - '1'
     af6:	81 e3       	ldi	r24, 0x31	; 49
     af8:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
	i2c_write(0x32);	// Data is stored: 0x32 - '2'
     afc:	82 e3       	ldi	r24, 0x32	; 50
     afe:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
	i2c_write(0x33);	// Data is stored: 0x33 - '3'
     b02:	83 e3       	ldi	r24, 0x33	; 51
     b04:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
	i2c_write(0x34);	// Data is stored: 0x34 - '4'
     b08:	84 e3       	ldi	r24, 0x34	; 52
     b0a:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
	i2c_stop();
     b0e:	0c 94 67 06 	jmp	0xcce	; 0xcce <i2c_stop>

00000b12 <eeprom_24c64_read>:
	// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
	// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !
	
	byte eepromReceiveByte0, eepromReceiveByte1, eepromReceiveByte2, eepromReceiveByte3, eepromReceiveByte4, eepromReceiveByte5;
// EEPROM READ
	i2c_start();
     b12:	0e 94 61 06 	call	0xcc2	; 0xcc2 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);		// EEPROM 24C64 ADDRESS ACCESS WRITE
     b16:	80 ea       	ldi	r24, 0xA0	; 160
     b18:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     b1c:	80 e0       	ldi	r24, 0x00	; 0
     b1e:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>

	i2c_start();
     b28:	0e 94 61 06 	call	0xcc2	; 0xcc2 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_READ);		// EEPROM 24C64 ADDRESS ACCESS READ
     b2c:	81 ea       	ldi	r24, 0xA1	; 161
     b2e:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <i2c_write>
	eepromReceiveByte0	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	0e 94 71 06 	call	0xce2	; 0xce2 <i2c_read>
	eepromReceiveByte1	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b38:	80 e0       	ldi	r24, 0x00	; 0
     b3a:	0e 94 71 06 	call	0xce2	; 0xce2 <i2c_read>
	eepromReceiveByte2	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b3e:	80 e0       	ldi	r24, 0x00	; 0
     b40:	0e 94 71 06 	call	0xce2	; 0xce2 <i2c_read>
	eepromReceiveByte3	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b44:	80 e0       	ldi	r24, 0x00	; 0
     b46:	0e 94 71 06 	call	0xce2	; 0xce2 <i2c_read>
	eepromReceiveByte4	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b4a:	80 e0       	ldi	r24, 0x00	; 0
     b4c:	0e 94 71 06 	call	0xce2	; 0xce2 <i2c_read>
	eepromReceiveByte5	= i2c_read(1);				// EEPROM DATA READ BYTE	// i2c_read(1) parametar razlichen ot 0 spira komunikaciqta NACK
     b50:	81 e0       	ldi	r24, 0x01	; 1
     b52:	0e 94 71 06 	call	0xce2	; 0xce2 <i2c_read>
	i2c_stop();
     b56:	0c 94 67 06 	jmp	0xcce	; 0xcce <i2c_stop>

00000b5a <reset>:
}
*/

unsigned char reset(void)
{
    DDRx |= (1<<Px);            //Ausgang
     b5a:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     b5c:	c0 98       	cbi	0x18, 0	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b5e:	8f e7       	ldi	r24, 0x7F	; 127
     b60:	97 e0       	ldi	r25, 0x07	; 7
     b62:	01 97       	sbiw	r24, 0x01	; 1
     b64:	f1 f7       	brne	.-4      	; 0xb62 <reset+0x8>
     b66:	00 c0       	rjmp	.+0      	; 0xb68 <reset+0xe>
     b68:	00 00       	nop
    _delay_us(480);
	DDRx &= ~(1<<Px);
     b6a:	b8 98       	cbi	0x17, 0	; 23
     b6c:	8f e3       	ldi	r24, 0x3F	; 63
     b6e:	91 e0       	ldi	r25, 0x01	; 1
     b70:	01 97       	sbiw	r24, 0x01	; 1
     b72:	f1 f7       	brne	.-4      	; 0xb70 <reset+0x16>
     b74:	00 c0       	rjmp	.+0      	; 0xb76 <reset+0x1c>
     b76:	00 00       	nop
    _delay_us(80);
	if(!(PINx & (1<<Px)))     //Prüfe Slave-Antwort
     b78:	b0 99       	sbic	0x16, 0	; 22
     b7a:	08 c0       	rjmp	.+16     	; 0xb8c <reset+0x32>
     b7c:	87 e0       	ldi	r24, 0x07	; 7
     b7e:	97 e0       	ldi	r25, 0x07	; 7
     b80:	01 97       	sbiw	r24, 0x01	; 1
     b82:	f1 f7       	brne	.-4      	; 0xb80 <reset+0x26>
     b84:	00 c0       	rjmp	.+0      	; 0xb86 <reset+0x2c>
     b86:	00 00       	nop
	{	
		_delay_us(450);
        return 1;
     b88:	81 e0       	ldi	r24, 0x01	; 1
     b8a:	08 95       	ret
	}
    else
	{
        return 0;
     b8c:	80 e0       	ldi	r24, 0x00	; 0
	}
}
     b8e:	08 95       	ret

00000b90 <read_bit>:

unsigned char read_bit(void)
{
    DDRx |= (1<<Px);            //Ausgang
     b90:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     b92:	c0 98       	cbi	0x18, 0	; 24
     b94:	85 e0       	ldi	r24, 0x05	; 5
     b96:	8a 95       	dec	r24
     b98:	f1 f7       	brne	.-4      	; 0xb96 <read_bit+0x6>
     b9a:	00 00       	nop
    _delay_us(1);
	DDRx &= ~(1<<Px);
     b9c:	b8 98       	cbi	0x17, 0	; 23
     b9e:	80 e4       	ldi	r24, 0x40	; 64
     ba0:	8a 95       	dec	r24
     ba2:	f1 f7       	brne	.-4      	; 0xba0 <read_bit+0x10>
    _delay_us(12);
    if(!(PINx & (1<<Px)))       //Abtastung innerhalb von 15µs
     ba4:	86 b3       	in	r24, 0x16	; 22
	}
	else
    {
		return 1;
	}
}
     ba6:	81 70       	andi	r24, 0x01	; 1
     ba8:	08 95       	ret

00000baa <write_bit>:

void write_bit(unsigned char bitval)    //kann 0 oder 1 sein
{
    DDRx |= (1<<Px);            //Ausgang
     baa:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     bac:	c0 98       	cbi	0x18, 0	; 24
    if(bitval)
     bae:	81 11       	cpse	r24, r1
	{
        PORTx |= (1<<Px);      //H-Pegel
     bb0:	c0 9a       	sbi	0x18, 0	; 24
     bb2:	87 eb       	ldi	r24, 0xB7	; 183
     bb4:	91 e0       	ldi	r25, 0x01	; 1
     bb6:	01 97       	sbiw	r24, 0x01	; 1
     bb8:	f1 f7       	brne	.-4      	; 0xbb6 <write_bit+0xc>
     bba:	00 c0       	rjmp	.+0      	; 0xbbc <write_bit+0x12>
     bbc:	00 00       	nop
    }
	_delay_us(110);        
    DDRx &= ~(1<<Px);
     bbe:	b8 98       	cbi	0x17, 0	; 23
    PORTx &= ~(1<<Px);
     bc0:	c0 98       	cbi	0x18, 0	; 24
     bc2:	08 95       	ret

00000bc4 <read_byte>:
}

unsigned char read_byte(void)
{
     bc4:	ff 92       	push	r15
     bc6:	0f 93       	push	r16
     bc8:	1f 93       	push	r17
     bca:	cf 93       	push	r28
     bcc:	df 93       	push	r29
     bce:	c0 e0       	ldi	r28, 0x00	; 0
     bd0:	d0 e0       	ldi	r29, 0x00	; 0
    unsigned char byte = 0;
     bd2:	f1 2c       	mov	r15, r1
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
		{
            byte |= (1<<i);
     bd4:	01 e0       	ldi	r16, 0x01	; 1
     bd6:	10 e0       	ldi	r17, 0x00	; 0
unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
     bd8:	0e 94 c8 05 	call	0xb90	; 0xb90 <read_bit>
     bdc:	88 23       	and	r24, r24
     bde:	39 f0       	breq	.+14     	; 0xbee <read_byte+0x2a>
		{
            byte |= (1<<i);
     be0:	98 01       	movw	r18, r16
     be2:	0c 2e       	mov	r0, r28
     be4:	01 c0       	rjmp	.+2      	; 0xbe8 <read_byte+0x24>
     be6:	22 0f       	add	r18, r18
     be8:	0a 94       	dec	r0
     bea:	ea f7       	brpl	.-6      	; 0xbe6 <read_byte+0x22>
     bec:	f2 2a       	or	r15, r18
     bee:	8f ed       	ldi	r24, 0xDF	; 223
     bf0:	91 e0       	ldi	r25, 0x01	; 1
     bf2:	01 97       	sbiw	r24, 0x01	; 1
     bf4:	f1 f7       	brne	.-4      	; 0xbf2 <read_byte+0x2e>
     bf6:	00 c0       	rjmp	.+0      	; 0xbf8 <read_byte+0x34>
     bf8:	00 00       	nop
     bfa:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
     bfc:	c8 30       	cpi	r28, 0x08	; 8
     bfe:	d1 05       	cpc	r29, r1
     c00:	59 f7       	brne	.-42     	; 0xbd8 <read_byte+0x14>
            byte |= (1<<i);
		}
        _delay_us(120);
    }
    return byte;
}
     c02:	8f 2d       	mov	r24, r15
     c04:	df 91       	pop	r29
     c06:	cf 91       	pop	r28
     c08:	1f 91       	pop	r17
     c0a:	0f 91       	pop	r16
     c0c:	ff 90       	pop	r15
     c0e:	08 95       	ret

00000c10 <write_byte>:

void write_byte(unsigned char byte)
{
     c10:	0f 93       	push	r16
     c12:	1f 93       	push	r17
     c14:	cf 93       	push	r28
     c16:	df 93       	push	r29
     c18:	c0 e0       	ldi	r28, 0x00	; 0
     c1a:	d0 e0       	ldi	r29, 0x00	; 0
    for(unsigned char i=0; i<8; i++)
	{
        if(byte & (1<<i))
     c1c:	08 2f       	mov	r16, r24
     c1e:	10 e0       	ldi	r17, 0x00	; 0
     c20:	c8 01       	movw	r24, r16
     c22:	0c 2e       	mov	r0, r28
     c24:	02 c0       	rjmp	.+4      	; 0xc2a <write_byte+0x1a>
     c26:	95 95       	asr	r25
     c28:	87 95       	ror	r24
     c2a:	0a 94       	dec	r0
     c2c:	e2 f7       	brpl	.-8      	; 0xc26 <write_byte+0x16>
     c2e:	80 ff       	sbrs	r24, 0
     c30:	02 c0       	rjmp	.+4      	; 0xc36 <write_byte+0x26>
		{
			write_bit(1);
     c32:	81 e0       	ldi	r24, 0x01	; 1
     c34:	01 c0       	rjmp	.+2      	; 0xc38 <write_byte+0x28>
		}
        else
		{
            write_bit(0);
     c36:	80 e0       	ldi	r24, 0x00	; 0
     c38:	0e 94 d5 05 	call	0xbaa	; 0xbaa <write_bit>
     c3c:	21 96       	adiw	r28, 0x01	; 1
    return byte;
}

void write_byte(unsigned char byte)
{
    for(unsigned char i=0; i<8; i++)
     c3e:	c8 30       	cpi	r28, 0x08	; 8
     c40:	d1 05       	cpc	r29, r1
     c42:	71 f7       	brne	.-36     	; 0xc20 <write_byte+0x10>
     c44:	8f ed       	ldi	r24, 0xDF	; 223
     c46:	91 e0       	ldi	r25, 0x01	; 1
     c48:	01 97       	sbiw	r24, 0x01	; 1
     c4a:	f1 f7       	brne	.-4      	; 0xc48 <write_byte+0x38>
     c4c:	00 c0       	rjmp	.+0      	; 0xc4e <write_byte+0x3e>
     c4e:	00 00       	nop
		{
            write_bit(0);
		}
	}
    _delay_us(120);
}  
     c50:	df 91       	pop	r29
     c52:	cf 91       	pop	r28
     c54:	1f 91       	pop	r17
     c56:	0f 91       	pop	r16
     c58:	08 95       	ret

00000c5a <wait_ready>:
	return 0;
}

void wait_ready(void)
{
	while(!(read_bit()));
     c5a:	0e 94 c8 05 	call	0xb90	; 0xb90 <read_bit>
     c5e:	88 23       	and	r24, r24
     c60:	e1 f3       	breq	.-8      	; 0xc5a <wait_ready>
}
     c62:	08 95       	ret

00000c64 <read_scratchpad>:
	}
    _delay_us(120);
}  

unsigned char read_scratchpad(void)
{
     c64:	cf 93       	push	r28
     c66:	df 93       	push	r29

	if(reset())
     c68:	0e 94 ad 05 	call	0xb5a	; 0xb5a <reset>
     c6c:	81 11       	cpse	r24, r1
     c6e:	02 c0       	rjmp	.+4      	; 0xc74 <read_scratchpad+0x10>
				scratchpad [i] = read_byte();
			}
			return 1;
		}
	}
	return 0;
     c70:	80 e0       	ldi	r24, 0x00	; 0
     c72:	1c c0       	rjmp	.+56     	; 0xcac <read_scratchpad+0x48>
unsigned char read_scratchpad(void)
{

	if(reset())
	{
		write_byte(0xCC);
     c74:	8c ec       	ldi	r24, 0xCC	; 204
     c76:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
		write_byte(0x44);
     c7a:	84 e4       	ldi	r24, 0x44	; 68
     c7c:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
		wait_ready();
     c80:	0e 94 2d 06 	call	0xc5a	; 0xc5a <wait_ready>
		if(reset())
     c84:	0e 94 ad 05 	call	0xb5a	; 0xb5a <reset>
     c88:	88 23       	and	r24, r24
     c8a:	91 f3       	breq	.-28     	; 0xc70 <read_scratchpad+0xc>
		{
			write_byte(0xCC);
     c8c:	8c ec       	ldi	r24, 0xCC	; 204
     c8e:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
			write_byte(0xBE);
     c92:	8e eb       	ldi	r24, 0xBE	; 190
     c94:	0e 94 08 06 	call	0xc10	; 0xc10 <write_byte>
     c98:	ca e5       	ldi	r28, 0x5A	; 90
     c9a:	d4 e0       	ldi	r29, 0x04	; 4
			for(unsigned char i=0; i<9; i++)
			{
				scratchpad [i] = read_byte();
     c9c:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <read_byte>
     ca0:	89 93       	st	Y+, r24
		wait_ready();
		if(reset())
		{
			write_byte(0xCC);
			write_byte(0xBE);
			for(unsigned char i=0; i<9; i++)
     ca2:	84 e0       	ldi	r24, 0x04	; 4
     ca4:	c3 36       	cpi	r28, 0x63	; 99
     ca6:	d8 07       	cpc	r29, r24
     ca8:	c9 f7       	brne	.-14     	; 0xc9c <read_scratchpad+0x38>
			{
				scratchpad [i] = read_byte();
			}
			return 1;
     caa:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	return 0;
}
     cac:	df 91       	pop	r29
     cae:	cf 91       	pop	r28
     cb0:	08 95       	ret

00000cb2 <i2c_init>:
|== TWPS = 1 => (4^TWPS)= 4  // TWSR = (0<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx01 => TWSR = 1 (DEC) => 4^1 =  4 =|
|== TWPS = 2 => (4^TWPS)=16  // TWSR = (1<<TWPS1)|(0<<TWPS0) => TWSR = 0bxxxxxx10 => TWSR = 2 (DEC) => 4^2 = 16 =|
|== TWPS = 3 => (4^TWPS)=64  // TWSR = (1<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx11 => TWSR = 3 (DEC) => 4^3 = 64 =|
|===============================================================================================================*/

	TWBR = 0b00010010;	// HEX=0x12	or DEC=18	// FCPU = 16 000 000 |-> SCL = 16000000 / (16+(2*TWBR*(4^TWPS)) = 16000000 / (16+(2*18*(4))) = 16000000 / 160 = 100 000 Hz = 100 kHz
     cb2:	82 e1       	ldi	r24, 0x12	; 18
     cb4:	80 b9       	out	0x00, r24	; 0
	TWSR = (0<<TWPS1)|(1<<TWPS0);	// SCL = 16 000 000 / 64  = 250 000 = 250kHz
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	81 b9       	out	0x01, r24	; 1
	TWCR = (1<<TWEN);	//	TWCR = 0x04; // TWCR = (x<<TWINT)|(x<<TWEA)|(x<<TWSTA)|(x<<TWSTO)|(x<<TWEN)|(x<<TWIE);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz
     cba:	84 e0       	ldi	r24, 0x04	; 4
     cbc:	86 bf       	out	0x36, r24	; 54
	TWDR = 0b00000000;
     cbe:	13 b8       	out	0x03, r1	; 3
     cc0:	08 95       	ret

00000cc2 <i2c_start>:
/*****************************************
** START CONDITION OF I2C COMMUNICATION **
*****************************************/
void i2c_start(void)
{
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     cc2:	84 ea       	ldi	r24, 0xA4	; 164
     cc4:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     cc6:	06 b6       	in	r0, 0x36	; 54
     cc8:	07 fe       	sbrs	r0, 7
     cca:	fd cf       	rjmp	.-6      	; 0xcc6 <i2c_start+0x4>
	{
	}
}
     ccc:	08 95       	ret

00000cce <i2c_stop>:
/****************************************
** STOP CONDITION OF I2C COMMUNICATION **
****************************************/
void i2c_stop()
{
	TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     cce:	84 e9       	ldi	r24, 0x94	; 148
     cd0:	86 bf       	out	0x36, r24	; 54
     cd2:	08 95       	ret

00000cd4 <i2c_write>:
/*******************************************
** WRITE/SEND 1 BYTE OF I2C COMMUNICATION **
*******************************************/
void i2c_write(unsigned char data)
{
	TWDR = data;
     cd4:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT)|(1<<TWEN);
     cd6:	84 e8       	ldi	r24, 0x84	; 132
     cd8:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     cda:	06 b6       	in	r0, 0x36	; 54
     cdc:	07 fe       	sbrs	r0, 7
     cde:	fd cf       	rjmp	.-6      	; 0xcda <i2c_write+0x6>
	{
	}
}
     ce0:	08 95       	ret

00000ce2 <i2c_read>:
/**********************************************
** READ/RECEIVE BYTE(S) OF I2C COMMUNICATION **
**********************************************/
unsigned char i2c_read(unsigned char isLast)
{
	if(isLast == 0 )
     ce2:	81 11       	cpse	r24, r1
     ce4:	02 c0       	rjmp	.+4      	; 0xcea <i2c_read+0x8>
	{
		TWCR = (1<<TWINT)|(1<<TWEA)|(1<<TWEN);	// to next receive byte
     ce6:	84 ec       	ldi	r24, 0xC4	; 196
     ce8:	01 c0       	rjmp	.+2      	; 0xcec <i2c_read+0xa>
	}
	else
	{
		TWCR = (1<<TWINT)|(1<<TWEN);			// to end of communication
     cea:	84 e8       	ldi	r24, 0x84	; 132
     cec:	86 bf       	out	0x36, r24	; 54
	}
	
	while((TWCR & (1<<TWINT)) == 0)
     cee:	06 b6       	in	r0, 0x36	; 54
     cf0:	07 fe       	sbrs	r0, 7
     cf2:	fd cf       	rjmp	.-6      	; 0xcee <i2c_read+0xc>
	{
	}
	return TWDR;
     cf4:	83 b1       	in	r24, 0x03	; 3
}
     cf6:	08 95       	ret

00000cf8 <LCD_EXECUTE_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_EXECUTE_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     cf8:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     cfa:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     cfc:	87 ff       	sbrs	r24, 7
     cfe:	02 c0       	rjmp	.+4      	; 0xd04 <LCD_EXECUTE_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     d00:	d8 9a       	sbi	0x1b, 0	; 27
     d02:	01 c0       	rjmp	.+2      	; 0xd06 <LCD_EXECUTE_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     d04:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     d06:	d9 9a       	sbi	0x1b, 1	; 27

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     d08:	88 0f       	add	r24, r24
     d0a:	91 50       	subi	r25, 0x01	; 1
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     d0c:	b1 f7       	brne	.-20     	; 0xcfa <LCD_EXECUTE_COMMAND+0x2>
		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     d0e:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     d10:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     d12:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     d14:	da 98       	cbi	0x1b, 2	; 27
     d16:	87 ea       	ldi	r24, 0xA7	; 167
     d18:	92 e0       	ldi	r25, 0x02	; 2
     d1a:	01 97       	sbiw	r24, 0x01	; 1
     d1c:	f1 f7       	brne	.-4      	; 0xd1a <LCD_EXECUTE_COMMAND+0x22>
     d1e:	00 c0       	rjmp	.+0      	; 0xd20 <LCD_EXECUTE_COMMAND+0x28>
     d20:	00 00       	nop
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     d22:	da 9a       	sbi	0x1b, 2	; 27
     d24:	87 ea       	ldi	r24, 0xA7	; 167
     d26:	92 e0       	ldi	r25, 0x02	; 2
     d28:	01 97       	sbiw	r24, 0x01	; 1
     d2a:	f1 f7       	brne	.-4      	; 0xd28 <LCD_EXECUTE_COMMAND+0x30>
     d2c:	00 c0       	rjmp	.+0      	; 0xd2e <LCD_EXECUTE_COMMAND+0x36>
     d2e:	00 00       	nop
	LCD_REGSELECT_low();	// RS = 0
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);			//rcall 180 us
*/
	LCD_ENABLE_low();		// EN = 0
     d30:	db 98       	cbi	0x1b, 3	; 27
     d32:	8f e8       	ldi	r24, 0x8F	; 143
     d34:	91 e0       	ldi	r25, 0x01	; 1
     d36:	01 97       	sbiw	r24, 0x01	; 1
     d38:	f1 f7       	brne	.-4      	; 0xd36 <LCD_EXECUTE_COMMAND+0x3e>
     d3a:	00 c0       	rjmp	.+0      	; 0xd3c <LCD_EXECUTE_COMMAND+0x44>
     d3c:	00 00       	nop
     d3e:	08 95       	ret

00000d40 <LCD_EXECUTE_DATA>:
/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
     d40:	fc 01       	movw	r30, r24
     d42:	9f 01       	movw	r18, r30
     d44:	28 1b       	sub	r18, r24
     d46:	39 0b       	sbc	r19, r25
     d48:	26 17       	cp	r18, r22
     d4a:	37 07       	cpc	r19, r23
     d4c:	2c f5       	brge	.+74     	; 0xd98 <LCD_EXECUTE_DATA+0x58>
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];
     d4e:	31 91       	ld	r19, Z+
     d50:	28 e0       	ldi	r18, 0x08	; 8

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     d52:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     d54:	37 ff       	sbrs	r19, 7
     d56:	02 c0       	rjmp	.+4      	; 0xd5c <LCD_EXECUTE_DATA+0x1c>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     d58:	d8 9a       	sbi	0x1b, 0	; 27
     d5a:	01 c0       	rjmp	.+2      	; 0xd5e <LCD_EXECUTE_DATA+0x1e>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     d5c:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     d5e:	d9 9a       	sbi	0x1b, 1	; 27

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     d60:	33 0f       	add	r19, r19
     d62:	21 50       	subi	r18, 0x01	; 1
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     d64:	b1 f7       	brne	.-20     	; 0xd52 <LCD_EXECUTE_DATA+0x12>
			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     d66:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     d68:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     d6a:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     d6c:	da 98       	cbi	0x1b, 2	; 27
     d6e:	a7 ea       	ldi	r26, 0xA7	; 167
     d70:	b2 e0       	ldi	r27, 0x02	; 2
     d72:	11 97       	sbiw	r26, 0x01	; 1
     d74:	f1 f7       	brne	.-4      	; 0xd72 <LCD_EXECUTE_DATA+0x32>
     d76:	00 c0       	rjmp	.+0      	; 0xd78 <LCD_EXECUTE_DATA+0x38>
     d78:	00 00       	nop
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     d7a:	da 9a       	sbi	0x1b, 2	; 27
     d7c:	a7 ea       	ldi	r26, 0xA7	; 167
     d7e:	b2 e0       	ldi	r27, 0x02	; 2
     d80:	11 97       	sbiw	r26, 0x01	; 1
     d82:	f1 f7       	brne	.-4      	; 0xd80 <LCD_EXECUTE_DATA+0x40>
     d84:	00 c0       	rjmp	.+0      	; 0xd86 <LCD_EXECUTE_DATA+0x46>
     d86:	00 00       	nop
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     d88:	db 98       	cbi	0x1b, 3	; 27
     d8a:	af e8       	ldi	r26, 0x8F	; 143
     d8c:	b1 e0       	ldi	r27, 0x01	; 1
     d8e:	11 97       	sbiw	r26, 0x01	; 1
     d90:	f1 f7       	brne	.-4      	; 0xd8e <LCD_EXECUTE_DATA+0x4e>
     d92:	00 c0       	rjmp	.+0      	; 0xd94 <LCD_EXECUTE_DATA+0x54>
     d94:	00 00       	nop
     d96:	d5 cf       	rjmp	.-86     	; 0xd42 <LCD_EXECUTE_DATA+0x2>
		_delay_us(100);
	}

//	LCD_EXECUTE_DATA_LAST();	// flush -> posleden simvol ili gore v cikala count_ns < numsymbols+1 ili count_ns <= numsymbols
}
     d98:	08 95       	ret

00000d9a <LCD_EXECUTE_DATA_ONE>:

/************************************************
** WRITE/TRANSMIT ONE DATA BYTE TO LCD DISPLAY **
************************************************/
void LCD_EXECUTE_DATA_ONE(unsigned char data)	// HELP: LCD_EXECUTE_DATA(unsigned char data_byte_symbols) // LCD shift left out, msb is first
{
     d9a:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     d9c:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     d9e:	87 ff       	sbrs	r24, 7
     da0:	02 c0       	rjmp	.+4      	; 0xda6 <LCD_EXECUTE_DATA_ONE+0xc>
		{
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     da2:	d8 9a       	sbi	0x1b, 0	; 27
     da4:	01 c0       	rjmp	.+2      	; 0xda8 <LCD_EXECUTE_DATA_ONE+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     da6:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     da8:	d9 9a       	sbi	0x1b, 1	; 27

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     daa:	88 0f       	add	r24, r24
     dac:	91 50       	subi	r25, 0x01	; 1
{
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     dae:	b1 f7       	brne	.-20     	; 0xd9c <LCD_EXECUTE_DATA_ONE+0x2>
		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
	}
//update from down comment
	LCD_REGSELECT_high();	// RS = 1
     db0:	dd 9a       	sbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     db2:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     db4:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment

	LCD_RCK_low();
     db6:	da 98       	cbi	0x1b, 2	; 27
     db8:	87 ea       	ldi	r24, 0xA7	; 167
     dba:	92 e0       	ldi	r25, 0x02	; 2
     dbc:	01 97       	sbiw	r24, 0x01	; 1
     dbe:	f1 f7       	brne	.-4      	; 0xdbc <LCD_EXECUTE_DATA_ONE+0x22>
     dc0:	00 c0       	rjmp	.+0      	; 0xdc2 <LCD_EXECUTE_DATA_ONE+0x28>
     dc2:	00 00       	nop
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     dc4:	da 9a       	sbi	0x1b, 2	; 27
     dc6:	87 ea       	ldi	r24, 0xA7	; 167
     dc8:	92 e0       	ldi	r25, 0x02	; 2
     dca:	01 97       	sbiw	r24, 0x01	; 1
     dcc:	f1 f7       	brne	.-4      	; 0xdca <LCD_EXECUTE_DATA_ONE+0x30>
     dce:	00 c0       	rjmp	.+0      	; 0xdd0 <LCD_EXECUTE_DATA_ONE+0x36>
     dd0:	00 00       	nop
	LCD_REGSELECT_high();	// RS = 1
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);
*/
	LCD_ENABLE_low();		// EN = 0
     dd2:	db 98       	cbi	0x1b, 3	; 27
     dd4:	8f e8       	ldi	r24, 0x8F	; 143
     dd6:	91 e0       	ldi	r25, 0x01	; 1
     dd8:	01 97       	sbiw	r24, 0x01	; 1
     dda:	f1 f7       	brne	.-4      	; 0xdd8 <LCD_EXECUTE_DATA_ONE+0x3e>
     ddc:	00 c0       	rjmp	.+0      	; 0xdde <LCD_EXECUTE_DATA_ONE+0x44>
     dde:	00 00       	nop
     de0:	08 95       	ret

00000de2 <LCD_EXECUTE_DATA_LAST>:
/*****************************************************************************
** WRITE/TRANSMIT LAST DATA BYTE TO LCD DISPLAY AND FLUSH SN74HC595 BUFFER  **
*****************************************************************************/
void LCD_EXECUTE_DATA_LAST()	// flush -> izchistvane na bufer - prinuditelno izpisvane na posleden simvol
{
	LCD_ENABLE_low();
     de2:	db 98       	cbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     de4:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     de6:	dd 9a       	sbi	0x1b, 5	; 27
     de8:	85 ed       	ldi	r24, 0xD5	; 213
     dea:	8a 95       	dec	r24
     dec:	f1 f7       	brne	.-4      	; 0xdea <LCD_EXECUTE_DATA_LAST+0x8>
     dee:	00 00       	nop
	_delay_us(40);				// from 100 or 180 //rcall 180 us
	LCD_ENABLE_high();
     df0:	db 9a       	sbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     df2:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     df4:	dd 9a       	sbi	0x1b, 5	; 27
     df6:	85 ed       	ldi	r24, 0xD5	; 213
     df8:	8a 95       	dec	r24
     dfa:	f1 f7       	brne	.-4      	; 0xdf8 <LCD_EXECUTE_DATA_LAST+0x16>
     dfc:	00 00       	nop
     dfe:	08 95       	ret

00000e00 <LCD_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     e00:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     e02:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     e04:	87 ff       	sbrs	r24, 7
     e06:	02 c0       	rjmp	.+4      	; 0xe0c <LCD_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     e08:	d8 9a       	sbi	0x1b, 0	; 27
     e0a:	01 c0       	rjmp	.+2      	; 0xe0e <LCD_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     e0c:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     e0e:	d9 9a       	sbi	0x1b, 1	; 27

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     e10:	88 0f       	add	r24, r24
     e12:	91 50       	subi	r25, 0x01	; 1
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     e14:	b1 f7       	brne	.-20     	; 0xe02 <LCD_COMMAND+0x2>
		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     e16:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     e18:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     e1a:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     e1c:	da 98       	cbi	0x1b, 2	; 27
     e1e:	87 ea       	ldi	r24, 0xA7	; 167
     e20:	92 e0       	ldi	r25, 0x02	; 2
     e22:	01 97       	sbiw	r24, 0x01	; 1
     e24:	f1 f7       	brne	.-4      	; 0xe22 <LCD_COMMAND+0x22>
     e26:	00 c0       	rjmp	.+0      	; 0xe28 <LCD_COMMAND+0x28>
     e28:	00 00       	nop
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     e2a:	da 9a       	sbi	0x1b, 2	; 27
     e2c:	87 ea       	ldi	r24, 0xA7	; 167
     e2e:	92 e0       	ldi	r25, 0x02	; 2
     e30:	01 97       	sbiw	r24, 0x01	; 1
     e32:	f1 f7       	brne	.-4      	; 0xe30 <LCD_COMMAND+0x30>
     e34:	00 c0       	rjmp	.+0      	; 0xe36 <LCD_COMMAND+0x36>
     e36:	00 00       	nop
	_delay_us(170);			//rcall 180 us

	LCD_ENABLE_low();		// EN = 0
     e38:	db 98       	cbi	0x1b, 3	; 27
     e3a:	8f e8       	ldi	r24, 0x8F	; 143
     e3c:	91 e0       	ldi	r25, 0x01	; 1
     e3e:	01 97       	sbiw	r24, 0x01	; 1
     e40:	f1 f7       	brne	.-4      	; 0xe3e <LCD_COMMAND+0x3e>
     e42:	00 c0       	rjmp	.+0      	; 0xe44 <LCD_COMMAND+0x44>
     e44:	00 00       	nop
     e46:	08 95       	ret

00000e48 <LCD_INIT>:
/**********************************
** INITIZLIZATION OF LCD DISPLAY **
**********************************/
void LCD_INIT()
{
	LCD_COMMAND(LCD_8BIT_2ROWS_FONT5X7);		// 0b00111000	// 1. Function set: 8-bit interface data (DL = 1), 2-line display (N = 1), 5 x 7 dot character font (F = 0)
     e48:	88 e3       	ldi	r24, 0x38	; 56
     e4a:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_ENTRY_MODE_INC_NOSHIFT);	// 0b00000110	// 2. Entry mode set: Increment by 1 (I/D = 1), No shift (S = 0)
     e4e:	86 e0       	ldi	r24, 0x06	; 6
     e50:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_MOVE_FIRST);								// 3.
     e54:	82 e0       	ldi	r24, 0x02	; 2
     e56:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 4. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     e5a:	81 e0       	ldi	r24, 0x01	; 1
     e5c:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
     e60:	8f eb       	ldi	r24, 0xBF	; 191
     e62:	92 e1       	ldi	r25, 0x12	; 18
     e64:	01 97       	sbiw	r24, 0x01	; 1
     e66:	f1 f7       	brne	.-4      	; 0xe64 <LCD_INIT+0x1c>
     e68:	00 c0       	rjmp	.+0      	; 0xe6a <LCD_INIT+0x22>
     e6a:	00 00       	nop
     e6c:	08 95       	ret

00000e6e <LCD_CLEAR_CONTAIN>:
/**************************************
** CLEAR ALL CONTAINS ON LCD DISPLAY **
**************************************/
void LCD_CLEAR_CONTAIN()
{
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 1. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     e6e:	81 e0       	ldi	r24, 0x01	; 1
     e70:	0e 94 00 07 	call	0xe00	; 0xe00 <LCD_COMMAND>
     e74:	8f eb       	ldi	r24, 0xBF	; 191
     e76:	92 e1       	ldi	r25, 0x12	; 18
     e78:	01 97       	sbiw	r24, 0x01	; 1
     e7a:	f1 f7       	brne	.-4      	; 0xe78 <LCD_CLEAR_CONTAIN+0xa>
     e7c:	00 c0       	rjmp	.+0      	; 0xe7e <LCD_CLEAR_CONTAIN+0x10>
     e7e:	00 00       	nop
     e80:	08 95       	ret

00000e82 <LCD_DATA_STRING>:
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     e82:	fc 01       	movw	r30, r24
     e84:	21 91       	ld	r18, Z+
     e86:	cf 01       	movw	r24, r30
     e88:	22 23       	and	r18, r18
     e8a:	21 f1       	breq	.+72     	; 0xed4 <LCD_DATA_STRING+0x52>
     e8c:	38 e0       	ldi	r19, 0x08	; 8
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     e8e:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     e90:	27 ff       	sbrs	r18, 7
     e92:	02 c0       	rjmp	.+4      	; 0xe98 <LCD_DATA_STRING+0x16>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     e94:	d8 9a       	sbi	0x1b, 0	; 27
     e96:	01 c0       	rjmp	.+2      	; 0xe9a <LCD_DATA_STRING+0x18>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     e98:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     e9a:	d9 9a       	sbi	0x1b, 1	; 27

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     e9c:	22 0f       	add	r18, r18
     e9e:	31 50       	subi	r19, 0x01	; 1
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     ea0:	b1 f7       	brne	.-20     	; 0xe8e <LCD_DATA_STRING+0xc>
			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     ea2:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     ea4:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     ea6:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     ea8:	da 98       	cbi	0x1b, 2	; 27
     eaa:	e7 ea       	ldi	r30, 0xA7	; 167
     eac:	f2 e0       	ldi	r31, 0x02	; 2
     eae:	31 97       	sbiw	r30, 0x01	; 1
     eb0:	f1 f7       	brne	.-4      	; 0xeae <LCD_DATA_STRING+0x2c>
     eb2:	00 c0       	rjmp	.+0      	; 0xeb4 <LCD_DATA_STRING+0x32>
     eb4:	00 00       	nop
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     eb6:	da 9a       	sbi	0x1b, 2	; 27
     eb8:	e7 ea       	ldi	r30, 0xA7	; 167
     eba:	f2 e0       	ldi	r31, 0x02	; 2
     ebc:	31 97       	sbiw	r30, 0x01	; 1
     ebe:	f1 f7       	brne	.-4      	; 0xebc <LCD_DATA_STRING+0x3a>
     ec0:	00 c0       	rjmp	.+0      	; 0xec2 <LCD_DATA_STRING+0x40>
     ec2:	00 00       	nop
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     ec4:	db 98       	cbi	0x1b, 3	; 27
     ec6:	ef e8       	ldi	r30, 0x8F	; 143
     ec8:	f1 e0       	ldi	r31, 0x01	; 1
     eca:	31 97       	sbiw	r30, 0x01	; 1
     ecc:	f1 f7       	brne	.-4      	; 0xeca <LCD_DATA_STRING+0x48>
     ece:	00 c0       	rjmp	.+0      	; 0xed0 <LCD_DATA_STRING+0x4e>
     ed0:	00 00       	nop
     ed2:	d7 cf       	rjmp	.-82     	; 0xe82 <LCD_DATA_STRING>
		_delay_us(100);
	}
}
     ed4:	08 95       	ret

00000ed6 <LCD_DATA_UINT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataUInt( (unsigned int)k + 1 );
void LCD_DATA_UINT(unsigned int data)		// void lcdDataUInt(const unsigned int data)
{
     ed6:	cf 93       	push	r28
     ed8:	df 93       	push	r29
     eda:	cd b7       	in	r28, 0x3d	; 61
     edc:	de b7       	in	r29, 0x3e	; 62
     ede:	2a 97       	sbiw	r28, 0x0a	; 10
     ee0:	0f b6       	in	r0, 0x3f	; 63
     ee2:	f8 94       	cli
     ee4:	de bf       	out	0x3e, r29	; 62
     ee6:	0f be       	out	0x3f, r0	; 63
     ee8:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(utoa(data, buffer, 10));	// 10 -> DECIMAL
     eea:	4a e0       	ldi	r20, 0x0A	; 10
     eec:	50 e0       	ldi	r21, 0x00	; 0
     eee:	be 01       	movw	r22, r28
     ef0:	6f 5f       	subi	r22, 0xFF	; 255
     ef2:	7f 4f       	sbci	r23, 0xFF	; 255
     ef4:	0e 94 c0 0b 	call	0x1780	; 0x1780 <utoa>
     ef8:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
}
     efc:	2a 96       	adiw	r28, 0x0a	; 10
     efe:	0f b6       	in	r0, 0x3f	; 63
     f00:	f8 94       	cli
     f02:	de bf       	out	0x3e, r29	; 62
     f04:	0f be       	out	0x3f, r0	; 63
     f06:	cd bf       	out	0x3d, r28	; 61
     f08:	df 91       	pop	r29
     f0a:	cf 91       	pop	r28
     f0c:	08 95       	ret

00000f0e <LCD_DATA_INT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataInt( (int)k + 1 );
void LCD_DATA_INT(int data)		// void lcdDataInt(const int data)
{
     f0e:	cf 93       	push	r28
     f10:	df 93       	push	r29
     f12:	cd b7       	in	r28, 0x3d	; 61
     f14:	de b7       	in	r29, 0x3e	; 62
     f16:	2a 97       	sbiw	r28, 0x0a	; 10
     f18:	0f b6       	in	r0, 0x3f	; 63
     f1a:	f8 94       	cli
     f1c:	de bf       	out	0x3e, r29	; 62
     f1e:	0f be       	out	0x3f, r0	; 63
     f20:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(itoa(data, buffer, 10));	// 10 -> DECIMAL
     f22:	4a e0       	ldi	r20, 0x0A	; 10
     f24:	50 e0       	ldi	r21, 0x00	; 0
     f26:	be 01       	movw	r22, r28
     f28:	6f 5f       	subi	r22, 0xFF	; 255
     f2a:	7f 4f       	sbci	r23, 0xFF	; 255
     f2c:	0e 94 46 0b 	call	0x168c	; 0x168c <itoa>
     f30:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
}
     f34:	2a 96       	adiw	r28, 0x0a	; 10
     f36:	0f b6       	in	r0, 0x3f	; 63
     f38:	f8 94       	cli
     f3a:	de bf       	out	0x3e, r29	; 62
     f3c:	0f be       	out	0x3f, r0	; 63
     f3e:	cd bf       	out	0x3d, r28	; 61
     f40:	df 91       	pop	r29
     f42:	cf 91       	pop	r28
     f44:	08 95       	ret

00000f46 <LCD_DATA_LONG>:
/*******************************************************
** WRITE/TRANSMIT MORE DATA LONG BYTES TO LCD DISPLAY **
*******************************************************/
// USE THIS: lcdDataLong( (long)k + 1 );
void LCD_DATA_LONG(long data)		// void lcdDataLong(const long data)
{
     f46:	cf 93       	push	r28
     f48:	df 93       	push	r29
     f4a:	cd b7       	in	r28, 0x3d	; 61
     f4c:	de b7       	in	r29, 0x3e	; 62
     f4e:	2a 97       	sbiw	r28, 0x0a	; 10
     f50:	0f b6       	in	r0, 0x3f	; 63
     f52:	f8 94       	cli
     f54:	de bf       	out	0x3e, r29	; 62
     f56:	0f be       	out	0x3f, r0	; 63
     f58:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ltoa(data, buffer, 10));	// 10 -> DECIMAL
     f5a:	2a e0       	ldi	r18, 0x0A	; 10
     f5c:	30 e0       	ldi	r19, 0x00	; 0
     f5e:	ae 01       	movw	r20, r28
     f60:	4f 5f       	subi	r20, 0xFF	; 255
     f62:	5f 4f       	sbci	r21, 0xFF	; 255
     f64:	0e 94 67 0b 	call	0x16ce	; 0x16ce <ltoa>
     f68:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
}
     f6c:	2a 96       	adiw	r28, 0x0a	; 10
     f6e:	0f b6       	in	r0, 0x3f	; 63
     f70:	f8 94       	cli
     f72:	de bf       	out	0x3e, r29	; 62
     f74:	0f be       	out	0x3f, r0	; 63
     f76:	cd bf       	out	0x3d, r28	; 61
     f78:	df 91       	pop	r29
     f7a:	cf 91       	pop	r28
     f7c:	08 95       	ret

00000f7e <LCD_DATA_ULONG>:
/****************************************************************
** WRITE/TRANSMIT MORE DATA UNSIGNED LONG BYTES TO LCD DISPLAY **
****************************************************************/
// USE THIS: lcdDataULong( (unsigned long)k + 1 );
void LCD_DATA_ULONG(unsigned long data)		// void lcdDataULong(const unsigned long data)
{
     f7e:	cf 93       	push	r28
     f80:	df 93       	push	r29
     f82:	cd b7       	in	r28, 0x3d	; 61
     f84:	de b7       	in	r29, 0x3e	; 62
     f86:	2a 97       	sbiw	r28, 0x0a	; 10
     f88:	0f b6       	in	r0, 0x3f	; 63
     f8a:	f8 94       	cli
     f8c:	de bf       	out	0x3e, r29	; 62
     f8e:	0f be       	out	0x3f, r0	; 63
     f90:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ultoa(data, buffer, 10));	// 10 -> DECIMAL
     f92:	2a e0       	ldi	r18, 0x0A	; 10
     f94:	30 e0       	ldi	r19, 0x00	; 0
     f96:	ae 01       	movw	r20, r28
     f98:	4f 5f       	subi	r20, 0xFF	; 255
     f9a:	5f 4f       	sbci	r21, 0xFF	; 255
     f9c:	0e 94 9b 0b 	call	0x1736	; 0x1736 <ultoa>
     fa0:	0e 94 41 07 	call	0xe82	; 0xe82 <LCD_DATA_STRING>
}
     fa4:	2a 96       	adiw	r28, 0x0a	; 10
     fa6:	0f b6       	in	r0, 0x3f	; 63
     fa8:	f8 94       	cli
     faa:	de bf       	out	0x3e, r29	; 62
     fac:	0f be       	out	0x3f, r0	; 63
     fae:	cd bf       	out	0x3d, r28	; 61
     fb0:	df 91       	pop	r29
     fb2:	cf 91       	pop	r28
     fb4:	08 95       	ret

00000fb6 <LCD_CGRAM_CUSTOM_SYMBOLS>:
	 { 0x0E, 0x1B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F },	// Battery Charging  80%	// addr40-47
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
     fb6:	cf 93       	push	r28
     fb8:	df 93       	push	r29
	for(rows=0; rows<7; rows++)
     fba:	10 92 75 04 	sts	0x0475, r1
     fbe:	10 92 74 04 	sts	0x0474, r1
     fc2:	80 91 74 04 	lds	r24, 0x0474
     fc6:	90 91 75 04 	lds	r25, 0x0475
     fca:	87 30       	cpi	r24, 0x07	; 7
     fcc:	91 05       	cpc	r25, r1
     fce:	34 f5       	brge	.+76     	; 0x101c <LCD_CGRAM_CUSTOM_SYMBOLS+0x66>
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
     fd0:	08 96       	adiw	r24, 0x08	; 8
     fd2:	88 0f       	add	r24, r24
     fd4:	88 0f       	add	r24, r24
     fd6:	88 0f       	add	r24, r24
     fd8:	0e 94 7c 06 	call	0xcf8	; 0xcf8 <LCD_EXECUTE_COMMAND>
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
     fdc:	c0 e0       	ldi	r28, 0x00	; 0
     fde:	d0 e0       	ldi	r29, 0x00	; 0
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
     fe0:	e0 91 74 04 	lds	r30, 0x0474
     fe4:	f0 91 75 04 	lds	r31, 0x0475
     fe8:	83 e0       	ldi	r24, 0x03	; 3
     fea:	ee 0f       	add	r30, r30
     fec:	ff 1f       	adc	r31, r31
     fee:	8a 95       	dec	r24
     ff0:	e1 f7       	brne	.-8      	; 0xfea <LCD_CGRAM_CUSTOM_SYMBOLS+0x34>
     ff2:	ec 0f       	add	r30, r28
     ff4:	fd 1f       	adc	r31, r29
     ff6:	eb 56       	subi	r30, 0x6B	; 107
     ff8:	ff 4f       	sbci	r31, 0xFF	; 255
     ffa:	80 81       	ld	r24, Z
     ffc:	0e 94 cd 06 	call	0xd9a	; 0xd9a <LCD_EXECUTE_DATA_ONE>
void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
    1000:	21 96       	adiw	r28, 0x01	; 1
    1002:	c8 30       	cpi	r28, 0x08	; 8
    1004:	d1 05       	cpc	r29, r1
    1006:	61 f7       	brne	.-40     	; 0xfe0 <LCD_CGRAM_CUSTOM_SYMBOLS+0x2a>
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
    1008:	80 91 74 04 	lds	r24, 0x0474
    100c:	90 91 75 04 	lds	r25, 0x0475
    1010:	01 96       	adiw	r24, 0x01	; 1
    1012:	90 93 75 04 	sts	0x0475, r25
    1016:	80 93 74 04 	sts	0x0474, r24
    101a:	d3 cf       	rjmp	.-90     	; 0xfc2 <LCD_CGRAM_CUSTOM_SYMBOLS+0xc>
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
		}
	}
}
    101c:	df 91       	pop	r29
    101e:	cf 91       	pop	r28
    1020:	08 95       	ret

00001022 <pga2310_reset>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_reset()
{
	spi_init();
    1022:	0e 94 fd 08 	call	0x11fa	; 0x11fa <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    1026:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1028:	60 e0       	ldi	r22, 0x00	; 0
    102a:	80 e0       	ldi	r24, 0x00	; 0
    102c:	0e 94 0e 09 	call	0x121c	; 0x121c <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    1030:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1032:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1034:	60 e0       	ldi	r22, 0x00	; 0
    1036:	80 e0       	ldi	r24, 0x00	; 0
    1038:	0e 94 0e 09 	call	0x121c	; 0x121c <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    103c:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    103e:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1040:	60 e0       	ldi	r22, 0x00	; 0
    1042:	80 e0       	ldi	r24, 0x00	; 0
    1044:	0e 94 0e 09 	call	0x121c	; 0x121c <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    1048:	df 9a       	sbi	0x1b, 7	; 27
    104a:	08 95       	ret

0000104c <pga2310_init>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_init()
{
	spi_init();
    104c:	0e 94 fd 08 	call	0x11fa	; 0x11fa <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    1050:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1052:	60 e0       	ldi	r22, 0x00	; 0
    1054:	80 e0       	ldi	r24, 0x00	; 0
    1056:	0e 94 0e 09 	call	0x121c	; 0x121c <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    105a:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    105c:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    105e:	60 e0       	ldi	r22, 0x00	; 0
    1060:	80 e0       	ldi	r24, 0x00	; 0
    1062:	0e 94 0e 09 	call	0x121c	; 0x121c <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    1066:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1068:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    106a:	60 e0       	ldi	r22, 0x00	; 0
    106c:	80 e0       	ldi	r24, 0x00	; 0
    106e:	0e 94 0e 09 	call	0x121c	; 0x121c <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    1072:	df 9a       	sbi	0x1b, 7	; 27
    1074:	08 95       	ret

00001076 <PGA2310_Volume_Update>:

/*************************************
** DEFINITION PGA2310 VOLUME UPDATE **
*************************************/
void PGA2310_Volume_Update(unsigned char pgaVolumeLeft, unsigned char pgaVolumeRight)
{
    1076:	cf 93       	push	r28
    1078:	df 93       	push	r29
    107a:	c8 2f       	mov	r28, r24
    107c:	d6 2f       	mov	r29, r22
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    107e:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    1080:	0e 94 0e 09 	call	0x121c	; 0x121c <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    1084:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1086:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    1088:	6d 2f       	mov	r22, r29
    108a:	8c 2f       	mov	r24, r28
    108c:	0e 94 0e 09 	call	0x121c	; 0x121c <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    1090:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA7 - /SS ENABLE
    1092:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    1094:	6d 2f       	mov	r22, r29
    1096:	8c 2f       	mov	r24, r28
    1098:	0e 94 0e 09 	call	0x121c	; 0x121c <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    109c:	df 9a       	sbi	0x1b, 7	; 27

//	return SUCCESS;
}
    109e:	df 91       	pop	r29
    10a0:	cf 91       	pop	r28
    10a2:	08 95       	ret

000010a4 <uart_init>:
{
	switch(F_CPU)
	{
		case 16000000UL:
		{
			UBRRL = 103;	// Baudrate: 9600; (Error = 0.2%; 16MHz)
    10a4:	87 e6       	ldi	r24, 0x67	; 103
    10a6:	89 b9       	out	0x09, r24	; 9
			UBRRH = 0;
    10a8:	10 bc       	out	0x20, r1	; 32
	LCD_DATA_STRING(" MHz");		// 20 symbols
#endif
	// Razpoznavane na baudrate (skorost): 1. Izprashta se byte. 2. Poluchava se byte. 3. Sravnqva se polucheniq byte == izprateniq byte. // This is LOOP TX->RX
	// 4. Ako byte pri sravnqvaneto e edin i sasht to skorostta e izbranata v momenta, ako byte e razlichen - da se probva sas sledvashta baudrate.

	UCSRC = 0b10000110;		// URSEL = 1 (Accessing to UBRRH or UCSRC, is read as zero when reading UBRRH. The URSEL must be zero when writing the UBRRH.); UMSEL = 0 (Asynchronous Operation); UPM1 = 0, UPM0 = 0 (Parity Mode Disabled); USBS = 0 (1-Stop Bit); UCSZ2 = 0, UCSZ1 = 1, UCSZ0 = 1 (8-DataBits); UCPOL = 0 Polarity TX & RX (Rising XCK Edge -> Transmitted Data Changed (Output of TxDPin), Falling XCK Edge -> Received Data Sampled (Input on RxDPin))
    10aa:	86 e8       	ldi	r24, 0x86	; 134
    10ac:	80 bd       	out	0x20, r24	; 32
	UCSRB = 0b00001000;		// Enable only TXEN	- Transmitting Uart/Usart	// UCSRB = 0b10011000;		// Enable TXEN,RXEN,RXCIE	Transmitting and Receiving Uart/Usart
    10ae:	88 e0       	ldi	r24, 0x08	; 8
    10b0:	8a b9       	out	0x0a, r24	; 10
	UDR = 0b00000000;		// INITIALIZATION NULL OF UART DATA
    10b2:	1c b8       	out	0x0c, r1	; 12
    10b4:	08 95       	ret

000010b6 <uart_transmit>:
/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
    10b6:	fc 01       	movw	r30, r24
    10b8:	9f 01       	movw	r18, r30
    10ba:	28 1b       	sub	r18, r24
    10bc:	39 0b       	sbc	r19, r25
    10be:	26 17       	cp	r18, r22
    10c0:	37 07       	cpc	r19, r23
    10c2:	2c f4       	brge	.+10     	; 0x10ce <uart_transmit+0x18>
	{
		//UDR = uart_data[count_ns];
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10c4:	5d 9b       	sbis	0x0b, 5	; 11
    10c6:	fe cf       	rjmp	.-4      	; 0x10c4 <uart_transmit+0xe>
		{
		}
		UDR = uart_data[count_ns];
    10c8:	21 91       	ld	r18, Z+
    10ca:	2c b9       	out	0x0c, r18	; 12
    10cc:	f5 cf       	rjmp	.-22     	; 0x10b8 <uart_transmit+0x2>
	}
}
    10ce:	08 95       	ret

000010d0 <uart_transmit_one>:
/***************************************
** TRANSMIT/SEND 1 BYTE OF UART/USART **
***************************************/
void uart_transmit_one(unsigned char uart_data)
{
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10d0:	5d 9b       	sbis	0x0b, 5	; 11
    10d2:	fe cf       	rjmp	.-4      	; 0x10d0 <uart_transmit_one>
	{
	}
	UDR = uart_data;
    10d4:	8c b9       	out	0x0c, r24	; 12
    10d6:	08 95       	ret

000010d8 <uart_transmit_DEC_to_BCD>:
** TRANSMIT/SEND 1 BYTE CONVERTED FROM DEC TO BCD OF UART/USART **		// NOT FINISHED
*****************************************************************/		// NOT FINISHED
void uart_transmit_DEC_to_BCD(unsigned char dec_to_bcd_data)
{// pravi se preobrazuvane ot DEC to BCD i preobrazuvane za izvejdane na parviq simvol s filtar
	
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10d8:	5d 9b       	sbis	0x0b, 5	; 11
    10da:	fe cf       	rjmp	.-4      	; 0x10d8 <uart_transmit_DEC_to_BCD>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data>>4));
    10dc:	98 2f       	mov	r25, r24
    10de:	92 95       	swap	r25
    10e0:	9f 70       	andi	r25, 0x0F	; 15
    10e2:	90 5d       	subi	r25, 0xD0	; 208
    10e4:	9c b9       	out	0x0c, r25	; 12

	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10e6:	5d 9b       	sbis	0x0b, 5	; 11
    10e8:	fe cf       	rjmp	.-4      	; 0x10e6 <uart_transmit_DEC_to_BCD+0xe>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data & 0x0F));
    10ea:	8f 70       	andi	r24, 0x0F	; 15
    10ec:	80 5d       	subi	r24, 0xD0	; 208
    10ee:	8c b9       	out	0x0c, r24	; 12
    10f0:	08 95       	ret

000010f2 <transmitUart>:
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
    10f2:	5d 9b       	sbis	0x0b, 5	; 11
    10f4:	fe cf       	rjmp	.-4      	; 0x10f2 <transmitUart>
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
    10f6:	8c b9       	out	0x0c, r24	; 12
    10f8:	08 95       	ret

000010fa <transmitUartString>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
    10fa:	cf 93       	push	r28
    10fc:	df 93       	push	r29
    10fe:	ec 01       	movw	r28, r24
	while(*data)
    1100:	89 91       	ld	r24, Y+
    1102:	88 23       	and	r24, r24
    1104:	19 f0       	breq	.+6      	; 0x110c <transmitUartString+0x12>
	{
		transmitUart(*data++);
    1106:	0e 94 79 08 	call	0x10f2	; 0x10f2 <transmitUart>
    110a:	fa cf       	rjmp	.-12     	; 0x1100 <transmitUartString+0x6>
	}
}
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	08 95       	ret

00001112 <transmitUartUInt>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned int BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: transmitUartUInt( (unsigned int)k + 1 );
void transmitUartUInt(unsigned int data)		// void transmitUartUInt(const unsigned int data)
{
    1112:	cf 93       	push	r28
    1114:	df 93       	push	r29
    1116:	cd b7       	in	r28, 0x3d	; 61
    1118:	de b7       	in	r29, 0x3e	; 62
    111a:	2a 97       	sbiw	r28, 0x0a	; 10
    111c:	0f b6       	in	r0, 0x3f	; 63
    111e:	f8 94       	cli
    1120:	de bf       	out	0x3e, r29	; 62
    1122:	0f be       	out	0x3f, r0	; 63
    1124:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(utoa(data, buffer, 10));		// 10 -> DECIMAL
    1126:	4a e0       	ldi	r20, 0x0A	; 10
    1128:	50 e0       	ldi	r21, 0x00	; 0
    112a:	be 01       	movw	r22, r28
    112c:	6f 5f       	subi	r22, 0xFF	; 255
    112e:	7f 4f       	sbci	r23, 0xFF	; 255
    1130:	0e 94 c0 0b 	call	0x1780	; 0x1780 <utoa>
    1134:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
}
    1138:	2a 96       	adiw	r28, 0x0a	; 10
    113a:	0f b6       	in	r0, 0x3f	; 63
    113c:	f8 94       	cli
    113e:	de bf       	out	0x3e, r29	; 62
    1140:	0f be       	out	0x3f, r0	; 63
    1142:	cd bf       	out	0x3d, r28	; 61
    1144:	df 91       	pop	r29
    1146:	cf 91       	pop	r28
    1148:	08 95       	ret

0000114a <transmitUartInt>:
/*****************************************		// NOT FINISHED
** TRANSMIT/SEND int BYTE OF UART/USART **		// NOT FINISHED
*****************************************/		// NOT FINISHED
// USE THIS: transmitUartInt( (int)k + 1 );
void transmitUartInt(int data)		// void transmitUartInt(const int data)
{
    114a:	cf 93       	push	r28
    114c:	df 93       	push	r29
    114e:	cd b7       	in	r28, 0x3d	; 61
    1150:	de b7       	in	r29, 0x3e	; 62
    1152:	2a 97       	sbiw	r28, 0x0a	; 10
    1154:	0f b6       	in	r0, 0x3f	; 63
    1156:	f8 94       	cli
    1158:	de bf       	out	0x3e, r29	; 62
    115a:	0f be       	out	0x3f, r0	; 63
    115c:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(itoa(data, buffer, 10));		// 10 -> DECIMAL
    115e:	4a e0       	ldi	r20, 0x0A	; 10
    1160:	50 e0       	ldi	r21, 0x00	; 0
    1162:	be 01       	movw	r22, r28
    1164:	6f 5f       	subi	r22, 0xFF	; 255
    1166:	7f 4f       	sbci	r23, 0xFF	; 255
    1168:	0e 94 46 0b 	call	0x168c	; 0x168c <itoa>
    116c:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
}
    1170:	2a 96       	adiw	r28, 0x0a	; 10
    1172:	0f b6       	in	r0, 0x3f	; 63
    1174:	f8 94       	cli
    1176:	de bf       	out	0x3e, r29	; 62
    1178:	0f be       	out	0x3f, r0	; 63
    117a:	cd bf       	out	0x3d, r28	; 61
    117c:	df 91       	pop	r29
    117e:	cf 91       	pop	r28
    1180:	08 95       	ret

00001182 <transmitUartULong>:
/***************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned long BYTE OF UART/USART **		// NOT FINISHED
***************************************************/		// NOT FINISHED
// USE THIS: transmitUartULong( (unsigned long)k + 1 );
void transmitUartULong(unsigned long data)		// void transmitUartULong(const unsigned long data)
{
    1182:	cf 93       	push	r28
    1184:	df 93       	push	r29
    1186:	cd b7       	in	r28, 0x3d	; 61
    1188:	de b7       	in	r29, 0x3e	; 62
    118a:	2a 97       	sbiw	r28, 0x0a	; 10
    118c:	0f b6       	in	r0, 0x3f	; 63
    118e:	f8 94       	cli
    1190:	de bf       	out	0x3e, r29	; 62
    1192:	0f be       	out	0x3f, r0	; 63
    1194:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ultoa(data, buffer, 10));		// 10 -> DECIMAL
    1196:	2a e0       	ldi	r18, 0x0A	; 10
    1198:	30 e0       	ldi	r19, 0x00	; 0
    119a:	ae 01       	movw	r20, r28
    119c:	4f 5f       	subi	r20, 0xFF	; 255
    119e:	5f 4f       	sbci	r21, 0xFF	; 255
    11a0:	0e 94 9b 0b 	call	0x1736	; 0x1736 <ultoa>
    11a4:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
}
    11a8:	2a 96       	adiw	r28, 0x0a	; 10
    11aa:	0f b6       	in	r0, 0x3f	; 63
    11ac:	f8 94       	cli
    11ae:	de bf       	out	0x3e, r29	; 62
    11b0:	0f be       	out	0x3f, r0	; 63
    11b2:	cd bf       	out	0x3d, r28	; 61
    11b4:	df 91       	pop	r29
    11b6:	cf 91       	pop	r28
    11b8:	08 95       	ret

000011ba <transmitUartLong>:
/******************************************		// NOT FINISHED
** TRANSMIT/SEND long BYTE OF UART/USART **		// NOT FINISHED
******************************************/		// NOT FINISHED
// USE THIS: transmitUartLong( (long)k + 1 );
void transmitUartLong(long data)		// void transmitUartLong(const long data)
{
    11ba:	cf 93       	push	r28
    11bc:	df 93       	push	r29
    11be:	cd b7       	in	r28, 0x3d	; 61
    11c0:	de b7       	in	r29, 0x3e	; 62
    11c2:	2a 97       	sbiw	r28, 0x0a	; 10
    11c4:	0f b6       	in	r0, 0x3f	; 63
    11c6:	f8 94       	cli
    11c8:	de bf       	out	0x3e, r29	; 62
    11ca:	0f be       	out	0x3f, r0	; 63
    11cc:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ltoa(data, buffer, 10));		// 10 -> DECIMAL
    11ce:	2a e0       	ldi	r18, 0x0A	; 10
    11d0:	30 e0       	ldi	r19, 0x00	; 0
    11d2:	ae 01       	movw	r20, r28
    11d4:	4f 5f       	subi	r20, 0xFF	; 255
    11d6:	5f 4f       	sbci	r21, 0xFF	; 255
    11d8:	0e 94 67 0b 	call	0x16ce	; 0x16ce <ltoa>
    11dc:	0e 94 7d 08 	call	0x10fa	; 0x10fa <transmitUartString>
}
    11e0:	2a 96       	adiw	r28, 0x0a	; 10
    11e2:	0f b6       	in	r0, 0x3f	; 63
    11e4:	f8 94       	cli
    11e6:	de bf       	out	0x3e, r29	; 62
    11e8:	0f be       	out	0x3f, r0	; 63
    11ea:	cd bf       	out	0x3d, r28	; 61
    11ec:	df 91       	pop	r29
    11ee:	cf 91       	pop	r28
    11f0:	08 95       	ret

000011f2 <receiveUart>:
/**************************************************		// NOT FINISHED
** RECEIVE/READ unsigned char BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
unsigned char receiveUart(void)
{
	while (!(UCSRA & (1<<RXC)))
    11f2:	5f 9b       	sbis	0x0b, 7	; 11
    11f4:	fe cf       	rjmp	.-4      	; 0x11f2 <receiveUart>
	{};							/* Wait for data to be received */
	return UDR;					/* Get and return received data from buffer */
    11f6:	8c b1       	in	r24, 0x0c	; 12
}
    11f8:	08 95       	ret

000011fa <spi_init>:
/**************************
** INITIZLIZATION OF SPI **
***************************/
void spi_init()
{
	SPSR = (0<<SPIF)|(0<<WCOL)|(0<<SPI2X);
    11fa:	1e b8       	out	0x0e, r1	; 14
//	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);			//0b01010010	// SPR1   = 1 - 16 000 000 / 64  = 250 000 = 250kHz  // KOMENTAR ZARADI SIMULACIQTA - PROTEUS BLOKIRANE ZARADI BIT V REGISTAR
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz	 // KAKVA KOMBINACIQ OT 4-te BITa VODI DO RAZBLOKIRANETO ???
    11fc:	83 e5       	ldi	r24, 0x53	; 83
    11fe:	8d b9       	out	0x0d, r24	; 13
	SPDR = 0b00000000;
    1200:	1f b8       	out	0x0f, r1	; 15

	PGA2310_U8_SPI_CS_high();	// /SS - DISABLE
	PGA2310_U8_SPI(0b00000000, 0b00000000);
	*/

	SPCR = (0<<SPE);
    1202:	1d b8       	out	0x0d, r1	; 13
    1204:	08 95       	ret

00001206 <spi_start>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1206:	83 e5       	ldi	r24, 0x53	; 83
    1208:	8d b9       	out	0x0d, r24	; 13
    120a:	08 95       	ret

0000120c <spi_stop>:
/**************************************
** DEFINITION SPI FUNCTION STOP ONLY **
**************************************/
void spi_stop()
{
	SPCR = (0<<SPE);
    120c:	1d b8       	out	0x0d, r1	; 13
    120e:	08 95       	ret

00001210 <spi_write_one_byte>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1210:	93 e5       	ldi	r25, 0x53	; 83
    1212:	9d b9       	out	0x0d, r25	; 13
void spi_write_one_byte(unsigned char data)	// void PGA2310_U7_SPI(byte volume_left, byte volume_right)	//PGA2310_U7_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data;				//volume_right;
    1214:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    1216:	77 9b       	sbis	0x0e, 7	; 14
    1218:	fe cf       	rjmp	.-4      	; 0x1216 <spi_write_one_byte+0x6>
	{
	}
}
    121a:	08 95       	ret

0000121c <spi_write_two_bytes>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    121c:	93 e5       	ldi	r25, 0x53	; 83
    121e:	9d b9       	out	0x0d, r25	; 13
void spi_write_two_bytes(unsigned char data1, unsigned char data2)	// void PGA2310_U6_SPI(byte volume_left, byte volume_right)	//PGA2310_U6_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data1;				//volume_left;
    1220:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    1222:	77 9b       	sbis	0x0e, 7	; 14
    1224:	fe cf       	rjmp	.-4      	; 0x1222 <spi_write_two_bytes+0x6>
	{
	}

//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data2;				//volume_right;
    1226:	6f b9       	out	0x0f, r22	; 15
	while(!(SPSR & (1<<SPIF)))
    1228:	77 9b       	sbis	0x0e, 7	; 14
    122a:	fe cf       	rjmp	.-4      	; 0x1228 <spi_write_two_bytes+0xc>
	{
	}
}
    122c:	08 95       	ret

0000122e <spi_write_more_bytes>:

/*********************************************
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
    122e:	fc 01       	movw	r30, r24
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1230:	93 e5       	ldi	r25, 0x53	; 83
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    1232:	81 91       	ld	r24, Z+
    1234:	88 23       	and	r24, r24
    1236:	31 f0       	breq	.+12     	; 0x1244 <spi_write_more_bytes+0x16>
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1238:	9d b9       	out	0x0d, r25	; 13
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
	{
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
		spi_start();
		SPDR = *data;			//volume_left;
    123a:	80 81       	ld	r24, Z
    123c:	8f b9       	out	0x0f, r24	; 15
		while(!(SPSR & (1<<SPIF)))
    123e:	77 9b       	sbis	0x0e, 7	; 14
    1240:	fe cf       	rjmp	.-4      	; 0x123e <spi_write_more_bytes+0x10>
    1242:	f7 cf       	rjmp	.-18     	; 0x1232 <spi_write_more_bytes+0x4>
		{
		}
	}
}
    1244:	08 95       	ret

00001246 <spi_read_more_bytes>:
unsigned char spi_read_more_bytes()	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
	unsigned char data = 0b00000000;
	//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data;			//volume_left;
    1246:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF)))
    1248:	77 9b       	sbis	0x0e, 7	; 14
    124a:	fe cf       	rjmp	.-4      	; 0x1248 <spi_read_more_bytes+0x2>
	{
	}
	return data;
}
    124c:	80 e0       	ldi	r24, 0x00	; 0
    124e:	08 95       	ret

00001250 <decToBcd>:
/**************************************************************
**** CONVERT NORMAL DECIMAL NUMBERS TO BINARY CODED DECIMAL ***
**************************************************************/
unsigned char decToBcd(unsigned char val)
{
	return ( (val/10*16) + (val%10) );	// Get DEC format -> convert DEC to HEX
    1250:	6a e0       	ldi	r22, 0x0A	; 10
    1252:	0e 94 3a 0b 	call	0x1674	; 0x1674 <__udivmodqi4>
}
    1256:	20 e1       	ldi	r18, 0x10	; 16
    1258:	82 9f       	mul	r24, r18
    125a:	90 0d       	add	r25, r0
    125c:	11 24       	eor	r1, r1
    125e:	89 2f       	mov	r24, r25
    1260:	08 95       	ret

00001262 <bcdToDec>:
/**************************************************************
**** CONVERT BINARY CODED DECIMAL TO NORMAL DECIMAL NUMBERS ***
**************************************************************/
unsigned char bcdToDec(unsigned char val)
{
	return ( (val/16*10) + (val%16) );	// Get HEX format -> convert HEX to DEC
    1262:	98 2f       	mov	r25, r24
    1264:	92 95       	swap	r25
    1266:	9f 70       	andi	r25, 0x0F	; 15
    1268:	8f 70       	andi	r24, 0x0F	; 15
}
    126a:	2a e0       	ldi	r18, 0x0A	; 10
    126c:	92 9f       	mul	r25, r18
    126e:	80 0d       	add	r24, r0
    1270:	11 24       	eor	r1, r1
    1272:	08 95       	ret

00001274 <shiftRightOutLsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    1274:	a0 9a       	sbi	0x14, 0	; 20
    1276:	88 e0       	ldi	r24, 0x08	; 8
void shiftRightOutLsbFirst()
{
	unsigned char conbyte = 0x44;
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
    1278:	94 e4       	ldi	r25, 0x44	; 68
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regALSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    127a:	90 ff       	sbrs	r25, 0
    127c:	02 c0       	rjmp	.+4      	; 0x1282 <shiftRightOutLsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v LSB
    127e:	a8 9a       	sbi	0x15, 0	; 21
    1280:	01 c0       	rjmp	.+2      	; 0x1284 <shiftRightOutLsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
    1282:	a8 98       	cbi	0x15, 0	; 21
		}
		
		regALSB = regALSB >> 1;	// shiftvane na >> nadqsno
    1284:	96 95       	lsr	r25
    1286:	81 50       	subi	r24, 0x01	; 1
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1288:	c1 f7       	brne	.-16     	; 0x127a <shiftRightOutLsbFirst+0x6>
		}
		
		regALSB = regALSB >> 1;	// shiftvane na >> nadqsno
	}

}
    128a:	08 95       	ret

0000128c <shiftLeftOutMsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    128c:	a0 9a       	sbi	0x14, 0	; 20
    128e:	88 e0       	ldi	r24, 0x08	; 8
void shiftLeftOutMsbFirst()
{
	unsigned char conbyte = 0x44;
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
    1290:	94 e4       	ldi	r25, 0x44	; 68
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regAMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
    1292:	97 ff       	sbrs	r25, 7
    1294:	02 c0       	rjmp	.+4      	; 0x129a <shiftLeftOutMsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v MSB
    1296:	a8 9a       	sbi	0x15, 0	; 21
    1298:	01 c0       	rjmp	.+2      	; 0x129c <shiftLeftOutMsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
    129a:	a8 98       	cbi	0x15, 0	; 21
		}
		
		regAMSB = regAMSB << 1;	// shiftvane na << nalqvo
    129c:	99 0f       	add	r25, r25
    129e:	81 50       	subi	r24, 0x01	; 1
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12a0:	c1 f7       	brne	.-16     	; 0x1292 <shiftLeftOutMsbFirst+0x6>
		}
		
		regAMSB = regAMSB << 1;	// shiftvane na << nalqvo
	}

}
    12a2:	08 95       	ret

000012a4 <shiftRightInLsbFirst>:
void shiftRightInLsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    12a4:	a0 98       	cbi	0x14, 0	; 20
    12a6:	88 e0       	ldi	r24, 0x08	; 8

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
    12a8:	93 b3       	in	r25, 0x13	; 19
    12aa:	81 50       	subi	r24, 0x01	; 1
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12ac:	e9 f7       	brne	.-6      	; 0x12a8 <shiftRightInLsbFirst+0x4>
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
	}

}
    12ae:	08 95       	ret

000012b0 <shiftLeftInMsbFirst>:
void shiftLeftInMsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    12b0:	a0 98       	cbi	0x14, 0	; 20
    12b2:	88 e0       	ldi	r24, 0x08	; 8

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
    12b4:	93 b3       	in	r25, 0x13	; 19
    12b6:	81 50       	subi	r24, 0x01	; 1
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12b8:	e9 f7       	brne	.-6      	; 0x12b4 <shiftLeftInMsbFirst+0x4>
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
	}

}
    12ba:	08 95       	ret

000012bc <delay_ms>:
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    12bc:	40 e0       	ldi	r20, 0x00	; 0
    12be:	50 e0       	ldi	r21, 0x00	; 0
    12c0:	48 17       	cp	r20, r24
    12c2:	59 07       	cpc	r21, r25
    12c4:	64 f4       	brge	.+24     	; 0x12de <delay_ms+0x22>
    12c6:	24 e6       	ldi	r18, 0x64	; 100
    12c8:	30 e0       	ldi	r19, 0x00	; 0
	{
		for(j=0;j<100;j++)
		{
		  asm("nop");
    12ca:	00 00       	nop
		  asm("nop");
    12cc:	00 00       	nop
    12ce:	21 50       	subi	r18, 0x01	; 1
    12d0:	31 09       	sbc	r19, r1
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
	{
		for(j=0;j<100;j++)
    12d2:	21 15       	cp	r18, r1
    12d4:	31 05       	cpc	r19, r1
    12d6:	c9 f7       	brne	.-14     	; 0x12ca <delay_ms+0xe>
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    12d8:	4f 5f       	subi	r20, 0xFF	; 255
    12da:	5f 4f       	sbci	r21, 0xFF	; 255
    12dc:	f1 cf       	rjmp	.-30     	; 0x12c0 <delay_ms+0x4>
    12de:	08 95       	ret

000012e0 <rotaryEncoderNikBarzakov>:
** READ/SCAN ROTARY ENCODER OF NIK BARZAKOV **
*********************************************/
char rotaryEncoderNikBarzakov()
{
	char tempEncoder = 0;
	if((ENCODER_A_low()) && (ENCODER_B_low()))			// A0, B0
    12e0:	9d 99       	sbic	0x13, 5	; 19
    12e2:	12 c0       	rjmp	.+36     	; 0x1308 <rotaryEncoderNikBarzakov+0x28>
    12e4:	9c 99       	sbic	0x13, 4	; 19
    12e6:	10 c0       	rjmp	.+32     	; 0x1308 <rotaryEncoderNikBarzakov+0x28>
    12e8:	87 ec       	ldi	r24, 0xC7	; 199
    12ea:	90 e0       	ldi	r25, 0x00	; 0
    12ec:	01 97       	sbiw	r24, 0x01	; 1
    12ee:	f1 f7       	brne	.-4      	; 0x12ec <rotaryEncoderNikBarzakov+0xc>
    12f0:	00 c0       	rjmp	.+0      	; 0x12f2 <rotaryEncoderNikBarzakov+0x12>
    12f2:	00 00       	nop
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_high()) && (ENCODER_B_low()))		// A1, B0
    12f4:	9d 99       	sbic	0x13, 5	; 19
    12f6:	02 c0       	rjmp	.+4      	; 0x12fc <rotaryEncoderNikBarzakov+0x1c>
/*********************************************
** READ/SCAN ROTARY ENCODER OF NIK BARZAKOV **
*********************************************/
char rotaryEncoderNikBarzakov()
{
	char tempEncoder = 0;
    12f8:	80 e0       	ldi	r24, 0x00	; 0
    12fa:	08 95       	ret
	if((ENCODER_A_low()) && (ENCODER_B_low()))			// A0, B0
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_high()) && (ENCODER_B_low()))		// A1, B0
    12fc:	83 b3       	in	r24, 0x13	; 19
    12fe:	82 95       	swap	r24
    1300:	81 70       	andi	r24, 0x01	; 1
    1302:	91 e0       	ldi	r25, 0x01	; 1
    1304:	89 27       	eor	r24, r25
    1306:	08 95       	ret
// VOLUME UP
			tempEncoder = 1;	//	tempEncoder++;
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}
	}
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    1308:	9d 9b       	sbis	0x13, 5	; 19
    130a:	f6 cf       	rjmp	.-20     	; 0x12f8 <rotaryEncoderNikBarzakov+0x18>
    130c:	9c 99       	sbic	0x13, 4	; 19
    130e:	f4 cf       	rjmp	.-24     	; 0x12f8 <rotaryEncoderNikBarzakov+0x18>
    1310:	87 ec       	ldi	r24, 0xC7	; 199
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	01 97       	sbiw	r24, 0x01	; 1
    1316:	f1 f7       	brne	.-4      	; 0x1314 <rotaryEncoderNikBarzakov+0x34>
    1318:	00 c0       	rjmp	.+0      	; 0x131a <rotaryEncoderNikBarzakov+0x3a>
    131a:	00 00       	nop
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    131c:	9d 99       	sbic	0x13, 5	; 19
    131e:	ec cf       	rjmp	.-40     	; 0x12f8 <rotaryEncoderNikBarzakov+0x18>
    1320:	83 b3       	in	r24, 0x13	; 19
    1322:	82 95       	swap	r24
    1324:	81 70       	andi	r24, 0x01	; 1
    1326:	91 e0       	ldi	r25, 0x01	; 1
    1328:	89 27       	eor	r24, r25
    132a:	81 95       	neg	r24
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    132c:	08 95       	ret

0000132e <rotaryEncoderVer1>:
** READ/SCAN ROTARY ENCODER VERSION 1 / MODEL 1 **
*************************************************/
char rotaryEncoderVer1()	// Check imediate now bits in PIN register.
{
	char tempEncoder = 0;							// A1, B1
	if((ENCODER_A_low()) && (ENCODER_B_high()))			// A0, B1
    132e:	9d 99       	sbic	0x13, 5	; 19
    1330:	12 c0       	rjmp	.+36     	; 0x1356 <rotaryEncoderVer1+0x28>
    1332:	9c 9b       	sbis	0x13, 4	; 19
    1334:	10 c0       	rjmp	.+32     	; 0x1356 <rotaryEncoderVer1+0x28>
    1336:	87 ec       	ldi	r24, 0xC7	; 199
    1338:	90 e0       	ldi	r25, 0x00	; 0
    133a:	01 97       	sbiw	r24, 0x01	; 1
    133c:	f1 f7       	brne	.-4      	; 0x133a <rotaryEncoderVer1+0xc>
    133e:	00 c0       	rjmp	.+0      	; 0x1340 <rotaryEncoderVer1+0x12>
    1340:	00 00       	nop
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    1342:	9d 9b       	sbis	0x13, 5	; 19
    1344:	02 c0       	rjmp	.+4      	; 0x134a <rotaryEncoderVer1+0x1c>
/*************************************************
** READ/SCAN ROTARY ENCODER VERSION 1 / MODEL 1 **
*************************************************/
char rotaryEncoderVer1()	// Check imediate now bits in PIN register.
{
	char tempEncoder = 0;							// A1, B1
    1346:	80 e0       	ldi	r24, 0x00	; 0
    1348:	08 95       	ret
	if((ENCODER_A_low()) && (ENCODER_B_high()))			// A0, B1
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    134a:	83 b3       	in	r24, 0x13	; 19
    134c:	82 95       	swap	r24
    134e:	81 70       	andi	r24, 0x01	; 1
    1350:	91 e0       	ldi	r25, 0x01	; 1
    1352:	89 27       	eor	r24, r25
    1354:	08 95       	ret
//			PORTD = volumeMassive[volumeIndex];
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}

	}													// A1. B1
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    1356:	9d 9b       	sbis	0x13, 5	; 19
    1358:	f6 cf       	rjmp	.-20     	; 0x1346 <rotaryEncoderVer1+0x18>
    135a:	9c 99       	sbic	0x13, 4	; 19
    135c:	f4 cf       	rjmp	.-24     	; 0x1346 <rotaryEncoderVer1+0x18>
    135e:	87 ec       	ldi	r24, 0xC7	; 199
    1360:	90 e0       	ldi	r25, 0x00	; 0
    1362:	01 97       	sbiw	r24, 0x01	; 1
    1364:	f1 f7       	brne	.-4      	; 0x1362 <rotaryEncoderVer1+0x34>
    1366:	00 c0       	rjmp	.+0      	; 0x1368 <rotaryEncoderVer1+0x3a>
    1368:	00 00       	nop
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    136a:	9d 99       	sbic	0x13, 5	; 19
    136c:	ec cf       	rjmp	.-40     	; 0x1346 <rotaryEncoderVer1+0x18>
    136e:	83 b3       	in	r24, 0x13	; 19
    1370:	82 95       	swap	r24
    1372:	81 70       	andi	r24, 0x01	; 1
    1374:	91 e0       	ldi	r25, 0x01	; 1
    1376:	89 27       	eor	r24, r25
    1378:	81 95       	neg	r24
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    137a:	08 95       	ret

0000137c <rotaryEncoderVer2>:
    137c:	87 ec       	ldi	r24, 0xC7	; 199
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	01 97       	sbiw	r24, 0x01	; 1
    1382:	f1 f7       	brne	.-4      	; 0x1380 <rotaryEncoderVer2+0x4>
    1384:	00 c0       	rjmp	.+0      	; 0x1386 <rotaryEncoderVer2+0xa>
    1386:	00 00       	nop
    1388:	87 ec       	ldi	r24, 0xC7	; 199
    138a:	90 e0       	ldi	r25, 0x00	; 0
    138c:	01 97       	sbiw	r24, 0x01	; 1
    138e:	f1 f7       	brne	.-4      	; 0x138c <rotaryEncoderVer2+0x10>
    1390:	00 c0       	rjmp	.+0      	; 0x1392 <rotaryEncoderVer2+0x16>
    1392:	00 00       	nop
    1394:	87 ec       	ldi	r24, 0xC7	; 199
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	01 97       	sbiw	r24, 0x01	; 1
    139a:	f1 f7       	brne	.-4      	; 0x1398 <rotaryEncoderVer2+0x1c>
    139c:	00 c0       	rjmp	.+0      	; 0x139e <rotaryEncoderVer2+0x22>
    139e:	00 00       	nop
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    13a0:	80 e0       	ldi	r24, 0x00	; 0
    13a2:	08 95       	ret

000013a4 <RELAYS_IN_INIT>:

/*********************************************
** INITIZLIZATION OF SHIFT REGISTER 74HC595 **
*********************************************/
void RELAYS_IN_INIT()
{
    13a4:	08 95       	ret

000013a6 <RELAYS_OUT_INIT>:
}

void RELAYS_OUT_INIT()
{
    13a6:	08 95       	ret

000013a8 <RELAYS_IN_CHOOSE>:

/****************************************************************************************************************
** DEFINITION RELAYS IN FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS IN **
****************************************************************************************************************/
void RELAYS_IN_CHOOSE(unsigned char rel_in)	// HELP: RELAYS_IN_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    13a8:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELIN_SCK_low();
    13aa:	ae 98       	cbi	0x15, 6	; 21

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    13ac:	80 ff       	sbrs	r24, 0
    13ae:	02 c0       	rjmp	.+4      	; 0x13b4 <RELAYS_IN_CHOOSE+0xc>
		{
			RELIN_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    13b0:	af 9a       	sbi	0x15, 7	; 21
    13b2:	01 c0       	rjmp	.+2      	; 0x13b6 <RELAYS_IN_CHOOSE+0xe>
		}
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    13b4:	af 98       	cbi	0x15, 7	; 21
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    13b6:	86 95       	lsr	r24

		RELIN_SCK_high();
    13b8:	ae 9a       	sbi	0x15, 6	; 21
    13ba:	91 50       	subi	r25, 0x01	; 1
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    13bc:	b1 f7       	brne	.-20     	; 0x13aa <RELAYS_IN_CHOOSE+0x2>
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELIN_SCK_high();
	}

	RELIN_RCK_low();
    13be:	ab 98       	cbi	0x15, 3	; 21
    13c0:	87 ea       	ldi	r24, 0xA7	; 167
    13c2:	92 e0       	ldi	r25, 0x02	; 2
    13c4:	01 97       	sbiw	r24, 0x01	; 1
    13c6:	f1 f7       	brne	.-4      	; 0x13c4 <RELAYS_IN_CHOOSE+0x1c>
    13c8:	00 c0       	rjmp	.+0      	; 0x13ca <RELAYS_IN_CHOOSE+0x22>
    13ca:	00 00       	nop
	_delay_us(170);			//rcall 180 us
	RELIN_RCK_high();
    13cc:	ab 9a       	sbi	0x15, 3	; 21
    13ce:	87 ea       	ldi	r24, 0xA7	; 167
    13d0:	92 e0       	ldi	r25, 0x02	; 2
    13d2:	01 97       	sbiw	r24, 0x01	; 1
    13d4:	f1 f7       	brne	.-4      	; 0x13d2 <RELAYS_IN_CHOOSE+0x2a>
    13d6:	00 c0       	rjmp	.+0      	; 0x13d8 <RELAYS_IN_CHOOSE+0x30>
    13d8:	00 00       	nop
    13da:	08 95       	ret

000013dc <relays_in1_2ch>:

}

void relays_in1_2ch()
{
	RELAYS_IN_CHOOSE(0b00100000);	// RELE 1
    13dc:	80 e2       	ldi	r24, 0x20	; 32
    13de:	0c 94 d4 09 	jmp	0x13a8	; 0x13a8 <RELAYS_IN_CHOOSE>

000013e2 <relays_in1_6ch>:
}

void relays_in1_6ch()
{
	RELAYS_IN_CHOOSE(0b01100001);	// RELE 1,2,3
    13e2:	81 e6       	ldi	r24, 0x61	; 97
    13e4:	0c 94 d4 09 	jmp	0x13a8	; 0x13a8 <RELAYS_IN_CHOOSE>

000013e8 <relays_in2_2ch>:
}

void relays_in2_2ch()
{
	RELAYS_IN_CHOOSE(0b00001010);	// RELE 4,5
    13e8:	8a e0       	ldi	r24, 0x0A	; 10
    13ea:	0c 94 d4 09 	jmp	0x13a8	; 0x13a8 <RELAYS_IN_CHOOSE>

000013ee <relays_in2_6ch>:
}

void relays_in2_6ch()
{
	RELAYS_IN_CHOOSE(0b10011010);	// RELE 4,5,6,7
    13ee:	8a e9       	ldi	r24, 0x9A	; 154
    13f0:	0c 94 d4 09 	jmp	0x13a8	; 0x13a8 <RELAYS_IN_CHOOSE>

000013f4 <relays_in3_2ch>:
}

void relays_in3_2ch()
{
	RELAYS_IN_CHOOSE(0b00001100);	// RELE 8,5
    13f4:	8c e0       	ldi	r24, 0x0C	; 12
    13f6:	0c 94 d4 09 	jmp	0x13a8	; 0x13a8 <RELAYS_IN_CHOOSE>

000013fa <relays_in3_6ch>:
}

void relays_in3_6ch()
{
	RELAYS_IN_CHOOSE(0b10011100);	// RELE 8,5,6,7
    13fa:	8c e9       	ldi	r24, 0x9C	; 156
    13fc:	0c 94 d4 09 	jmp	0x13a8	; 0x13a8 <RELAYS_IN_CHOOSE>

00001400 <relays_in_off>:
}

void relays_in_off()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    1400:	80 e0       	ldi	r24, 0x00	; 0
    1402:	0c 94 d4 09 	jmp	0x13a8	; 0x13a8 <RELAYS_IN_CHOOSE>

00001406 <relays_in_init>:
}

void relays_in_init()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    1406:	80 e0       	ldi	r24, 0x00	; 0
    1408:	0c 94 d4 09 	jmp	0x13a8	; 0x13a8 <RELAYS_IN_CHOOSE>

0000140c <RELAYS_OUT_CHOOSE>:
}
/******************************************************************************************************************
** DEFINITION RELAYS OUT FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS OUT **
******************************************************************************************************************/
void RELAYS_OUT_CHOOSE(unsigned char rel_out)	// HELP: RELAYS_OUT_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    140c:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELOUT_SCK_low();
    140e:	96 98       	cbi	0x12, 6	; 18

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1410:	80 ff       	sbrs	r24, 0
    1412:	02 c0       	rjmp	.+4      	; 0x1418 <RELAYS_OUT_CHOOSE+0xc>
		{
			RELOUT_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    1414:	c4 9a       	sbi	0x18, 4	; 24
    1416:	01 c0       	rjmp	.+2      	; 0x141a <RELAYS_OUT_CHOOSE+0xe>
		}
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    1418:	c4 98       	cbi	0x18, 4	; 24
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    141a:	86 95       	lsr	r24

		RELOUT_SCK_high();
    141c:	96 9a       	sbi	0x12, 6	; 18
    141e:	91 50       	subi	r25, 0x01	; 1
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1420:	b1 f7       	brne	.-20     	; 0x140e <RELAYS_OUT_CHOOSE+0x2>
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELOUT_SCK_high();
	}

	RELOUT_RCK_low();
    1422:	97 98       	cbi	0x12, 7	; 18
    1424:	87 ea       	ldi	r24, 0xA7	; 167
    1426:	92 e0       	ldi	r25, 0x02	; 2
    1428:	01 97       	sbiw	r24, 0x01	; 1
    142a:	f1 f7       	brne	.-4      	; 0x1428 <RELAYS_OUT_CHOOSE+0x1c>
    142c:	00 c0       	rjmp	.+0      	; 0x142e <RELAYS_OUT_CHOOSE+0x22>
    142e:	00 00       	nop
	_delay_us(170);			//rcall 180 us
	RELOUT_RCK_high();
    1430:	97 9a       	sbi	0x12, 7	; 18
    1432:	87 ea       	ldi	r24, 0xA7	; 167
    1434:	92 e0       	ldi	r25, 0x02	; 2
    1436:	01 97       	sbiw	r24, 0x01	; 1
    1438:	f1 f7       	brne	.-4      	; 0x1436 <RELAYS_OUT_CHOOSE+0x2a>
    143a:	00 c0       	rjmp	.+0      	; 0x143c <RELAYS_OUT_CHOOSE+0x30>
    143c:	00 00       	nop
    143e:	08 95       	ret

00001440 <relays_out_1ch>:

}

void relays_out_1ch()
{
	RELAYS_OUT_CHOOSE(0b10000000);	// RELE 1
    1440:	80 e8       	ldi	r24, 0x80	; 128
    1442:	0c 94 06 0a 	jmp	0x140c	; 0x140c <RELAYS_OUT_CHOOSE>

00001446 <relays_out_6ch>:
}

void relays_out_6ch()
{
	RELAYS_OUT_CHOOSE(0b11111100);	// RELE 1,2,3,4,5,6
    1446:	8c ef       	ldi	r24, 0xFC	; 252
    1448:	0c 94 06 0a 	jmp	0x140c	; 0x140c <RELAYS_OUT_CHOOSE>

0000144c <relays_out_off>:
}
void relays_out_off()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    144c:	80 e0       	ldi	r24, 0x00	; 0
    144e:	0c 94 06 0a 	jmp	0x140c	; 0x140c <RELAYS_OUT_CHOOSE>

00001452 <relays_out_init>:
}
void relays_out_init()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    1452:	80 e0       	ldi	r24, 0x00	; 0
    1454:	0c 94 06 0a 	jmp	0x140c	; 0x140c <RELAYS_OUT_CHOOSE>

00001458 <GetSIRC12>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    1458:	10 92 69 04 	sts	0x0469, r1
    145c:	10 92 6e 04 	sts	0x046E, r1

	while(irPin);				//wait for it to be low
    1460:	82 99       	sbic	0x10, 2	; 16
    1462:	fe cf       	rjmp	.-4      	; 0x1460 <GetSIRC12+0x8>
    1464:	80 e0       	ldi	r24, 0x00	; 0
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    1466:	82 99       	sbic	0x10, 2	; 16
    1468:	08 c0       	rjmp	.+16     	; 0x147a <GetSIRC12+0x22>
    {
		lTime++;				//increment every 200uS until pin is high
    146a:	8f 5f       	subi	r24, 0xFF	; 255
    146c:	ef e1       	ldi	r30, 0x1F	; 31
    146e:	f3 e0       	ldi	r31, 0x03	; 3
    1470:	31 97       	sbiw	r30, 0x01	; 1
    1472:	f1 f7       	brne	.-4      	; 0x1470 <GetSIRC12+0x18>
    1474:	00 c0       	rjmp	.+0      	; 0x1476 <GetSIRC12+0x1e>
    1476:	00 00       	nop
    1478:	f6 cf       	rjmp	.-20     	; 0x1466 <GetSIRC12+0xe>
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    147a:	8b 50       	subi	r24, 0x0B	; 11
    147c:	83 30       	cpi	r24, 0x03	; 3
    147e:	c0 f5       	brcc	.+112    	; 0x14f0 <GetSIRC12+0x98>
    1480:	87 e0       	ldi	r24, 0x07	; 7
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1482:	90 91 69 04 	lds	r25, 0x0469
    1486:	96 95       	lsr	r25
    1488:	90 93 69 04 	sts	0x0469, r25

			while(irPin);			//wait for it to be low
    148c:	82 99       	sbic	0x10, 2	; 16
    148e:	fe cf       	rjmp	.-4      	; 0x148c <GetSIRC12+0x34>
    1490:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1492:	82 99       	sbic	0x10, 2	; 16
    1494:	08 c0       	rjmp	.+16     	; 0x14a6 <GetSIRC12+0x4e>
			{
			    lTime++;			//increment every 200uS until pin is high
    1496:	9f 5f       	subi	r25, 0xFF	; 255
    1498:	ef e1       	ldi	r30, 0x1F	; 31
    149a:	f3 e0       	ldi	r31, 0x03	; 3
    149c:	31 97       	sbiw	r30, 0x01	; 1
    149e:	f1 f7       	brne	.-4      	; 0x149c <GetSIRC12+0x44>
    14a0:	00 c0       	rjmp	.+0      	; 0x14a2 <GetSIRC12+0x4a>
    14a2:	00 00       	nop
    14a4:	f6 cf       	rjmp	.-20     	; 0x1492 <GetSIRC12+0x3a>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    14a6:	96 30       	cpi	r25, 0x06	; 6
    14a8:	28 f0       	brcs	.+10     	; 0x14b4 <GetSIRC12+0x5c>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    14aa:	90 91 69 04 	lds	r25, 0x0469
    14ae:	90 64       	ori	r25, 0x40	; 64
    14b0:	90 93 69 04 	sts	0x0469, r25
    14b4:	81 50       	subi	r24, 0x01	; 1
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    14b6:	29 f7       	brne	.-54     	; 0x1482 <GetSIRC12+0x2a>
    14b8:	85 e0       	ldi	r24, 0x05	; 5
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    14ba:	90 91 6e 04 	lds	r25, 0x046E
    14be:	96 95       	lsr	r25
    14c0:	90 93 6e 04 	sts	0x046E, r25

			while(irPin);			//wait for it to be low
    14c4:	82 99       	sbic	0x10, 2	; 16
    14c6:	fe cf       	rjmp	.-4      	; 0x14c4 <GetSIRC12+0x6c>
    14c8:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    14ca:	82 99       	sbic	0x10, 2	; 16
    14cc:	08 c0       	rjmp	.+16     	; 0x14de <GetSIRC12+0x86>
			{
				lTime++;			//increment every 200uS until pin is high
    14ce:	9f 5f       	subi	r25, 0xFF	; 255
    14d0:	ef e1       	ldi	r30, 0x1F	; 31
    14d2:	f3 e0       	ldi	r31, 0x03	; 3
    14d4:	31 97       	sbiw	r30, 0x01	; 1
    14d6:	f1 f7       	brne	.-4      	; 0x14d4 <GetSIRC12+0x7c>
    14d8:	00 c0       	rjmp	.+0      	; 0x14da <GetSIRC12+0x82>
    14da:	00 00       	nop
    14dc:	f6 cf       	rjmp	.-20     	; 0x14ca <GetSIRC12+0x72>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    14de:	96 30       	cpi	r25, 0x06	; 6
    14e0:	28 f0       	brcs	.+10     	; 0x14ec <GetSIRC12+0x94>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    14e2:	90 91 6e 04 	lds	r25, 0x046E
    14e6:	90 61       	ori	r25, 0x10	; 16
    14e8:	90 93 6e 04 	sts	0x046E, r25
    14ec:	81 50       	subi	r24, 0x01	; 1

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
    14ee:	29 f7       	brne	.-54     	; 0x14ba <GetSIRC12+0x62>
    14f0:	08 95       	ret

000014f2 <GetSIRC15>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    14f2:	10 92 69 04 	sts	0x0469, r1
    14f6:	10 92 6e 04 	sts	0x046E, r1

	while(irPin);				//wait for it to be low
    14fa:	82 99       	sbic	0x10, 2	; 16
    14fc:	fe cf       	rjmp	.-4      	; 0x14fa <GetSIRC15+0x8>
    14fe:	80 e0       	ldi	r24, 0x00	; 0
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    1500:	82 99       	sbic	0x10, 2	; 16
    1502:	08 c0       	rjmp	.+16     	; 0x1514 <GetSIRC15+0x22>
    {
		lTime++;				//increment every 200uS until pin is high
    1504:	8f 5f       	subi	r24, 0xFF	; 255
    1506:	ef e1       	ldi	r30, 0x1F	; 31
    1508:	f3 e0       	ldi	r31, 0x03	; 3
    150a:	31 97       	sbiw	r30, 0x01	; 1
    150c:	f1 f7       	brne	.-4      	; 0x150a <GetSIRC15+0x18>
    150e:	00 c0       	rjmp	.+0      	; 0x1510 <GetSIRC15+0x1e>
    1510:	00 00       	nop
    1512:	f6 cf       	rjmp	.-20     	; 0x1500 <GetSIRC15+0xe>
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1514:	8b 50       	subi	r24, 0x0B	; 11
    1516:	83 30       	cpi	r24, 0x03	; 3
    1518:	c0 f5       	brcc	.+112    	; 0x158a <GetSIRC15+0x98>
    151a:	87 e0       	ldi	r24, 0x07	; 7
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    151c:	90 91 69 04 	lds	r25, 0x0469
    1520:	96 95       	lsr	r25
    1522:	90 93 69 04 	sts	0x0469, r25

			while(irPin);			//wait for it to be low
    1526:	82 99       	sbic	0x10, 2	; 16
    1528:	fe cf       	rjmp	.-4      	; 0x1526 <GetSIRC15+0x34>
    152a:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    152c:	82 99       	sbic	0x10, 2	; 16
    152e:	08 c0       	rjmp	.+16     	; 0x1540 <GetSIRC15+0x4e>
			{
			    lTime++;			//increment every 200uS until pin is high
    1530:	9f 5f       	subi	r25, 0xFF	; 255
    1532:	ef e1       	ldi	r30, 0x1F	; 31
    1534:	f3 e0       	ldi	r31, 0x03	; 3
    1536:	31 97       	sbiw	r30, 0x01	; 1
    1538:	f1 f7       	brne	.-4      	; 0x1536 <GetSIRC15+0x44>
    153a:	00 c0       	rjmp	.+0      	; 0x153c <GetSIRC15+0x4a>
    153c:	00 00       	nop
    153e:	f6 cf       	rjmp	.-20     	; 0x152c <GetSIRC15+0x3a>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1540:	96 30       	cpi	r25, 0x06	; 6
    1542:	28 f0       	brcs	.+10     	; 0x154e <GetSIRC15+0x5c>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    1544:	90 91 69 04 	lds	r25, 0x0469
    1548:	90 64       	ori	r25, 0x40	; 64
    154a:	90 93 69 04 	sts	0x0469, r25
    154e:	81 50       	subi	r24, 0x01	; 1
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    1550:	29 f7       	brne	.-54     	; 0x151c <GetSIRC15+0x2a>
    1552:	88 e0       	ldi	r24, 0x08	; 8
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1554:	90 91 6e 04 	lds	r25, 0x046E
    1558:	96 95       	lsr	r25
    155a:	90 93 6e 04 	sts	0x046E, r25

			while(irPin);			//wait for it to be low
    155e:	82 99       	sbic	0x10, 2	; 16
    1560:	fe cf       	rjmp	.-4      	; 0x155e <GetSIRC15+0x6c>
    1562:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1564:	82 99       	sbic	0x10, 2	; 16
    1566:	08 c0       	rjmp	.+16     	; 0x1578 <GetSIRC15+0x86>
			{
				lTime++;			//increment every 200uS until pin is high
    1568:	9f 5f       	subi	r25, 0xFF	; 255
    156a:	ef e1       	ldi	r30, 0x1F	; 31
    156c:	f3 e0       	ldi	r31, 0x03	; 3
    156e:	31 97       	sbiw	r30, 0x01	; 1
    1570:	f1 f7       	brne	.-4      	; 0x156e <GetSIRC15+0x7c>
    1572:	00 c0       	rjmp	.+0      	; 0x1574 <GetSIRC15+0x82>
    1574:	00 00       	nop
    1576:	f6 cf       	rjmp	.-20     	; 0x1564 <GetSIRC15+0x72>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1578:	96 30       	cpi	r25, 0x06	; 6
    157a:	28 f0       	brcs	.+10     	; 0x1586 <GetSIRC15+0x94>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    157c:	90 91 6e 04 	lds	r25, 0x046E
    1580:	90 61       	ori	r25, 0x10	; 16
    1582:	90 93 6e 04 	sts	0x046E, r25
    1586:	81 50       	subi	r24, 0x01	; 1

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
    1588:	29 f7       	brne	.-54     	; 0x1554 <GetSIRC15+0x62>
    158a:	08 95       	ret

0000158c <GetSIRC20>:
{
	char x;
	char lTime;

//StartLook:
	irExtended = irAddress = irCommand = 0;
    158c:	10 92 69 04 	sts	0x0469, r1
    1590:	10 92 6e 04 	sts	0x046E, r1
    1594:	10 92 70 04 	sts	0x0470, r1

	while(irPin);				//wait for it to be low
    1598:	82 99       	sbic	0x10, 2	; 16
    159a:	fe cf       	rjmp	.-4      	; 0x1598 <GetSIRC20+0xc>
    159c:	80 e0       	ldi	r24, 0x00	; 0
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    159e:	82 99       	sbic	0x10, 2	; 16
    15a0:	08 c0       	rjmp	.+16     	; 0x15b2 <GetSIRC20+0x26>
    {
		lTime++;				//increment every 200uS until pin is high
    15a2:	8f 5f       	subi	r24, 0xFF	; 255
    15a4:	ef e1       	ldi	r30, 0x1F	; 31
    15a6:	f3 e0       	ldi	r31, 0x03	; 3
    15a8:	31 97       	sbiw	r30, 0x01	; 1
    15aa:	f1 f7       	brne	.-4      	; 0x15a8 <GetSIRC20+0x1c>
    15ac:	00 c0       	rjmp	.+0      	; 0x15ae <GetSIRC20+0x22>
    15ae:	00 00       	nop
    15b0:	f6 cf       	rjmp	.-20     	; 0x159e <GetSIRC20+0x12>
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    15b2:	8b 50       	subi	r24, 0x0B	; 11
    15b4:	83 30       	cpi	r24, 0x03	; 3
    15b6:	08 f0       	brcs	.+2      	; 0x15ba <GetSIRC20+0x2e>
    15b8:	54 c0       	rjmp	.+168    	; 0x1662 <GetSIRC20+0xd6>
    15ba:	87 e0       	ldi	r24, 0x07	; 7
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    15bc:	90 91 69 04 	lds	r25, 0x0469
    15c0:	96 95       	lsr	r25
    15c2:	90 93 69 04 	sts	0x0469, r25

			while(irPin);			//wait for it to be low
    15c6:	82 99       	sbic	0x10, 2	; 16
    15c8:	fe cf       	rjmp	.-4      	; 0x15c6 <GetSIRC20+0x3a>
    15ca:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    15cc:	82 99       	sbic	0x10, 2	; 16
    15ce:	08 c0       	rjmp	.+16     	; 0x15e0 <GetSIRC20+0x54>
			{
			    lTime++;			//increment every 200uS until pin is high
    15d0:	9f 5f       	subi	r25, 0xFF	; 255
    15d2:	ef e1       	ldi	r30, 0x1F	; 31
    15d4:	f3 e0       	ldi	r31, 0x03	; 3
    15d6:	31 97       	sbiw	r30, 0x01	; 1
    15d8:	f1 f7       	brne	.-4      	; 0x15d6 <GetSIRC20+0x4a>
    15da:	00 c0       	rjmp	.+0      	; 0x15dc <GetSIRC20+0x50>
    15dc:	00 00       	nop
    15de:	f6 cf       	rjmp	.-20     	; 0x15cc <GetSIRC20+0x40>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    15e0:	96 30       	cpi	r25, 0x06	; 6
    15e2:	28 f0       	brcs	.+10     	; 0x15ee <GetSIRC20+0x62>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    15e4:	90 91 69 04 	lds	r25, 0x0469
    15e8:	90 64       	ori	r25, 0x40	; 64
    15ea:	90 93 69 04 	sts	0x0469, r25
    15ee:	81 50       	subi	r24, 0x01	; 1
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    15f0:	29 f7       	brne	.-54     	; 0x15bc <GetSIRC20+0x30>
    15f2:	85 e0       	ldi	r24, 0x05	; 5
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    15f4:	90 91 6e 04 	lds	r25, 0x046E
    15f8:	96 95       	lsr	r25
    15fa:	90 93 6e 04 	sts	0x046E, r25

			while(irPin);			//wait for it to be low
    15fe:	82 99       	sbic	0x10, 2	; 16
    1600:	fe cf       	rjmp	.-4      	; 0x15fe <GetSIRC20+0x72>
    1602:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1604:	82 99       	sbic	0x10, 2	; 16
    1606:	08 c0       	rjmp	.+16     	; 0x1618 <GetSIRC20+0x8c>
			{
				lTime++;			//increment every 200uS until pin is high
    1608:	9f 5f       	subi	r25, 0xFF	; 255
    160a:	ef e1       	ldi	r30, 0x1F	; 31
    160c:	f3 e0       	ldi	r31, 0x03	; 3
    160e:	31 97       	sbiw	r30, 0x01	; 1
    1610:	f1 f7       	brne	.-4      	; 0x160e <GetSIRC20+0x82>
    1612:	00 c0       	rjmp	.+0      	; 0x1614 <GetSIRC20+0x88>
    1614:	00 00       	nop
    1616:	f6 cf       	rjmp	.-20     	; 0x1604 <GetSIRC20+0x78>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1618:	96 30       	cpi	r25, 0x06	; 6
    161a:	28 f0       	brcs	.+10     	; 0x1626 <GetSIRC20+0x9a>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    161c:	90 91 6e 04 	lds	r25, 0x046E
    1620:	90 61       	ori	r25, 0x10	; 16
    1622:	90 93 6e 04 	sts	0x046E, r25
    1626:	81 50       	subi	r24, 0x01	; 1

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
    1628:	29 f7       	brne	.-54     	; 0x15f4 <GetSIRC20+0x68>
    162a:	88 e0       	ldi	r24, 0x08	; 8
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
		{
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1
    162c:	90 91 70 04 	lds	r25, 0x0470
    1630:	96 95       	lsr	r25
    1632:	90 93 70 04 	sts	0x0470, r25

			while(irPin);			//wait for it to be low
    1636:	82 99       	sbic	0x10, 2	; 16
    1638:	fe cf       	rjmp	.-4      	; 0x1636 <GetSIRC20+0xaa>
    163a:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    163c:	82 99       	sbic	0x10, 2	; 16
    163e:	08 c0       	rjmp	.+16     	; 0x1650 <GetSIRC20+0xc4>
			{
				lTime++;			//increment every 200uS until pin is high
    1640:	9f 5f       	subi	r25, 0xFF	; 255
    1642:	ef e1       	ldi	r30, 0x1F	; 31
    1644:	f3 e0       	ldi	r31, 0x03	; 3
    1646:	31 97       	sbiw	r30, 0x01	; 1
    1648:	f1 f7       	brne	.-4      	; 0x1646 <GetSIRC20+0xba>
    164a:	00 c0       	rjmp	.+0      	; 0x164c <GetSIRC20+0xc0>
    164c:	00 00       	nop
    164e:	f6 cf       	rjmp	.-20     	; 0x163c <GetSIRC20+0xb0>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1650:	96 30       	cpi	r25, 0x06	; 6
    1652:	28 f0       	brcs	.+10     	; 0x165e <GetSIRC20+0xd2>
				irExtended |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1654:	90 91 70 04 	lds	r25, 0x0470
    1658:	90 61       	ori	r25, 0x10	; 16
    165a:	90 93 70 04 	sts	0x0470, r25
    165e:	81 50       	subi	r24, 0x01	; 1

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
    1660:	29 f7       	brne	.-54     	; 0x162c <GetSIRC20+0xa0>
    1662:	08 95       	ret

00001664 <main>:
******************************** START OF MAIN APPLICATION **********************************
********************************************************************************************/

int main(void)
{
	init_all();				// PREDI DA TRAGNEM // inicializacia na vsichko
    1664:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <init_all>
	ext0_intrpt_on();		// PREDI DA TRAGNEM // ENABLE interrupts to access IR DETECTION as call to function "IR_DECODER()" for -> SONY IR REMOTE
    1668:	0e 94 5b 00 	call	0xb6	; 0xb6 <ext0_intrpt_on>
//	ext2_intrpt_on();
//	temperature();

	sei();					// PREDI DA TRAGNEM 		// file "avr/interrupt.h"
    166c:	78 94       	sei
//	SREG = (1<<I);

	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
    166e:	94 9a       	sbi	0x12, 4	; 18
	while(1)
	{		
		buttons_press();	// izchakvane za natiskane na buton
    1670:	0e 94 0a 05 	call	0xa14	; 0xa14 <buttons_press>

00001674 <__udivmodqi4>:
    1674:	99 1b       	sub	r25, r25
    1676:	79 e0       	ldi	r23, 0x09	; 9
    1678:	04 c0       	rjmp	.+8      	; 0x1682 <__udivmodqi4_ep>

0000167a <__udivmodqi4_loop>:
    167a:	99 1f       	adc	r25, r25
    167c:	96 17       	cp	r25, r22
    167e:	08 f0       	brcs	.+2      	; 0x1682 <__udivmodqi4_ep>
    1680:	96 1b       	sub	r25, r22

00001682 <__udivmodqi4_ep>:
    1682:	88 1f       	adc	r24, r24
    1684:	7a 95       	dec	r23
    1686:	c9 f7       	brne	.-14     	; 0x167a <__udivmodqi4_loop>
    1688:	80 95       	com	r24
    168a:	08 95       	ret

0000168c <itoa>:
    168c:	fb 01       	movw	r30, r22
    168e:	9f 01       	movw	r18, r30
    1690:	e8 94       	clt
    1692:	42 30       	cpi	r20, 0x02	; 2
    1694:	c4 f0       	brlt	.+48     	; 0x16c6 <itoa+0x3a>
    1696:	45 32       	cpi	r20, 0x25	; 37
    1698:	b4 f4       	brge	.+44     	; 0x16c6 <itoa+0x3a>
    169a:	4a 30       	cpi	r20, 0x0A	; 10
    169c:	29 f4       	brne	.+10     	; 0x16a8 <itoa+0x1c>
    169e:	97 fb       	bst	r25, 7
    16a0:	1e f4       	brtc	.+6      	; 0x16a8 <itoa+0x1c>
    16a2:	90 95       	com	r25
    16a4:	81 95       	neg	r24
    16a6:	9f 4f       	sbci	r25, 0xFF	; 255
    16a8:	64 2f       	mov	r22, r20
    16aa:	77 27       	eor	r23, r23
    16ac:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <__udivmodhi4>
    16b0:	80 5d       	subi	r24, 0xD0	; 208
    16b2:	8a 33       	cpi	r24, 0x3A	; 58
    16b4:	0c f0       	brlt	.+2      	; 0x16b8 <itoa+0x2c>
    16b6:	89 5d       	subi	r24, 0xD9	; 217
    16b8:	81 93       	st	Z+, r24
    16ba:	cb 01       	movw	r24, r22
    16bc:	00 97       	sbiw	r24, 0x00	; 0
    16be:	a1 f7       	brne	.-24     	; 0x16a8 <itoa+0x1c>
    16c0:	16 f4       	brtc	.+4      	; 0x16c6 <itoa+0x3a>
    16c2:	5d e2       	ldi	r21, 0x2D	; 45
    16c4:	51 93       	st	Z+, r21
    16c6:	10 82       	st	Z, r1
    16c8:	c9 01       	movw	r24, r18
    16ca:	0c 94 d6 0b 	jmp	0x17ac	; 0x17ac <strrev>

000016ce <ltoa>:
    16ce:	fa 01       	movw	r30, r20
    16d0:	cf 93       	push	r28
    16d2:	ff 93       	push	r31
    16d4:	ef 93       	push	r30
    16d6:	22 30       	cpi	r18, 0x02	; 2
    16d8:	44 f1       	brlt	.+80     	; 0x172a <ltoa+0x5c>
    16da:	25 32       	cpi	r18, 0x25	; 37
    16dc:	34 f5       	brge	.+76     	; 0x172a <ltoa+0x5c>
    16de:	c2 2f       	mov	r28, r18
    16e0:	e8 94       	clt
    16e2:	ca 30       	cpi	r28, 0x0A	; 10
    16e4:	49 f4       	brne	.+18     	; 0x16f8 <ltoa+0x2a>
    16e6:	97 fb       	bst	r25, 7
    16e8:	3e f4       	brtc	.+14     	; 0x16f8 <ltoa+0x2a>
    16ea:	90 95       	com	r25
    16ec:	80 95       	com	r24
    16ee:	70 95       	com	r23
    16f0:	61 95       	neg	r22
    16f2:	7f 4f       	sbci	r23, 0xFF	; 255
    16f4:	8f 4f       	sbci	r24, 0xFF	; 255
    16f6:	9f 4f       	sbci	r25, 0xFF	; 255
    16f8:	2c 2f       	mov	r18, r28
    16fa:	33 27       	eor	r19, r19
    16fc:	44 27       	eor	r20, r20
    16fe:	55 27       	eor	r21, r21
    1700:	ff 93       	push	r31
    1702:	ef 93       	push	r30
    1704:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <__udivmodsi4>
    1708:	ef 91       	pop	r30
    170a:	ff 91       	pop	r31
    170c:	60 5d       	subi	r22, 0xD0	; 208
    170e:	6a 33       	cpi	r22, 0x3A	; 58
    1710:	0c f0       	brlt	.+2      	; 0x1714 <ltoa+0x46>
    1712:	69 5d       	subi	r22, 0xD9	; 217
    1714:	61 93       	st	Z+, r22
    1716:	b9 01       	movw	r22, r18
    1718:	ca 01       	movw	r24, r20
    171a:	60 50       	subi	r22, 0x00	; 0
    171c:	70 40       	sbci	r23, 0x00	; 0
    171e:	80 40       	sbci	r24, 0x00	; 0
    1720:	90 40       	sbci	r25, 0x00	; 0
    1722:	51 f7       	brne	.-44     	; 0x16f8 <ltoa+0x2a>
    1724:	16 f4       	brtc	.+4      	; 0x172a <ltoa+0x5c>
    1726:	cd e2       	ldi	r28, 0x2D	; 45
    1728:	c1 93       	st	Z+, r28
    172a:	10 82       	st	Z, r1
    172c:	8f 91       	pop	r24
    172e:	9f 91       	pop	r25
    1730:	cf 91       	pop	r28
    1732:	0c 94 d6 0b 	jmp	0x17ac	; 0x17ac <strrev>

00001736 <ultoa>:
    1736:	fa 01       	movw	r30, r20
    1738:	cf 93       	push	r28
    173a:	ff 93       	push	r31
    173c:	ef 93       	push	r30
    173e:	22 30       	cpi	r18, 0x02	; 2
    1740:	cc f0       	brlt	.+50     	; 0x1774 <ultoa+0x3e>
    1742:	25 32       	cpi	r18, 0x25	; 37
    1744:	bc f4       	brge	.+46     	; 0x1774 <ultoa+0x3e>
    1746:	c2 2f       	mov	r28, r18
    1748:	2c 2f       	mov	r18, r28
    174a:	33 27       	eor	r19, r19
    174c:	44 27       	eor	r20, r20
    174e:	55 27       	eor	r21, r21
    1750:	ff 93       	push	r31
    1752:	ef 93       	push	r30
    1754:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <__udivmodsi4>
    1758:	ef 91       	pop	r30
    175a:	ff 91       	pop	r31
    175c:	60 5d       	subi	r22, 0xD0	; 208
    175e:	6a 33       	cpi	r22, 0x3A	; 58
    1760:	0c f0       	brlt	.+2      	; 0x1764 <ultoa+0x2e>
    1762:	69 5d       	subi	r22, 0xD9	; 217
    1764:	61 93       	st	Z+, r22
    1766:	b9 01       	movw	r22, r18
    1768:	ca 01       	movw	r24, r20
    176a:	60 50       	subi	r22, 0x00	; 0
    176c:	70 40       	sbci	r23, 0x00	; 0
    176e:	80 40       	sbci	r24, 0x00	; 0
    1770:	90 40       	sbci	r25, 0x00	; 0
    1772:	51 f7       	brne	.-44     	; 0x1748 <ultoa+0x12>
    1774:	10 82       	st	Z, r1
    1776:	8f 91       	pop	r24
    1778:	9f 91       	pop	r25
    177a:	cf 91       	pop	r28
    177c:	0c 94 d6 0b 	jmp	0x17ac	; 0x17ac <strrev>

00001780 <utoa>:
    1780:	fb 01       	movw	r30, r22
    1782:	9f 01       	movw	r18, r30
    1784:	42 30       	cpi	r20, 0x02	; 2
    1786:	74 f0       	brlt	.+28     	; 0x17a4 <utoa+0x24>
    1788:	45 32       	cpi	r20, 0x25	; 37
    178a:	64 f4       	brge	.+24     	; 0x17a4 <utoa+0x24>
    178c:	64 2f       	mov	r22, r20
    178e:	77 27       	eor	r23, r23
    1790:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <__udivmodhi4>
    1794:	80 5d       	subi	r24, 0xD0	; 208
    1796:	8a 33       	cpi	r24, 0x3A	; 58
    1798:	0c f0       	brlt	.+2      	; 0x179c <utoa+0x1c>
    179a:	89 5d       	subi	r24, 0xD9	; 217
    179c:	81 93       	st	Z+, r24
    179e:	cb 01       	movw	r24, r22
    17a0:	00 97       	sbiw	r24, 0x00	; 0
    17a2:	a1 f7       	brne	.-24     	; 0x178c <utoa+0xc>
    17a4:	10 82       	st	Z, r1
    17a6:	c9 01       	movw	r24, r18
    17a8:	0c 94 d6 0b 	jmp	0x17ac	; 0x17ac <strrev>

000017ac <strrev>:
    17ac:	dc 01       	movw	r26, r24
    17ae:	fc 01       	movw	r30, r24
    17b0:	67 2f       	mov	r22, r23
    17b2:	71 91       	ld	r23, Z+
    17b4:	77 23       	and	r23, r23
    17b6:	e1 f7       	brne	.-8      	; 0x17b0 <strrev+0x4>
    17b8:	32 97       	sbiw	r30, 0x02	; 2
    17ba:	04 c0       	rjmp	.+8      	; 0x17c4 <strrev+0x18>
    17bc:	7c 91       	ld	r23, X
    17be:	6d 93       	st	X+, r22
    17c0:	70 83       	st	Z, r23
    17c2:	62 91       	ld	r22, -Z
    17c4:	ae 17       	cp	r26, r30
    17c6:	bf 07       	cpc	r27, r31
    17c8:	c8 f3       	brcs	.-14     	; 0x17bc <strrev+0x10>
    17ca:	08 95       	ret

000017cc <__udivmodhi4>:
    17cc:	aa 1b       	sub	r26, r26
    17ce:	bb 1b       	sub	r27, r27
    17d0:	51 e1       	ldi	r21, 0x11	; 17
    17d2:	07 c0       	rjmp	.+14     	; 0x17e2 <__udivmodhi4_ep>

000017d4 <__udivmodhi4_loop>:
    17d4:	aa 1f       	adc	r26, r26
    17d6:	bb 1f       	adc	r27, r27
    17d8:	a6 17       	cp	r26, r22
    17da:	b7 07       	cpc	r27, r23
    17dc:	10 f0       	brcs	.+4      	; 0x17e2 <__udivmodhi4_ep>
    17de:	a6 1b       	sub	r26, r22
    17e0:	b7 0b       	sbc	r27, r23

000017e2 <__udivmodhi4_ep>:
    17e2:	88 1f       	adc	r24, r24
    17e4:	99 1f       	adc	r25, r25
    17e6:	5a 95       	dec	r21
    17e8:	a9 f7       	brne	.-22     	; 0x17d4 <__udivmodhi4_loop>
    17ea:	80 95       	com	r24
    17ec:	90 95       	com	r25
    17ee:	bc 01       	movw	r22, r24
    17f0:	cd 01       	movw	r24, r26
    17f2:	08 95       	ret

000017f4 <__udivmodsi4>:
    17f4:	a1 e2       	ldi	r26, 0x21	; 33
    17f6:	1a 2e       	mov	r1, r26
    17f8:	aa 1b       	sub	r26, r26
    17fa:	bb 1b       	sub	r27, r27
    17fc:	fd 01       	movw	r30, r26
    17fe:	0d c0       	rjmp	.+26     	; 0x181a <__udivmodsi4_ep>

00001800 <__udivmodsi4_loop>:
    1800:	aa 1f       	adc	r26, r26
    1802:	bb 1f       	adc	r27, r27
    1804:	ee 1f       	adc	r30, r30
    1806:	ff 1f       	adc	r31, r31
    1808:	a2 17       	cp	r26, r18
    180a:	b3 07       	cpc	r27, r19
    180c:	e4 07       	cpc	r30, r20
    180e:	f5 07       	cpc	r31, r21
    1810:	20 f0       	brcs	.+8      	; 0x181a <__udivmodsi4_ep>
    1812:	a2 1b       	sub	r26, r18
    1814:	b3 0b       	sbc	r27, r19
    1816:	e4 0b       	sbc	r30, r20
    1818:	f5 0b       	sbc	r31, r21

0000181a <__udivmodsi4_ep>:
    181a:	66 1f       	adc	r22, r22
    181c:	77 1f       	adc	r23, r23
    181e:	88 1f       	adc	r24, r24
    1820:	99 1f       	adc	r25, r25
    1822:	1a 94       	dec	r1
    1824:	69 f7       	brne	.-38     	; 0x1800 <__udivmodsi4_loop>
    1826:	60 95       	com	r22
    1828:	70 95       	com	r23
    182a:	80 95       	com	r24
    182c:	90 95       	com	r25
    182e:	9b 01       	movw	r18, r22
    1830:	ac 01       	movw	r20, r24
    1832:	bd 01       	movw	r22, r26
    1834:	cf 01       	movw	r24, r30
    1836:	08 95       	ret

00001838 <_exit>:
    1838:	f8 94       	cli

0000183a <__stop_program>:
    183a:	ff cf       	rjmp	.-2      	; 0x183a <__stop_program>
