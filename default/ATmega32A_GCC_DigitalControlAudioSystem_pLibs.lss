
ATmega32A_GCC_DigitalControlAudioSystem_pLibs.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001690  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000630  00800060  00001690  00001724  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002b  00800690  00800690  00001d54  2**0
                  ALLOC
  3 .debug_aranges 00000180  00000000  00000000  00001d54  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000a1e  00000000  00000000  00001ed4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002d30  00000000  00000000  000028f2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d93  00000000  00000000  00005622  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000028c7  00000000  00000000  000063b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007d0  00000000  00000000  00008c7c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000b78  00000000  00000000  0000944c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000ce8  00000000  00000000  00009fc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000798  00000000  00000000  0000acac  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 2c 04 	jmp	0x858	; 0x858 <__vector_1>
       8:	0c 94 91 00 	jmp	0x122	; 0x122 <__vector_2>
       c:	0c 94 9b 00 	jmp	0x136	; 0x136 <__vector_3>
      10:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__vector_4>
      14:	0c 94 af 00 	jmp	0x15e	; 0x15e <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	16 e0       	ldi	r17, 0x06	; 6
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e9       	ldi	r30, 0x90	; 144
      68:	f6 e1       	ldi	r31, 0x16	; 22
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 39       	cpi	r26, 0x90	; 144
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a0 e9       	ldi	r26, 0x90	; 144
      7a:	b6 e0       	ldi	r27, 0x06	; 6
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ab 3b       	cpi	r26, 0xBB	; 187
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e7 03 	call	0x7ce	; 0x7ce <main>
      8a:	0c 94 46 0b 	jmp	0x168c	; 0x168c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <port_init>:
*****************************************/
void port_init(void)
{	

// PORT A connections
	DDRA  = 0b11111111;		//  PA7:U8/PGA2310,CS; PA6:U7/PGA2310,CS; PA5:CON2LCD,RS; PA4:CON2LCD,RW; PA3:CON2LCD,E; PA2:U2/74HC595,RCLK(LCD); PA1:U2/74HC595,SCLK(LCD); PA0:U2/74HC595,DATA(LCD);
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	8a bb       	out	0x1a, r24	; 26
	PORTA = 0b00000000;		//	Interfaces: NOT USED. PULLUP DISABLE in PORTA.
      96:	1b ba       	out	0x1b, r1	; 27

// PORT B connections
	DDRB  = 0b10111000;		//  PB7:U6,U7,U8/PGA2310,SCLK; PB6:U6,U7,U8/PGA2310,SDO(CON33,36,39); PB5:U6,U7,U8/PGA2310,SDI; PB4:U12/74HC595,DATA(REL_OUT); PB3:U6/PGA2310,CS; PB2:CON8/BUTTON,"ESCAPE",INT2; PB1:CON5/BUTTON,"ON/OFF"; PB0:CON14TempSensor/DS18S20,DQ,IN/OUT;
      98:	88 eb       	ldi	r24, 0xB8	; 184
      9a:	87 bb       	out	0x17, r24	; 23
	PORTB = 0b00000111;		//	Interfaces: EXTERNAL INTERRUPT 2; SPI. set pullup to IRTSOP2240 / BUTTON(on/off) / DS18s20.
      9c:	87 e0       	ldi	r24, 0x07	; 7
      9e:	88 bb       	out	0x18, r24	; 24

// PORT C connections
	DDRC  = 0b11001100;		//  PC7:U10/74HC595,DATA(REL_IN); PC6:U10/74HC595,SCLK(REL_IN); PC5:EncoderED1112S,A; PC4:EncoderED1112S,B; PC3:U10/74HC595,RCLK(REL_IN); PC2:Q2/BD237(RELAY_POWER_SUPPLY); PC1:DS1307/24C64,I2C/SDA; PC0:DS1307/24C64,I2C/SCL;
      a0:	8c ec       	ldi	r24, 0xCC	; 204
      a2:	84 bb       	out	0x14, r24	; 20
	PORTC = 0b00000000;		//	Interfaces: I2C. PULLUP DISABLE in PORTC.
      a4:	15 ba       	out	0x15, r1	; 21

// PORT D connections
	DDRD  = 0b11110000;		//  PD7:U12/74HC595,RCLK(REL_OUT); PD6:U12/74HC595,SCLK(REL_OUT); PD5:Q1/BD237(FAN_CONTROL_PWM); PD4:LED5/"ON/OFF AUDIO SYSTEM"; PD3:CON11/EncoderBUTTON,"MENU/ENTER"/INT1; PD2:CON12/IR/TSOP2240,/INT0; PD1:CON14/MAX232,UART/TXD; PD0:CON14/MAX232,UART/RXD;
      a6:	80 ef       	ldi	r24, 0xF0	; 240
      a8:	81 bb       	out	0x11, r24	; 17
	PORTD = 0b00001100;		//	Interfaces: TIMER1; UART/USART; EXTERNAL INTERRUPT 0, 1. PULLUP DISABLE in PORTD.
      aa:	8c e0       	ldi	r24, 0x0C	; 12
      ac:	82 bb       	out	0x12, r24	; 18
//	DDRD&=~_BV(0);// DDD0 = "0"  (DDD0=DDRD nulev bit) set PORTD pin0 to zero as input
//	PORTD|=_BV(0);// PD0  = "1"  Enable pull up
//	PORTD|=_BV(1);// PD1  = "1"  led
//	DDRD|=_BV(1); // DDD1 = "1"  (DDD1=DDRD parvi bit) set PORTD pin1 to one as output

}
      ae:	08 95       	ret

000000b0 <ext0_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 0 **
*******************************************/
void ext0_intrpt_init(void)
{
	MCUCR = 0b00000010;	// SETUP EXT INT 0, ISC01 = 1, ISC00 = 0: Falling edge on INT0 activates the interrupt; ISC01 = 1, ISC00 = 1: Rising edge on INT0 activates the interrupt;
      b0:	82 e0       	ldi	r24, 0x02	; 2
      b2:	85 bf       	out	0x35, r24	; 53

// IN FUNCTIONS:
//	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
//	GIFR   = 0b01000000;	// Clear INT0 flag.
}
      b4:	08 95       	ret

000000b6 <ext0_intrpt_on>:
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      b6:	80 e4       	ldi	r24, 0x40	; 64
      b8:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      ba:	8a bf       	out	0x3a, r24	; 58
}
      bc:	08 95       	ret

000000be <ext0_intrpt_off>:
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      be:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      c0:	80 e4       	ldi	r24, 0x40	; 64
      c2:	8a bf       	out	0x3a, r24	; 58
}
      c4:	08 95       	ret

000000c6 <ext1_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 1 **
*******************************************/
void ext1_intrpt_init(void)
{
}
      c6:	08 95       	ret

000000c8 <ext2_intrpt_init>:
//	MCUCSR = 0b00000000;	// SETUP EXT INT 2, ISC2 = 0: Falling edge on INT2 activates the interrupt; ISC2 = 1: Rising edge on INT2 activates the interrupt;

// IN FUNCTIONS:
//	GICR   = 0b00100000;	// INT2 = 0: Disable External Interrupt on INT2; INT2 = 1: Enable External Interrupt on INT2;
//	GIFR   = 0b00100000;	// Clear INT2 flag.
}
      c8:	08 95       	ret

000000ca <timer1_init>:
*****************************/
void timer1_init()
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  = 0b00000000;	// maskov registar za prekasvaniq
      ca:	19 be       	out	0x39, r1	; 57
	TCNT1H = 0b00000000;
      cc:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
      ce:	1c bc       	out	0x2c, r1	; 44

//	OCR1BH = 100; //20;			// 0   = 0b00000000 (DEC = BIN)	// LED
//	OCR1BL = 100; //20;			// 200 = 0b11001000 (DEC = BIN)	// LED

//	TIMSK = (1 << OCIE1A);
}
      d0:	08 95       	ret

000000d2 <timer1_on_speed1>:
void timer1_on_speed1()
{
	TCCR1A = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      d2:	81 e8       	ldi	r24, 0x81	; 129
      d4:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00010001;
      d6:	81 e1       	ldi	r24, 0x11	; 17
      d8:	8e bd       	out	0x2e, r24	; 46

	OCR1AH = 0; // FAN PWM ON
      da:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 1; // FAN PWM ON
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	8a bd       	out	0x2a, r24	; 42

//	OCR1BH = 0; // LED PWM ON
//	OCR1BL = 1; // LED PWM ON
}
      e0:	08 95       	ret

000000e2 <timer1_off>:
void timer1_off()
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
      e2:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
      e4:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
      e6:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
      e8:	1a bc       	out	0x2a, r1	; 42

//	OCR1BH = 0; // LED PWM OFF
//	OCR1BL = 0; // LED PWM OFF
}
      ea:	08 95       	ret

000000ec <FAN_PWM_SPEED1>:

//	TIMSK = (1 << OCIE1A);
}
void timer1_on_speed1()
{
	TCCR1A = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      ec:	81 e8       	ldi	r24, 0x81	; 129
      ee:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00010001;
      f0:	81 e1       	ldi	r24, 0x11	; 17
      f2:	8e bd       	out	0x2e, r24	; 46

	OCR1AH = 0; // FAN PWM ON
      f4:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 1; // FAN PWM ON
      f6:	81 e0       	ldi	r24, 0x01	; 1
      f8:	8a bd       	out	0x2a, r24	; 42
******** DEFINITIONS OF FAN ********
***********************************/
void FAN_PWM_SPEED1()
{
	timer1_on_speed1();
}
      fa:	08 95       	ret

000000fc <FAN_PWM_OFF>:
//	OCR1BH = 0; // LED PWM ON
//	OCR1BL = 1; // LED PWM ON
}
void timer1_off()
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
      fc:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
      fe:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     100:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     102:	1a bc       	out	0x2a, r1	; 42
	timer1_on_speed1();
}
void FAN_PWM_OFF()
{
	timer1_off();
}
     104:	08 95       	ret

00000106 <timer2_init>:
/*****************************
** INITIZLIZATION OF TIMER2 **
*****************************/
void timer2_init(void)
{
	SFIOR = 0b00000010;		// Prescaler Reset Timer2 (bit1 –> PSR2)
     106:	82 e0       	ldi	r24, 0x02	; 2
     108:	80 bf       	out	0x30, r24	; 48
	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     10a:	81 e8       	ldi	r24, 0x81	; 129
     10c:	85 bd       	out	0x25, r24	; 37
	OCR2 = 0; // FAN PWM ON
     10e:	13 bc       	out	0x23, r1	; 35
}
     110:	08 95       	ret

00000112 <timer2_on>:
/*************************************
******** DEFINITIONS OF TIMER ********
*************************************/
void timer2_on(void)	// Timer2 On
{
	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     112:	81 e8       	ldi	r24, 0x81	; 129
     114:	85 bd       	out	0x25, r24	; 37
	OCR2 = 1; // FAN PWM ON
     116:	81 e0       	ldi	r24, 0x01	; 1
     118:	83 bd       	out	0x23, r24	; 35
}
     11a:	08 95       	ret

0000011c <timer2_off>:

void timer2_off(void)	// Timer2 Off
{
	TCCR2 = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     11c:	15 bc       	out	0x25, r1	; 37
	OCR2 = 0; // FAN PWM OFF
     11e:	13 bc       	out	0x23, r1	; 35
}
     120:	08 95       	ret

00000122 <__vector_2>:

/*****************************************
**** EXTERNAL INTERRUPT 1 VECTOR 02 ******
*****************************************/
ISR(INT1_vect)
{
     122:	1f 92       	push	r1
     124:	0f 92       	push	r0
     126:	0f b6       	in	r0, 0x3f	; 63
     128:	0f 92       	push	r0
     12a:	11 24       	eor	r1, r1
}
     12c:	0f 90       	pop	r0
     12e:	0f be       	out	0x3f, r0	; 63
     130:	0f 90       	pop	r0
     132:	1f 90       	pop	r1
     134:	18 95       	reti

00000136 <__vector_3>:

/*****************************************
**** EXTERNAL INTERRUPT 2 VECTOR 03 ******
*****************************************/
ISR(INT2_vect)
{
     136:	1f 92       	push	r1
     138:	0f 92       	push	r0
     13a:	0f b6       	in	r0, 0x3f	; 63
     13c:	0f 92       	push	r0
     13e:	11 24       	eor	r1, r1
}
     140:	0f 90       	pop	r0
     142:	0f be       	out	0x3f, r0	; 63
     144:	0f 90       	pop	r0
     146:	1f 90       	pop	r1
     148:	18 95       	reti

0000014a <__vector_4>:

/*****************************************
**** TIMER 2 OUTPUT COMPARE VECTOR 04 ****
*****************************************/
ISR(TIMER2_COMP_vect)
{
     14a:	1f 92       	push	r1
     14c:	0f 92       	push	r0
     14e:	0f b6       	in	r0, 0x3f	; 63
     150:	0f 92       	push	r0
     152:	11 24       	eor	r1, r1
}
     154:	0f 90       	pop	r0
     156:	0f be       	out	0x3f, r0	; 63
     158:	0f 90       	pop	r0
     15a:	1f 90       	pop	r1
     15c:	18 95       	reti

0000015e <__vector_5>:

/*****************************************
**** TIMER 2 OVERFLOW VECTOR 05 **********
*****************************************/
ISR(TIMER2_OVF_vect)
{
     15e:	1f 92       	push	r1
     160:	0f 92       	push	r0
     162:	0f b6       	in	r0, 0x3f	; 63
     164:	0f 92       	push	r0
     166:	11 24       	eor	r1, r1
}
     168:	0f 90       	pop	r0
     16a:	0f be       	out	0x3f, r0	; 63
     16c:	0f 90       	pop	r0
     16e:	1f 90       	pop	r1
     170:	18 95       	reti

00000172 <init_all>:
*********************************** START OF APPLICATION ************************************
********************************************************************************************/

void init_all()
{
	port_init();		// IO init and configure all port
     172:	0e 94 49 00 	call	0x92	; 0x92 <port_init>
//	timer2_init();
	LCD_INIT();			// LCD init and reset all lcd contain
     176:	0e 94 2d 06 	call	0xc5a	; 0xc5a <LCD_INIT>
	uart_init();		// UART debug init
     17a:	0e 94 f8 07 	call	0xff0	; 0xff0 <uart_init>
	about();			// Any debug important information
     17e:	0e 94 a0 08 	call	0x1140	; 0x1140 <about>

	pga2310_init();		// SPI init and reset all (U6, U7, U8) PGA2310 volume values to null
     182:	0e 94 22 07 	call	0xe44	; 0xe44 <pga2310_init>
//	relays_in_init();	// ?? nujno li e ?
//	relays_out_init();	// ?? nujno li e ?


}
     186:	08 95       	ret

00000188 <tempDataUartSort>:
}

void tempDataUartSort(void)
{
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] byte ");
     188:	80 e6       	ldi	r24, 0x60	; 96
     18a:	90 e0       	ldi	r25, 0x00	; 0
     18c:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartInt(i);
     190:	80 91 91 06 	lds	r24, 0x0691
     194:	90 e0       	ldi	r25, 0x00	; 0
     196:	0e 94 c0 07 	call	0xf80	; 0xf80 <transmitUartInt>
	transmitUartString(" : ");
     19a:	82 e7       	ldi	r24, 0x72	; 114
     19c:	90 e0       	ldi	r25, 0x00	; 0
     19e:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartInt(store[i]);
     1a2:	80 91 91 06 	lds	r24, 0x0691
     1a6:	e2 e9       	ldi	r30, 0x92	; 146
     1a8:	f6 e0       	ldi	r31, 0x06	; 6
     1aa:	e8 0f       	add	r30, r24
     1ac:	f1 1d       	adc	r31, r1
     1ae:	80 81       	ld	r24, Z
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	0e 94 c0 07 	call	0xf80	; 0xf80 <transmitUartInt>
	transmitUartString("\r\n");
     1b6:	86 e7       	ldi	r24, 0x76	; 118
     1b8:	90 e0       	ldi	r25, 0x00	; 0
     1ba:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif	
}
     1be:	08 95       	ret

000001c0 <temperMeasur>:
	}
	return 0;
}

char temperMeasur(unsigned char byte0, unsigned char byte1, unsigned char byte6, unsigned char byte7)
{
     1c0:	1f 93       	push	r17
	char tC = 0;
	char temper = 0;
	double k = 0;
	double j = 0;

	byte0 = store [0];
     1c2:	10 91 92 06 	lds	r17, 0x0692
	byte1 = store [1];
     1c6:	80 91 93 06 	lds	r24, 0x0693
	byte6 = store [6];
	byte7 = store [7];

	k = ((byte7 - byte6) / byte7) + 0.25;

	if((byte1 == 0x00) && (byte0 == 0x00))
     1ca:	88 23       	and	r24, r24
     1cc:	61 f5       	brne	.+88     	; 0x226 <temperMeasur+0x66>
     1ce:	11 23       	and	r17, r17
     1d0:	79 f4       	brne	.+30     	; 0x1f0 <temperMeasur+0x30>
	{
		tC = (byte0/2);
		j = tC - k;
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     1d2:	89 e7       	ldi	r24, 0x79	; 121
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartInt(tC);		// uart debug information string 
     1da:	80 e0       	ldi	r24, 0x00	; 0
     1dc:	90 e0       	ldi	r25, 0x00	; 0
     1de:	0e 94 c0 07 	call	0xf80	; 0xf80 <transmitUartInt>
	transmitUartString(".0 C\r\n");			// uart debug information string
     1e2:	83 e9       	ldi	r24, 0x93	; 147
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     1ea:	80 e0       	ldi	r24, 0x00	; 0
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	13 c0       	rjmp	.+38     	; 0x216 <temperMeasur+0x56>
	LCD_DATA_STRING(".0 C");		//
	}
	else if((byte1 == 0x00) && (byte0 != 0x00))
	{
		transmitUartString("+");
     1f0:	8f e9       	ldi	r24, 0x9F	; 159
     1f2:	90 e0       	ldi	r25, 0x00	; 0
     1f4:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
		tC = (byte0/2);
		j = tC - k;
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     1f8:	89 e7       	ldi	r24, 0x79	; 121
     1fa:	90 e0       	ldi	r25, 0x00	; 0
     1fc:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartInt(tC);		// uart debug information string 
     200:	16 95       	lsr	r17
     202:	81 2f       	mov	r24, r17
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	0e 94 c0 07 	call	0xf80	; 0xf80 <transmitUartInt>
	transmitUartString(".0 C\r\n");			// uart debug information string
     20a:	83 e9       	ldi	r24, 0x93	; 147
     20c:	90 e0       	ldi	r25, 0x00	; 0
     20e:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     212:	81 2f       	mov	r24, r17
     214:	90 e0       	ldi	r25, 0x00	; 0
     216:	0e 94 d3 06 	call	0xda6	; 0xda6 <LCD_DATA_INT>
	LCD_DATA_STRING(".0 C");		//
     21a:	8a e9       	ldi	r24, 0x9A	; 154
     21c:	90 e0       	ldi	r25, 0x00	; 0
     21e:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
     222:	80 e0       	ldi	r24, 0x00	; 0
     224:	1b c0       	rjmp	.+54     	; 0x25c <temperMeasur+0x9c>
	}
	else if((byte1 == 0xFF) && (byte0 != 0x00))
     226:	8f 3f       	cpi	r24, 0xFF	; 255
     228:	a1 f4       	brne	.+40     	; 0x252 <temperMeasur+0x92>
     22a:	11 23       	and	r17, r17
     22c:	91 f0       	breq	.+36     	; 0x252 <temperMeasur+0x92>
	{
		transmitUartString("-");
     22e:	81 ea       	ldi	r24, 0xA1	; 161
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
//		tC = ((byte0 - 255.5) / 2);		// ne e dobre obraboteno za otricatelni chisla
		tC = ((byte0 - 255) / 2);
		j = tC - k;
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     236:	89 e7       	ldi	r24, 0x79	; 121
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartInt(tC);		// uart debug information string 
     23e:	81 2f       	mov	r24, r17
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	8f 5f       	subi	r24, 0xFF	; 255
     244:	90 40       	sbci	r25, 0x00	; 0
     246:	62 e0       	ldi	r22, 0x02	; 2
     248:	70 e0       	ldi	r23, 0x00	; 0
     24a:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <__divmodhi4>
     24e:	16 2f       	mov	r17, r22
     250:	d8 cf       	rjmp	.-80     	; 0x202 <temperMeasur+0x42>
	}
	else
	{
		//lcdDataString("ERROR!");	// ERROR not return to display!!!!
#ifdef DEBUG_ERROR
	transmitUartString("[UART ERROR] ERROR TEMPERATURE\r\n");		// uart debug information string
     252:	83 ea       	ldi	r24, 0xA3	; 163
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
     25a:	81 e0       	ldi	r24, 0x01	; 1
#endif
		return 1;
	}

	return temper;
}
     25c:	1f 91       	pop	r17
     25e:	08 95       	ret

00000260 <oneWireRight>:
	}
	return 0;
}

unsigned char oneWireRight()
{
     260:	1f 93       	push	r17
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
     262:	84 ec       	ldi	r24, 0xC4	; 196
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     26a:	0e 94 bf 04 	call	0x97e	; 0x97e <reset>
     26e:	88 23       	and	r24, r24
     270:	09 f4       	brne	.+2      	; 0x274 <oneWireRight+0x14>
     272:	57 c0       	rjmp	.+174    	; 0x322 <oneWireRight+0xc2>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     274:	85 e5       	ldi	r24, 0x55	; 85
     276:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		// 64-bit ROM CODE
		write_byte(0x10);	// Byte 0
     27a:	80 e1       	ldi	r24, 0x10	; 16
     27c:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0x6D);	// Byte 1
     280:	8d e6       	ldi	r24, 0x6D	; 109
     282:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0xF4);	// Byte 2
     286:	84 ef       	ldi	r24, 0xF4	; 244
     288:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0x8F);	// Byte 3
     28c:	8f e8       	ldi	r24, 0x8F	; 143
     28e:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0x02);	// Byte 4
     292:	82 e0       	ldi	r24, 0x02	; 2
     294:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0x08);	// Byte 5
     298:	88 e0       	ldi	r24, 0x08	; 8
     29a:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0x00);	// Byte 6
     29e:	80 e0       	ldi	r24, 0x00	; 0
     2a0:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0xB1);	// Byte 7
     2a4:	81 eb       	ldi	r24, 0xB1	; 177
     2a6:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		// 64-bit ROM CODE

		write_byte(0x44);	// Master issues Convert T command.
     2aa:	84 e4       	ldi	r24, 0x44	; 68
     2ac:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     2b0:	0e 94 3b 05 	call	0xa76	; 0xa76 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     2b4:	0e 94 bf 04 	call	0x97e	; 0x97e <reset>
     2b8:	88 23       	and	r24, r24
     2ba:	99 f1       	breq	.+102    	; 0x322 <oneWireRight+0xc2>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     2bc:	85 e5       	ldi	r24, 0x55	; 85
     2be:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			// 64-bit ROM CODE
			write_byte(0x10);	// Byte 0
     2c2:	80 e1       	ldi	r24, 0x10	; 16
     2c4:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0x6D);	// Byte 1
     2c8:	8d e6       	ldi	r24, 0x6D	; 109
     2ca:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0xF4);	// Byte 2
     2ce:	84 ef       	ldi	r24, 0xF4	; 244
     2d0:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0x8F);	// Byte 3
     2d4:	8f e8       	ldi	r24, 0x8F	; 143
     2d6:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0x02);	// Byte 4
     2da:	82 e0       	ldi	r24, 0x02	; 2
     2dc:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0x08);	// Byte 5
     2e0:	88 e0       	ldi	r24, 0x08	; 8
     2e2:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0x00);	// Byte 6
     2e6:	80 e0       	ldi	r24, 0x00	; 0
     2e8:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0xB1);	// Byte 7
     2ec:	81 eb       	ldi	r24, 0xB1	; 177
     2ee:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
     2f2:	8e eb       	ldi	r24, 0xBE	; 190
     2f4:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			for(i=0; i<9; i++)
     2f8:	10 92 91 06 	sts	0x0691, r1
     2fc:	0c c0       	rjmp	.+24     	; 0x316 <oneWireRight+0xb6>
			{
				store [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     2fe:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <read_byte>
     302:	e1 2f       	mov	r30, r17
     304:	f0 e0       	ldi	r31, 0x00	; 0
     306:	ee 56       	subi	r30, 0x6E	; 110
     308:	f9 4f       	sbci	r31, 0xF9	; 249
     30a:	80 83       	st	Z, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     30c:	80 91 91 06 	lds	r24, 0x0691
     310:	8f 5f       	subi	r24, 0xFF	; 255
     312:	80 93 91 06 	sts	0x0691, r24
     316:	10 91 91 06 	lds	r17, 0x0691
     31a:	19 30       	cpi	r17, 0x09	; 9
     31c:	80 f3       	brcs	.-32     	; 0x2fe <oneWireRight+0x9e>
     31e:	81 e0       	ldi	r24, 0x01	; 1
     320:	01 c0       	rjmp	.+2      	; 0x324 <oneWireRight+0xc4>
     322:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     324:	1f 91       	pop	r17
     326:	08 95       	ret

00000328 <oneWireLeft>:

/*******************************************
**** 1-WIRE DS18x20 Temperature Sensors ****
*******************************************/
unsigned char oneWireLeft()
{
     328:	1f 93       	push	r17
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
     32a:	85 e0       	ldi	r24, 0x05	; 5
     32c:	91 e0       	ldi	r25, 0x01	; 1
     32e:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     332:	0e 94 bf 04 	call	0x97e	; 0x97e <reset>
     336:	88 23       	and	r24, r24
     338:	09 f4       	brne	.+2      	; 0x33c <oneWireLeft+0x14>
     33a:	57 c0       	rjmp	.+174    	; 0x3ea <oneWireLeft+0xc2>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     33c:	85 e5       	ldi	r24, 0x55	; 85
     33e:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		// 64-bit ROM CODE
		write_byte(0x10);	// Byte 0
     342:	80 e1       	ldi	r24, 0x10	; 16
     344:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0xDB);	// Byte 1
     348:	8b ed       	ldi	r24, 0xDB	; 219
     34a:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0x09);	// Byte 2
     34e:	89 e0       	ldi	r24, 0x09	; 9
     350:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0xA5);	// Byte 3
     354:	85 ea       	ldi	r24, 0xA5	; 165
     356:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0x01);	// Byte 4
     35a:	81 e0       	ldi	r24, 0x01	; 1
     35c:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0x08);	// Byte 5
     360:	88 e0       	ldi	r24, 0x08	; 8
     362:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0x00);	// Byte 6
     366:	80 e0       	ldi	r24, 0x00	; 0
     368:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0xC1);	// Byte 7
     36c:	81 ec       	ldi	r24, 0xC1	; 193
     36e:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		// 64-bit ROM CODE

		write_byte(0x44);	// Master issues Convert T command.
     372:	84 e4       	ldi	r24, 0x44	; 68
     374:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     378:	0e 94 3b 05 	call	0xa76	; 0xa76 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     37c:	0e 94 bf 04 	call	0x97e	; 0x97e <reset>
     380:	88 23       	and	r24, r24
     382:	99 f1       	breq	.+102    	; 0x3ea <oneWireLeft+0xc2>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     384:	85 e5       	ldi	r24, 0x55	; 85
     386:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			// 64-bit ROM CODE
			write_byte(0x10);	// Byte 0
     38a:	80 e1       	ldi	r24, 0x10	; 16
     38c:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0xDB);	// Byte 1
     390:	8b ed       	ldi	r24, 0xDB	; 219
     392:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0x09);	// Byte 2
     396:	89 e0       	ldi	r24, 0x09	; 9
     398:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0xA5);	// Byte 3
     39c:	85 ea       	ldi	r24, 0xA5	; 165
     39e:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0x01);	// Byte 4
     3a2:	81 e0       	ldi	r24, 0x01	; 1
     3a4:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0x08);	// Byte 5
     3a8:	88 e0       	ldi	r24, 0x08	; 8
     3aa:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0x00);	// Byte 6
     3ae:	80 e0       	ldi	r24, 0x00	; 0
     3b0:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0xC1);	// Byte 7
     3b4:	81 ec       	ldi	r24, 0xC1	; 193
     3b6:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
     3ba:	8e eb       	ldi	r24, 0xBE	; 190
     3bc:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			for(i=0; i<9; i++)
     3c0:	10 92 91 06 	sts	0x0691, r1
     3c4:	0c c0       	rjmp	.+24     	; 0x3de <oneWireLeft+0xb6>
			{
				store [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     3c6:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <read_byte>
     3ca:	e1 2f       	mov	r30, r17
     3cc:	f0 e0       	ldi	r31, 0x00	; 0
     3ce:	ee 56       	subi	r30, 0x6E	; 110
     3d0:	f9 4f       	sbci	r31, 0xF9	; 249
     3d2:	80 83       	st	Z, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     3d4:	80 91 91 06 	lds	r24, 0x0691
     3d8:	8f 5f       	subi	r24, 0xFF	; 255
     3da:	80 93 91 06 	sts	0x0691, r24
     3de:	10 91 91 06 	lds	r17, 0x0691
     3e2:	19 30       	cpi	r17, 0x09	; 9
     3e4:	80 f3       	brcs	.-32     	; 0x3c6 <oneWireLeft+0x9e>
     3e6:	81 e0       	ldi	r24, 0x01	; 1
     3e8:	01 c0       	rjmp	.+2      	; 0x3ec <oneWireLeft+0xc4>
     3ea:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     3ec:	1f 91       	pop	r17
     3ee:	08 95       	ret

000003f0 <temperature>:
*****************************/
void temperature()
{
//	LED_low_DISPLAYLED_high();
//	LCD_INIT();								// LCD INITIZLIZATION
	LCD_COMMAND(LCD_SELECT_1ROW);	// select row 1
     3f0:	80 e0       	ldi	r24, 0x00	; 0
     3f2:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
	LCD_DATA_STRING("    TEPERATURE    ");		//
     3f6:	85 e4       	ldi	r24, 0x45	; 69
     3f8:	91 e0       	ldi	r25, 0x01	; 1
     3fa:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
     3fe:	80 ec       	ldi	r24, 0xC0	; 192
     400:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
	LCD_DATA_STRING("LEFT  SENSOR: ");				//
     404:	88 e5       	ldi	r24, 0x58	; 88
     406:	91 e0       	ldi	r25, 0x01	; 1
     408:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>

	oneWireLeft();
     40c:	0e 94 94 01 	call	0x328	; 0x328 <oneWireLeft>
	for(i=0; i<9; i++)
     410:	10 92 91 06 	sts	0x0691, r1
     414:	07 c0       	rjmp	.+14     	; 0x424 <temperature+0x34>
	{
		tempDataUartSort();
     416:	0e 94 c4 00 	call	0x188	; 0x188 <tempDataUartSort>
	LCD_DATA_STRING("    TEPERATURE    ");		//
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
	LCD_DATA_STRING("LEFT  SENSOR: ");				//

	oneWireLeft();
	for(i=0; i<9; i++)
     41a:	80 91 91 06 	lds	r24, 0x0691
     41e:	8f 5f       	subi	r24, 0xFF	; 255
     420:	80 93 91 06 	sts	0x0691, r24
     424:	80 91 91 06 	lds	r24, 0x0691
     428:	89 30       	cpi	r24, 0x09	; 9
     42a:	a8 f3       	brcs	.-22     	; 0x416 <temperature+0x26>
	transmitUartInt(store[i]);
	transmitUartString("\r\n");
#endif
*/
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     42c:	80 91 af 06 	lds	r24, 0x06AF
     430:	60 91 ab 06 	lds	r22, 0x06AB
     434:	40 91 aa 06 	lds	r20, 0x06AA
     438:	20 91 a7 06 	lds	r18, 0x06A7
     43c:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
     440:	84 e9       	ldi	r24, 0x94	; 148
     442:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
     446:	87 e6       	ldi	r24, 0x67	; 103
     448:	91 e0       	ldi	r25, 0x01	; 1
     44a:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
	oneWireRight();
     44e:	0e 94 30 01 	call	0x260	; 0x260 <oneWireRight>
	for(i=0; i<9; i++)
     452:	10 92 91 06 	sts	0x0691, r1
     456:	07 c0       	rjmp	.+14     	; 0x466 <temperature+0x76>
	{
		tempDataUartSort();
     458:	0e 94 c4 00 	call	0x188	; 0x188 <tempDataUartSort>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
	oneWireRight();
	for(i=0; i<9; i++)
     45c:	80 91 91 06 	lds	r24, 0x0691
     460:	8f 5f       	subi	r24, 0xFF	; 255
     462:	80 93 91 06 	sts	0x0691, r24
     466:	80 91 91 06 	lds	r24, 0x0691
     46a:	89 30       	cpi	r24, 0x09	; 9
     46c:	a8 f3       	brcs	.-22     	; 0x458 <temperature+0x68>
	transmitUartInt(store[i]);
	transmitUartString("\r\n");
#endif
*/
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     46e:	80 91 af 06 	lds	r24, 0x06AF
     472:	60 91 ab 06 	lds	r22, 0x06AB
     476:	40 91 aa 06 	lds	r20, 0x06AA
     47a:	20 91 a7 06 	lds	r18, 0x06A7
     47e:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
     482:	84 ed       	ldi	r24, 0xD4	; 212
     484:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
	LCD_DATA_STRING("             DS18x20");		//
     488:	86 e7       	ldi	r24, 0x76	; 118
     48a:	91 e0       	ldi	r25, 0x01	; 1
     48c:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
}
     490:	08 95       	ret

00000492 <ampliferOff>:
/*********************
**** AMPLIFER OFF ****
*********************/
void ampliferOff(void)
{
	flagStatusBits->flagPower = 0;		// flag for amplifer off
     492:	e0 91 ad 06 	lds	r30, 0x06AD
     496:	f0 91 ae 06 	lds	r31, 0x06AE
     49a:	80 81       	ld	r24, Z
     49c:	8e 7f       	andi	r24, 0xFE	; 254
     49e:	80 83       	st	Z, r24

	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     4a0:	80 e0       	ldi	r24, 0x00	; 0
     4a2:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer Off    ");	// 20 symbols
     4a6:	8b e8       	ldi	r24, 0x8B	; 139
     4a8:	91 e0       	ldi	r25, 0x01	; 1
     4aa:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>

	LCD_COMMAND(LCD_OFF);						// LCD ON without CURSOR
     4ae:	88 e0       	ldi	r24, 0x08	; 8
     4b0:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>

//			FAN_low();		// PORTD5 - FAN OFF (logic "0")  NON PWM, NON TIMER1

// RELAYS OFF
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch off relays out for all 6 channels\r\n");		// uart debug information string
     4b4:	80 ea       	ldi	r24, 0xA0	; 160
     4b6:	91 e0       	ldi	r25, 0x01	; 1
     4b8:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
//	relays_out_off();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
//	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch off relays in for all 6 channels\r\n");		// uart debug information string
     4bc:	8e ed       	ldi	r24, 0xDE	; 222
     4be:	91 e0       	ldi	r25, 0x01	; 1
     4c0:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
//	relays_in_off();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
//	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch off relays for power 220V\r\n");		// uart debug information string
     4c4:	8b e1       	ldi	r24, 0x1B	; 27
     4c6:	92 e0       	ldi	r25, 0x02	; 2
     4c8:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
//	REL_POWER_low();// RELAY POWER OFF				// PESHO COMMENT 14.08.2015, 21:10

#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Fan is off\r\n");
     4cc:	81 e5       	ldi	r24, 0x51	; 81
     4ce:	92 e0       	ldi	r25, 0x02	; 2
     4d0:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
//	OCR1BH = 0; // LED PWM ON
//	OCR1BL = 1; // LED PWM ON
}
void timer1_off()
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     4d4:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     4d6:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     4d8:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     4da:	1a bc       	out	0x2a, r1	; 42
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Fan is off\r\n");
#endif
	FAN_PWM_OFF();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1

	LCD_CLEAR_CONTAIN();
     4dc:	0e 94 25 06 	call	0xc4a	; 0xc4a <LCD_CLEAR_CONTAIN>
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Display off and status led on\r\n");
     4e0:	8a e6       	ldi	r24, 0x6A	; 106
     4e2:	92 e0       	ldi	r25, 0x02	; 2
     4e4:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     4e8:	94 9a       	sbi	0x12, 4	; 18
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Amplifer is off\r\n");
     4ea:	86 e9       	ldi	r24, 0x96	; 150
     4ec:	92 e0       	ldi	r25, 0x02	; 2
     4ee:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
     4f2:	88 e8       	ldi	r24, 0x88	; 136
     4f4:	93 e1       	ldi	r25, 0x13	; 19
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4f6:	20 e9       	ldi	r18, 0x90	; 144
     4f8:	31 e0       	ldi	r19, 0x01	; 1
     4fa:	f9 01       	movw	r30, r18
     4fc:	31 97       	sbiw	r30, 0x01	; 1
     4fe:	f1 f7       	brne	.-4      	; 0x4fc <ampliferOff+0x6a>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     500:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     502:	d9 f7       	brne	.-10     	; 0x4fa <ampliferOff+0x68>
#endif

	_delay_ms(500);	// izchakvane pri natiskane za izkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton
}
     504:	08 95       	ret

00000506 <ampliferOn>:
/********************
**** AMPLIFER ON ****
********************/
void ampliferOn(void)
{
	flagStatusBits->flagPower = 1;		// flag for amplifer on
     506:	e0 91 ad 06 	lds	r30, 0x06AD
     50a:	f0 91 ae 06 	lds	r31, 0x06AE
     50e:	80 81       	ld	r24, Z
     510:	81 60       	ori	r24, 0x01	; 1
     512:	80 83       	st	Z, r24

#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Amplifer is on\r\n");
     514:	84 eb       	ldi	r24, 0xB4	; 180
     516:	92 e0       	ldi	r25, 0x02	; 2
     518:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Display on and status led off\r\n");
     51c:	81 ed       	ldi	r24, 0xD1	; 209
     51e:	92 e0       	ldi	r25, 0x02	; 2
     520:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     524:	94 98       	cbi	0x12, 4	; 18

	LCD_CLEAR_CONTAIN();						// clear all contain on display
     526:	0e 94 25 06 	call	0xc4a	; 0xc4a <LCD_CLEAR_CONTAIN>
	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     52a:	80 e0       	ldi	r24, 0x00	; 0
     52c:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer On     ");	// 20 symbols
     530:	8d ef       	ldi	r24, 0xFD	; 253
     532:	92 e0       	ldi	r25, 0x02	; 2
     534:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);				// select row 2
     538:	80 ec       	ldi	r24, 0xC0	; 192
     53a:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
	LCD_DATA_STRING("P.UPINOV  P.STOYANOV");	// 20 symbols //	LCD_EXECUTE_DATA("P.UPINOV  P.STOYANOV",20);	// char "DATA", int 13 of chars of "DATA"
     53e:	82 e1       	ldi	r24, 0x12	; 18
     540:	93 e0       	ldi	r25, 0x03	; 3
     542:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     546:	8c e0       	ldi	r24, 0x0C	; 12
     548:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>

#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Fan is on\r\n");
     54c:	87 e2       	ldi	r24, 0x27	; 39
     54e:	93 e0       	ldi	r25, 0x03	; 3
     550:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartString("[UART INFO] Fan is always on, it isn't sensitive to temperature, because DS18S20 is disabling\r\n");
     554:	8f e3       	ldi	r24, 0x3F	; 63
     556:	93 e0       	ldi	r25, 0x03	; 3
     558:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>

//	TIMSK = (1 << OCIE1A);
}
void timer1_on_speed1()
{
	TCCR1A = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     55c:	81 e8       	ldi	r24, 0x81	; 129
     55e:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00010001;
     560:	81 e1       	ldi	r24, 0x11	; 17
     562:	8e bd       	out	0x2e, r24	; 46

	OCR1AH = 0; // FAN PWM ON
     564:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 1; // FAN PWM ON
     566:	81 e0       	ldi	r24, 0x01	; 1
     568:	8a bd       	out	0x2a, r24	; 42
	FAN_PWM_SPEED1();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1
//	FAN_high();			// PORTD5 - FAN ON (logic "1")	NON PWM, NON TIMER1

// RELAYS ON
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch on relays for power 220V\r\n");		// uart debug information string
     56a:	8f e9       	ldi	r24, 0x9F	; 159
     56c:	93 e0       	ldi	r25, 0x03	; 3
     56e:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
//	REL_POWER_high();// RELAY POWER ON TRAFs		// PESHO COMMENT 14.08.2015, 21:10
//	_delay_ms(4000);								// PESHO COMMENT 14.08.2015, 21:10
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch on relays in for all 6 channels\r\n");		// uart debug information string
     572:	84 ed       	ldi	r24, 0xD4	; 212
     574:	93 e0       	ldi	r25, 0x03	; 3
     576:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
//	relays_in1_6ch();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
//	_delay_ms(700);									// PESHO COMMENT 14.08.2015, 21:10
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch on relays out for all 6 channels\r\n");		// uart debug information string
     57a:	80 e1       	ldi	r24, 0x10	; 16
     57c:	94 e0       	ldi	r25, 0x04	; 4
     57e:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
     582:	80 e1       	ldi	r24, 0x10	; 16
     584:	97 e2       	ldi	r25, 0x27	; 39
     586:	20 e9       	ldi	r18, 0x90	; 144
     588:	31 e0       	ldi	r19, 0x01	; 1
     58a:	f9 01       	movw	r30, r18
     58c:	31 97       	sbiw	r30, 0x01	; 1
     58e:	f1 f7       	brne	.-4      	; 0x58c <ampliferOn+0x86>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     590:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     592:	d9 f7       	brne	.-10     	; 0x58a <ampliferOn+0x84>
#endif
//	relays_out_6ch();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
	_delay_ms(1000);	// izchakvane pri natiskane za vkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton
}
     594:	08 95       	ret

00000596 <commonEncoder>:
**********************************************/
void commonEncoder(void)	// not finished
{
	static signed char saveValue = 0;	// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!! static ???
	signed char temp = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     596:	0e 94 c5 08 	call	0x118a	; 0x118a <rotaryEncoderNikBarzakov>
	if(0==temp)
     59a:	88 23       	and	r24, r24
     59c:	09 f4       	brne	.+2      	; 0x5a0 <commonEncoder+0xa>
     59e:	4f c0       	rjmp	.+158    	; 0x63e <commonEncoder+0xa8>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     5a0:	8f 3f       	cpi	r24, 0xFF	; 255
     5a2:	41 f5       	brne	.+80     	; 0x5f4 <commonEncoder+0x5e>
	{
		// encoder is decrement
		if(saveValue < -127)
     5a4:	80 91 9c 06 	lds	r24, 0x069C
     5a8:	80 38       	cpi	r24, 0x80	; 128
     5aa:	11 f4       	brne	.+4      	; 0x5b0 <commonEncoder+0x1a>
		{
			saveValue = 127;	// SIGNED CHAR MIN VALUE = -127
     5ac:	8f e7       	ldi	r24, 0x7F	; 127
     5ae:	01 c0       	rjmp	.+2      	; 0x5b2 <commonEncoder+0x1c>
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     5b0:	81 50       	subi	r24, 0x01	; 1
     5b2:	80 93 9c 06 	sts	0x069C, r24
		}
// LCD PRINT VALUE
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     5b6:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     5b8:	8c e0       	ldi	r24, 0x0C	; 12
     5ba:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     5be:	84 ed       	ldi	r24, 0xD4	; 212
     5c0:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
		if (saveValue > 99)
     5c4:	80 91 9c 06 	lds	r24, 0x069C
     5c8:	84 36       	cpi	r24, 0x64	; 100
     5ca:	1c f0       	brlt	.+6      	; 0x5d2 <commonEncoder+0x3c>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     5cc:	8d e4       	ldi	r24, 0x4D	; 77
     5ce:	94 e0       	ldi	r25, 0x04	; 4
     5d0:	07 c0       	rjmp	.+14     	; 0x5e0 <commonEncoder+0x4a>
		}
		else if (saveValue > 9)
     5d2:	8a 30       	cpi	r24, 0x0A	; 10
     5d4:	1c f0       	brlt	.+6      	; 0x5dc <commonEncoder+0x46>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     5d6:	86 e5       	ldi	r24, 0x56	; 86
     5d8:	94 e0       	ldi	r25, 0x04	; 4
     5da:	02 c0       	rjmp	.+4      	; 0x5e0 <commonEncoder+0x4a>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     5dc:	80 e6       	ldi	r24, 0x60	; 96
     5de:	94 e0       	ldi	r25, 0x04	; 4
     5e0:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     5e4:	80 91 9c 06 	lds	r24, 0x069C
     5e8:	99 27       	eor	r25, r25
     5ea:	87 fd       	sbrc	r24, 7
     5ec:	90 95       	com	r25
     5ee:	0e 94 d3 06 	call	0xda6	; 0xda6 <LCD_DATA_INT>
     5f2:	08 95       	ret
	}
	else if(1==temp)
     5f4:	81 30       	cpi	r24, 0x01	; 1
     5f6:	19 f5       	brne	.+70     	; 0x63e <commonEncoder+0xa8>
		{
			saveValue = 128;	// SIGNED CHAR MAX VALUE = +128
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     5f8:	80 91 9c 06 	lds	r24, 0x069C
     5fc:	8f 5f       	subi	r24, 0xFF	; 255
     5fe:	80 93 9c 06 	sts	0x069C, r24
		}

	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     602:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     604:	8c e0       	ldi	r24, 0x0C	; 12
     606:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     60a:	84 ed       	ldi	r24, 0xD4	; 212
     60c:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
		if (saveValue > 99)
     610:	80 91 9c 06 	lds	r24, 0x069C
     614:	84 36       	cpi	r24, 0x64	; 100
     616:	1c f0       	brlt	.+6      	; 0x61e <commonEncoder+0x88>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     618:	8d e4       	ldi	r24, 0x4D	; 77
     61a:	94 e0       	ldi	r25, 0x04	; 4
     61c:	07 c0       	rjmp	.+14     	; 0x62c <commonEncoder+0x96>
		}
		else if (saveValue > 9)
     61e:	8a 30       	cpi	r24, 0x0A	; 10
     620:	1c f0       	brlt	.+6      	; 0x628 <commonEncoder+0x92>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     622:	86 e5       	ldi	r24, 0x56	; 86
     624:	94 e0       	ldi	r25, 0x04	; 4
     626:	02 c0       	rjmp	.+4      	; 0x62c <commonEncoder+0x96>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     628:	80 e6       	ldi	r24, 0x60	; 96
     62a:	94 e0       	ldi	r25, 0x04	; 4
     62c:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     630:	80 91 9c 06 	lds	r24, 0x069C
     634:	99 27       	eor	r25, r25
     636:	87 fd       	sbrc	r24, 7
     638:	90 95       	com	r25
     63a:	0e 94 d3 06 	call	0xda6	; 0xda6 <LCD_DATA_INT>
     63e:	08 95       	ret

00000640 <volumeUpdate>:
/*************************************
**** VOLUME UPDATE and LCD UPDATE ****
*************************************/
void volumeUpdate(void)
{
	PGA2310_Volume_Update(volumeValue[volumeIndex], volumeValue[volumeIndex]);	// update volume value on all channels
     640:	e0 91 90 06 	lds	r30, 0x0690
     644:	f0 e0       	ldi	r31, 0x00	; 0
     646:	e0 58       	subi	r30, 0x80	; 128
     648:	fb 4f       	sbci	r31, 0xFB	; 251
     64a:	60 81       	ld	r22, Z
     64c:	86 2f       	mov	r24, r22
     64e:	0e 94 0b 07 	call	0xe16	; 0xe16 <PGA2310_Volume_Update>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     652:	84 ed       	ldi	r24, 0xD4	; 212
     654:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
//		LCD_DATA_STRING("Volume: ");	// 20 symbols
	if (volumeIndex > 9)
     658:	80 91 90 06 	lds	r24, 0x0690
     65c:	8a 30       	cpi	r24, 0x0A	; 10
     65e:	18 f0       	brcs	.+6      	; 0x666 <volumeUpdate+0x26>
	{
		LCD_DATA_STRING("Volume: ");	// 20 symbols
     660:	8d e4       	ldi	r24, 0x4D	; 77
     662:	94 e0       	ldi	r25, 0x04	; 4
     664:	02 c0       	rjmp	.+4      	; 0x66a <volumeUpdate+0x2a>
	}
	else
	{
		LCD_DATA_STRING("Volume: 0");	// 20 symbols
     666:	86 e5       	ldi	r24, 0x56	; 86
     668:	94 e0       	ldi	r25, 0x04	; 4
     66a:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
	}
	LCD_DATA_INT(volumeIndex);			// 20 symbols
     66e:	80 91 90 06 	lds	r24, 0x0690
     672:	90 e0       	ldi	r25, 0x00	; 0
     674:	0e 94 d3 06 	call	0xda6	; 0xda6 <LCD_DATA_INT>
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Volume: ");		// uart debug information string
     678:	8b e6       	ldi	r24, 0x6B	; 107
     67a:	94 e0       	ldi	r25, 0x04	; 4
     67c:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartInt(volumeIndex);		// uart debug information string 
     680:	80 91 90 06 	lds	r24, 0x0690
     684:	90 e0       	ldi	r25, 0x00	; 0
     686:	0e 94 c0 07 	call	0xf80	; 0xf80 <transmitUartInt>
	transmitUartString("\r\n");			// uart debug information string
     68a:	86 e7       	ldi	r24, 0x76	; 118
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
}
     692:	08 95       	ret

00000694 <volumeProcess>:
**** VOLUME PROCESS FUNCTION ****
********************************/
void volumeProcess(void)
{
	signed char temp = 0;//, tempEnc = 0, tempRem = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     694:	0e 94 c5 08 	call	0x118a	; 0x118a <rotaryEncoderNikBarzakov>
//	tempRem = remoteVolume();
	if(0==temp)
     698:	88 23       	and	r24, r24
     69a:	e1 f0       	breq	.+56     	; 0x6d4 <volumeProcess+0x40>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     69c:	8f 3f       	cpi	r24, 0xFF	; 255
     69e:	69 f4       	brne	.+26     	; 0x6ba <volumeProcess+0x26>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MIN + 1))
     6a0:	80 91 90 06 	lds	r24, 0x0690
     6a4:	88 23       	and	r24, r24
     6a6:	19 f4       	brne	.+6      	; 0x6ae <volumeProcess+0x1a>
		{
			volumeIndex = VOLUME_MIN;
     6a8:	10 92 90 06 	sts	0x0690, r1
     6ac:	03 c0       	rjmp	.+6      	; 0x6b4 <volumeProcess+0x20>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     6ae:	81 50       	subi	r24, 0x01	; 1
     6b0:	80 93 90 06 	sts	0x0690, r24
		}
		volumeUpdate();
     6b4:	0e 94 20 03 	call	0x640	; 0x640 <volumeUpdate>
     6b8:	08 95       	ret
	}
	else if(1==temp)
     6ba:	81 30       	cpi	r24, 0x01	; 1
     6bc:	59 f4       	brne	.+22     	; 0x6d4 <volumeProcess+0x40>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_MAX - 2))
     6be:	80 91 90 06 	lds	r24, 0x0690
     6c2:	83 31       	cpi	r24, 0x13	; 19
     6c4:	10 f0       	brcs	.+4      	; 0x6ca <volumeProcess+0x36>
		{
			volumeIndex = (VOLUME_MAX - 1);
     6c6:	83 e1       	ldi	r24, 0x13	; 19
     6c8:	01 c0       	rjmp	.+2      	; 0x6cc <volumeProcess+0x38>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     6ca:	8f 5f       	subi	r24, 0xFF	; 255
     6cc:	80 93 90 06 	sts	0x0690, r24
		}
		volumeUpdate();
     6d0:	0e 94 20 03 	call	0x640	; 0x640 <volumeUpdate>
     6d4:	08 95       	ret

000006d6 <buttons_press>:


}

void buttons_press()
{
     6d6:	cf 93       	push	r28
     6d8:	df 93       	push	r29
	flagStatusBits = &fSB;
     6da:	85 eb       	ldi	r24, 0xB5	; 181
     6dc:	96 e0       	ldi	r25, 0x06	; 6
     6de:	90 93 ae 06 	sts	0x06AE, r25
     6e2:	80 93 ad 06 	sts	0x06AD, r24
	flagStatusBits->flagPower=0;	// inicializirane s nuli, no nai veroqtno poradi tova che e globalna stru
     6e6:	80 91 b5 06 	lds	r24, 0x06B5
	flagStatusBits->flagMute=0;		// inicializirane
     6ea:	8c 7f       	andi	r24, 0xFC	; 252
     6ec:	80 93 b5 06 	sts	0x06B5, r24
     6f0:	c0 e9       	ldi	r28, 0x90	; 144
     6f2:	d1 e0       	ldi	r29, 0x01	; 1
		LCD_DATA_INT(flagStatusBits->flagMute);		// 20 symbols
	_delay_ms(2000);
*/
	while(1)
	{
		if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)	// obj ptr flagStatusBtnRegister from struct flagStatusBtnOnOff
     6f4:	b1 99       	sbic	0x16, 1	; 22
     6f6:	0a c0       	rjmp	.+20     	; 0x70c <buttons_press+0x36>
     6f8:	e0 91 ad 06 	lds	r30, 0x06AD
     6fc:	f0 91 ae 06 	lds	r31, 0x06AE
     700:	80 81       	ld	r24, Z
     702:	80 fd       	sbrc	r24, 0
     704:	03 c0       	rjmp	.+6      	; 0x70c <buttons_press+0x36>
		{
//			flagStatusBits->flagPower = 1;			// filter za buton ON
			ampliferOn();
     706:	0e 94 83 02 	call	0x506	; 0x506 <ampliferOn>
     70a:	f4 cf       	rjmp	.-24     	; 0x6f4 <buttons_press+0x1e>
//			_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
		}
		else if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     70c:	b1 99       	sbic	0x16, 1	; 22
     70e:	0a c0       	rjmp	.+20     	; 0x724 <buttons_press+0x4e>
     710:	e0 91 ad 06 	lds	r30, 0x06AD
     714:	f0 91 ae 06 	lds	r31, 0x06AE
     718:	80 81       	ld	r24, Z
     71a:	80 ff       	sbrs	r24, 0
     71c:	03 c0       	rjmp	.+6      	; 0x724 <buttons_press+0x4e>
		{
//			flagStatusBits->flagPower = 0;			// filter za buton OFF
			ampliferOff();
     71e:	0e 94 49 02 	call	0x492	; 0x492 <ampliferOff>
     722:	e8 cf       	rjmp	.-48     	; 0x6f4 <buttons_press+0x1e>
		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     724:	b2 99       	sbic	0x16, 2	; 22
     726:	11 c0       	rjmp	.+34     	; 0x74a <buttons_press+0x74>
     728:	e0 91 ad 06 	lds	r30, 0x06AD
     72c:	f0 91 ae 06 	lds	r31, 0x06AE
     730:	80 81       	ld	r24, Z
     732:	80 ff       	sbrs	r24, 0
     734:	0a c0       	rjmp	.+20     	; 0x74a <buttons_press+0x74>
		{
//			LCD_DATA_STRING("PRESSED BTN ESCAPE  ");	// 20 symbols
//			LCD_COMMAND(LCD_ON);
			LCD_CLEAR_CONTAIN();
     736:	0e 94 25 06 	call	0xc4a	; 0xc4a <LCD_CLEAR_CONTAIN>
     73a:	88 e8       	ldi	r24, 0x88	; 136
     73c:	93 e1       	ldi	r25, 0x13	; 19
     73e:	fe 01       	movw	r30, r28
     740:	31 97       	sbiw	r30, 0x01	; 1
     742:	f1 f7       	brne	.-4      	; 0x740 <buttons_press+0x6a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     744:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     746:	d9 f7       	brne	.-10     	; 0x73e <buttons_press+0x68>
     748:	d5 cf       	rjmp	.-86     	; 0x6f4 <buttons_press+0x1e>
			_delay_ms(500);
//			volumeUp();
//			_delay_ms(200);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     74a:	83 99       	sbic	0x10, 3	; 16
     74c:	0f c0       	rjmp	.+30     	; 0x76c <buttons_press+0x96>
     74e:	e0 91 ad 06 	lds	r30, 0x06AD
     752:	f0 91 ae 06 	lds	r31, 0x06AE
     756:	80 81       	ld	r24, Z
     758:	80 ff       	sbrs	r24, 0
     75a:	08 c0       	rjmp	.+16     	; 0x76c <buttons_press+0x96>
     75c:	88 e8       	ldi	r24, 0x88	; 136
     75e:	93 e1       	ldi	r25, 0x13	; 19
     760:	fe 01       	movw	r30, r28
     762:	31 97       	sbiw	r30, 0x01	; 1
     764:	f1 f7       	brne	.-4      	; 0x762 <buttons_press+0x8c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     766:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     768:	d9 f7       	brne	.-10     	; 0x760 <buttons_press+0x8a>
     76a:	c4 cf       	rjmp	.-120    	; 0x6f4 <buttons_press+0x1e>
			_delay_ms(500);
//			volumeDown();
//			_delay_ms(200);

		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     76c:	b2 99       	sbic	0x16, 2	; 22
     76e:	0f c0       	rjmp	.+30     	; 0x78e <buttons_press+0xb8>
     770:	e0 91 ad 06 	lds	r30, 0x06AD
     774:	f0 91 ae 06 	lds	r31, 0x06AE
     778:	80 81       	ld	r24, Z
     77a:	80 fd       	sbrc	r24, 0
     77c:	08 c0       	rjmp	.+16     	; 0x78e <buttons_press+0xb8>
     77e:	88 e8       	ldi	r24, 0x88	; 136
     780:	93 e1       	ldi	r25, 0x13	; 19
     782:	fe 01       	movw	r30, r28
     784:	31 97       	sbiw	r30, 0x01	; 1
     786:	f1 f7       	brne	.-4      	; 0x784 <buttons_press+0xae>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     788:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     78a:	d9 f7       	brne	.-10     	; 0x782 <buttons_press+0xac>
     78c:	b3 cf       	rjmp	.-154    	; 0x6f4 <buttons_press+0x1e>
//			LCD_COMMAND(LCD_ON);
			_delay_ms(500);
//			setupMode();
//			_delay_ms(1000);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     78e:	83 99       	sbic	0x10, 3	; 16
     790:	11 c0       	rjmp	.+34     	; 0x7b4 <buttons_press+0xde>
     792:	e0 91 ad 06 	lds	r30, 0x06AD
     796:	f0 91 ae 06 	lds	r31, 0x06AE
     79a:	80 81       	ld	r24, Z
     79c:	80 fd       	sbrc	r24, 0
     79e:	0a c0       	rjmp	.+20     	; 0x7b4 <buttons_press+0xde>
		{
			temperature();
     7a0:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <temperature>
     7a4:	88 e8       	ldi	r24, 0x88	; 136
     7a6:	93 e1       	ldi	r25, 0x13	; 19
     7a8:	fe 01       	movw	r30, r28
     7aa:	31 97       	sbiw	r30, 0x01	; 1
     7ac:	f1 f7       	brne	.-4      	; 0x7aa <buttons_press+0xd4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7ae:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7b0:	d9 f7       	brne	.-10     	; 0x7a8 <buttons_press+0xd2>
     7b2:	a0 cf       	rjmp	.-192    	; 0x6f4 <buttons_press+0x1e>
//			LCD_COMMAND(LCD_OFF);
			_delay_ms(500);
//			about();
//			_delay_ms(1000);
		}
		else if(flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     7b4:	e0 91 ad 06 	lds	r30, 0x06AD
     7b8:	f0 91 ae 06 	lds	r31, 0x06AE
     7bc:	80 81       	ld	r24, Z
     7be:	80 ff       	sbrs	r24, 0
     7c0:	03 c0       	rjmp	.+6      	; 0x7c8 <buttons_press+0xf2>
		{
			volumeProcess();
     7c2:	0e 94 4a 03 	call	0x694	; 0x694 <volumeProcess>
     7c6:	96 cf       	rjmp	.-212    	; 0x6f4 <buttons_press+0x1e>
		}
		else if(flagStatusBits->flagPower == 0)
		{
			commonEncoder();
     7c8:	0e 94 cb 02 	call	0x596	; 0x596 <commonEncoder>
     7cc:	93 cf       	rjmp	.-218    	; 0x6f4 <buttons_press+0x1e>

000007ce <main>:
******************************** START OF MAIN APPLICATION **********************************
********************************************************************************************/

int main(void)
{
	init_all();				// inicializacia na vsichko
     7ce:	0e 94 b9 00 	call	0x172	; 0x172 <init_all>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     7d2:	80 e4       	ldi	r24, 0x40	; 64
     7d4:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     7d6:	8a bf       	out	0x3a, r24	; 58
{
	init_all();				// inicializacia na vsichko
	ext0_intrpt_on();		// ENABLE interrupts to access IR DETECTION as call to function "IR_DECODER()" for -> SONY IR REMOTE
//	ext2_intrpt_on();

	sei();							// file "avr/interrupt.h"
     7d8:	78 94       	sei
//	SREG = (1<<I);

	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     7da:	94 9a       	sbi	0x12, 4	; 18
	while(1)
	{		
		buttons_press();	// izchakvane za natiskane na buton
     7dc:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <buttons_press>
     7e0:	fd cf       	rjmp	.-6      	; 0x7dc <main+0xe>

000007e2 <irDecode>:
************************************/
void irDecode(void)
{
//	byte byteSS0, byteSS1, byteMM0, byteMM1, byteHH0, byteHH1, byteDD0, byteDD1, byteMont0, byteMont1, byteYY0, byteYY1; // variables for convert DEC to BCD for LCD and UART for Time and Date

	GetSIRC12();
     7e2:	0e 94 71 09 	call	0x12e2	; 0x12e2 <GetSIRC12>
	if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 0)		// IR POWER -> ON
     7e6:	90 91 b1 06 	lds	r25, 0x06B1
     7ea:	91 30       	cpi	r25, 0x01	; 1
     7ec:	29 f4       	brne	.+10     	; 0x7f8 <irDecode+0x16>
     7ee:	80 91 ac 06 	lds	r24, 0x06AC
     7f2:	85 31       	cpi	r24, 0x15	; 21
     7f4:	99 f4       	brne	.+38     	; 0x81c <irDecode+0x3a>
     7f6:	06 c0       	rjmp	.+12     	; 0x804 <irDecode+0x22>
     7f8:	94 30       	cpi	r25, 0x04	; 4
     7fa:	21 f5       	brne	.+72     	; 0x844 <irDecode+0x62>
     7fc:	80 91 ac 06 	lds	r24, 0x06AC
     800:	8d 30       	cpi	r24, 0x0D	; 13
     802:	99 f4       	brne	.+38     	; 0x82a <irDecode+0x48>
     804:	e0 91 ad 06 	lds	r30, 0x06AD
     808:	f0 91 ae 06 	lds	r31, 0x06AE
     80c:	80 81       	ld	r24, Z
     80e:	80 fd       	sbrc	r24, 0
     810:	03 c0       	rjmp	.+6      	; 0x818 <irDecode+0x36>
	{		
		ampliferOn();
     812:	0e 94 83 02 	call	0x506	; 0x506 <ampliferOn>
     816:	16 c0       	rjmp	.+44     	; 0x844 <irDecode+0x62>
//		_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 1)	// IR POWER -> OFF
     818:	91 30       	cpi	r25, 0x01	; 1
     81a:	29 f4       	brne	.+10     	; 0x826 <irDecode+0x44>
     81c:	80 91 ac 06 	lds	r24, 0x06AC
     820:	85 31       	cpi	r24, 0x15	; 21
     822:	81 f4       	brne	.+32     	; 0x844 <irDecode+0x62>
     824:	06 c0       	rjmp	.+12     	; 0x832 <irDecode+0x50>
     826:	94 30       	cpi	r25, 0x04	; 4
     828:	69 f4       	brne	.+26     	; 0x844 <irDecode+0x62>
     82a:	80 91 ac 06 	lds	r24, 0x06AC
     82e:	8d 30       	cpi	r24, 0x0D	; 13
     830:	49 f4       	brne	.+18     	; 0x844 <irDecode+0x62>
     832:	e0 91 ad 06 	lds	r30, 0x06AD
     836:	f0 91 ae 06 	lds	r31, 0x06AE
     83a:	80 81       	ld	r24, Z
     83c:	80 ff       	sbrs	r24, 0
     83e:	02 c0       	rjmp	.+4      	; 0x844 <irDecode+0x62>
	{
		ampliferOff();
     840:	0e 94 49 02 	call	0x492	; 0x492 <ampliferOff>
     844:	80 ed       	ldi	r24, 0xD0	; 208
     846:	97 e0       	ldi	r25, 0x07	; 7
     848:	20 e9       	ldi	r18, 0x90	; 144
     84a:	31 e0       	ldi	r19, 0x01	; 1
     84c:	f9 01       	movw	r30, r18
     84e:	31 97       	sbiw	r30, 0x01	; 1
     850:	f1 f7       	brne	.-4      	; 0x84e <irDecode+0x6c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     852:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     854:	d9 f7       	brne	.-10     	; 0x84c <irDecode+0x6a>
*/	else
	{
		// DO NOTING
	}
	_delay_ms(200);
}
     856:	08 95       	ret

00000858 <__vector_1>:

/*****************************************
**** EXTERNAL INTERRUPT 0 VECTOR 01 ******
*****************************************/
ISR(INT0_vect)
{
     858:	1f 92       	push	r1
     85a:	0f 92       	push	r0
     85c:	0f b6       	in	r0, 0x3f	; 63
     85e:	0f 92       	push	r0
     860:	11 24       	eor	r1, r1
     862:	2f 93       	push	r18
     864:	3f 93       	push	r19
     866:	4f 93       	push	r20
     868:	5f 93       	push	r21
     86a:	6f 93       	push	r22
     86c:	7f 93       	push	r23
     86e:	8f 93       	push	r24
     870:	9f 93       	push	r25
     872:	af 93       	push	r26
     874:	bf 93       	push	r27
     876:	ef 93       	push	r30
     878:	ff 93       	push	r31
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     87a:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     87c:	80 e4       	ldi	r24, 0x40	; 64
     87e:	8a bf       	out	0x3a, r24	; 58
	ext0_intrpt_off();	// DISABLE new IR DETECTION

// LOGIC CHECK BEGIN
// VERIFY PRESSED IR BUTTON and switch to low line of IR pin PD2
	unsigned char low_level = 0;
    if(irPin == 0)
     880:	82 99       	sbic	0x10, 2	; 16
     882:	0b c0       	rjmp	.+22     	; 0x89a <__stack+0x3b>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     884:	8a e0       	ldi	r24, 0x0A	; 10
     886:	98 2f       	mov	r25, r24
     888:	9a 95       	dec	r25
     88a:	f1 f7       	brne	.-4      	; 0x888 <__stack+0x29>
     88c:	98 2f       	mov	r25, r24
     88e:	9a 95       	dec	r25
     890:	f1 f7       	brne	.-4      	; 0x88e <__stack+0x2f>
     892:	8a 95       	dec	r24
     894:	f1 f7       	brne	.-4      	; 0x892 <__stack+0x33>
			_delay_us(2);	//2uS delay
		}

		if(low_level == 3)
		{
			irDecode();
     896:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <irDecode>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     89a:	80 e4       	ldi	r24, 0x40	; 64
     89c:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     89e:	8a bf       	out	0x3a, r24	; 58
		}
    }
// LOGIC CHECK END

	ext0_intrpt_on();	// ENABLE new IR DETECTION
}
     8a0:	ff 91       	pop	r31
     8a2:	ef 91       	pop	r30
     8a4:	bf 91       	pop	r27
     8a6:	af 91       	pop	r26
     8a8:	9f 91       	pop	r25
     8aa:	8f 91       	pop	r24
     8ac:	7f 91       	pop	r23
     8ae:	6f 91       	pop	r22
     8b0:	5f 91       	pop	r21
     8b2:	4f 91       	pop	r20
     8b4:	3f 91       	pop	r19
     8b6:	2f 91       	pop	r18
     8b8:	0f 90       	pop	r0
     8ba:	0f be       	out	0x3f, r0	; 63
     8bc:	0f 90       	pop	r0
     8be:	1f 90       	pop	r1
     8c0:	18 95       	reti

000008c2 <eeprom_24c64_read>:
	// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
	// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !
	
	byte eepromReceiveByte0, eepromReceiveByte1, eepromReceiveByte2, eepromReceiveByte3, eepromReceiveByte4, eepromReceiveByte5;
// EEPROM READ
	i2c_start();
     8c2:	0e 94 6f 05 	call	0xade	; 0xade <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);		// EEPROM 24C64 ADDRESS ACCESS WRITE
     8c6:	80 ea       	ldi	r24, 0xA0	; 160
     8c8:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     8cc:	80 e0       	ldi	r24, 0x00	; 0
     8ce:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     8d2:	80 e0       	ldi	r24, 0x00	; 0
     8d4:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>

	i2c_start();
     8d8:	0e 94 6f 05 	call	0xade	; 0xade <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_READ);		// EEPROM 24C64 ADDRESS ACCESS READ
     8dc:	81 ea       	ldi	r24, 0xA1	; 161
     8de:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
	eepromReceiveByte0	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     8e2:	80 e0       	ldi	r24, 0x00	; 0
     8e4:	0e 94 7f 05 	call	0xafe	; 0xafe <i2c_read>
	eepromReceiveByte1	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     8e8:	80 e0       	ldi	r24, 0x00	; 0
     8ea:	0e 94 7f 05 	call	0xafe	; 0xafe <i2c_read>
	eepromReceiveByte2	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     8ee:	80 e0       	ldi	r24, 0x00	; 0
     8f0:	0e 94 7f 05 	call	0xafe	; 0xafe <i2c_read>
	eepromReceiveByte3	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     8f4:	80 e0       	ldi	r24, 0x00	; 0
     8f6:	0e 94 7f 05 	call	0xafe	; 0xafe <i2c_read>
	eepromReceiveByte4	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     8fa:	80 e0       	ldi	r24, 0x00	; 0
     8fc:	0e 94 7f 05 	call	0xafe	; 0xafe <i2c_read>
	eepromReceiveByte5	= i2c_read(1);				// EEPROM DATA READ BYTE	// i2c_read(1) parametar razlichen ot 0 spira komunikaciqta NACK
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	0e 94 7f 05 	call	0xafe	; 0xafe <i2c_read>
	i2c_stop();
     906:	0e 94 75 05 	call	0xaea	; 0xaea <i2c_stop>
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte2);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte3);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte4);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte5);
*/
}
     90a:	08 95       	ret

0000090c <eeprom_24c64_write>:
// Za da se vijda tova koeto se e zapisalo v pametta, a ne ot tozi bibliotechen fail !!!!!!!!!
// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !

// EEPROM WRITE
	i2c_start();
     90c:	0e 94 6f 05 	call	0xade	; 0xade <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     910:	80 ea       	ldi	r24, 0xA0	; 160
     912:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     916:	80 e0       	ldi	r24, 0x00	; 0
     918:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     91c:	80 e0       	ldi	r24, 0x00	; 0
     91e:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
// Write data
	i2c_write(0x30);	// Data is stored: 0x30 - '0'
     922:	80 e3       	ldi	r24, 0x30	; 48
     924:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
	i2c_write(0x31);	// Data is stored: 0x31 - '1'
     928:	81 e3       	ldi	r24, 0x31	; 49
     92a:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
	i2c_write(0x32);	// Data is stored: 0x32 - '2'
     92e:	82 e3       	ldi	r24, 0x32	; 50
     930:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
	i2c_write(0x33);	// Data is stored: 0x33 - '3'
     934:	83 e3       	ldi	r24, 0x33	; 51
     936:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
	i2c_write(0x34);	// Data is stored: 0x34 - '4'
     93a:	84 e3       	ldi	r24, 0x34	; 52
     93c:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
	i2c_stop();
     940:	0e 94 75 05 	call	0xaea	; 0xaea <i2c_stop>
}
     944:	08 95       	ret

00000946 <eeprom_24c64_reset>:

/*************************************
** RESET AND ZERO FILL EEPROM 24C64 **
*************************************/
void eeprom_24c64_reset()
{
     946:	cf 93       	push	r28
     948:	df 93       	push	r29
	unsigned int i;	// 16 bits
// EEPROM WRITE
	i2c_start();
     94a:	0e 94 6f 05 	call	0xade	; 0xade <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     94e:	80 ea       	ldi	r24, 0xA0	; 160
     950:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     954:	80 e0       	ldi	r24, 0x00	; 0
     956:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     95a:	80 e0       	ldi	r24, 0x00	; 0
     95c:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
     960:	c0 e0       	ldi	r28, 0x00	; 0
     962:	d0 e0       	ldi	r29, 0x00	; 0
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
     964:	80 e0       	ldi	r24, 0x00	; 0
     966:	0e 94 78 05 	call	0xaf0	; 0xaf0 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
     96a:	21 96       	adiw	r28, 0x01	; 1
     96c:	8f e1       	ldi	r24, 0x1F	; 31
     96e:	cf 3f       	cpi	r28, 0xFF	; 255
     970:	d8 07       	cpc	r29, r24
     972:	c1 f7       	brne	.-16     	; 0x964 <eeprom_24c64_reset+0x1e>
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
	}
	i2c_stop();
     974:	0e 94 75 05 	call	0xaea	; 0xaea <i2c_stop>
}
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	08 95       	ret

0000097e <reset>:
}
*/

unsigned char reset(void)
{
    DDRx |= (1<<Px);            //Ausgang
     97e:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     980:	c0 98       	cbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     982:	80 e8       	ldi	r24, 0x80	; 128
     984:	97 e0       	ldi	r25, 0x07	; 7
     986:	01 97       	sbiw	r24, 0x01	; 1
     988:	f1 f7       	brne	.-4      	; 0x986 <reset+0x8>
    _delay_us(480);
	DDRx &= ~(1<<Px);
     98a:	b8 98       	cbi	0x17, 0	; 23
     98c:	80 e4       	ldi	r24, 0x40	; 64
     98e:	91 e0       	ldi	r25, 0x01	; 1
     990:	01 97       	sbiw	r24, 0x01	; 1
     992:	f1 f7       	brne	.-4      	; 0x990 <reset+0x12>
    _delay_us(80);
	if(!(PINx & (1<<Px)))     //Prüfe Slave-Antwort
     994:	b0 9b       	sbis	0x16, 0	; 22
     996:	02 c0       	rjmp	.+4      	; 0x99c <reset+0x1e>
     998:	80 e0       	ldi	r24, 0x00	; 0
     99a:	08 95       	ret
     99c:	88 e0       	ldi	r24, 0x08	; 8
     99e:	97 e0       	ldi	r25, 0x07	; 7
     9a0:	01 97       	sbiw	r24, 0x01	; 1
     9a2:	f1 f7       	brne	.-4      	; 0x9a0 <reset+0x22>
     9a4:	81 e0       	ldi	r24, 0x01	; 1
	}
    else
	{
        return 0;
	}
}
     9a6:	08 95       	ret

000009a8 <read_bit>:

unsigned char read_bit(void)
{
    DDRx |= (1<<Px);            //Ausgang
     9a8:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     9aa:	c0 98       	cbi	0x18, 0	; 24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     9ac:	85 e0       	ldi	r24, 0x05	; 5
     9ae:	8a 95       	dec	r24
     9b0:	f1 f7       	brne	.-4      	; 0x9ae <read_bit+0x6>
    _delay_us(1);
	DDRx &= ~(1<<Px);
     9b2:	b8 98       	cbi	0x17, 0	; 23
     9b4:	80 e4       	ldi	r24, 0x40	; 64
     9b6:	8a 95       	dec	r24
     9b8:	f1 f7       	brne	.-4      	; 0x9b6 <read_bit+0xe>
    _delay_us(12);
    if(!(PINx & (1<<Px)))       //Abtastung innerhalb von 15µs
     9ba:	86 b3       	in	r24, 0x16	; 22
	}
	else
    {
		return 1;
	}
}
     9bc:	81 70       	andi	r24, 0x01	; 1
     9be:	08 95       	ret

000009c0 <write_bit>:

void write_bit(unsigned char bitval)    //kann 0 oder 1 sein
{
    DDRx |= (1<<Px);            //Ausgang
     9c0:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     9c2:	c0 98       	cbi	0x18, 0	; 24
    if(bitval)
     9c4:	81 11       	cpse	r24, r1
	{
        PORTx |= (1<<Px);      //H-Pegel
     9c6:	c0 9a       	sbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     9c8:	88 eb       	ldi	r24, 0xB8	; 184
     9ca:	91 e0       	ldi	r25, 0x01	; 1
     9cc:	01 97       	sbiw	r24, 0x01	; 1
     9ce:	f1 f7       	brne	.-4      	; 0x9cc <write_bit+0xc>
    }
	_delay_us(110);        
    DDRx &= ~(1<<Px);
     9d0:	b8 98       	cbi	0x17, 0	; 23
    PORTx &= ~(1<<Px);
     9d2:	c0 98       	cbi	0x18, 0	; 24
}
     9d4:	08 95       	ret

000009d6 <read_byte>:

unsigned char read_byte(void)
{
     9d6:	cf 92       	push	r12
     9d8:	df 92       	push	r13
     9da:	ef 92       	push	r14
     9dc:	ff 92       	push	r15
     9de:	1f 93       	push	r17
     9e0:	cf 93       	push	r28
     9e2:	df 93       	push	r29
     9e4:	10 e0       	ldi	r17, 0x00	; 0
     9e6:	c0 e0       	ldi	r28, 0x00	; 0
     9e8:	d0 e0       	ldi	r29, 0x00	; 0
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
		{
            byte |= (1<<i);
     9ea:	91 e0       	ldi	r25, 0x01	; 1
     9ec:	c9 2e       	mov	r12, r25
     9ee:	d1 2c       	mov	r13, r1
     9f0:	80 ee       	ldi	r24, 0xE0	; 224
     9f2:	e8 2e       	mov	r14, r24
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	f8 2e       	mov	r15, r24
unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
     9f8:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <read_bit>
     9fc:	88 23       	and	r24, r24
     9fe:	41 f0       	breq	.+16     	; 0xa10 <read_byte+0x3a>
		{
            byte |= (1<<i);
     a00:	c6 01       	movw	r24, r12
     a02:	0c 2e       	mov	r0, r28
     a04:	02 c0       	rjmp	.+4      	; 0xa0a <read_byte+0x34>
     a06:	88 0f       	add	r24, r24
     a08:	99 1f       	adc	r25, r25
     a0a:	0a 94       	dec	r0
     a0c:	e2 f7       	brpl	.-8      	; 0xa06 <read_byte+0x30>
     a0e:	18 2b       	or	r17, r24
     a10:	c7 01       	movw	r24, r14
     a12:	01 97       	sbiw	r24, 0x01	; 1
     a14:	f1 f7       	brne	.-4      	; 0xa12 <read_byte+0x3c>
     a16:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
     a18:	c8 30       	cpi	r28, 0x08	; 8
     a1a:	d1 05       	cpc	r29, r1
     a1c:	69 f7       	brne	.-38     	; 0x9f8 <read_byte+0x22>
            byte |= (1<<i);
		}
        _delay_us(120);
    }
    return byte;
}
     a1e:	81 2f       	mov	r24, r17
     a20:	df 91       	pop	r29
     a22:	cf 91       	pop	r28
     a24:	1f 91       	pop	r17
     a26:	ff 90       	pop	r15
     a28:	ef 90       	pop	r14
     a2a:	df 90       	pop	r13
     a2c:	cf 90       	pop	r12
     a2e:	08 95       	ret

00000a30 <write_byte>:

void write_byte(unsigned char byte)
{
     a30:	0f 93       	push	r16
     a32:	1f 93       	push	r17
     a34:	cf 93       	push	r28
     a36:	df 93       	push	r29
     a38:	c0 e0       	ldi	r28, 0x00	; 0
     a3a:	d0 e0       	ldi	r29, 0x00	; 0
    for(unsigned char i=0; i<8; i++)
	{
        if(byte & (1<<i))
     a3c:	08 2f       	mov	r16, r24
     a3e:	10 e0       	ldi	r17, 0x00	; 0
     a40:	c8 01       	movw	r24, r16
     a42:	0c 2e       	mov	r0, r28
     a44:	02 c0       	rjmp	.+4      	; 0xa4a <write_byte+0x1a>
     a46:	95 95       	asr	r25
     a48:	87 95       	ror	r24
     a4a:	0a 94       	dec	r0
     a4c:	e2 f7       	brpl	.-8      	; 0xa46 <write_byte+0x16>
     a4e:	80 ff       	sbrs	r24, 0
     a50:	02 c0       	rjmp	.+4      	; 0xa56 <write_byte+0x26>
		{
			write_bit(1);
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	01 c0       	rjmp	.+2      	; 0xa58 <write_byte+0x28>
		}
        else
		{
            write_bit(0);
     a56:	80 e0       	ldi	r24, 0x00	; 0
     a58:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <write_bit>
     a5c:	21 96       	adiw	r28, 0x01	; 1
    return byte;
}

void write_byte(unsigned char byte)
{
    for(unsigned char i=0; i<8; i++)
     a5e:	c8 30       	cpi	r28, 0x08	; 8
     a60:	d1 05       	cpc	r29, r1
     a62:	71 f7       	brne	.-36     	; 0xa40 <write_byte+0x10>
     a64:	80 ee       	ldi	r24, 0xE0	; 224
     a66:	91 e0       	ldi	r25, 0x01	; 1
     a68:	01 97       	sbiw	r24, 0x01	; 1
     a6a:	f1 f7       	brne	.-4      	; 0xa68 <write_byte+0x38>
		{
            write_bit(0);
		}
	}
    _delay_us(120);
}  
     a6c:	df 91       	pop	r29
     a6e:	cf 91       	pop	r28
     a70:	1f 91       	pop	r17
     a72:	0f 91       	pop	r16
     a74:	08 95       	ret

00000a76 <wait_ready>:
	return 0;
}

void wait_ready(void)
{
	while(!(read_bit()));
     a76:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <read_bit>
     a7a:	88 23       	and	r24, r24
     a7c:	e1 f3       	breq	.-8      	; 0xa76 <wait_ready>
}
     a7e:	08 95       	ret

00000a80 <read_scratchpad>:
	}
    _delay_us(120);
}  

unsigned char read_scratchpad(void)
{
     a80:	cf 93       	push	r28
     a82:	df 93       	push	r29

	if(reset())
     a84:	0e 94 bf 04 	call	0x97e	; 0x97e <reset>
     a88:	88 23       	and	r24, r24
     a8a:	e9 f0       	breq	.+58     	; 0xac6 <read_scratchpad+0x46>
	{
		write_byte(0xCC);
     a8c:	8c ec       	ldi	r24, 0xCC	; 204
     a8e:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		write_byte(0x44);
     a92:	84 e4       	ldi	r24, 0x44	; 68
     a94:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
		wait_ready();
     a98:	0e 94 3b 05 	call	0xa76	; 0xa76 <wait_ready>
		if(reset())
     a9c:	0e 94 bf 04 	call	0x97e	; 0x97e <reset>
     aa0:	88 23       	and	r24, r24
     aa2:	89 f0       	breq	.+34     	; 0xac6 <read_scratchpad+0x46>
		{
			write_byte(0xCC);
     aa4:	8c ec       	ldi	r24, 0xCC	; 204
     aa6:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
			write_byte(0xBE);
     aaa:	8e eb       	ldi	r24, 0xBE	; 190
     aac:	0e 94 18 05 	call	0xa30	; 0xa30 <write_byte>
     ab0:	cd e9       	ldi	r28, 0x9D	; 157
     ab2:	d6 e0       	ldi	r29, 0x06	; 6
			for(unsigned char i=0; i<9; i++)
			{
				scratchpad [i] = read_byte();
     ab4:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <read_byte>
     ab8:	89 93       	st	Y+, r24
		wait_ready();
		if(reset())
		{
			write_byte(0xCC);
			write_byte(0xBE);
			for(unsigned char i=0; i<9; i++)
     aba:	86 e0       	ldi	r24, 0x06	; 6
     abc:	c6 3a       	cpi	r28, 0xA6	; 166
     abe:	d8 07       	cpc	r29, r24
     ac0:	c9 f7       	brne	.-14     	; 0xab4 <read_scratchpad+0x34>
     ac2:	81 e0       	ldi	r24, 0x01	; 1
     ac4:	01 c0       	rjmp	.+2      	; 0xac8 <read_scratchpad+0x48>
     ac6:	80 e0       	ldi	r24, 0x00	; 0
			}
			return 1;
		}
	}
	return 0;
}
     ac8:	df 91       	pop	r29
     aca:	cf 91       	pop	r28
     acc:	08 95       	ret

00000ace <i2c_init>:
|== TWPS = 1 => (4^TWPS)= 4  // TWSR = (0<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx01 => TWSR = 1 (DEC) => 4^1 =  4 =|
|== TWPS = 2 => (4^TWPS)=16  // TWSR = (1<<TWPS1)|(0<<TWPS0) => TWSR = 0bxxxxxx10 => TWSR = 2 (DEC) => 4^2 = 16 =|
|== TWPS = 3 => (4^TWPS)=64  // TWSR = (1<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx11 => TWSR = 3 (DEC) => 4^3 = 64 =|
|===============================================================================================================*/

	TWBR = 0b00010010;	// HEX=0x12	or DEC=18	// FCPU = 16 000 000 |-> SCL = 16000000 / (16+(2*TWBR*(4^TWPS)) = 16000000 / (16+(2*18*(4))) = 16000000 / 160 = 100 000 Hz = 100 kHz
     ace:	82 e1       	ldi	r24, 0x12	; 18
     ad0:	80 b9       	out	0x00, r24	; 0
	TWSR = (0<<TWPS1)|(1<<TWPS0);	// SCL = 16 000 000 / 64  = 250 000 = 250kHz
     ad2:	81 e0       	ldi	r24, 0x01	; 1
     ad4:	81 b9       	out	0x01, r24	; 1
	TWCR = (1<<TWEN);	//	TWCR = 0x04; // TWCR = (x<<TWINT)|(x<<TWEA)|(x<<TWSTA)|(x<<TWSTO)|(x<<TWEN)|(x<<TWIE);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz
     ad6:	84 e0       	ldi	r24, 0x04	; 4
     ad8:	86 bf       	out	0x36, r24	; 54
	TWDR = 0b00000000;
     ada:	13 b8       	out	0x03, r1	; 3
}
     adc:	08 95       	ret

00000ade <i2c_start>:
/*****************************************
** START CONDITION OF I2C COMMUNICATION **
*****************************************/
void i2c_start(void)
{
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     ade:	84 ea       	ldi	r24, 0xA4	; 164
     ae0:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     ae2:	06 b6       	in	r0, 0x36	; 54
     ae4:	07 fe       	sbrs	r0, 7
     ae6:	fd cf       	rjmp	.-6      	; 0xae2 <i2c_start+0x4>
	{
	}
}
     ae8:	08 95       	ret

00000aea <i2c_stop>:
/****************************************
** STOP CONDITION OF I2C COMMUNICATION **
****************************************/
void i2c_stop()
{
	TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     aea:	84 e9       	ldi	r24, 0x94	; 148
     aec:	86 bf       	out	0x36, r24	; 54
}
     aee:	08 95       	ret

00000af0 <i2c_write>:
/*******************************************
** WRITE/SEND 1 BYTE OF I2C COMMUNICATION **
*******************************************/
void i2c_write(unsigned char data)
{
	TWDR = data;
     af0:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT)|(1<<TWEN);
     af2:	84 e8       	ldi	r24, 0x84	; 132
     af4:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     af6:	06 b6       	in	r0, 0x36	; 54
     af8:	07 fe       	sbrs	r0, 7
     afa:	fd cf       	rjmp	.-6      	; 0xaf6 <i2c_write+0x6>
	{
	}
}
     afc:	08 95       	ret

00000afe <i2c_read>:
/**********************************************
** READ/RECEIVE BYTE(S) OF I2C COMMUNICATION **
**********************************************/
unsigned char i2c_read(unsigned char isLast)
{
	if(isLast == 0 )
     afe:	88 23       	and	r24, r24
     b00:	11 f4       	brne	.+4      	; 0xb06 <i2c_read+0x8>
	{
		TWCR = (1<<TWINT)|(1<<TWEA)|(1<<TWEN);	// to next receive byte
     b02:	84 ec       	ldi	r24, 0xC4	; 196
     b04:	01 c0       	rjmp	.+2      	; 0xb08 <i2c_read+0xa>
	}
	else
	{
		TWCR = (1<<TWINT)|(1<<TWEN);			// to end of communication
     b06:	84 e8       	ldi	r24, 0x84	; 132
     b08:	86 bf       	out	0x36, r24	; 54
	}
	
	while((TWCR & (1<<TWINT)) == 0)
     b0a:	06 b6       	in	r0, 0x36	; 54
     b0c:	07 fe       	sbrs	r0, 7
     b0e:	fd cf       	rjmp	.-6      	; 0xb0a <i2c_read+0xc>
	{
	}
	return TWDR;
     b10:	83 b1       	in	r24, 0x03	; 3
}
     b12:	08 95       	ret

00000b14 <LCD_EXECUTE_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_EXECUTE_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     b14:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     b16:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     b18:	87 ff       	sbrs	r24, 7
     b1a:	02 c0       	rjmp	.+4      	; 0xb20 <LCD_EXECUTE_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     b1c:	d8 9a       	sbi	0x1b, 0	; 27
     b1e:	01 c0       	rjmp	.+2      	; 0xb22 <LCD_EXECUTE_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     b20:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     b22:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     b24:	9f 5f       	subi	r25, 0xFF	; 255
     b26:	98 30       	cpi	r25, 0x08	; 8
     b28:	11 f0       	breq	.+4      	; 0xb2e <LCD_EXECUTE_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     b2a:	88 0f       	add	r24, r24
     b2c:	f4 cf       	rjmp	.-24     	; 0xb16 <LCD_EXECUTE_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     b2e:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     b30:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     b32:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     b34:	da 98       	cbi	0x1b, 2	; 27
     b36:	88 ea       	ldi	r24, 0xA8	; 168
     b38:	92 e0       	ldi	r25, 0x02	; 2
     b3a:	fc 01       	movw	r30, r24
     b3c:	31 97       	sbiw	r30, 0x01	; 1
     b3e:	f1 f7       	brne	.-4      	; 0xb3c <LCD_EXECUTE_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     b40:	da 9a       	sbi	0x1b, 2	; 27
     b42:	01 97       	sbiw	r24, 0x01	; 1
     b44:	f1 f7       	brne	.-4      	; 0xb42 <LCD_EXECUTE_COMMAND+0x2e>
	LCD_REGSELECT_low();	// RS = 0
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);			//rcall 180 us
*/
	LCD_ENABLE_low();		// EN = 0
     b46:	db 98       	cbi	0x1b, 3	; 27
     b48:	80 e9       	ldi	r24, 0x90	; 144
     b4a:	91 e0       	ldi	r25, 0x01	; 1
     b4c:	01 97       	sbiw	r24, 0x01	; 1
     b4e:	f1 f7       	brne	.-4      	; 0xb4c <LCD_EXECUTE_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us

}
     b50:	08 95       	ret

00000b52 <LCD_EXECUTE_DATA>:

/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	40 e0       	ldi	r20, 0x00	; 0
     b58:	50 e0       	ldi	r21, 0x00	; 0
     b5a:	a8 ea       	ldi	r26, 0xA8	; 168
     b5c:	b2 e0       	ldi	r27, 0x02	; 2
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];
     b5e:	c0 e9       	ldi	r28, 0x90	; 144
     b60:	d1 e0       	ldi	r29, 0x01	; 1
     b62:	22 c0       	rjmp	.+68     	; 0xba8 <LCD_EXECUTE_DATA+0x56>
     b64:	fc 01       	movw	r30, r24
     b66:	e4 0f       	add	r30, r20
     b68:	f5 1f       	adc	r31, r21
     b6a:	e0 81       	ld	r30, Z
     b6c:	20 e0       	ldi	r18, 0x00	; 0

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     b6e:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     b70:	e7 ff       	sbrs	r30, 7
     b72:	02 c0       	rjmp	.+4      	; 0xb78 <LCD_EXECUTE_DATA+0x26>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     b74:	d8 9a       	sbi	0x1b, 0	; 27
     b76:	01 c0       	rjmp	.+2      	; 0xb7a <LCD_EXECUTE_DATA+0x28>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     b78:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     b7a:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     b7c:	2f 5f       	subi	r18, 0xFF	; 255
     b7e:	28 30       	cpi	r18, 0x08	; 8
     b80:	11 f0       	breq	.+4      	; 0xb86 <LCD_EXECUTE_DATA+0x34>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     b82:	ee 0f       	add	r30, r30
     b84:	f4 cf       	rjmp	.-24     	; 0xb6e <LCD_EXECUTE_DATA+0x1c>
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     b86:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     b88:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     b8a:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     b8c:	da 98       	cbi	0x1b, 2	; 27
     b8e:	fd 01       	movw	r30, r26
     b90:	31 97       	sbiw	r30, 0x01	; 1
     b92:	f1 f7       	brne	.-4      	; 0xb90 <LCD_EXECUTE_DATA+0x3e>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     b94:	da 9a       	sbi	0x1b, 2	; 27
     b96:	fd 01       	movw	r30, r26
     b98:	31 97       	sbiw	r30, 0x01	; 1
     b9a:	f1 f7       	brne	.-4      	; 0xb98 <LCD_EXECUTE_DATA+0x46>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     b9c:	db 98       	cbi	0x1b, 3	; 27
     b9e:	fe 01       	movw	r30, r28
     ba0:	31 97       	sbiw	r30, 0x01	; 1
     ba2:	f1 f7       	brne	.-4      	; 0xba0 <LCD_EXECUTE_DATA+0x4e>
/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
     ba4:	4f 5f       	subi	r20, 0xFF	; 255
     ba6:	5f 4f       	sbci	r21, 0xFF	; 255
     ba8:	46 17       	cp	r20, r22
     baa:	57 07       	cpc	r21, r23
     bac:	dc f2       	brlt	.-74     	; 0xb64 <LCD_EXECUTE_DATA+0x12>
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}

//	LCD_EXECUTE_DATA_LAST();	// flush -> posleden simvol ili gore v cikala count_ns < numsymbols+1 ili count_ns <= numsymbols
}
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	08 95       	ret

00000bb4 <LCD_EXECUTE_DATA_ONE>:

/************************************************
** WRITE/TRANSMIT ONE DATA BYTE TO LCD DISPLAY **
************************************************/
void LCD_EXECUTE_DATA_ONE(unsigned char data)	// HELP: LCD_EXECUTE_DATA(unsigned char data_byte_symbols) // LCD shift left out, msb is first
{
     bb4:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     bb6:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     bb8:	87 ff       	sbrs	r24, 7
     bba:	02 c0       	rjmp	.+4      	; 0xbc0 <LCD_EXECUTE_DATA_ONE+0xc>
		{
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     bbc:	d8 9a       	sbi	0x1b, 0	; 27
     bbe:	01 c0       	rjmp	.+2      	; 0xbc2 <LCD_EXECUTE_DATA_ONE+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     bc0:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     bc2:	d9 9a       	sbi	0x1b, 1	; 27
{
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     bc4:	9f 5f       	subi	r25, 0xFF	; 255
     bc6:	98 30       	cpi	r25, 0x08	; 8
     bc8:	11 f0       	breq	.+4      	; 0xbce <LCD_EXECUTE_DATA_ONE+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     bca:	88 0f       	add	r24, r24
     bcc:	f4 cf       	rjmp	.-24     	; 0xbb6 <LCD_EXECUTE_DATA_ONE+0x2>
	}
//update from down comment
	LCD_REGSELECT_high();	// RS = 1
     bce:	dd 9a       	sbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     bd0:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     bd2:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment

	LCD_RCK_low();
     bd4:	da 98       	cbi	0x1b, 2	; 27
     bd6:	88 ea       	ldi	r24, 0xA8	; 168
     bd8:	92 e0       	ldi	r25, 0x02	; 2
     bda:	fc 01       	movw	r30, r24
     bdc:	31 97       	sbiw	r30, 0x01	; 1
     bde:	f1 f7       	brne	.-4      	; 0xbdc <LCD_EXECUTE_DATA_ONE+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     be0:	da 9a       	sbi	0x1b, 2	; 27
     be2:	01 97       	sbiw	r24, 0x01	; 1
     be4:	f1 f7       	brne	.-4      	; 0xbe2 <LCD_EXECUTE_DATA_ONE+0x2e>
	LCD_REGSELECT_high();	// RS = 1
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);
*/
	LCD_ENABLE_low();		// EN = 0
     be6:	db 98       	cbi	0x1b, 3	; 27
     be8:	80 e9       	ldi	r24, 0x90	; 144
     bea:	91 e0       	ldi	r25, 0x01	; 1
     bec:	01 97       	sbiw	r24, 0x01	; 1
     bee:	f1 f7       	brne	.-4      	; 0xbec <LCD_EXECUTE_DATA_ONE+0x38>
	_delay_us(100);
}
     bf0:	08 95       	ret

00000bf2 <LCD_EXECUTE_DATA_LAST>:
/*****************************************************************************
** WRITE/TRANSMIT LAST DATA BYTE TO LCD DISPLAY AND FLUSH SN74HC595 BUFFER  **
*****************************************************************************/
void LCD_EXECUTE_DATA_LAST()	// flush -> izchistvane na bufer - prinuditelno izpisvane na posleden simvol
{
	LCD_ENABLE_low();
     bf2:	db 98       	cbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     bf4:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     bf6:	dd 9a       	sbi	0x1b, 5	; 27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     bf8:	85 ed       	ldi	r24, 0xD5	; 213
     bfa:	98 2f       	mov	r25, r24
     bfc:	9a 95       	dec	r25
     bfe:	f1 f7       	brne	.-4      	; 0xbfc <LCD_EXECUTE_DATA_LAST+0xa>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
	LCD_ENABLE_high();
     c00:	db 9a       	sbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     c02:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     c04:	dd 9a       	sbi	0x1b, 5	; 27
     c06:	8a 95       	dec	r24
     c08:	f1 f7       	brne	.-4      	; 0xc06 <LCD_EXECUTE_DATA_LAST+0x14>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
}
     c0a:	08 95       	ret

00000c0c <LCD_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     c0c:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     c0e:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     c10:	87 ff       	sbrs	r24, 7
     c12:	02 c0       	rjmp	.+4      	; 0xc18 <LCD_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     c14:	d8 9a       	sbi	0x1b, 0	; 27
     c16:	01 c0       	rjmp	.+2      	; 0xc1a <LCD_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     c18:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     c1a:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     c1c:	9f 5f       	subi	r25, 0xFF	; 255
     c1e:	98 30       	cpi	r25, 0x08	; 8
     c20:	11 f0       	breq	.+4      	; 0xc26 <LCD_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     c22:	88 0f       	add	r24, r24
     c24:	f4 cf       	rjmp	.-24     	; 0xc0e <LCD_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     c26:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     c28:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     c2a:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     c2c:	da 98       	cbi	0x1b, 2	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c2e:	88 ea       	ldi	r24, 0xA8	; 168
     c30:	92 e0       	ldi	r25, 0x02	; 2
     c32:	fc 01       	movw	r30, r24
     c34:	31 97       	sbiw	r30, 0x01	; 1
     c36:	f1 f7       	brne	.-4      	; 0xc34 <LCD_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     c38:	da 9a       	sbi	0x1b, 2	; 27
     c3a:	01 97       	sbiw	r24, 0x01	; 1
     c3c:	f1 f7       	brne	.-4      	; 0xc3a <LCD_COMMAND+0x2e>
	_delay_us(170);			//rcall 180 us

	LCD_ENABLE_low();		// EN = 0
     c3e:	db 98       	cbi	0x1b, 3	; 27
     c40:	80 e9       	ldi	r24, 0x90	; 144
     c42:	91 e0       	ldi	r25, 0x01	; 1
     c44:	01 97       	sbiw	r24, 0x01	; 1
     c46:	f1 f7       	brne	.-4      	; 0xc44 <LCD_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us
}
     c48:	08 95       	ret

00000c4a <LCD_CLEAR_CONTAIN>:
/**************************************
** CLEAR ALL CONTAINS ON LCD DISPLAY **
**************************************/
void LCD_CLEAR_CONTAIN()
{
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 1. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     c4a:	81 e0       	ldi	r24, 0x01	; 1
     c4c:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
     c50:	80 ec       	ldi	r24, 0xC0	; 192
     c52:	92 e1       	ldi	r25, 0x12	; 18
     c54:	01 97       	sbiw	r24, 0x01	; 1
     c56:	f1 f7       	brne	.-4      	; 0xc54 <LCD_CLEAR_CONTAIN+0xa>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
}
     c58:	08 95       	ret

00000c5a <LCD_INIT>:
/**********************************
** INITIZLIZATION OF LCD DISPLAY **
**********************************/
void LCD_INIT()
{
	LCD_COMMAND(LCD_8BIT_2ROWS_FONT5X7);		// 0b00111000	// 1. Function set: 8-bit interface data (DL = 1), 2-line display (N = 1), 5 x 7 dot character font (F = 0)
     c5a:	88 e3       	ldi	r24, 0x38	; 56
     c5c:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_ENTRY_MODE_INC_NOSHIFT);	// 0b00000110	// 2. Entry mode set: Increment by 1 (I/D = 1), No shift (S = 0)
     c60:	86 e0       	ldi	r24, 0x06	; 6
     c62:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_MOVE_FIRST);								// 3.
     c66:	82 e0       	ldi	r24, 0x02	; 2
     c68:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 4. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     c6c:	81 e0       	ldi	r24, 0x01	; 1
     c6e:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
     c72:	80 ec       	ldi	r24, 0xC0	; 192
     c74:	92 e1       	ldi	r25, 0x12	; 18
     c76:	01 97       	sbiw	r24, 0x01	; 1
     c78:	f1 f7       	brne	.-4      	; 0xc76 <LCD_INIT+0x1c>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
//	LCD_COMMAND(LCD_ON_BLINK_CURSOR);			// 0b00001111	// 5. Display on/off control: Display on (D = 1), Cursor on (C = 1), Blinking on (B = 1)
//	_delay_us(40);	// 37 uS	// comment for simulation
//	LCD_COMMAND(LCD_OFF);										// 5. Display off
}
     c7a:	08 95       	ret

00000c7c <LCD_DATA_STRING>:

/*********************************************************
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
     c7c:	fc 01       	movw	r30, r24
     c7e:	28 ea       	ldi	r18, 0xA8	; 168
     c80:	32 e0       	ldi	r19, 0x02	; 2
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     c82:	40 e9       	ldi	r20, 0x90	; 144
     c84:	51 e0       	ldi	r21, 0x01	; 1
     c86:	1d c0       	rjmp	.+58     	; 0xcc2 <LCD_DATA_STRING+0x46>
     c88:	90 e0       	ldi	r25, 0x00	; 0
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     c8a:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     c8c:	87 ff       	sbrs	r24, 7
     c8e:	02 c0       	rjmp	.+4      	; 0xc94 <LCD_DATA_STRING+0x18>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     c90:	d8 9a       	sbi	0x1b, 0	; 27
     c92:	01 c0       	rjmp	.+2      	; 0xc96 <LCD_DATA_STRING+0x1a>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     c94:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     c96:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     c98:	9f 5f       	subi	r25, 0xFF	; 255
     c9a:	98 30       	cpi	r25, 0x08	; 8
     c9c:	11 f0       	breq	.+4      	; 0xca2 <LCD_DATA_STRING+0x26>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     c9e:	88 0f       	add	r24, r24
     ca0:	f4 cf       	rjmp	.-24     	; 0xc8a <LCD_DATA_STRING+0xe>
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;
     ca2:	31 96       	adiw	r30, 0x01	; 1
			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     ca4:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     ca6:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     ca8:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     caa:	da 98       	cbi	0x1b, 2	; 27
     cac:	c9 01       	movw	r24, r18
     cae:	01 97       	sbiw	r24, 0x01	; 1
     cb0:	f1 f7       	brne	.-4      	; 0xcae <LCD_DATA_STRING+0x32>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     cb2:	da 9a       	sbi	0x1b, 2	; 27
     cb4:	c9 01       	movw	r24, r18
     cb6:	01 97       	sbiw	r24, 0x01	; 1
     cb8:	f1 f7       	brne	.-4      	; 0xcb6 <LCD_DATA_STRING+0x3a>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     cba:	db 98       	cbi	0x1b, 3	; 27
     cbc:	ca 01       	movw	r24, r20
     cbe:	01 97       	sbiw	r24, 0x01	; 1
     cc0:	f1 f7       	brne	.-4      	; 0xcbe <LCD_DATA_STRING+0x42>
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     cc2:	80 81       	ld	r24, Z
     cc4:	88 23       	and	r24, r24
     cc6:	01 f7       	brne	.-64     	; 0xc88 <LCD_DATA_STRING+0xc>
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}
}
     cc8:	08 95       	ret

00000cca <LCD_CGRAM_CUSTOM_SYMBOLS>:
	 { 0x0E, 0x1B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F },	// Battery Charging  80%	// addr40-47
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
     cca:	cf 93       	push	r28
     ccc:	df 93       	push	r29
	for(rows=0; rows<7; rows++)
     cce:	10 92 b8 06 	sts	0x06B8, r1
     cd2:	10 92 b7 06 	sts	0x06B7, r1
     cd6:	25 c0       	rjmp	.+74     	; 0xd22 <LCD_CGRAM_CUSTOM_SYMBOLS+0x58>
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
     cd8:	08 96       	adiw	r24, 0x08	; 8
     cda:	88 0f       	add	r24, r24
     cdc:	88 0f       	add	r24, r24
     cde:	88 0f       	add	r24, r24
     ce0:	0e 94 8a 05 	call	0xb14	; 0xb14 <LCD_EXECUTE_COMMAND>
     ce4:	c0 e0       	ldi	r28, 0x00	; 0
     ce6:	d0 e0       	ldi	r29, 0x00	; 0
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
     ce8:	e0 91 b7 06 	lds	r30, 0x06B7
     cec:	f0 91 b8 06 	lds	r31, 0x06B8
     cf0:	83 e0       	ldi	r24, 0x03	; 3
     cf2:	ee 0f       	add	r30, r30
     cf4:	ff 1f       	adc	r31, r31
     cf6:	8a 95       	dec	r24
     cf8:	e1 f7       	brne	.-8      	; 0xcf2 <LCD_CGRAM_CUSTOM_SYMBOLS+0x28>
     cfa:	ec 0f       	add	r30, r28
     cfc:	fd 1f       	adc	r31, r29
     cfe:	ec 56       	subi	r30, 0x6C	; 108
     d00:	fb 4f       	sbci	r31, 0xFB	; 251
     d02:	80 81       	ld	r24, Z
     d04:	0e 94 da 05 	call	0xbb4	; 0xbb4 <LCD_EXECUTE_DATA_ONE>
void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
     d08:	21 96       	adiw	r28, 0x01	; 1
     d0a:	c8 30       	cpi	r28, 0x08	; 8
     d0c:	d1 05       	cpc	r29, r1
     d0e:	61 f7       	brne	.-40     	; 0xce8 <LCD_CGRAM_CUSTOM_SYMBOLS+0x1e>
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
     d10:	80 91 b7 06 	lds	r24, 0x06B7
     d14:	90 91 b8 06 	lds	r25, 0x06B8
     d18:	01 96       	adiw	r24, 0x01	; 1
     d1a:	90 93 b8 06 	sts	0x06B8, r25
     d1e:	80 93 b7 06 	sts	0x06B7, r24
     d22:	80 91 b7 06 	lds	r24, 0x06B7
     d26:	90 91 b8 06 	lds	r25, 0x06B8
     d2a:	87 30       	cpi	r24, 0x07	; 7
     d2c:	91 05       	cpc	r25, r1
     d2e:	a4 f2       	brlt	.-88     	; 0xcd8 <LCD_CGRAM_CUSTOM_SYMBOLS+0xe>
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
		}
	}
}
     d30:	df 91       	pop	r29
     d32:	cf 91       	pop	r28
     d34:	08 95       	ret

00000d36 <LCD_DATA_ULONG>:
/****************************************************************
** WRITE/TRANSMIT MORE DATA UNSIGNED LONG BYTES TO LCD DISPLAY **
****************************************************************/
// USE THIS: lcdDataULong( (unsigned long)k + 1 );
void LCD_DATA_ULONG(unsigned long data)		// void lcdDataULong(const unsigned long data)
{
     d36:	df 93       	push	r29
     d38:	cf 93       	push	r28
     d3a:	cd b7       	in	r28, 0x3d	; 61
     d3c:	de b7       	in	r29, 0x3e	; 62
     d3e:	2a 97       	sbiw	r28, 0x0a	; 10
     d40:	0f b6       	in	r0, 0x3f	; 63
     d42:	f8 94       	cli
     d44:	de bf       	out	0x3e, r29	; 62
     d46:	0f be       	out	0x3f, r0	; 63
     d48:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ultoa(data, buffer, 10));	// 10 -> DECIMAL
     d4a:	ae 01       	movw	r20, r28
     d4c:	4f 5f       	subi	r20, 0xFF	; 255
     d4e:	5f 4f       	sbci	r21, 0xFF	; 255
     d50:	2a e0       	ldi	r18, 0x0A	; 10
     d52:	30 e0       	ldi	r19, 0x00	; 0
     d54:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <ultoa>
     d58:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
}
     d5c:	2a 96       	adiw	r28, 0x0a	; 10
     d5e:	0f b6       	in	r0, 0x3f	; 63
     d60:	f8 94       	cli
     d62:	de bf       	out	0x3e, r29	; 62
     d64:	0f be       	out	0x3f, r0	; 63
     d66:	cd bf       	out	0x3d, r28	; 61
     d68:	cf 91       	pop	r28
     d6a:	df 91       	pop	r29
     d6c:	08 95       	ret

00000d6e <LCD_DATA_LONG>:
/*******************************************************
** WRITE/TRANSMIT MORE DATA LONG BYTES TO LCD DISPLAY **
*******************************************************/
// USE THIS: lcdDataLong( (long)k + 1 );
void LCD_DATA_LONG(long data)		// void lcdDataLong(const long data)
{
     d6e:	df 93       	push	r29
     d70:	cf 93       	push	r28
     d72:	cd b7       	in	r28, 0x3d	; 61
     d74:	de b7       	in	r29, 0x3e	; 62
     d76:	2a 97       	sbiw	r28, 0x0a	; 10
     d78:	0f b6       	in	r0, 0x3f	; 63
     d7a:	f8 94       	cli
     d7c:	de bf       	out	0x3e, r29	; 62
     d7e:	0f be       	out	0x3f, r0	; 63
     d80:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ltoa(data, buffer, 10));	// 10 -> DECIMAL
     d82:	ae 01       	movw	r20, r28
     d84:	4f 5f       	subi	r20, 0xFF	; 255
     d86:	5f 4f       	sbci	r21, 0xFF	; 255
     d88:	2a e0       	ldi	r18, 0x0A	; 10
     d8a:	30 e0       	ldi	r19, 0x00	; 0
     d8c:	0e 94 a5 0a 	call	0x154a	; 0x154a <ltoa>
     d90:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
}
     d94:	2a 96       	adiw	r28, 0x0a	; 10
     d96:	0f b6       	in	r0, 0x3f	; 63
     d98:	f8 94       	cli
     d9a:	de bf       	out	0x3e, r29	; 62
     d9c:	0f be       	out	0x3f, r0	; 63
     d9e:	cd bf       	out	0x3d, r28	; 61
     da0:	cf 91       	pop	r28
     da2:	df 91       	pop	r29
     da4:	08 95       	ret

00000da6 <LCD_DATA_INT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataInt( (int)k + 1 );
void LCD_DATA_INT(int data)		// void lcdDataInt(const int data)
{
     da6:	df 93       	push	r29
     da8:	cf 93       	push	r28
     daa:	cd b7       	in	r28, 0x3d	; 61
     dac:	de b7       	in	r29, 0x3e	; 62
     dae:	2a 97       	sbiw	r28, 0x0a	; 10
     db0:	0f b6       	in	r0, 0x3f	; 63
     db2:	f8 94       	cli
     db4:	de bf       	out	0x3e, r29	; 62
     db6:	0f be       	out	0x3f, r0	; 63
     db8:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(itoa(data, buffer, 10));	// 10 -> DECIMAL
     dba:	be 01       	movw	r22, r28
     dbc:	6f 5f       	subi	r22, 0xFF	; 255
     dbe:	7f 4f       	sbci	r23, 0xFF	; 255
     dc0:	4a e0       	ldi	r20, 0x0A	; 10
     dc2:	50 e0       	ldi	r21, 0x00	; 0
     dc4:	0e 94 84 0a 	call	0x1508	; 0x1508 <itoa>
     dc8:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
}
     dcc:	2a 96       	adiw	r28, 0x0a	; 10
     dce:	0f b6       	in	r0, 0x3f	; 63
     dd0:	f8 94       	cli
     dd2:	de bf       	out	0x3e, r29	; 62
     dd4:	0f be       	out	0x3f, r0	; 63
     dd6:	cd bf       	out	0x3d, r28	; 61
     dd8:	cf 91       	pop	r28
     dda:	df 91       	pop	r29
     ddc:	08 95       	ret

00000dde <LCD_DATA_UINT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataUInt( (unsigned int)k + 1 );
void LCD_DATA_UINT(unsigned int data)		// void lcdDataUInt(const unsigned int data)
{
     dde:	df 93       	push	r29
     de0:	cf 93       	push	r28
     de2:	cd b7       	in	r28, 0x3d	; 61
     de4:	de b7       	in	r29, 0x3e	; 62
     de6:	2a 97       	sbiw	r28, 0x0a	; 10
     de8:	0f b6       	in	r0, 0x3f	; 63
     dea:	f8 94       	cli
     dec:	de bf       	out	0x3e, r29	; 62
     dee:	0f be       	out	0x3f, r0	; 63
     df0:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(utoa(data, buffer, 10));	// 10 -> DECIMAL
     df2:	be 01       	movw	r22, r28
     df4:	6f 5f       	subi	r22, 0xFF	; 255
     df6:	7f 4f       	sbci	r23, 0xFF	; 255
     df8:	4a e0       	ldi	r20, 0x0A	; 10
     dfa:	50 e0       	ldi	r21, 0x00	; 0
     dfc:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <utoa>
     e00:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
}
     e04:	2a 96       	adiw	r28, 0x0a	; 10
     e06:	0f b6       	in	r0, 0x3f	; 63
     e08:	f8 94       	cli
     e0a:	de bf       	out	0x3e, r29	; 62
     e0c:	0f be       	out	0x3f, r0	; 63
     e0e:	cd bf       	out	0x3d, r28	; 61
     e10:	cf 91       	pop	r28
     e12:	df 91       	pop	r29
     e14:	08 95       	ret

00000e16 <PGA2310_Volume_Update>:

/*************************************
** DEFINITION PGA2310 VOLUME UPDATE **
*************************************/
void PGA2310_Volume_Update(unsigned char pgaVolumeLeft, unsigned char pgaVolumeRight)
{
     e16:	0f 93       	push	r16
     e18:	1f 93       	push	r17
     e1a:	18 2f       	mov	r17, r24
     e1c:	06 2f       	mov	r16, r22
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
     e1e:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
     e20:	0e 94 2e 08 	call	0x105c	; 0x105c <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
     e24:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     e26:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
     e28:	81 2f       	mov	r24, r17
     e2a:	60 2f       	mov	r22, r16
     e2c:	0e 94 2e 08 	call	0x105c	; 0x105c <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
     e30:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA7 - /SS ENABLE
     e32:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
     e34:	81 2f       	mov	r24, r17
     e36:	60 2f       	mov	r22, r16
     e38:	0e 94 2e 08 	call	0x105c	; 0x105c <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
     e3c:	df 9a       	sbi	0x1b, 7	; 27

//	return SUCCESS;
}
     e3e:	1f 91       	pop	r17
     e40:	0f 91       	pop	r16
     e42:	08 95       	ret

00000e44 <pga2310_init>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_init()
{
	spi_init();
     e44:	0e 94 1d 08 	call	0x103a	; 0x103a <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
     e48:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     e4a:	80 e0       	ldi	r24, 0x00	; 0
     e4c:	60 e0       	ldi	r22, 0x00	; 0
     e4e:	0e 94 2e 08 	call	0x105c	; 0x105c <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
     e52:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     e54:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     e56:	80 e0       	ldi	r24, 0x00	; 0
     e58:	60 e0       	ldi	r22, 0x00	; 0
     e5a:	0e 94 2e 08 	call	0x105c	; 0x105c <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
     e5e:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     e60:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     e62:	80 e0       	ldi	r24, 0x00	; 0
     e64:	60 e0       	ldi	r22, 0x00	; 0
     e66:	0e 94 2e 08 	call	0x105c	; 0x105c <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
     e6a:	df 9a       	sbi	0x1b, 7	; 27
}
     e6c:	08 95       	ret

00000e6e <pga2310_reset>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_reset()
{
	spi_init();
     e6e:	0e 94 1d 08 	call	0x103a	; 0x103a <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
     e72:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     e74:	80 e0       	ldi	r24, 0x00	; 0
     e76:	60 e0       	ldi	r22, 0x00	; 0
     e78:	0e 94 2e 08 	call	0x105c	; 0x105c <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
     e7c:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     e7e:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     e80:	80 e0       	ldi	r24, 0x00	; 0
     e82:	60 e0       	ldi	r22, 0x00	; 0
     e84:	0e 94 2e 08 	call	0x105c	; 0x105c <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
     e88:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     e8a:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     e8c:	80 e0       	ldi	r24, 0x00	; 0
     e8e:	60 e0       	ldi	r22, 0x00	; 0
     e90:	0e 94 2e 08 	call	0x105c	; 0x105c <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
     e94:	df 9a       	sbi	0x1b, 7	; 27
}
     e96:	08 95       	ret

00000e98 <uart_setup>:
			
		}
	}

//	UBRRL = 103;			// Baudrate: 9600; Parity: 0; StopBits: 1 (Error = 0.2%; 16MHz)
	UBRRH = 0;
     e98:	10 bc       	out	0x20, r1	; 32

	UCSRC = 0b10000110;		// URSEL = 1 (Accessing to UBRRH or UCSRC, is read as zero when reading UBRRH. The URSEL must be zero when writing the UBRRH.); UMSEL = 0 (Asynchronous Operation); UPM1 = 0, UPM0 = 0 (Parity Mode Disabled); USBS = 0 (1-Stop Bit); UCSZ2 = 0, UCSZ1 = 1, UCSZ0 = 1 (8-DataBits); UCPOL = 0 Polarity TX & RX (Rising XCK Edge -> Transmitted Data Changed (Output of TxDPin), Falling XCK Edge -> Received Data Sampled (Input on RxDPin))
     e9a:	86 e8       	ldi	r24, 0x86	; 134
     e9c:	80 bd       	out	0x20, r24	; 32
	UCSRB = 0b10011000;		// TXEN,RXEN,RXCIE					// Enable Uart/Usart TX and RX
     e9e:	88 e9       	ldi	r24, 0x98	; 152
     ea0:	8a b9       	out	0x0a, r24	; 10
	UDR = 0b00000000;		// INITIALIZATION NULL OF UART DATA
     ea2:	1c b8       	out	0x0c, r1	; 12
}
     ea4:	08 95       	ret

00000ea6 <uart_transmit>:

/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
     ea6:	ac 01       	movw	r20, r24
     ea8:	20 e0       	ldi	r18, 0x00	; 0
     eaa:	30 e0       	ldi	r19, 0x00	; 0
     eac:	09 c0       	rjmp	.+18     	; 0xec0 <uart_transmit+0x1a>
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		//UDR = uart_data[count_ns];
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
     eae:	5d 9b       	sbis	0x0b, 5	; 11
     eb0:	fe cf       	rjmp	.-4      	; 0xeae <uart_transmit+0x8>
		{
		}
		UDR = uart_data[count_ns];
     eb2:	fa 01       	movw	r30, r20
     eb4:	e2 0f       	add	r30, r18
     eb6:	f3 1f       	adc	r31, r19
     eb8:	80 81       	ld	r24, Z
     eba:	8c b9       	out	0x0c, r24	; 12
/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
     ebc:	2f 5f       	subi	r18, 0xFF	; 255
     ebe:	3f 4f       	sbci	r19, 0xFF	; 255
     ec0:	26 17       	cp	r18, r22
     ec2:	37 07       	cpc	r19, r23
     ec4:	a4 f3       	brlt	.-24     	; 0xeae <uart_transmit+0x8>
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
		{
		}
		UDR = uart_data[count_ns];
	}
}
     ec6:	08 95       	ret

00000ec8 <uart_transmit_one>:
/***************************************
** TRANSMIT/SEND 1 BYTE OF UART/USART **
***************************************/
void uart_transmit_one(unsigned char uart_data)
{
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
     ec8:	5d 9b       	sbis	0x0b, 5	; 11
     eca:	fe cf       	rjmp	.-4      	; 0xec8 <uart_transmit_one>
	{
	}
	UDR = uart_data;
     ecc:	8c b9       	out	0x0c, r24	; 12
}
     ece:	08 95       	ret

00000ed0 <uart_transmit_DEC_to_BCD>:

/*****************************************************************		// NOT FINISHED
** TRANSMIT/SEND 1 BYTE CONVERTED FROM DEC TO BCD OF UART/USART **		// NOT FINISHED
*****************************************************************/		// NOT FINISHED
void uart_transmit_DEC_to_BCD(unsigned char dec_to_bcd_data)
{// pravi se preobrazuvane ot DEC to BCD i preobrazuvane za izvejdane na parviq simvol s filtar
     ed0:	98 2f       	mov	r25, r24
	
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
     ed2:	5d 9b       	sbis	0x0b, 5	; 11
     ed4:	fe cf       	rjmp	.-4      	; 0xed2 <uart_transmit_DEC_to_BCD+0x2>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data>>4));
     ed6:	89 2f       	mov	r24, r25
     ed8:	82 95       	swap	r24
     eda:	8f 70       	andi	r24, 0x0F	; 15
     edc:	80 5d       	subi	r24, 0xD0	; 208
     ede:	8c b9       	out	0x0c, r24	; 12

	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
     ee0:	5d 9b       	sbis	0x0b, 5	; 11
     ee2:	fe cf       	rjmp	.-4      	; 0xee0 <uart_transmit_DEC_to_BCD+0x10>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data & 0x0F));
     ee4:	9f 70       	andi	r25, 0x0F	; 15
     ee6:	90 5d       	subi	r25, 0xD0	; 208
     ee8:	9c b9       	out	0x0c, r25	; 12
	byte bcdToDec(byte val)
	{
  		return ( (val/16*10) + (val%16) );
	}
*/
}
     eea:	08 95       	ret

00000eec <transmitUart>:
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
     eec:	5d 9b       	sbis	0x0b, 5	; 11
     eee:	fe cf       	rjmp	.-4      	; 0xeec <transmitUart>
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
     ef0:	8c b9       	out	0x0c, r24	; 12
}
     ef2:	08 95       	ret

00000ef4 <transmitUartString>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
     ef4:	fc 01       	movw	r30, r24
     ef6:	04 c0       	rjmp	.+8      	; 0xf00 <transmitUartString+0xc>
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
     ef8:	5d 9b       	sbis	0x0b, 5	; 11
     efa:	fe cf       	rjmp	.-4      	; 0xef8 <transmitUartString+0x4>
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
	{
		transmitUart(*data++);
     efc:	31 96       	adiw	r30, 0x01	; 1
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
     efe:	8c b9       	out	0x0c, r24	; 12
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
     f00:	80 81       	ld	r24, Z
     f02:	88 23       	and	r24, r24
     f04:	c9 f7       	brne	.-14     	; 0xef8 <transmitUartString+0x4>
	{
		transmitUart(*data++);
	}
}
     f06:	08 95       	ret

00000f08 <receiveUart>:
/**************************************************		// NOT FINISHED
** RECEIVE/READ unsigned char BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
unsigned char receiveUart(void)
{
	while (!(UCSRA & (1<<RXC)))
     f08:	5f 9b       	sbis	0x0b, 7	; 11
     f0a:	fe cf       	rjmp	.-4      	; 0xf08 <receiveUart>
	{};							/* Wait for data to be received */
	return UDR;					/* Get and return received data from buffer */
     f0c:	8c b1       	in	r24, 0x0c	; 12
}
     f0e:	08 95       	ret

00000f10 <transmitUartLong>:
/******************************************		// NOT FINISHED
** TRANSMIT/SEND long BYTE OF UART/USART **		// NOT FINISHED
******************************************/		// NOT FINISHED
// USE THIS: transmitUartLong( (long)k + 1 );
void transmitUartLong(long data)		// void transmitUartLong(const long data)
{
     f10:	df 93       	push	r29
     f12:	cf 93       	push	r28
     f14:	cd b7       	in	r28, 0x3d	; 61
     f16:	de b7       	in	r29, 0x3e	; 62
     f18:	2a 97       	sbiw	r28, 0x0a	; 10
     f1a:	0f b6       	in	r0, 0x3f	; 63
     f1c:	f8 94       	cli
     f1e:	de bf       	out	0x3e, r29	; 62
     f20:	0f be       	out	0x3f, r0	; 63
     f22:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ltoa(data, buffer, 10));		// 10 -> DECIMAL
     f24:	ae 01       	movw	r20, r28
     f26:	4f 5f       	subi	r20, 0xFF	; 255
     f28:	5f 4f       	sbci	r21, 0xFF	; 255
     f2a:	2a e0       	ldi	r18, 0x0A	; 10
     f2c:	30 e0       	ldi	r19, 0x00	; 0
     f2e:	0e 94 a5 0a 	call	0x154a	; 0x154a <ltoa>
     f32:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
}
     f36:	2a 96       	adiw	r28, 0x0a	; 10
     f38:	0f b6       	in	r0, 0x3f	; 63
     f3a:	f8 94       	cli
     f3c:	de bf       	out	0x3e, r29	; 62
     f3e:	0f be       	out	0x3f, r0	; 63
     f40:	cd bf       	out	0x3d, r28	; 61
     f42:	cf 91       	pop	r28
     f44:	df 91       	pop	r29
     f46:	08 95       	ret

00000f48 <transmitUartULong>:
/***************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned long BYTE OF UART/USART **		// NOT FINISHED
***************************************************/		// NOT FINISHED
// USE THIS: transmitUartULong( (unsigned long)k + 1 );
void transmitUartULong(unsigned long data)		// void transmitUartULong(const unsigned long data)
{
     f48:	df 93       	push	r29
     f4a:	cf 93       	push	r28
     f4c:	cd b7       	in	r28, 0x3d	; 61
     f4e:	de b7       	in	r29, 0x3e	; 62
     f50:	2a 97       	sbiw	r28, 0x0a	; 10
     f52:	0f b6       	in	r0, 0x3f	; 63
     f54:	f8 94       	cli
     f56:	de bf       	out	0x3e, r29	; 62
     f58:	0f be       	out	0x3f, r0	; 63
     f5a:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ultoa(data, buffer, 10));		// 10 -> DECIMAL
     f5c:	ae 01       	movw	r20, r28
     f5e:	4f 5f       	subi	r20, 0xFF	; 255
     f60:	5f 4f       	sbci	r21, 0xFF	; 255
     f62:	2a e0       	ldi	r18, 0x0A	; 10
     f64:	30 e0       	ldi	r19, 0x00	; 0
     f66:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <ultoa>
     f6a:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
}
     f6e:	2a 96       	adiw	r28, 0x0a	; 10
     f70:	0f b6       	in	r0, 0x3f	; 63
     f72:	f8 94       	cli
     f74:	de bf       	out	0x3e, r29	; 62
     f76:	0f be       	out	0x3f, r0	; 63
     f78:	cd bf       	out	0x3d, r28	; 61
     f7a:	cf 91       	pop	r28
     f7c:	df 91       	pop	r29
     f7e:	08 95       	ret

00000f80 <transmitUartInt>:
/*****************************************		// NOT FINISHED
** TRANSMIT/SEND int BYTE OF UART/USART **		// NOT FINISHED
*****************************************/		// NOT FINISHED
// USE THIS: transmitUartInt( (int)k + 1 );
void transmitUartInt(int data)		// void transmitUartInt(const int data)
{
     f80:	df 93       	push	r29
     f82:	cf 93       	push	r28
     f84:	cd b7       	in	r28, 0x3d	; 61
     f86:	de b7       	in	r29, 0x3e	; 62
     f88:	2a 97       	sbiw	r28, 0x0a	; 10
     f8a:	0f b6       	in	r0, 0x3f	; 63
     f8c:	f8 94       	cli
     f8e:	de bf       	out	0x3e, r29	; 62
     f90:	0f be       	out	0x3f, r0	; 63
     f92:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(itoa(data, buffer, 10));		// 10 -> DECIMAL
     f94:	be 01       	movw	r22, r28
     f96:	6f 5f       	subi	r22, 0xFF	; 255
     f98:	7f 4f       	sbci	r23, 0xFF	; 255
     f9a:	4a e0       	ldi	r20, 0x0A	; 10
     f9c:	50 e0       	ldi	r21, 0x00	; 0
     f9e:	0e 94 84 0a 	call	0x1508	; 0x1508 <itoa>
     fa2:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
}
     fa6:	2a 96       	adiw	r28, 0x0a	; 10
     fa8:	0f b6       	in	r0, 0x3f	; 63
     faa:	f8 94       	cli
     fac:	de bf       	out	0x3e, r29	; 62
     fae:	0f be       	out	0x3f, r0	; 63
     fb0:	cd bf       	out	0x3d, r28	; 61
     fb2:	cf 91       	pop	r28
     fb4:	df 91       	pop	r29
     fb6:	08 95       	ret

00000fb8 <transmitUartUInt>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned int BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: transmitUartUInt( (unsigned int)k + 1 );
void transmitUartUInt(unsigned int data)		// void transmitUartUInt(const unsigned int data)
{
     fb8:	df 93       	push	r29
     fba:	cf 93       	push	r28
     fbc:	cd b7       	in	r28, 0x3d	; 61
     fbe:	de b7       	in	r29, 0x3e	; 62
     fc0:	2a 97       	sbiw	r28, 0x0a	; 10
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	f8 94       	cli
     fc6:	de bf       	out	0x3e, r29	; 62
     fc8:	0f be       	out	0x3f, r0	; 63
     fca:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(utoa(data, buffer, 10));		// 10 -> DECIMAL
     fcc:	be 01       	movw	r22, r28
     fce:	6f 5f       	subi	r22, 0xFF	; 255
     fd0:	7f 4f       	sbci	r23, 0xFF	; 255
     fd2:	4a e0       	ldi	r20, 0x0A	; 10
     fd4:	50 e0       	ldi	r21, 0x00	; 0
     fd6:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <utoa>
     fda:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
}
     fde:	2a 96       	adiw	r28, 0x0a	; 10
     fe0:	0f b6       	in	r0, 0x3f	; 63
     fe2:	f8 94       	cli
     fe4:	de bf       	out	0x3e, r29	; 62
     fe6:	0f be       	out	0x3f, r0	; 63
     fe8:	cd bf       	out	0x3d, r28	; 61
     fea:	cf 91       	pop	r28
     fec:	df 91       	pop	r29
     fee:	08 95       	ret

00000ff0 <uart_init>:
{
	switch(F_CPU)
	{
		case 16000000UL:
		{
			UBRRL = 103;	// Baudrate: 9600; (Error = 0.2%; 16MHz)
     ff0:	87 e6       	ldi	r24, 0x67	; 103
     ff2:	89 b9       	out	0x09, r24	; 9
			UBRRH = 0;
     ff4:	10 bc       	out	0x20, r1	; 32
		{
			break;
		}
	}
#ifdef DEBUG_SETTING
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     ff6:	8c e0       	ldi	r24, 0x0C	; 12
     ff8:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 2								// and next is update volume lcd information
     ffc:	84 ed       	ldi	r24, 0xD4	; 212
     ffe:	0e 94 06 06 	call	0xc0c	; 0xc0c <LCD_COMMAND>
	LCD_DATA_STRING("Freq: ");		// 20 symbols			
    1002:	8c ec       	ldi	r24, 0xCC	; 204
    1004:	94 e0       	ldi	r25, 0x04	; 4
    1006:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
	LCD_DATA_ULONG(F_CPU);			// 20 symbols
    100a:	60 e0       	ldi	r22, 0x00	; 0
    100c:	74 e2       	ldi	r23, 0x24	; 36
    100e:	84 ef       	ldi	r24, 0xF4	; 244
    1010:	90 e0       	ldi	r25, 0x00	; 0
    1012:	0e 94 9b 06 	call	0xd36	; 0xd36 <LCD_DATA_ULONG>
	LCD_DATA_STRING(" MHz");		// 20 symbols
    1016:	83 ed       	ldi	r24, 0xD3	; 211
    1018:	94 e0       	ldi	r25, 0x04	; 4
    101a:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_DATA_STRING>
//	debug_print();

	// Razpoznavane na baudrate (skorost): 1. Izprashta se byte. 2. Poluchava se byte. 3. Sravnqva se polucheniq byte == izprateniq byte. // This is LOOP TX->RX
	// 4. Ako byte pri sravnqvaneto e edin i sasht to skorostta e izbranata v momenta, ako byte e razlichen - da se probva sas sledvashta baudrate.

	UCSRC = 0b10000110;		// URSEL = 1 (Accessing to UBRRH or UCSRC, is read as zero when reading UBRRH. The URSEL must be zero when writing the UBRRH.); UMSEL = 0 (Asynchronous Operation); UPM1 = 0, UPM0 = 0 (Parity Mode Disabled); USBS = 0 (1-Stop Bit); UCSZ2 = 0, UCSZ1 = 1, UCSZ0 = 1 (8-DataBits); UCPOL = 0 Polarity TX & RX (Rising XCK Edge -> Transmitted Data Changed (Output of TxDPin), Falling XCK Edge -> Received Data Sampled (Input on RxDPin))
    101e:	86 e8       	ldi	r24, 0x86	; 134
    1020:	80 bd       	out	0x20, r24	; 32
//	UCSRB = 0b10011000;		// Enable TXEN,RXEN,RXCIE	// Enable Uart/Usart TX and RX
	UCSRB = 0b00001000;		// Enable only TXEN			// Enable Uart/Usart only TX
    1022:	88 e0       	ldi	r24, 0x08	; 8
    1024:	8a b9       	out	0x0a, r24	; 10
	UDR = 0b00000000;		// INITIALIZATION NULL OF UART DATA
    1026:	1c b8       	out	0x0c, r1	; 12

#ifdef DEBUG_INFO
	transmitUartString("\r\n");
    1028:	88 ed       	ldi	r24, 0xD8	; 216
    102a:	94 e0       	ldi	r25, 0x04	; 4
    102c:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
#if DEBUG_SETTING
	transmitUartString("[UART Serial Port Settings] Baud rate: 9600, Data bits: 8 bits, Stop bits: 1 bit, Parity: None, Flow control: None or XON/XOFF\r\n");
    1030:	8b ed       	ldi	r24, 0xDB	; 219
    1032:	94 e0       	ldi	r25, 0x04	; 4
    1034:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
}
    1038:	08 95       	ret

0000103a <spi_init>:
/**************************
** INITIZLIZATION OF SPI **
***************************/
void spi_init()
{
	SPSR = (0<<SPIF)|(0<<WCOL)|(0<<SPI2X);
    103a:	1e b8       	out	0x0e, r1	; 14
//	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);			//0b01010010	// SPR1   = 1 - 16 000 000 / 64  = 250 000 = 250kHz  // KOMENTAR ZARADI SIMULACIQTA - PROTEUS BLOKIRANE ZARADI BIT V REGISTAR
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz	 // KAKVA KOMBINACIQ OT 4-te BITa VODI DO RAZBLOKIRANETO ???
    103c:	83 e5       	ldi	r24, 0x53	; 83
    103e:	8d b9       	out	0x0d, r24	; 13
	SPDR = 0b00000000;
    1040:	1f b8       	out	0x0f, r1	; 15

	PGA2310_U8_SPI_CS_high();	// /SS - DISABLE
	PGA2310_U8_SPI(0b00000000, 0b00000000);
	*/

	SPCR = (0<<SPE);
    1042:	1d b8       	out	0x0d, r1	; 13
}
    1044:	08 95       	ret

00001046 <spi_start>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1046:	83 e5       	ldi	r24, 0x53	; 83
    1048:	8d b9       	out	0x0d, r24	; 13
}
    104a:	08 95       	ret

0000104c <spi_stop>:
/**************************************
** DEFINITION SPI FUNCTION STOP ONLY **
**************************************/
void spi_stop()
{
	SPCR = (0<<SPE);
    104c:	1d b8       	out	0x0d, r1	; 13
}
    104e:	08 95       	ret

00001050 <spi_write_one_byte>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1050:	93 e5       	ldi	r25, 0x53	; 83
    1052:	9d b9       	out	0x0d, r25	; 13
void spi_write_one_byte(unsigned char data)	// void PGA2310_U7_SPI(byte volume_left, byte volume_right)	//PGA2310_U7_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data;				//volume_right;
    1054:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    1056:	77 9b       	sbis	0x0e, 7	; 14
    1058:	fe cf       	rjmp	.-4      	; 0x1056 <spi_write_one_byte+0x6>
	{
	}
}
    105a:	08 95       	ret

0000105c <spi_write_two_bytes>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    105c:	93 e5       	ldi	r25, 0x53	; 83
    105e:	9d b9       	out	0x0d, r25	; 13
void spi_write_two_bytes(unsigned char data1, unsigned char data2)	// void PGA2310_U6_SPI(byte volume_left, byte volume_right)	//PGA2310_U6_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data1;				//volume_left;
    1060:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    1062:	77 9b       	sbis	0x0e, 7	; 14
    1064:	fe cf       	rjmp	.-4      	; 0x1062 <spi_write_two_bytes+0x6>
	{
	}

//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data2;				//volume_right;
    1066:	6f b9       	out	0x0f, r22	; 15
	while(!(SPSR & (1<<SPIF)))
    1068:	77 9b       	sbis	0x0e, 7	; 14
    106a:	fe cf       	rjmp	.-4      	; 0x1068 <spi_write_two_bytes+0xc>
	{
	}
}
    106c:	08 95       	ret

0000106e <spi_write_more_bytes>:

/*********************************************
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
    106e:	fc 01       	movw	r30, r24
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1070:	93 e5       	ldi	r25, 0x53	; 83
    1072:	06 c0       	rjmp	.+12     	; 0x1080 <spi_write_more_bytes+0x12>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    1074:	31 96       	adiw	r30, 0x01	; 1
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1076:	9d b9       	out	0x0d, r25	; 13
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
	{
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
		spi_start();
		SPDR = *data;			//volume_left;
    1078:	80 81       	ld	r24, Z
    107a:	8f b9       	out	0x0f, r24	; 15
		while(!(SPSR & (1<<SPIF)))
    107c:	77 9b       	sbis	0x0e, 7	; 14
    107e:	fe cf       	rjmp	.-4      	; 0x107c <spi_write_more_bytes+0xe>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    1080:	80 81       	ld	r24, Z
    1082:	88 23       	and	r24, r24
    1084:	b9 f7       	brne	.-18     	; 0x1074 <spi_write_more_bytes+0x6>
		SPDR = *data;			//volume_left;
		while(!(SPSR & (1<<SPIF)))
		{
		}
	}
}
    1086:	08 95       	ret

00001088 <spi_read_more_bytes>:
unsigned char spi_read_more_bytes()	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
	unsigned char data = 0b00000000;
	//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data;			//volume_left;
    1088:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF)))
    108a:	77 9b       	sbis	0x0e, 7	; 14
    108c:	fe cf       	rjmp	.-4      	; 0x108a <spi_read_more_bytes+0x2>
	{
	}
	return data;
}
    108e:	80 e0       	ldi	r24, 0x00	; 0
    1090:	08 95       	ret

00001092 <decToBcd>:

/**************************************************************
**** CONVERT NORMAL DECIMAL NUMBERS TO BINARY CODED DECIMAL ***
**************************************************************/
unsigned char decToBcd(unsigned char val)
{
    1092:	48 2f       	mov	r20, r24
    1094:	6a e0       	ldi	r22, 0x0A	; 10
    1096:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <__udivmodqi4>
    109a:	28 2f       	mov	r18, r24
    109c:	30 e0       	ldi	r19, 0x00	; 0
    109e:	84 e0       	ldi	r24, 0x04	; 4
    10a0:	22 0f       	add	r18, r18
    10a2:	33 1f       	adc	r19, r19
    10a4:	8a 95       	dec	r24
    10a6:	e1 f7       	brne	.-8      	; 0x10a0 <decToBcd+0xe>
    10a8:	84 2f       	mov	r24, r20
    10aa:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <__udivmodqi4>
	return ( (val/10*16) + (val%10) );	// Get DEC format -> convert DEC to HEX
}
    10ae:	89 2f       	mov	r24, r25
    10b0:	82 0f       	add	r24, r18
    10b2:	08 95       	ret

000010b4 <bcdToDec>:

/**************************************************************
**** CONVERT BINARY CODED DECIMAL TO NORMAL DECIMAL NUMBERS ***
**************************************************************/
unsigned char bcdToDec(unsigned char val)
{
    10b4:	28 2f       	mov	r18, r24
    10b6:	22 95       	swap	r18
    10b8:	2f 70       	andi	r18, 0x0F	; 15
    10ba:	9a e0       	ldi	r25, 0x0A	; 10
    10bc:	29 9f       	mul	r18, r25
    10be:	90 01       	movw	r18, r0
    10c0:	11 24       	eor	r1, r1
    10c2:	8f 70       	andi	r24, 0x0F	; 15
	return ( (val/16*10) + (val%16) );	// Get HEX format -> convert HEX to DEC
}
    10c4:	82 0f       	add	r24, r18
    10c6:	08 95       	ret

000010c8 <shiftRightOutLsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    10c8:	a0 9a       	sbi	0x14, 0	; 20
    10ca:	94 e4       	ldi	r25, 0x44	; 68
    10cc:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regALSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    10ce:	90 ff       	sbrs	r25, 0
    10d0:	02 c0       	rjmp	.+4      	; 0x10d6 <shiftRightOutLsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v LSB
    10d2:	a8 9a       	sbi	0x15, 0	; 21
    10d4:	01 c0       	rjmp	.+2      	; 0x10d8 <shiftRightOutLsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
    10d6:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    10d8:	8f 5f       	subi	r24, 0xFF	; 255
    10da:	88 30       	cpi	r24, 0x08	; 8
    10dc:	11 f0       	breq	.+4      	; 0x10e2 <shiftRightOutLsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
		}
		
		regALSB = regALSB >> 1;	// shiftvane na >> nadqsno
    10de:	96 95       	lsr	r25
    10e0:	f6 cf       	rjmp	.-20     	; 0x10ce <shiftRightOutLsbFirst+0x6>
    10e2:	08 95       	ret

000010e4 <shiftLeftOutMsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    10e4:	a0 9a       	sbi	0x14, 0	; 20
    10e6:	94 e4       	ldi	r25, 0x44	; 68
    10e8:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regAMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
    10ea:	97 ff       	sbrs	r25, 7
    10ec:	02 c0       	rjmp	.+4      	; 0x10f2 <shiftLeftOutMsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v MSB
    10ee:	a8 9a       	sbi	0x15, 0	; 21
    10f0:	01 c0       	rjmp	.+2      	; 0x10f4 <shiftLeftOutMsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
    10f2:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    10f4:	8f 5f       	subi	r24, 0xFF	; 255
    10f6:	88 30       	cpi	r24, 0x08	; 8
    10f8:	11 f0       	breq	.+4      	; 0x10fe <shiftLeftOutMsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
		}
		
		regAMSB = regAMSB << 1;	// shiftvane na << nalqvo
    10fa:	99 0f       	add	r25, r25
    10fc:	f6 cf       	rjmp	.-20     	; 0x10ea <shiftLeftOutMsbFirst+0x6>
    10fe:	08 95       	ret

00001100 <shiftRightInLsbFirst>:
void shiftRightInLsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    1100:	a0 98       	cbi	0x14, 0	; 20
    1102:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
    1104:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1106:	8f 5f       	subi	r24, 0xFF	; 255
    1108:	88 30       	cpi	r24, 0x08	; 8
    110a:	e1 f7       	brne	.-8      	; 0x1104 <shiftRightInLsbFirst+0x4>
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
	}

}
    110c:	08 95       	ret

0000110e <shiftLeftInMsbFirst>:
void shiftLeftInMsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    110e:	a0 98       	cbi	0x14, 0	; 20
    1110:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
    1112:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1114:	8f 5f       	subi	r24, 0xFF	; 255
    1116:	88 30       	cpi	r24, 0x08	; 8
    1118:	e1 f7       	brne	.-8      	; 0x1112 <shiftLeftInMsbFirst+0x4>
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
	}

}
    111a:	08 95       	ret

0000111c <delay_ms>:

/*************************************************************
*********** FUNCTION SOFTWARE DELAY IN MILISECONDS ***********
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
    111c:	40 e0       	ldi	r20, 0x00	; 0
    111e:	50 e0       	ldi	r21, 0x00	; 0
    1120:	0b c0       	rjmp	.+22     	; 0x1138 <delay_ms+0x1c>
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1122:	20 e0       	ldi	r18, 0x00	; 0
    1124:	30 e0       	ldi	r19, 0x00	; 0
	{
		for(j=0;j<100;j++)
		{
		  asm("nop");
    1126:	00 00       	nop
		  asm("nop");
    1128:	00 00       	nop
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
	{
		for(j=0;j<100;j++)
    112a:	2f 5f       	subi	r18, 0xFF	; 255
    112c:	3f 4f       	sbci	r19, 0xFF	; 255
    112e:	24 36       	cpi	r18, 0x64	; 100
    1130:	31 05       	cpc	r19, r1
    1132:	c9 f7       	brne	.-14     	; 0x1126 <delay_ms+0xa>
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1134:	4f 5f       	subi	r20, 0xFF	; 255
    1136:	5f 4f       	sbci	r21, 0xFF	; 255
    1138:	48 17       	cp	r20, r24
    113a:	59 07       	cpc	r21, r25
    113c:	94 f3       	brlt	.-28     	; 0x1122 <delay_ms+0x6>
		{
		  asm("nop");
		  asm("nop");
		}
	}
}
    113e:	08 95       	ret

00001140 <about>:


void about(void)
{
    1140:	0f 93       	push	r16
    1142:	1f 93       	push	r17
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] =====================================================\r\n");
    1144:	0c e5       	ldi	r16, 0x5C	; 92
    1146:	15 e0       	ldi	r17, 0x05	; 5
    1148:	c8 01       	movw	r24, r16
    114a:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartString("[UART INFO] \tAuthors and creators: P.Upinov and P.Stoyanov\r\n");
    114e:	80 ea       	ldi	r24, 0xA0	; 160
    1150:	95 e0       	ldi	r25, 0x05	; 5
    1152:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartString("[UART INFO] \tDevice name: Digital Control Audio System\r\n");
    1156:	8d ed       	ldi	r24, 0xDD	; 221
    1158:	95 e0       	ldi	r25, 0x05	; 5
    115a:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartString("[UART INFO] \tFirmware version beta ");
    115e:	86 e1       	ldi	r24, 0x16	; 22
    1160:	96 e0       	ldi	r25, 0x06	; 6
    1162:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartInt(FIRMWARE_VERSION);
    1166:	8a e1       	ldi	r24, 0x1A	; 26
    1168:	90 e0       	ldi	r25, 0x00	; 0
    116a:	0e 94 c0 07 	call	0xf80	; 0xf80 <transmitUartInt>
	transmitUartString("\r\n");
    116e:	8a e3       	ldi	r24, 0x3A	; 58
    1170:	96 e0       	ldi	r25, 0x06	; 6
    1172:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartString("[UART INFO] =====================================================\r\n");
    1176:	c8 01       	movw	r24, r16
    1178:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
	transmitUartString("[UART INFO] Da dobavq upravlenie na:\r\n- FAN\r\n- DS18S20\r\n- IR\r\n- RTC\r\n- Memory\r\n\r\n");
    117c:	8d e3       	ldi	r24, 0x3D	; 61
    117e:	96 e0       	ldi	r25, 0x06	; 6
    1180:	0e 94 7a 07 	call	0xef4	; 0xef4 <transmitUartString>
#endif
}
    1184:	1f 91       	pop	r17
    1186:	0f 91       	pop	r16
    1188:	08 95       	ret

0000118a <rotaryEncoderNikBarzakov>:
** READ/SCAN ROTARY ENCODER OF NIK BARZAKOV **
*********************************************/
char rotaryEncoderNikBarzakov()
{
	char tempEncoder = 0;
	if((ENCODER_A_low()) && (ENCODER_B_low()))			// A0, B0
    118a:	9d 99       	sbic	0x13, 5	; 19
    118c:	0e c0       	rjmp	.+28     	; 0x11aa <rotaryEncoderNikBarzakov+0x20>
    118e:	9c 99       	sbic	0x13, 4	; 19
    1190:	0c c0       	rjmp	.+24     	; 0x11aa <rotaryEncoderNikBarzakov+0x20>
    1192:	88 ec       	ldi	r24, 0xC8	; 200
    1194:	90 e0       	ldi	r25, 0x00	; 0
    1196:	01 97       	sbiw	r24, 0x01	; 1
    1198:	f1 f7       	brne	.-4      	; 0x1196 <rotaryEncoderNikBarzakov+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_high()) && (ENCODER_B_low()))		// A1, B0
    119a:	9d 9b       	sbis	0x13, 5	; 19
    119c:	14 c0       	rjmp	.+40     	; 0x11c6 <rotaryEncoderNikBarzakov+0x3c>
    119e:	83 b3       	in	r24, 0x13	; 19
    11a0:	82 95       	swap	r24
    11a2:	8f 70       	andi	r24, 0x0F	; 15
    11a4:	80 95       	com	r24
    11a6:	81 70       	andi	r24, 0x01	; 1
    11a8:	08 95       	ret
// VOLUME UP
			tempEncoder = 1;	//	tempEncoder++;
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}
	}
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    11aa:	9d 9b       	sbis	0x13, 5	; 19
    11ac:	0c c0       	rjmp	.+24     	; 0x11c6 <rotaryEncoderNikBarzakov+0x3c>
    11ae:	9c 99       	sbic	0x13, 4	; 19
    11b0:	0a c0       	rjmp	.+20     	; 0x11c6 <rotaryEncoderNikBarzakov+0x3c>
    11b2:	88 ec       	ldi	r24, 0xC8	; 200
    11b4:	90 e0       	ldi	r25, 0x00	; 0
    11b6:	01 97       	sbiw	r24, 0x01	; 1
    11b8:	f1 f7       	brne	.-4      	; 0x11b6 <rotaryEncoderNikBarzakov+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    11ba:	9d 99       	sbic	0x13, 5	; 19
    11bc:	04 c0       	rjmp	.+8      	; 0x11c6 <rotaryEncoderNikBarzakov+0x3c>
    11be:	9c 99       	sbic	0x13, 4	; 19
    11c0:	02 c0       	rjmp	.+4      	; 0x11c6 <rotaryEncoderNikBarzakov+0x3c>
    11c2:	8f ef       	ldi	r24, 0xFF	; 255
    11c4:	08 95       	ret
    11c6:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    11c8:	08 95       	ret

000011ca <rotaryEncoderVer1>:
** READ/SCAN ROTARY ENCODER VERSION 1 / MODEL 1 **
*************************************************/
char rotaryEncoderVer1()	// Check imediate now bits in PIN register.
{
	char tempEncoder = 0;							// A1, B1
	if((ENCODER_A_low()) && (ENCODER_B_high()))			// A0, B1
    11ca:	9d 99       	sbic	0x13, 5	; 19
    11cc:	0e c0       	rjmp	.+28     	; 0x11ea <rotaryEncoderVer1+0x20>
    11ce:	9c 9b       	sbis	0x13, 4	; 19
    11d0:	0c c0       	rjmp	.+24     	; 0x11ea <rotaryEncoderVer1+0x20>
    11d2:	88 ec       	ldi	r24, 0xC8	; 200
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	01 97       	sbiw	r24, 0x01	; 1
    11d8:	f1 f7       	brne	.-4      	; 0x11d6 <rotaryEncoderVer1+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    11da:	9d 99       	sbic	0x13, 5	; 19
    11dc:	14 c0       	rjmp	.+40     	; 0x1206 <rotaryEncoderVer1+0x3c>
    11de:	83 b3       	in	r24, 0x13	; 19
    11e0:	82 95       	swap	r24
    11e2:	8f 70       	andi	r24, 0x0F	; 15
    11e4:	80 95       	com	r24
    11e6:	81 70       	andi	r24, 0x01	; 1
    11e8:	08 95       	ret
//			PORTD = volumeMassive[volumeIndex];
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}

	}													// A1. B1
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    11ea:	9d 9b       	sbis	0x13, 5	; 19
    11ec:	0c c0       	rjmp	.+24     	; 0x1206 <rotaryEncoderVer1+0x3c>
    11ee:	9c 99       	sbic	0x13, 4	; 19
    11f0:	0a c0       	rjmp	.+20     	; 0x1206 <rotaryEncoderVer1+0x3c>
    11f2:	88 ec       	ldi	r24, 0xC8	; 200
    11f4:	90 e0       	ldi	r25, 0x00	; 0
    11f6:	01 97       	sbiw	r24, 0x01	; 1
    11f8:	f1 f7       	brne	.-4      	; 0x11f6 <rotaryEncoderVer1+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    11fa:	9d 99       	sbic	0x13, 5	; 19
    11fc:	04 c0       	rjmp	.+8      	; 0x1206 <rotaryEncoderVer1+0x3c>
    11fe:	9c 99       	sbic	0x13, 4	; 19
    1200:	02 c0       	rjmp	.+4      	; 0x1206 <rotaryEncoderVer1+0x3c>
    1202:	8f ef       	ldi	r24, 0xFF	; 255
    1204:	08 95       	ret
    1206:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    1208:	08 95       	ret

0000120a <rotaryEncoderVer2>:
    120a:	88 ec       	ldi	r24, 0xC8	; 200
    120c:	90 e0       	ldi	r25, 0x00	; 0
    120e:	fc 01       	movw	r30, r24
    1210:	31 97       	sbiw	r30, 0x01	; 1
    1212:	f1 f7       	brne	.-4      	; 0x1210 <rotaryEncoderVer2+0x6>
    1214:	fc 01       	movw	r30, r24
    1216:	31 97       	sbiw	r30, 0x01	; 1
    1218:	f1 f7       	brne	.-4      	; 0x1216 <rotaryEncoderVer2+0xc>
    121a:	01 97       	sbiw	r24, 0x01	; 1
    121c:	f1 f7       	brne	.-4      	; 0x121a <rotaryEncoderVer2+0x10>
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    121e:	80 e0       	ldi	r24, 0x00	; 0
    1220:	08 95       	ret

00001222 <RELAYS_IN_INIT>:
/*********************************************
** INITIZLIZATION OF SHIFT REGISTER 74HC595 **
*********************************************/
void RELAYS_IN_INIT()
{
}
    1222:	08 95       	ret

00001224 <RELAYS_OUT_INIT>:

void RELAYS_OUT_INIT()
{
}
    1224:	08 95       	ret

00001226 <RELAYS_IN_CHOOSE>:

/****************************************************************************************************************
** DEFINITION RELAYS IN FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS IN **
****************************************************************************************************************/
void RELAYS_IN_CHOOSE(unsigned char rel_in)	// HELP: RELAYS_IN_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    1226:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELIN_SCK_low();
    1228:	ae 98       	cbi	0x15, 6	; 21

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    122a:	80 ff       	sbrs	r24, 0
    122c:	02 c0       	rjmp	.+4      	; 0x1232 <RELAYS_IN_CHOOSE+0xc>
		{
			RELIN_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    122e:	af 9a       	sbi	0x15, 7	; 21
    1230:	01 c0       	rjmp	.+2      	; 0x1234 <RELAYS_IN_CHOOSE+0xe>
		}
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    1232:	af 98       	cbi	0x15, 7	; 21
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELIN_SCK_high();
    1234:	ae 9a       	sbi	0x15, 6	; 21
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1236:	9f 5f       	subi	r25, 0xFF	; 255
    1238:	98 30       	cpi	r25, 0x08	; 8
    123a:	11 f0       	breq	.+4      	; 0x1240 <RELAYS_IN_CHOOSE+0x1a>
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    123c:	86 95       	lsr	r24
    123e:	f4 cf       	rjmp	.-24     	; 0x1228 <RELAYS_IN_CHOOSE+0x2>

		RELIN_SCK_high();
	}

	RELIN_RCK_low();
    1240:	ab 98       	cbi	0x15, 3	; 21
    1242:	88 ea       	ldi	r24, 0xA8	; 168
    1244:	92 e0       	ldi	r25, 0x02	; 2
    1246:	fc 01       	movw	r30, r24
    1248:	31 97       	sbiw	r30, 0x01	; 1
    124a:	f1 f7       	brne	.-4      	; 0x1248 <RELAYS_IN_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELIN_RCK_high();
    124c:	ab 9a       	sbi	0x15, 3	; 21
    124e:	01 97       	sbiw	r24, 0x01	; 1
    1250:	f1 f7       	brne	.-4      	; 0x124e <RELAYS_IN_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    1252:	08 95       	ret

00001254 <relays_in1_2ch>:

void relays_in1_2ch()
{
	RELAYS_IN_CHOOSE(0b00100000);	// RELE 1
    1254:	80 e2       	ldi	r24, 0x20	; 32
    1256:	0e 94 13 09 	call	0x1226	; 0x1226 <RELAYS_IN_CHOOSE>
}
    125a:	08 95       	ret

0000125c <relays_in1_6ch>:

void relays_in1_6ch()
{
	RELAYS_IN_CHOOSE(0b01100001);	// RELE 1,2,3
    125c:	81 e6       	ldi	r24, 0x61	; 97
    125e:	0e 94 13 09 	call	0x1226	; 0x1226 <RELAYS_IN_CHOOSE>
}
    1262:	08 95       	ret

00001264 <relays_in2_2ch>:

void relays_in2_2ch()
{
	RELAYS_IN_CHOOSE(0b00001010);	// RELE 4,5
    1264:	8a e0       	ldi	r24, 0x0A	; 10
    1266:	0e 94 13 09 	call	0x1226	; 0x1226 <RELAYS_IN_CHOOSE>
}
    126a:	08 95       	ret

0000126c <relays_in2_6ch>:

void relays_in2_6ch()
{
	RELAYS_IN_CHOOSE(0b10011010);	// RELE 4,5,6,7
    126c:	8a e9       	ldi	r24, 0x9A	; 154
    126e:	0e 94 13 09 	call	0x1226	; 0x1226 <RELAYS_IN_CHOOSE>
}
    1272:	08 95       	ret

00001274 <relays_in3_2ch>:

void relays_in3_2ch()
{
	RELAYS_IN_CHOOSE(0b00001100);	// RELE 8,5
    1274:	8c e0       	ldi	r24, 0x0C	; 12
    1276:	0e 94 13 09 	call	0x1226	; 0x1226 <RELAYS_IN_CHOOSE>
}
    127a:	08 95       	ret

0000127c <relays_in3_6ch>:

void relays_in3_6ch()
{
	RELAYS_IN_CHOOSE(0b10011100);	// RELE 8,5,6,7
    127c:	8c e9       	ldi	r24, 0x9C	; 156
    127e:	0e 94 13 09 	call	0x1226	; 0x1226 <RELAYS_IN_CHOOSE>
}
    1282:	08 95       	ret

00001284 <relays_in_off>:

void relays_in_off()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    1284:	80 e0       	ldi	r24, 0x00	; 0
    1286:	0e 94 13 09 	call	0x1226	; 0x1226 <RELAYS_IN_CHOOSE>
}
    128a:	08 95       	ret

0000128c <relays_in_init>:

void relays_in_init()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    128c:	80 e0       	ldi	r24, 0x00	; 0
    128e:	0e 94 13 09 	call	0x1226	; 0x1226 <RELAYS_IN_CHOOSE>
}
    1292:	08 95       	ret

00001294 <RELAYS_OUT_CHOOSE>:
/******************************************************************************************************************
** DEFINITION RELAYS OUT FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS OUT **
******************************************************************************************************************/
void RELAYS_OUT_CHOOSE(unsigned char rel_out)	// HELP: RELAYS_OUT_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    1294:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELOUT_SCK_low();
    1296:	96 98       	cbi	0x12, 6	; 18

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1298:	80 ff       	sbrs	r24, 0
    129a:	02 c0       	rjmp	.+4      	; 0x12a0 <RELAYS_OUT_CHOOSE+0xc>
		{
			RELOUT_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    129c:	c4 9a       	sbi	0x18, 4	; 24
    129e:	01 c0       	rjmp	.+2      	; 0x12a2 <RELAYS_OUT_CHOOSE+0xe>
		}
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    12a0:	c4 98       	cbi	0x18, 4	; 24
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELOUT_SCK_high();
    12a2:	96 9a       	sbi	0x12, 6	; 18
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12a4:	9f 5f       	subi	r25, 0xFF	; 255
    12a6:	98 30       	cpi	r25, 0x08	; 8
    12a8:	11 f0       	breq	.+4      	; 0x12ae <RELAYS_OUT_CHOOSE+0x1a>
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    12aa:	86 95       	lsr	r24
    12ac:	f4 cf       	rjmp	.-24     	; 0x1296 <RELAYS_OUT_CHOOSE+0x2>

		RELOUT_SCK_high();
	}

	RELOUT_RCK_low();
    12ae:	97 98       	cbi	0x12, 7	; 18
    12b0:	88 ea       	ldi	r24, 0xA8	; 168
    12b2:	92 e0       	ldi	r25, 0x02	; 2
    12b4:	fc 01       	movw	r30, r24
    12b6:	31 97       	sbiw	r30, 0x01	; 1
    12b8:	f1 f7       	brne	.-4      	; 0x12b6 <RELAYS_OUT_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELOUT_RCK_high();
    12ba:	97 9a       	sbi	0x12, 7	; 18
    12bc:	01 97       	sbiw	r24, 0x01	; 1
    12be:	f1 f7       	brne	.-4      	; 0x12bc <RELAYS_OUT_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    12c0:	08 95       	ret

000012c2 <relays_out_1ch>:

void relays_out_1ch()
{
	RELAYS_OUT_CHOOSE(0b10000000);	// RELE 1
    12c2:	80 e8       	ldi	r24, 0x80	; 128
    12c4:	0e 94 4a 09 	call	0x1294	; 0x1294 <RELAYS_OUT_CHOOSE>
}
    12c8:	08 95       	ret

000012ca <relays_out_6ch>:

void relays_out_6ch()
{
	RELAYS_OUT_CHOOSE(0b11111100);	// RELE 1,2,3,4,5,6
    12ca:	8c ef       	ldi	r24, 0xFC	; 252
    12cc:	0e 94 4a 09 	call	0x1294	; 0x1294 <RELAYS_OUT_CHOOSE>
}
    12d0:	08 95       	ret

000012d2 <relays_out_off>:
void relays_out_off()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    12d2:	80 e0       	ldi	r24, 0x00	; 0
    12d4:	0e 94 4a 09 	call	0x1294	; 0x1294 <RELAYS_OUT_CHOOSE>
}
    12d8:	08 95       	ret

000012da <relays_out_init>:
void relays_out_init()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    12da:	80 e0       	ldi	r24, 0x00	; 0
    12dc:	0e 94 4a 09 	call	0x1294	; 0x1294 <RELAYS_OUT_CHOOSE>
}
    12e0:	08 95       	ret

000012e2 <GetSIRC12>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    12e2:	10 92 ac 06 	sts	0x06AC, r1
    12e6:	10 92 b1 06 	sts	0x06B1, r1

	while(irPin);				//wait for it to be low
    12ea:	82 99       	sbic	0x10, 2	; 16
    12ec:	fe cf       	rjmp	.-4      	; 0x12ea <GetSIRC12+0x8>
    12ee:	20 e0       	ldi	r18, 0x00	; 0
    12f0:	40 e2       	ldi	r20, 0x20	; 32
    12f2:	53 e0       	ldi	r21, 0x03	; 3
    12f4:	04 c0       	rjmp	.+8      	; 0x12fe <GetSIRC12+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    12f6:	2f 5f       	subi	r18, 0xFF	; 255
    12f8:	ca 01       	movw	r24, r20
    12fa:	01 97       	sbiw	r24, 0x01	; 1
    12fc:	f1 f7       	brne	.-4      	; 0x12fa <GetSIRC12+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    12fe:	82 9b       	sbis	0x10, 2	; 16
    1300:	fa cf       	rjmp	.-12     	; 0x12f6 <GetSIRC12+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1302:	2b 50       	subi	r18, 0x0B	; 11
    1304:	23 30       	cpi	r18, 0x03	; 3
    1306:	70 f5       	brcc	.+92     	; 0x1364 <GetSIRC12+0x82>
	{
		return;		//goto StartLook;
    1308:	40 e0       	ldi	r20, 0x00	; 0
    130a:	30 e0       	ldi	r19, 0x00	; 0
    130c:	60 e2       	ldi	r22, 0x20	; 32
    130e:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1310:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1312:	82 99       	sbic	0x10, 2	; 16
    1314:	fe cf       	rjmp	.-4      	; 0x1312 <GetSIRC12+0x30>
    1316:	20 e0       	ldi	r18, 0x00	; 0
    1318:	04 c0       	rjmp	.+8      	; 0x1322 <GetSIRC12+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    131a:	2f 5f       	subi	r18, 0xFF	; 255
    131c:	cb 01       	movw	r24, r22
    131e:	01 97       	sbiw	r24, 0x01	; 1
    1320:	f1 f7       	brne	.-4      	; 0x131e <GetSIRC12+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1322:	82 9b       	sbis	0x10, 2	; 16
    1324:	fa cf       	rjmp	.-12     	; 0x131a <GetSIRC12+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1326:	26 30       	cpi	r18, 0x06	; 6
    1328:	08 f0       	brcs	.+2      	; 0x132c <GetSIRC12+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    132a:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    132c:	4f 5f       	subi	r20, 0xFF	; 255
    132e:	47 30       	cpi	r20, 0x07	; 7
    1330:	79 f7       	brne	.-34     	; 0x1310 <GetSIRC12+0x2e>
    1332:	30 93 ac 06 	sts	0x06AC, r19
    1336:	40 e0       	ldi	r20, 0x00	; 0
    1338:	30 e0       	ldi	r19, 0x00	; 0
    133a:	60 e2       	ldi	r22, 0x20	; 32
    133c:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    133e:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1340:	82 99       	sbic	0x10, 2	; 16
    1342:	fe cf       	rjmp	.-4      	; 0x1340 <GetSIRC12+0x5e>
    1344:	20 e0       	ldi	r18, 0x00	; 0
    1346:	04 c0       	rjmp	.+8      	; 0x1350 <GetSIRC12+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1348:	2f 5f       	subi	r18, 0xFF	; 255
    134a:	cb 01       	movw	r24, r22
    134c:	01 97       	sbiw	r24, 0x01	; 1
    134e:	f1 f7       	brne	.-4      	; 0x134c <GetSIRC12+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1350:	82 9b       	sbis	0x10, 2	; 16
    1352:	fa cf       	rjmp	.-12     	; 0x1348 <GetSIRC12+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1354:	26 30       	cpi	r18, 0x06	; 6
    1356:	08 f0       	brcs	.+2      	; 0x135a <GetSIRC12+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1358:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
    135a:	4f 5f       	subi	r20, 0xFF	; 255
    135c:	45 30       	cpi	r20, 0x05	; 5
    135e:	79 f7       	brne	.-34     	; 0x133e <GetSIRC12+0x5c>
    1360:	30 93 b1 06 	sts	0x06B1, r19
    1364:	08 95       	ret

00001366 <GetSIRC15>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    1366:	10 92 ac 06 	sts	0x06AC, r1
    136a:	10 92 b1 06 	sts	0x06B1, r1

	while(irPin);				//wait for it to be low
    136e:	82 99       	sbic	0x10, 2	; 16
    1370:	fe cf       	rjmp	.-4      	; 0x136e <GetSIRC15+0x8>
    1372:	20 e0       	ldi	r18, 0x00	; 0
    1374:	40 e2       	ldi	r20, 0x20	; 32
    1376:	53 e0       	ldi	r21, 0x03	; 3
    1378:	04 c0       	rjmp	.+8      	; 0x1382 <GetSIRC15+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    137a:	2f 5f       	subi	r18, 0xFF	; 255
    137c:	ca 01       	movw	r24, r20
    137e:	01 97       	sbiw	r24, 0x01	; 1
    1380:	f1 f7       	brne	.-4      	; 0x137e <GetSIRC15+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    1382:	82 9b       	sbis	0x10, 2	; 16
    1384:	fa cf       	rjmp	.-12     	; 0x137a <GetSIRC15+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1386:	2b 50       	subi	r18, 0x0B	; 11
    1388:	23 30       	cpi	r18, 0x03	; 3
    138a:	70 f5       	brcc	.+92     	; 0x13e8 <GetSIRC15+0x82>
	{
		return;		//goto StartLook;
    138c:	40 e0       	ldi	r20, 0x00	; 0
    138e:	30 e0       	ldi	r19, 0x00	; 0
    1390:	60 e2       	ldi	r22, 0x20	; 32
    1392:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1394:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1396:	82 99       	sbic	0x10, 2	; 16
    1398:	fe cf       	rjmp	.-4      	; 0x1396 <GetSIRC15+0x30>
    139a:	20 e0       	ldi	r18, 0x00	; 0
    139c:	04 c0       	rjmp	.+8      	; 0x13a6 <GetSIRC15+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    139e:	2f 5f       	subi	r18, 0xFF	; 255
    13a0:	cb 01       	movw	r24, r22
    13a2:	01 97       	sbiw	r24, 0x01	; 1
    13a4:	f1 f7       	brne	.-4      	; 0x13a2 <GetSIRC15+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    13a6:	82 9b       	sbis	0x10, 2	; 16
    13a8:	fa cf       	rjmp	.-12     	; 0x139e <GetSIRC15+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    13aa:	26 30       	cpi	r18, 0x06	; 6
    13ac:	08 f0       	brcs	.+2      	; 0x13b0 <GetSIRC15+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    13ae:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    13b0:	4f 5f       	subi	r20, 0xFF	; 255
    13b2:	47 30       	cpi	r20, 0x07	; 7
    13b4:	79 f7       	brne	.-34     	; 0x1394 <GetSIRC15+0x2e>
    13b6:	30 93 ac 06 	sts	0x06AC, r19
    13ba:	40 e0       	ldi	r20, 0x00	; 0
    13bc:	30 e0       	ldi	r19, 0x00	; 0
    13be:	60 e2       	ldi	r22, 0x20	; 32
    13c0:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    13c2:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    13c4:	82 99       	sbic	0x10, 2	; 16
    13c6:	fe cf       	rjmp	.-4      	; 0x13c4 <GetSIRC15+0x5e>
    13c8:	20 e0       	ldi	r18, 0x00	; 0
    13ca:	04 c0       	rjmp	.+8      	; 0x13d4 <GetSIRC15+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    13cc:	2f 5f       	subi	r18, 0xFF	; 255
    13ce:	cb 01       	movw	r24, r22
    13d0:	01 97       	sbiw	r24, 0x01	; 1
    13d2:	f1 f7       	brne	.-4      	; 0x13d0 <GetSIRC15+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    13d4:	82 9b       	sbis	0x10, 2	; 16
    13d6:	fa cf       	rjmp	.-12     	; 0x13cc <GetSIRC15+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    13d8:	26 30       	cpi	r18, 0x06	; 6
    13da:	08 f0       	brcs	.+2      	; 0x13de <GetSIRC15+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    13dc:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
    13de:	4f 5f       	subi	r20, 0xFF	; 255
    13e0:	48 30       	cpi	r20, 0x08	; 8
    13e2:	79 f7       	brne	.-34     	; 0x13c2 <GetSIRC15+0x5c>
    13e4:	30 93 b1 06 	sts	0x06B1, r19
    13e8:	08 95       	ret

000013ea <GetSIRC20>:
{
	char x;
	char lTime;

//StartLook:
	irExtended = irAddress = irCommand = 0;
    13ea:	10 92 ac 06 	sts	0x06AC, r1
    13ee:	10 92 b1 06 	sts	0x06B1, r1
    13f2:	10 92 b3 06 	sts	0x06B3, r1

	while(irPin);				//wait for it to be low
    13f6:	82 99       	sbic	0x10, 2	; 16
    13f8:	fe cf       	rjmp	.-4      	; 0x13f6 <GetSIRC20+0xc>
    13fa:	20 e0       	ldi	r18, 0x00	; 0
    13fc:	40 e2       	ldi	r20, 0x20	; 32
    13fe:	53 e0       	ldi	r21, 0x03	; 3
    1400:	04 c0       	rjmp	.+8      	; 0x140a <GetSIRC20+0x20>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    1402:	2f 5f       	subi	r18, 0xFF	; 255
    1404:	ca 01       	movw	r24, r20
    1406:	01 97       	sbiw	r24, 0x01	; 1
    1408:	f1 f7       	brne	.-4      	; 0x1406 <GetSIRC20+0x1c>
	irExtended = irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    140a:	82 9b       	sbis	0x10, 2	; 16
    140c:	fa cf       	rjmp	.-12     	; 0x1402 <GetSIRC20+0x18>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    140e:	2b 50       	subi	r18, 0x0B	; 11
    1410:	23 30       	cpi	r18, 0x03	; 3
    1412:	08 f0       	brcs	.+2      	; 0x1416 <GetSIRC20+0x2c>
    1414:	45 c0       	rjmp	.+138    	; 0x14a0 <GetSIRC20+0xb6>
	{
		return;		//goto StartLook;
    1416:	40 e0       	ldi	r20, 0x00	; 0
    1418:	30 e0       	ldi	r19, 0x00	; 0
    141a:	60 e2       	ldi	r22, 0x20	; 32
    141c:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    141e:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1420:	82 99       	sbic	0x10, 2	; 16
    1422:	fe cf       	rjmp	.-4      	; 0x1420 <GetSIRC20+0x36>
    1424:	20 e0       	ldi	r18, 0x00	; 0
    1426:	04 c0       	rjmp	.+8      	; 0x1430 <GetSIRC20+0x46>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    1428:	2f 5f       	subi	r18, 0xFF	; 255
    142a:	cb 01       	movw	r24, r22
    142c:	01 97       	sbiw	r24, 0x01	; 1
    142e:	f1 f7       	brne	.-4      	; 0x142c <GetSIRC20+0x42>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1430:	82 9b       	sbis	0x10, 2	; 16
    1432:	fa cf       	rjmp	.-12     	; 0x1428 <GetSIRC20+0x3e>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1434:	26 30       	cpi	r18, 0x06	; 6
    1436:	08 f0       	brcs	.+2      	; 0x143a <GetSIRC20+0x50>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    1438:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    143a:	4f 5f       	subi	r20, 0xFF	; 255
    143c:	47 30       	cpi	r20, 0x07	; 7
    143e:	79 f7       	brne	.-34     	; 0x141e <GetSIRC20+0x34>
    1440:	30 93 ac 06 	sts	0x06AC, r19
    1444:	40 e0       	ldi	r20, 0x00	; 0
    1446:	30 e0       	ldi	r19, 0x00	; 0
    1448:	60 e2       	ldi	r22, 0x20	; 32
    144a:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    144c:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    144e:	82 99       	sbic	0x10, 2	; 16
    1450:	fe cf       	rjmp	.-4      	; 0x144e <GetSIRC20+0x64>
    1452:	20 e0       	ldi	r18, 0x00	; 0
    1454:	04 c0       	rjmp	.+8      	; 0x145e <GetSIRC20+0x74>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1456:	2f 5f       	subi	r18, 0xFF	; 255
    1458:	cb 01       	movw	r24, r22
    145a:	01 97       	sbiw	r24, 0x01	; 1
    145c:	f1 f7       	brne	.-4      	; 0x145a <GetSIRC20+0x70>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    145e:	82 9b       	sbis	0x10, 2	; 16
    1460:	fa cf       	rjmp	.-12     	; 0x1456 <GetSIRC20+0x6c>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1462:	26 30       	cpi	r18, 0x06	; 6
    1464:	08 f0       	brcs	.+2      	; 0x1468 <GetSIRC20+0x7e>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1466:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
    1468:	4f 5f       	subi	r20, 0xFF	; 255
    146a:	45 30       	cpi	r20, 0x05	; 5
    146c:	79 f7       	brne	.-34     	; 0x144c <GetSIRC20+0x62>
    146e:	30 93 b1 06 	sts	0x06B1, r19
    1472:	40 e0       	ldi	r20, 0x00	; 0
    1474:	30 e0       	ldi	r19, 0x00	; 0
    1476:	60 e2       	ldi	r22, 0x20	; 32
    1478:	73 e0       	ldi	r23, 0x03	; 3
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
		{
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1
    147a:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    147c:	82 99       	sbic	0x10, 2	; 16
    147e:	fe cf       	rjmp	.-4      	; 0x147c <GetSIRC20+0x92>
    1480:	20 e0       	ldi	r18, 0x00	; 0
    1482:	04 c0       	rjmp	.+8      	; 0x148c <GetSIRC20+0xa2>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1484:	2f 5f       	subi	r18, 0xFF	; 255
    1486:	cb 01       	movw	r24, r22
    1488:	01 97       	sbiw	r24, 0x01	; 1
    148a:	f1 f7       	brne	.-4      	; 0x1488 <GetSIRC20+0x9e>
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    148c:	82 9b       	sbis	0x10, 2	; 16
    148e:	fa cf       	rjmp	.-12     	; 0x1484 <GetSIRC20+0x9a>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1490:	26 30       	cpi	r18, 0x06	; 6
    1492:	08 f0       	brcs	.+2      	; 0x1496 <GetSIRC20+0xac>
				irExtended |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1494:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
    1496:	4f 5f       	subi	r20, 0xFF	; 255
    1498:	48 30       	cpi	r20, 0x08	; 8
    149a:	79 f7       	brne	.-34     	; 0x147a <GetSIRC20+0x90>
    149c:	30 93 b3 06 	sts	0x06B3, r19
    14a0:	08 95       	ret

000014a2 <__udivmodqi4>:
    14a2:	99 1b       	sub	r25, r25
    14a4:	79 e0       	ldi	r23, 0x09	; 9
    14a6:	04 c0       	rjmp	.+8      	; 0x14b0 <__udivmodqi4_ep>

000014a8 <__udivmodqi4_loop>:
    14a8:	99 1f       	adc	r25, r25
    14aa:	96 17       	cp	r25, r22
    14ac:	08 f0       	brcs	.+2      	; 0x14b0 <__udivmodqi4_ep>
    14ae:	96 1b       	sub	r25, r22

000014b0 <__udivmodqi4_ep>:
    14b0:	88 1f       	adc	r24, r24
    14b2:	7a 95       	dec	r23
    14b4:	c9 f7       	brne	.-14     	; 0x14a8 <__udivmodqi4_loop>
    14b6:	80 95       	com	r24
    14b8:	08 95       	ret

000014ba <__divmodhi4>:
    14ba:	97 fb       	bst	r25, 7
    14bc:	09 2e       	mov	r0, r25
    14be:	07 26       	eor	r0, r23
    14c0:	0a d0       	rcall	.+20     	; 0x14d6 <__divmodhi4_neg1>
    14c2:	77 fd       	sbrc	r23, 7
    14c4:	04 d0       	rcall	.+8      	; 0x14ce <__divmodhi4_neg2>
    14c6:	0c d0       	rcall	.+24     	; 0x14e0 <__udivmodhi4>
    14c8:	06 d0       	rcall	.+12     	; 0x14d6 <__divmodhi4_neg1>
    14ca:	00 20       	and	r0, r0
    14cc:	1a f4       	brpl	.+6      	; 0x14d4 <__divmodhi4_exit>

000014ce <__divmodhi4_neg2>:
    14ce:	70 95       	com	r23
    14d0:	61 95       	neg	r22
    14d2:	7f 4f       	sbci	r23, 0xFF	; 255

000014d4 <__divmodhi4_exit>:
    14d4:	08 95       	ret

000014d6 <__divmodhi4_neg1>:
    14d6:	f6 f7       	brtc	.-4      	; 0x14d4 <__divmodhi4_exit>
    14d8:	90 95       	com	r25
    14da:	81 95       	neg	r24
    14dc:	9f 4f       	sbci	r25, 0xFF	; 255
    14de:	08 95       	ret

000014e0 <__udivmodhi4>:
    14e0:	aa 1b       	sub	r26, r26
    14e2:	bb 1b       	sub	r27, r27
    14e4:	51 e1       	ldi	r21, 0x11	; 17
    14e6:	07 c0       	rjmp	.+14     	; 0x14f6 <__udivmodhi4_ep>

000014e8 <__udivmodhi4_loop>:
    14e8:	aa 1f       	adc	r26, r26
    14ea:	bb 1f       	adc	r27, r27
    14ec:	a6 17       	cp	r26, r22
    14ee:	b7 07       	cpc	r27, r23
    14f0:	10 f0       	brcs	.+4      	; 0x14f6 <__udivmodhi4_ep>
    14f2:	a6 1b       	sub	r26, r22
    14f4:	b7 0b       	sbc	r27, r23

000014f6 <__udivmodhi4_ep>:
    14f6:	88 1f       	adc	r24, r24
    14f8:	99 1f       	adc	r25, r25
    14fa:	5a 95       	dec	r21
    14fc:	a9 f7       	brne	.-22     	; 0x14e8 <__udivmodhi4_loop>
    14fe:	80 95       	com	r24
    1500:	90 95       	com	r25
    1502:	bc 01       	movw	r22, r24
    1504:	cd 01       	movw	r24, r26
    1506:	08 95       	ret

00001508 <itoa>:
    1508:	fb 01       	movw	r30, r22
    150a:	9f 01       	movw	r18, r30
    150c:	e8 94       	clt
    150e:	42 30       	cpi	r20, 0x02	; 2
    1510:	c4 f0       	brlt	.+48     	; 0x1542 <itoa+0x3a>
    1512:	45 32       	cpi	r20, 0x25	; 37
    1514:	b4 f4       	brge	.+44     	; 0x1542 <itoa+0x3a>
    1516:	4a 30       	cpi	r20, 0x0A	; 10
    1518:	29 f4       	brne	.+10     	; 0x1524 <itoa+0x1c>
    151a:	97 fb       	bst	r25, 7
    151c:	1e f4       	brtc	.+6      	; 0x1524 <itoa+0x1c>
    151e:	90 95       	com	r25
    1520:	81 95       	neg	r24
    1522:	9f 4f       	sbci	r25, 0xFF	; 255
    1524:	64 2f       	mov	r22, r20
    1526:	77 27       	eor	r23, r23
    1528:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <__udivmodhi4>
    152c:	80 5d       	subi	r24, 0xD0	; 208
    152e:	8a 33       	cpi	r24, 0x3A	; 58
    1530:	0c f0       	brlt	.+2      	; 0x1534 <itoa+0x2c>
    1532:	89 5d       	subi	r24, 0xD9	; 217
    1534:	81 93       	st	Z+, r24
    1536:	cb 01       	movw	r24, r22
    1538:	00 97       	sbiw	r24, 0x00	; 0
    153a:	a1 f7       	brne	.-24     	; 0x1524 <itoa+0x1c>
    153c:	16 f4       	brtc	.+4      	; 0x1542 <itoa+0x3a>
    153e:	5d e2       	ldi	r21, 0x2D	; 45
    1540:	51 93       	st	Z+, r21
    1542:	10 82       	st	Z, r1
    1544:	c9 01       	movw	r24, r18
    1546:	0c 94 14 0b 	jmp	0x1628	; 0x1628 <strrev>

0000154a <ltoa>:
    154a:	fa 01       	movw	r30, r20
    154c:	cf 93       	push	r28
    154e:	ff 93       	push	r31
    1550:	ef 93       	push	r30
    1552:	22 30       	cpi	r18, 0x02	; 2
    1554:	44 f1       	brlt	.+80     	; 0x15a6 <ltoa+0x5c>
    1556:	25 32       	cpi	r18, 0x25	; 37
    1558:	34 f5       	brge	.+76     	; 0x15a6 <ltoa+0x5c>
    155a:	c2 2f       	mov	r28, r18
    155c:	e8 94       	clt
    155e:	ca 30       	cpi	r28, 0x0A	; 10
    1560:	49 f4       	brne	.+18     	; 0x1574 <ltoa+0x2a>
    1562:	97 fb       	bst	r25, 7
    1564:	3e f4       	brtc	.+14     	; 0x1574 <ltoa+0x2a>
    1566:	90 95       	com	r25
    1568:	80 95       	com	r24
    156a:	70 95       	com	r23
    156c:	61 95       	neg	r22
    156e:	7f 4f       	sbci	r23, 0xFF	; 255
    1570:	8f 4f       	sbci	r24, 0xFF	; 255
    1572:	9f 4f       	sbci	r25, 0xFF	; 255
    1574:	2c 2f       	mov	r18, r28
    1576:	33 27       	eor	r19, r19
    1578:	44 27       	eor	r20, r20
    157a:	55 27       	eor	r21, r21
    157c:	ff 93       	push	r31
    157e:	ef 93       	push	r30
    1580:	0e 94 24 0b 	call	0x1648	; 0x1648 <__udivmodsi4>
    1584:	ef 91       	pop	r30
    1586:	ff 91       	pop	r31
    1588:	60 5d       	subi	r22, 0xD0	; 208
    158a:	6a 33       	cpi	r22, 0x3A	; 58
    158c:	0c f0       	brlt	.+2      	; 0x1590 <ltoa+0x46>
    158e:	69 5d       	subi	r22, 0xD9	; 217
    1590:	61 93       	st	Z+, r22
    1592:	b9 01       	movw	r22, r18
    1594:	ca 01       	movw	r24, r20
    1596:	60 50       	subi	r22, 0x00	; 0
    1598:	70 40       	sbci	r23, 0x00	; 0
    159a:	80 40       	sbci	r24, 0x00	; 0
    159c:	90 40       	sbci	r25, 0x00	; 0
    159e:	51 f7       	brne	.-44     	; 0x1574 <ltoa+0x2a>
    15a0:	16 f4       	brtc	.+4      	; 0x15a6 <ltoa+0x5c>
    15a2:	cd e2       	ldi	r28, 0x2D	; 45
    15a4:	c1 93       	st	Z+, r28
    15a6:	10 82       	st	Z, r1
    15a8:	8f 91       	pop	r24
    15aa:	9f 91       	pop	r25
    15ac:	cf 91       	pop	r28
    15ae:	0c 94 14 0b 	jmp	0x1628	; 0x1628 <strrev>

000015b2 <ultoa>:
    15b2:	fa 01       	movw	r30, r20
    15b4:	cf 93       	push	r28
    15b6:	ff 93       	push	r31
    15b8:	ef 93       	push	r30
    15ba:	22 30       	cpi	r18, 0x02	; 2
    15bc:	cc f0       	brlt	.+50     	; 0x15f0 <ultoa+0x3e>
    15be:	25 32       	cpi	r18, 0x25	; 37
    15c0:	bc f4       	brge	.+46     	; 0x15f0 <ultoa+0x3e>
    15c2:	c2 2f       	mov	r28, r18
    15c4:	2c 2f       	mov	r18, r28
    15c6:	33 27       	eor	r19, r19
    15c8:	44 27       	eor	r20, r20
    15ca:	55 27       	eor	r21, r21
    15cc:	ff 93       	push	r31
    15ce:	ef 93       	push	r30
    15d0:	0e 94 24 0b 	call	0x1648	; 0x1648 <__udivmodsi4>
    15d4:	ef 91       	pop	r30
    15d6:	ff 91       	pop	r31
    15d8:	60 5d       	subi	r22, 0xD0	; 208
    15da:	6a 33       	cpi	r22, 0x3A	; 58
    15dc:	0c f0       	brlt	.+2      	; 0x15e0 <ultoa+0x2e>
    15de:	69 5d       	subi	r22, 0xD9	; 217
    15e0:	61 93       	st	Z+, r22
    15e2:	b9 01       	movw	r22, r18
    15e4:	ca 01       	movw	r24, r20
    15e6:	60 50       	subi	r22, 0x00	; 0
    15e8:	70 40       	sbci	r23, 0x00	; 0
    15ea:	80 40       	sbci	r24, 0x00	; 0
    15ec:	90 40       	sbci	r25, 0x00	; 0
    15ee:	51 f7       	brne	.-44     	; 0x15c4 <ultoa+0x12>
    15f0:	10 82       	st	Z, r1
    15f2:	8f 91       	pop	r24
    15f4:	9f 91       	pop	r25
    15f6:	cf 91       	pop	r28
    15f8:	0c 94 14 0b 	jmp	0x1628	; 0x1628 <strrev>

000015fc <utoa>:
    15fc:	fb 01       	movw	r30, r22
    15fe:	9f 01       	movw	r18, r30
    1600:	42 30       	cpi	r20, 0x02	; 2
    1602:	74 f0       	brlt	.+28     	; 0x1620 <utoa+0x24>
    1604:	45 32       	cpi	r20, 0x25	; 37
    1606:	64 f4       	brge	.+24     	; 0x1620 <utoa+0x24>
    1608:	64 2f       	mov	r22, r20
    160a:	77 27       	eor	r23, r23
    160c:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <__udivmodhi4>
    1610:	80 5d       	subi	r24, 0xD0	; 208
    1612:	8a 33       	cpi	r24, 0x3A	; 58
    1614:	0c f0       	brlt	.+2      	; 0x1618 <utoa+0x1c>
    1616:	89 5d       	subi	r24, 0xD9	; 217
    1618:	81 93       	st	Z+, r24
    161a:	cb 01       	movw	r24, r22
    161c:	00 97       	sbiw	r24, 0x00	; 0
    161e:	a1 f7       	brne	.-24     	; 0x1608 <utoa+0xc>
    1620:	10 82       	st	Z, r1
    1622:	c9 01       	movw	r24, r18
    1624:	0c 94 14 0b 	jmp	0x1628	; 0x1628 <strrev>

00001628 <strrev>:
    1628:	dc 01       	movw	r26, r24
    162a:	fc 01       	movw	r30, r24
    162c:	67 2f       	mov	r22, r23
    162e:	71 91       	ld	r23, Z+
    1630:	77 23       	and	r23, r23
    1632:	e1 f7       	brne	.-8      	; 0x162c <strrev+0x4>
    1634:	32 97       	sbiw	r30, 0x02	; 2
    1636:	04 c0       	rjmp	.+8      	; 0x1640 <strrev+0x18>
    1638:	7c 91       	ld	r23, X
    163a:	6d 93       	st	X+, r22
    163c:	70 83       	st	Z, r23
    163e:	62 91       	ld	r22, -Z
    1640:	ae 17       	cp	r26, r30
    1642:	bf 07       	cpc	r27, r31
    1644:	c8 f3       	brcs	.-14     	; 0x1638 <strrev+0x10>
    1646:	08 95       	ret

00001648 <__udivmodsi4>:
    1648:	a1 e2       	ldi	r26, 0x21	; 33
    164a:	1a 2e       	mov	r1, r26
    164c:	aa 1b       	sub	r26, r26
    164e:	bb 1b       	sub	r27, r27
    1650:	fd 01       	movw	r30, r26
    1652:	0d c0       	rjmp	.+26     	; 0x166e <__udivmodsi4_ep>

00001654 <__udivmodsi4_loop>:
    1654:	aa 1f       	adc	r26, r26
    1656:	bb 1f       	adc	r27, r27
    1658:	ee 1f       	adc	r30, r30
    165a:	ff 1f       	adc	r31, r31
    165c:	a2 17       	cp	r26, r18
    165e:	b3 07       	cpc	r27, r19
    1660:	e4 07       	cpc	r30, r20
    1662:	f5 07       	cpc	r31, r21
    1664:	20 f0       	brcs	.+8      	; 0x166e <__udivmodsi4_ep>
    1666:	a2 1b       	sub	r26, r18
    1668:	b3 0b       	sbc	r27, r19
    166a:	e4 0b       	sbc	r30, r20
    166c:	f5 0b       	sbc	r31, r21

0000166e <__udivmodsi4_ep>:
    166e:	66 1f       	adc	r22, r22
    1670:	77 1f       	adc	r23, r23
    1672:	88 1f       	adc	r24, r24
    1674:	99 1f       	adc	r25, r25
    1676:	1a 94       	dec	r1
    1678:	69 f7       	brne	.-38     	; 0x1654 <__udivmodsi4_loop>
    167a:	60 95       	com	r22
    167c:	70 95       	com	r23
    167e:	80 95       	com	r24
    1680:	90 95       	com	r25
    1682:	9b 01       	movw	r18, r22
    1684:	ac 01       	movw	r20, r24
    1686:	bd 01       	movw	r22, r26
    1688:	cf 01       	movw	r24, r30
    168a:	08 95       	ret

0000168c <_exit>:
    168c:	f8 94       	cli

0000168e <__stop_program>:
    168e:	ff cf       	rjmp	.-2      	; 0x168e <__stop_program>
