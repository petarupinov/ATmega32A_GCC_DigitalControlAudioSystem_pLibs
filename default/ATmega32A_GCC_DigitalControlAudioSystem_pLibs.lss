
ATmega32A_GCC_DigitalControlAudioSystem_pLibs.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000181a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000734  00800060  0000181a  000018ae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002b  00800794  00800794  00001fe2  2**0
                  ALLOC
  3 .debug_aranges 00000180  00000000  00000000  00001fe2  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000a89  00000000  00000000  00002162  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002f41  00000000  00000000  00002beb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d5e  00000000  00000000  00005b2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002a4d  00000000  00000000  0000688a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007d0  00000000  00000000  000092d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000ba3  00000000  00000000  00009aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000e1e  00000000  00000000  0000a64b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000798  00000000  00000000  0000b469  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 35 05 	jmp	0xa6a	; 0xa6a <__vector_1>
       8:	0c 94 97 00 	jmp	0x12e	; 0x12e <__vector_2>
       c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__vector_3>
      10:	0c 94 ab 00 	jmp	0x156	; 0x156 <__vector_4>
      14:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	17 e0       	ldi	r17, 0x07	; 7
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e1       	ldi	r30, 0x1A	; 26
      68:	f8 e1       	ldi	r31, 0x18	; 24
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 39       	cpi	r26, 0x94	; 148
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a4 e9       	ldi	r26, 0x94	; 148
      7a:	b7 e0       	ldi	r27, 0x07	; 7
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 3b       	cpi	r26, 0xBF	; 191
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 60 04 	call	0x8c0	; 0x8c0 <main>
      8a:	0c 94 0b 0c 	jmp	0x1816	; 0x1816 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <port_init>:
*****************************************/
void port_init(void)
{	

// PORT A connections
	DDRA  = 0b11111111;		//  PA7:U8/PGA2310,CS; PA6:U7/PGA2310,CS; PA5:CON2LCD,RS; PA4:CON2LCD,RW; PA3:CON2LCD,E; PA2:U2/74HC595,RCLK(LCD); PA1:U2/74HC595,SCLK(LCD); PA0:U2/74HC595,DATA(LCD);
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	8a bb       	out	0x1a, r24	; 26
	PORTA = 0b00000000;		//	Interfaces: NOT USED. PULLUP DISABLE in PORTA.
      96:	1b ba       	out	0x1b, r1	; 27

// PORT B connections
	DDRB  = 0b10111000;		//  PB7:U6,U7,U8/PGA2310,SCLK; PB6:U6,U7,U8/PGA2310,SDO(CON33,36,39); PB5:U6,U7,U8/PGA2310,SDI; PB4:U12/74HC595,DATA(REL_OUT); PB3:U6/PGA2310,CS; PB2:CON8/BUTTON,"ESCAPE",INT2; PB1:CON5/BUTTON,"ON/OFF"; PB0:CON14TempSensor/DS18S20,DQ,IN/OUT;
      98:	88 eb       	ldi	r24, 0xB8	; 184
      9a:	87 bb       	out	0x17, r24	; 23
	PORTB = 0b00000111;		//	Interfaces: EXTERNAL INTERRUPT 2; SPI. set pullup to IRTSOP2240 / BUTTON(on/off) / DS18s20.
      9c:	87 e0       	ldi	r24, 0x07	; 7
      9e:	88 bb       	out	0x18, r24	; 24

// PORT C connections
	DDRC  = 0b11001100;		//  PC7:U10/74HC595,DATA(REL_IN); PC6:U10/74HC595,SCLK(REL_IN); PC5:EncoderED1112S,A; PC4:EncoderED1112S,B; PC3:U10/74HC595,RCLK(REL_IN); PC2:Q2/BD237(RELAY_POWER_SUPPLY); PC1:DS1307/24C64,I2C/SDA; PC0:DS1307/24C64,I2C/SCL;
      a0:	8c ec       	ldi	r24, 0xCC	; 204
      a2:	84 bb       	out	0x14, r24	; 20
	PORTC = 0b00000000;		//	Interfaces: I2C. PULLUP DISABLE in PORTC.
      a4:	15 ba       	out	0x15, r1	; 21

// PORT D connections
	DDRD  = 0b11110000;		//  PD7:U12/74HC595,RCLK(REL_OUT); PD6:U12/74HC595,SCLK(REL_OUT); PD5:Q1/BD237(FAN_CONTROL_PWM); PD4:LED5/"ON/OFF AUDIO SYSTEM"; PD3:CON11/EncoderBUTTON,"MENU/ENTER"/INT1; PD2:CON12/IR/TSOP2240,/INT0; PD1:CON14/MAX232,UART/TXD; PD0:CON14/MAX232,UART/RXD;
      a6:	80 ef       	ldi	r24, 0xF0	; 240
      a8:	81 bb       	out	0x11, r24	; 17
	PORTD = 0b00001100;		//	Interfaces: TIMER1; UART/USART; EXTERNAL INTERRUPT 0, 1. PULLUP DISABLE in PORTD.
      aa:	8c e0       	ldi	r24, 0x0C	; 12
      ac:	82 bb       	out	0x12, r24	; 18
//	DDRD&=~_BV(0);// DDD0 = "0"  (DDD0=DDRD nulev bit) set PORTD pin0 to zero as input
//	PORTD|=_BV(0);// PD0  = "1"  Enable pull up
//	PORTD|=_BV(1);// PD1  = "1"  led
//	DDRD|=_BV(1); // DDD1 = "1"  (DDD1=DDRD parvi bit) set PORTD pin1 to one as output

}
      ae:	08 95       	ret

000000b0 <ext0_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 0 **
*******************************************/
void ext0_intrpt_init(void)
{
	MCUCR = 0b00000010;	// SETUP EXT INT 0, ISC01 = 1, ISC00 = 0: Falling edge on INT0 activates the interrupt; ISC01 = 1, ISC00 = 1: Rising edge on INT0 activates the interrupt;
      b0:	82 e0       	ldi	r24, 0x02	; 2
      b2:	85 bf       	out	0x35, r24	; 53

// IN FUNCTIONS:
//	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
//	GIFR   = 0b01000000;	// Clear INT0 flag.
}
      b4:	08 95       	ret

000000b6 <ext0_intrpt_on>:
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      b6:	80 e4       	ldi	r24, 0x40	; 64
      b8:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      ba:	8a bf       	out	0x3a, r24	; 58
}
      bc:	08 95       	ret

000000be <ext0_intrpt_off>:
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      be:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      c0:	80 e4       	ldi	r24, 0x40	; 64
      c2:	8a bf       	out	0x3a, r24	; 58
}
      c4:	08 95       	ret

000000c6 <ext1_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 1 **
*******************************************/
void ext1_intrpt_init(void)
{
}
      c6:	08 95       	ret

000000c8 <ext2_intrpt_init>:
//	MCUCSR = 0b00000000;	// SETUP EXT INT 2, ISC2 = 0: Falling edge on INT2 activates the interrupt; ISC2 = 1: Rising edge on INT2 activates the interrupt;

// IN FUNCTIONS:
//	GICR   = 0b00100000;	// INT2 = 0: Disable External Interrupt on INT2; INT2 = 1: Enable External Interrupt on INT2;
//	GIFR   = 0b00100000;	// Clear INT2 flag.
}
      c8:	08 95       	ret

000000ca <timer1_init>:
*****************************/
void timer1_init(void)
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  = 0b00000000;	// maskov registar za prekasvaniq
      ca:	19 be       	out	0x39, r1	; 57
	TCNT1H = 0b00000000;
      cc:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
      ce:	1c bc       	out	0x2c, r1	; 44

//	OCR1BH = 100; //20;			// 0   = 0b00000000 (DEC = BIN)	// LED
//	OCR1BL = 100; //20;			// 200 = 0b11001000 (DEC = BIN)	// LED

//	TIMSK = (1 << OCIE1A);
}
      d0:	08 95       	ret

000000d2 <timer2_init>:
/*****************************
** INITIZLIZATION OF TIMER2 **
*****************************/
void timer2_init(void)
{
	SFIOR = 0b00000010;		// Prescaler Reset Timer2 (bit1 –> PSR2)
      d2:	82 e0       	ldi	r24, 0x02	; 2
      d4:	80 bf       	out	0x30, r24	; 48
	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      d6:	81 e8       	ldi	r24, 0x81	; 129
      d8:	85 bd       	out	0x25, r24	; 37
	OCR2 = 0; // FAN PWM ON
      da:	13 bc       	out	0x23, r1	; 35
}
      dc:	08 95       	ret

000000de <timer1_on_speed>:
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      de:	81 ea       	ldi	r24, 0xA1	; 161
      e0:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
      e2:	81 e0       	ldi	r24, 0x01	; 1
      e4:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
      e6:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
      e8:	80 91 4f 07 	lds	r24, 0x074F
      ec:	e0 e5       	ldi	r30, 0x50	; 80
      ee:	f7 e0       	ldi	r31, 0x07	; 7
      f0:	e8 0f       	add	r30, r24
      f2:	f1 1d       	adc	r31, r1
      f4:	80 81       	ld	r24, Z
      f6:	8a bd       	out	0x2a, r24	; 42

// CHANNEL B
//	OCR1BH = 0; // LED PWM ON				// out	OCR1BH, r16		; 0   = 0b00000000 (DEC = BIN)
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}
      f8:	08 95       	ret

000000fa <timer1_off>:

void timer1_off(void)
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
      fa:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
      fc:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
      fe:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     100:	1a bc       	out	0x2a, r1	; 42

//	OCR1BH = 0; // LED PWM OFF
//	OCR1BL = 0; // LED PWM OFF
}
     102:	08 95       	ret

00000104 <fan_pwm_control_speed>:
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     104:	81 ea       	ldi	r24, 0xA1	; 161
     106:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     108:	81 e0       	ldi	r24, 0x01	; 1
     10a:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     10c:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     10e:	80 91 4f 07 	lds	r24, 0x074F
     112:	e0 e5       	ldi	r30, 0x50	; 80
     114:	f7 e0       	ldi	r31, 0x07	; 7
     116:	e8 0f       	add	r30, r24
     118:	f1 1d       	adc	r31, r1
     11a:	80 81       	ld	r24, Z
     11c:	8a bd       	out	0x2a, r24	; 42
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
}
     11e:	08 95       	ret

00000120 <fan_pwm_off>:
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}

void timer1_off(void)
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     120:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     122:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     124:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     126:	1a bc       	out	0x2a, r1	; 42
	timer1_on_speed();
}
void fan_pwm_off(void)
{
	timer1_off();
}
     128:	08 95       	ret

0000012a <timer2_on>:
***************************************/
void timer2_on(void)	// Timer2 On
{
//	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
//	OCR2 = 1; // FAN PWM ON
}
     12a:	08 95       	ret

0000012c <timer2_off>:

void timer2_off(void)	// Timer2 Off
{
//	TCCR2 = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
//	OCR2 = 0; // FAN PWM OFF
}
     12c:	08 95       	ret

0000012e <__vector_2>:

/*****************************************
**** EXTERNAL INTERRUPT 1 VECTOR 02 ******
*****************************************/
ISR(INT1_vect)
{
     12e:	1f 92       	push	r1
     130:	0f 92       	push	r0
     132:	0f b6       	in	r0, 0x3f	; 63
     134:	0f 92       	push	r0
     136:	11 24       	eor	r1, r1
}
     138:	0f 90       	pop	r0
     13a:	0f be       	out	0x3f, r0	; 63
     13c:	0f 90       	pop	r0
     13e:	1f 90       	pop	r1
     140:	18 95       	reti

00000142 <__vector_3>:

/*****************************************
**** EXTERNAL INTERRUPT 2 VECTOR 03 ******
*****************************************/
ISR(INT2_vect)
{
     142:	1f 92       	push	r1
     144:	0f 92       	push	r0
     146:	0f b6       	in	r0, 0x3f	; 63
     148:	0f 92       	push	r0
     14a:	11 24       	eor	r1, r1
}
     14c:	0f 90       	pop	r0
     14e:	0f be       	out	0x3f, r0	; 63
     150:	0f 90       	pop	r0
     152:	1f 90       	pop	r1
     154:	18 95       	reti

00000156 <__vector_4>:

/*****************************************
**** TIMER 2 OUTPUT COMPARE VECTOR 04 ****
*****************************************/
ISR(TIMER2_COMP_vect)
{
     156:	1f 92       	push	r1
     158:	0f 92       	push	r0
     15a:	0f b6       	in	r0, 0x3f	; 63
     15c:	0f 92       	push	r0
     15e:	11 24       	eor	r1, r1
}
     160:	0f 90       	pop	r0
     162:	0f be       	out	0x3f, r0	; 63
     164:	0f 90       	pop	r0
     166:	1f 90       	pop	r1
     168:	18 95       	reti

0000016a <__vector_5>:

/*****************************************
**** TIMER 2 OVERFLOW VECTOR 05 **********
*****************************************/
ISR(TIMER2_OVF_vect)
{
     16a:	1f 92       	push	r1
     16c:	0f 92       	push	r0
     16e:	0f b6       	in	r0, 0x3f	; 63
     170:	0f 92       	push	r0
     172:	11 24       	eor	r1, r1
}
     174:	0f 90       	pop	r0
     176:	0f be       	out	0x3f, r0	; 63
     178:	0f 90       	pop	r0
     17a:	1f 90       	pop	r1
     17c:	18 95       	reti

0000017e <about>:

	return temper;
}

void about(void)
{
     17e:	0f 93       	push	r16
     180:	1f 93       	push	r17
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] =====================================================\r\n");
     182:	00 e6       	ldi	r16, 0x60	; 96
     184:	10 e0       	ldi	r17, 0x00	; 0
     186:	c8 01       	movw	r24, r16
     188:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartString("[UART INFO] \tAuthors and creators: P.Upinov and P.Stoyanov\r\n");
     18c:	84 ea       	ldi	r24, 0xA4	; 164
     18e:	90 e0       	ldi	r25, 0x00	; 0
     190:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartString("[UART INFO] \tDevice name: Digital Control Audio System\r\n");
     194:	81 ee       	ldi	r24, 0xE1	; 225
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartString("[UART INFO] \tFirmware version beta ");
     19c:	8a e1       	ldi	r24, 0x1A	; 26
     19e:	91 e0       	ldi	r25, 0x01	; 1
     1a0:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartInt(FIRMWARE_VERSION);
     1a4:	8f e1       	ldi	r24, 0x1F	; 31
     1a6:	90 e0       	ldi	r25, 0x00	; 0
     1a8:	0e 94 cf 08 	call	0x119e	; 0x119e <transmitUartInt>
		transmitUartString("\r\n");
     1ac:	8e e3       	ldi	r24, 0x3E	; 62
     1ae:	91 e0       	ldi	r25, 0x01	; 1
     1b0:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartString("[UART INFO] =====================================================\r\n");
     1b4:	c8 01       	movw	r24, r16
     1b6:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartString("[UART INFO] Da dobavq upravlenie na:\
     1ba:	81 e4       	ldi	r24, 0x41	; 65
     1bc:	91 e0       	ldi	r25, 0x01	; 1
     1be:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
						\r\n[UART INFO] - FAN smart controlling			\
						\r\n[UART INFO] - DS18S20						\
						\r\n[UART INFO] - RTC							\
						\r\n[UART INFO] - Memory\r\n");
	#endif
}
     1c2:	1f 91       	pop	r17
     1c4:	0f 91       	pop	r16
     1c6:	08 95       	ret

000001c8 <init_all>:
*********************************** START OF APPLICATION ************************************
********************************************************************************************/

void init_all()
{
	port_init();		// IO init and configure all port
     1c8:	0e 94 49 00 	call	0x92	; 0x92 <port_init>
*****************************/
void timer1_init(void)
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  = 0b00000000;	// maskov registar za prekasvaniq
     1cc:	19 be       	out	0x39, r1	; 57
	TCNT1H = 0b00000000;
     1ce:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
     1d0:	1c bc       	out	0x2c, r1	; 44
void init_all()
{
	port_init();		// IO init and configure all port
	timer1_init();		// FAN INIT
//	timer2_init();
	LCD_INIT();			// LCD init and reset all lcd contain
     1d2:	0e 94 36 07 	call	0xe6c	; 0xe6c <LCD_INIT>
	uart_init();		// UART debug init
     1d6:	0e 94 86 08 	call	0x110c	; 0x110c <uart_init>
	about();			// Any debug important information
     1da:	0e 94 bf 00 	call	0x17e	; 0x17e <about>

	pga2310_init();		// SPI init and reset all (U6, U7, U8) PGA2310 volume values to null
     1de:	0e 94 2b 08 	call	0x1056	; 0x1056 <pga2310_init>
	relays_in_init();	// nujno e daden reset be da bade izkliuche usilvatelq, togava reletata za vhod i izhod (bez power relay) sa ostanali vkliucheni
     1e2:	0e 94 0b 0a 	call	0x1416	; 0x1416 <relays_in_init>
	relays_out_init();	// nujno e daden reset be da bade izkliuche usilvatelq, togava reletata za vhod i izhod (bez power relay)sa ostanali vkliucheni
     1e6:	0e 94 32 0a 	call	0x1464	; 0x1464 <relays_out_init>


}
     1ea:	08 95       	ret

000001ec <temperMeasur>:
	}
	return 0;
}

char temperMeasur(unsigned char byte0, unsigned char byte1, unsigned char byte6, unsigned char byte7)
{
     1ec:	1f 93       	push	r17
	char tC = 0;
	char temper = 0;
	double k = 0;
	double j = 0;

	byte0 = storeTemp [0];
     1ee:	10 91 96 07 	lds	r17, 0x0796
	byte1 = storeTemp [1];
     1f2:	80 91 97 07 	lds	r24, 0x0797
	byte6 = storeTemp [6];
	byte7 = storeTemp [7];

	k = ((byte7 - byte6) / byte7) + 0.25;

	if((byte1 == 0x00) && (byte0 == 0x00))
     1f6:	88 23       	and	r24, r24
     1f8:	61 f5       	brne	.+88     	; 0x252 <temperMeasur+0x66>
     1fa:	11 23       	and	r17, r17
     1fc:	79 f4       	brne	.+30     	; 0x21c <temperMeasur+0x30>
	{
		tC = (byte0/2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     1fe:	85 ef       	ldi	r24, 0xF5	; 245
     200:	91 e0       	ldi	r25, 0x01	; 1
     202:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     206:	80 e0       	ldi	r24, 0x00	; 0
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	0e 94 cf 08 	call	0x119e	; 0x119e <transmitUartInt>
		transmitUartString(".0 C\r\n");			// uart debug information string
     20e:	8f e0       	ldi	r24, 0x0F	; 15
     210:	92 e0       	ldi	r25, 0x02	; 2
     212:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     216:	80 e0       	ldi	r24, 0x00	; 0
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	13 c0       	rjmp	.+38     	; 0x242 <temperMeasur+0x56>
	LCD_DATA_STRING(".0 C");		//
	}
	else if((byte1 == 0x00) && (byte0 != 0x00))
	{
		transmitUartString("+");
     21c:	8b e1       	ldi	r24, 0x1B	; 27
     21e:	92 e0       	ldi	r25, 0x02	; 2
     220:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		tC = (byte0/2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     224:	85 ef       	ldi	r24, 0xF5	; 245
     226:	91 e0       	ldi	r25, 0x01	; 1
     228:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     22c:	16 95       	lsr	r17
     22e:	81 2f       	mov	r24, r17
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	0e 94 cf 08 	call	0x119e	; 0x119e <transmitUartInt>
		transmitUartString(".0 C\r\n");			// uart debug information string
     236:	8f e0       	ldi	r24, 0x0F	; 15
     238:	92 e0       	ldi	r25, 0x02	; 2
     23a:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     23e:	81 2f       	mov	r24, r17
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <LCD_DATA_INT>
	LCD_DATA_STRING(".0 C");		//
     246:	86 e1       	ldi	r24, 0x16	; 22
     248:	92 e0       	ldi	r25, 0x02	; 2
     24a:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
     24e:	80 e0       	ldi	r24, 0x00	; 0
     250:	1b c0       	rjmp	.+54     	; 0x288 <temperMeasur+0x9c>
	}
	else if((byte1 == 0xFF) && (byte0 != 0x00))
     252:	8f 3f       	cpi	r24, 0xFF	; 255
     254:	a1 f4       	brne	.+40     	; 0x27e <temperMeasur+0x92>
     256:	11 23       	and	r17, r17
     258:	91 f0       	breq	.+36     	; 0x27e <temperMeasur+0x92>
	{
		transmitUartString("-");
     25a:	8d e1       	ldi	r24, 0x1D	; 29
     25c:	92 e0       	ldi	r25, 0x02	; 2
     25e:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
//		tC = ((byte0 - 255.5) / 2);		// ne e dobre obraboteno za otricatelni chisla
		tC = ((byte0 - 255) / 2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     262:	85 ef       	ldi	r24, 0xF5	; 245
     264:	91 e0       	ldi	r25, 0x01	; 1
     266:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     26a:	81 2f       	mov	r24, r17
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	8f 5f       	subi	r24, 0xFF	; 255
     270:	90 40       	sbci	r25, 0x00	; 0
     272:	62 e0       	ldi	r22, 0x02	; 2
     274:	70 e0       	ldi	r23, 0x00	; 0
     276:	0e 94 22 0b 	call	0x1644	; 0x1644 <__divmodhi4>
     27a:	16 2f       	mov	r17, r22
     27c:	d8 cf       	rjmp	.-80     	; 0x22e <temperMeasur+0x42>
	}
	else
	{
		//lcdDataString("ERROR!");	// ERROR not return to display!!!!
	#ifdef DEBUG_ERROR
		transmitUartString("[UART ERROR] ERROR TEMPERATURE\r\n");		// uart debug information string
     27e:	8f e1       	ldi	r24, 0x1F	; 31
     280:	92 e0       	ldi	r25, 0x02	; 2
     282:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
     286:	81 e0       	ldi	r24, 0x01	; 1
	#endif
		return 1;
	}

	return temper;
}
     288:	1f 91       	pop	r17
     28a:	08 95       	ret

0000028c <oneWireRight>:
	}
	return 0;
}

unsigned char oneWireRight()
{
     28c:	0f 93       	push	r16
     28e:	1f 93       	push	r17
     290:	cf 93       	push	r28
     292:	df 93       	push	r29
	unsigned char i;

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
     294:	80 e4       	ldi	r24, 0x40	; 64
     296:	92 e0       	ldi	r25, 0x02	; 2
     298:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     29c:	0e 94 c8 05 	call	0xb90	; 0xb90 <reset>
     2a0:	88 23       	and	r24, r24
     2a2:	81 f1       	breq	.+96     	; 0x304 <oneWireRight+0x78>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     2a4:	85 e5       	ldi	r24, 0x55	; 85
     2a6:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
     2aa:	07 e4       	ldi	r16, 0x47	; 71
     2ac:	17 e0       	ldi	r17, 0x07	; 7
     2ae:	e8 01       	movw	r28, r16
		for(i=0; i<8; i++)
		{
			write_byte(rightTempSensorRomCode[i]);	// 64-bit ROM CODE
     2b0:	89 91       	ld	r24, Y+
     2b2:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
		transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
	{
		write_byte(0x55);	// Master issues Match ROM command.
		for(i=0; i<8; i++)
     2b6:	87 e0       	ldi	r24, 0x07	; 7
     2b8:	cf 34       	cpi	r28, 0x4F	; 79
     2ba:	d8 07       	cpc	r29, r24
     2bc:	c9 f7       	brne	.-14     	; 0x2b0 <oneWireRight+0x24>
		write_byte(0x08);	// Byte 5
		write_byte(0x00);	// Byte 6
		write_byte(0xB1);	// Byte 7
		// 64-bit ROM CODE
*/
		write_byte(0x44);	// Master issues Convert T command.
     2be:	84 e4       	ldi	r24, 0x44	; 68
     2c0:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     2c4:	0e 94 44 06 	call	0xc88	; 0xc88 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     2c8:	0e 94 c8 05 	call	0xb90	; 0xb90 <reset>
     2cc:	88 23       	and	r24, r24
     2ce:	d1 f0       	breq	.+52     	; 0x304 <oneWireRight+0x78>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     2d0:	85 e5       	ldi	r24, 0x55	; 85
     2d2:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
			for(i=0; i<8; i++)
			{
				write_byte(rightTempSensorRomCode[i]);	// 64-bit ROM CODE
     2d6:	f8 01       	movw	r30, r16
     2d8:	81 91       	ld	r24, Z+
     2da:	8f 01       	movw	r16, r30
     2dc:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
		write_byte(0x44);	// Master issues Convert T command.
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
		{
			write_byte(0x55);	// Master issues Match ROM command.
			for(i=0; i<8; i++)
     2e0:	f7 e0       	ldi	r31, 0x07	; 7
     2e2:	0f 34       	cpi	r16, 0x4F	; 79
     2e4:	1f 07       	cpc	r17, r31
     2e6:	b9 f7       	brne	.-18     	; 0x2d6 <oneWireRight+0x4a>
			write_byte(0x08);	// Byte 5
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
     2e8:	8e eb       	ldi	r24, 0xBE	; 190
     2ea:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
     2ee:	c6 e9       	ldi	r28, 0x96	; 150
     2f0:	d7 e0       	ldi	r29, 0x07	; 7
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     2f2:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <read_byte>
     2f6:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     2f8:	87 e0       	ldi	r24, 0x07	; 7
     2fa:	cf 39       	cpi	r28, 0x9F	; 159
     2fc:	d8 07       	cpc	r29, r24
     2fe:	c9 f7       	brne	.-14     	; 0x2f2 <oneWireRight+0x66>
     300:	81 e0       	ldi	r24, 0x01	; 1
     302:	01 c0       	rjmp	.+2      	; 0x306 <oneWireRight+0x7a>
     304:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     306:	df 91       	pop	r29
     308:	cf 91       	pop	r28
     30a:	1f 91       	pop	r17
     30c:	0f 91       	pop	r16
     30e:	08 95       	ret

00000310 <oneWireLeft>:

/*******************************************
**** 1-WIRE DS18x20 Temperature Sensors ****
*******************************************/
unsigned char oneWireLeft()
{
     310:	0f 93       	push	r16
     312:	1f 93       	push	r17
     314:	cf 93       	push	r28
     316:	df 93       	push	r29
	unsigned char i;

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
     318:	81 e8       	ldi	r24, 0x81	; 129
     31a:	92 e0       	ldi	r25, 0x02	; 2
     31c:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     320:	0e 94 c8 05 	call	0xb90	; 0xb90 <reset>
     324:	88 23       	and	r24, r24
     326:	81 f1       	breq	.+96     	; 0x388 <oneWireLeft+0x78>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     328:	85 e5       	ldi	r24, 0x55	; 85
     32a:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
     32e:	0f e3       	ldi	r16, 0x3F	; 63
     330:	17 e0       	ldi	r17, 0x07	; 7
     332:	e8 01       	movw	r28, r16
		for(i=0; i<8; i++)
		{
			write_byte(leftTempSensorRomCode[i]);	// 64-bit ROM CODE
     334:	89 91       	ld	r24, Y+
     336:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
		transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
	{
		write_byte(0x55);	// Master issues Match ROM command.
		for(i=0; i<8; i++)
     33a:	87 e0       	ldi	r24, 0x07	; 7
     33c:	c7 34       	cpi	r28, 0x47	; 71
     33e:	d8 07       	cpc	r29, r24
     340:	c9 f7       	brne	.-14     	; 0x334 <oneWireLeft+0x24>
		write_byte(0x08);	// Byte 5
		write_byte(0x00);	// Byte 6
		write_byte(0xC1);	// Byte 7
		// 64-bit ROM CODE
*/
		write_byte(0x44);	// Master issues Convert T command.
     342:	84 e4       	ldi	r24, 0x44	; 68
     344:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     348:	0e 94 44 06 	call	0xc88	; 0xc88 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     34c:	0e 94 c8 05 	call	0xb90	; 0xb90 <reset>
     350:	88 23       	and	r24, r24
     352:	d1 f0       	breq	.+52     	; 0x388 <oneWireLeft+0x78>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     354:	85 e5       	ldi	r24, 0x55	; 85
     356:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
			for(i=0; i<8; i++)
			{
				write_byte(leftTempSensorRomCode[i]);	// 64-bit ROM CODE
     35a:	f8 01       	movw	r30, r16
     35c:	81 91       	ld	r24, Z+
     35e:	8f 01       	movw	r16, r30
     360:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
		write_byte(0x44);	// Master issues Convert T command.
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
		{
			write_byte(0x55);	// Master issues Match ROM command.
			for(i=0; i<8; i++)
     364:	f7 e0       	ldi	r31, 0x07	; 7
     366:	07 34       	cpi	r16, 0x47	; 71
     368:	1f 07       	cpc	r17, r31
     36a:	b9 f7       	brne	.-18     	; 0x35a <oneWireLeft+0x4a>
			write_byte(0x08);	// Byte 5
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
     36c:	8e eb       	ldi	r24, 0xBE	; 190
     36e:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
     372:	c6 e9       	ldi	r28, 0x96	; 150
     374:	d7 e0       	ldi	r29, 0x07	; 7
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     376:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <read_byte>
     37a:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     37c:	87 e0       	ldi	r24, 0x07	; 7
     37e:	cf 39       	cpi	r28, 0x9F	; 159
     380:	d8 07       	cpc	r29, r24
     382:	c9 f7       	brne	.-14     	; 0x376 <oneWireLeft+0x66>
     384:	81 e0       	ldi	r24, 0x01	; 1
     386:	01 c0       	rjmp	.+2      	; 0x38a <oneWireLeft+0x7a>
     388:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     38a:	df 91       	pop	r29
     38c:	cf 91       	pop	r28
     38e:	1f 91       	pop	r17
     390:	0f 91       	pop	r16
     392:	08 95       	ret

00000394 <temperature>:

/*****************************
**** TEMPERATURE FUNCTION ****
*****************************/
void temperature()
{
     394:	cf 93       	push	r28
     396:	df 93       	push	r29
	unsigned char i;
//	LED_low_DISPLAYLED_high();
//	LCD_INIT();								// LCD INITIZLIZATION
	LCD_CLEAR_CONTAIN();
     398:	0e 94 2e 07 	call	0xe5c	; 0xe5c <LCD_CLEAR_CONTAIN>

	LCD_COMMAND(LCD_SELECT_1ROW);	// select row 1
     39c:	80 e0       	ldi	r24, 0x00	; 0
     39e:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
	LCD_DATA_STRING("     TEMERATURE     ");		//
     3a2:	81 ec       	ldi	r24, 0xC1	; 193
     3a4:	92 e0       	ldi	r25, 0x02	; 2
     3a6:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
     3aa:	80 ec       	ldi	r24, 0xC0	; 192
     3ac:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
	LCD_DATA_STRING("LEFT  SENSOR: ");				//
     3b0:	86 ed       	ldi	r24, 0xD6	; 214
     3b2:	92 e0       	ldi	r25, 0x02	; 2
     3b4:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>

	oneWireLeft();
     3b8:	0e 94 88 01 	call	0x310	; 0x310 <oneWireLeft>
     3bc:	c0 e0       	ldi	r28, 0x00	; 0
     3be:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] byte ");
     3c0:	85 ee       	ldi	r24, 0xE5	; 229
     3c2:	92 e0       	ldi	r25, 0x02	; 2
     3c4:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartInt(i);
     3c8:	ce 01       	movw	r24, r28
     3ca:	0e 94 cf 08 	call	0x119e	; 0x119e <transmitUartInt>
		transmitUartString(" : ");
     3ce:	87 ef       	ldi	r24, 0xF7	; 247
     3d0:	92 e0       	ldi	r25, 0x02	; 2
     3d2:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartInt(storeTemp[i]);
     3d6:	fe 01       	movw	r30, r28
     3d8:	ea 56       	subi	r30, 0x6A	; 106
     3da:	f8 4f       	sbci	r31, 0xF8	; 248
     3dc:	80 81       	ld	r24, Z
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	0e 94 cf 08 	call	0x119e	; 0x119e <transmitUartInt>
		transmitUartString("\r\n");
     3e4:	8e e3       	ldi	r24, 0x3E	; 62
     3e6:	91 e0       	ldi	r25, 0x01	; 1
     3e8:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
     3ec:	21 96       	adiw	r28, 0x01	; 1
	LCD_DATA_STRING("     TEMERATURE     ");		//
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
	LCD_DATA_STRING("LEFT  SENSOR: ");				//

	oneWireLeft();
	for(i=0; i<9; i++)
     3ee:	c9 30       	cpi	r28, 0x09	; 9
     3f0:	d1 05       	cpc	r29, r1
     3f2:	31 f7       	brne	.-52     	; 0x3c0 <temperature+0x2c>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     3f4:	80 91 b3 07 	lds	r24, 0x07B3
     3f8:	60 91 af 07 	lds	r22, 0x07AF
     3fc:	40 91 ae 07 	lds	r20, 0x07AE
     400:	20 91 ab 07 	lds	r18, 0x07AB
     404:	0e 94 f6 00 	call	0x1ec	; 0x1ec <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
     408:	84 e9       	ldi	r24, 0x94	; 148
     40a:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
     40e:	8b ef       	ldi	r24, 0xFB	; 251
     410:	92 e0       	ldi	r25, 0x02	; 2
     412:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
	oneWireRight();
     416:	0e 94 46 01 	call	0x28c	; 0x28c <oneWireRight>
     41a:	c0 e0       	ldi	r28, 0x00	; 0
     41c:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] byte ");
     41e:	85 ee       	ldi	r24, 0xE5	; 229
     420:	92 e0       	ldi	r25, 0x02	; 2
     422:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartInt(i);
     426:	ce 01       	movw	r24, r28
     428:	0e 94 cf 08 	call	0x119e	; 0x119e <transmitUartInt>
		transmitUartString(" : ");
     42c:	87 ef       	ldi	r24, 0xF7	; 247
     42e:	92 e0       	ldi	r25, 0x02	; 2
     430:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartInt(storeTemp[i]);
     434:	fe 01       	movw	r30, r28
     436:	ea 56       	subi	r30, 0x6A	; 106
     438:	f8 4f       	sbci	r31, 0xF8	; 248
     43a:	80 81       	ld	r24, Z
     43c:	90 e0       	ldi	r25, 0x00	; 0
     43e:	0e 94 cf 08 	call	0x119e	; 0x119e <transmitUartInt>
		transmitUartString("\r\n");
     442:	8e e3       	ldi	r24, 0x3E	; 62
     444:	91 e0       	ldi	r25, 0x01	; 1
     446:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
     44a:	21 96       	adiw	r28, 0x01	; 1
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
	oneWireRight();
	for(i=0; i<9; i++)
     44c:	c9 30       	cpi	r28, 0x09	; 9
     44e:	d1 05       	cpc	r29, r1
     450:	31 f7       	brne	.-52     	; 0x41e <temperature+0x8a>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     452:	80 91 b3 07 	lds	r24, 0x07B3
     456:	60 91 af 07 	lds	r22, 0x07AF
     45a:	40 91 ae 07 	lds	r20, 0x07AE
     45e:	20 91 ab 07 	lds	r18, 0x07AB
     462:	0e 94 f6 00 	call	0x1ec	; 0x1ec <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
     466:	84 ed       	ldi	r24, 0xD4	; 212
     468:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
	LCD_DATA_STRING("             DS18x20");		//
     46c:	8a e0       	ldi	r24, 0x0A	; 10
     46e:	93 e0       	ldi	r25, 0x03	; 3
     470:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
}
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28
     478:	08 95       	ret

0000047a <commonEncoder>:
**********************************************/
void commonEncoder(void)	// not finished
{
	static signed char saveValue = 0;	// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!! static ???
	signed char temp = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     47a:	0e 94 8a 09 	call	0x1314	; 0x1314 <rotaryEncoderNikBarzakov>
	if(0==temp)
     47e:	88 23       	and	r24, r24
     480:	09 f4       	brne	.+2      	; 0x484 <commonEncoder+0xa>
     482:	4f c0       	rjmp	.+158    	; 0x522 <commonEncoder+0xa8>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     484:	8f 3f       	cpi	r24, 0xFF	; 255
     486:	41 f5       	brne	.+80     	; 0x4d8 <commonEncoder+0x5e>
	{
		// encoder is decrement
		if(saveValue < -127)
     488:	80 91 a0 07 	lds	r24, 0x07A0
     48c:	80 38       	cpi	r24, 0x80	; 128
     48e:	11 f4       	brne	.+4      	; 0x494 <commonEncoder+0x1a>
		{
			saveValue = 127;	// SIGNED CHAR MIN VALUE = -127
     490:	8f e7       	ldi	r24, 0x7F	; 127
     492:	01 c0       	rjmp	.+2      	; 0x496 <commonEncoder+0x1c>
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     494:	81 50       	subi	r24, 0x01	; 1
     496:	80 93 a0 07 	sts	0x07A0, r24
//			fanSpeedStep [FAN_LIMIT_POSITIONS]
		}
// LCD PRINT VALUE
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     49a:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     49c:	8c e0       	ldi	r24, 0x0C	; 12
     49e:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     4a2:	84 ed       	ldi	r24, 0xD4	; 212
     4a4:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
		if (saveValue > 99)
     4a8:	80 91 a0 07 	lds	r24, 0x07A0
     4ac:	84 36       	cpi	r24, 0x64	; 100
     4ae:	1c f0       	brlt	.+6      	; 0x4b6 <commonEncoder+0x3c>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     4b0:	8f e1       	ldi	r24, 0x1F	; 31
     4b2:	93 e0       	ldi	r25, 0x03	; 3
     4b4:	07 c0       	rjmp	.+14     	; 0x4c4 <commonEncoder+0x4a>
		}
		else if (saveValue > 9)
     4b6:	8a 30       	cpi	r24, 0x0A	; 10
     4b8:	1c f0       	brlt	.+6      	; 0x4c0 <commonEncoder+0x46>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     4ba:	88 e2       	ldi	r24, 0x28	; 40
     4bc:	93 e0       	ldi	r25, 0x03	; 3
     4be:	02 c0       	rjmp	.+4      	; 0x4c4 <commonEncoder+0x4a>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     4c0:	82 e3       	ldi	r24, 0x32	; 50
     4c2:	93 e0       	ldi	r25, 0x03	; 3
     4c4:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     4c8:	80 91 a0 07 	lds	r24, 0x07A0
     4cc:	99 27       	eor	r25, r25
     4ce:	87 fd       	sbrc	r24, 7
     4d0:	90 95       	com	r25
     4d2:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <LCD_DATA_INT>
     4d6:	08 95       	ret
	}
	else if(1==temp)
     4d8:	81 30       	cpi	r24, 0x01	; 1
     4da:	19 f5       	brne	.+70     	; 0x522 <commonEncoder+0xa8>
		{
			saveValue = 128;	// SIGNED CHAR MAX VALUE = +128
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     4dc:	80 91 a0 07 	lds	r24, 0x07A0
     4e0:	8f 5f       	subi	r24, 0xFF	; 255
     4e2:	80 93 a0 07 	sts	0x07A0, r24
		}

	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     4e6:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     4e8:	8c e0       	ldi	r24, 0x0C	; 12
     4ea:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     4ee:	84 ed       	ldi	r24, 0xD4	; 212
     4f0:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
		if (saveValue > 99)
     4f4:	80 91 a0 07 	lds	r24, 0x07A0
     4f8:	84 36       	cpi	r24, 0x64	; 100
     4fa:	1c f0       	brlt	.+6      	; 0x502 <commonEncoder+0x88>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     4fc:	8f e1       	ldi	r24, 0x1F	; 31
     4fe:	93 e0       	ldi	r25, 0x03	; 3
     500:	07 c0       	rjmp	.+14     	; 0x510 <commonEncoder+0x96>
		}
		else if (saveValue > 9)
     502:	8a 30       	cpi	r24, 0x0A	; 10
     504:	1c f0       	brlt	.+6      	; 0x50c <commonEncoder+0x92>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     506:	88 e2       	ldi	r24, 0x28	; 40
     508:	93 e0       	ldi	r25, 0x03	; 3
     50a:	02 c0       	rjmp	.+4      	; 0x510 <commonEncoder+0x96>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     50c:	82 e3       	ldi	r24, 0x32	; 50
     50e:	93 e0       	ldi	r25, 0x03	; 3
     510:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     514:	80 91 a0 07 	lds	r24, 0x07A0
     518:	99 27       	eor	r25, r25
     51a:	87 fd       	sbrc	r24, 7
     51c:	90 95       	com	r25
     51e:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <LCD_DATA_INT>
     522:	08 95       	ret

00000524 <volumeUpdate>:
/*************************************
**** VOLUME UPDATE and LCD UPDATE ****
*************************************/
void volumeUpdate(void)
{
	PGA2310_Volume_Update(volumeValue[volumeIndex], volumeValue[volumeIndex]);	// update volume value on all channels
     524:	e0 91 95 07 	lds	r30, 0x0795
     528:	f0 e0       	ldi	r31, 0x00	; 0
     52a:	e5 5d       	subi	r30, 0xD5	; 213
     52c:	f8 4f       	sbci	r31, 0xF8	; 248
     52e:	60 81       	ld	r22, Z
     530:	86 2f       	mov	r24, r22
     532:	0e 94 14 08 	call	0x1028	; 0x1028 <PGA2310_Volume_Update>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     536:	84 ed       	ldi	r24, 0xD4	; 212
     538:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
//		LCD_DATA_STRING("Volume: ");	// 20 symbols
	if (volumeIndex > 9)
     53c:	80 91 95 07 	lds	r24, 0x0795
     540:	8a 30       	cpi	r24, 0x0A	; 10
     542:	18 f0       	brcs	.+6      	; 0x54a <volumeUpdate+0x26>
	{
		LCD_DATA_STRING("Volume: ");	// 20 symbols
     544:	8f e1       	ldi	r24, 0x1F	; 31
     546:	93 e0       	ldi	r25, 0x03	; 3
     548:	02 c0       	rjmp	.+4      	; 0x54e <volumeUpdate+0x2a>
	}
	else
	{
		LCD_DATA_STRING("Volume: 0");	// 20 symbols
     54a:	88 e2       	ldi	r24, 0x28	; 40
     54c:	93 e0       	ldi	r25, 0x03	; 3
     54e:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
	}
	LCD_DATA_INT(volumeIndex);			// 20 symbols
     552:	80 91 95 07 	lds	r24, 0x0795
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <LCD_DATA_INT>
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Volume: ");		// uart debug information string
     55c:	8d e3       	ldi	r24, 0x3D	; 61
     55e:	93 e0       	ldi	r25, 0x03	; 3
     560:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartInt(volumeIndex);		// uart debug information string 
     564:	80 91 95 07 	lds	r24, 0x0795
     568:	90 e0       	ldi	r25, 0x00	; 0
     56a:	0e 94 cf 08 	call	0x119e	; 0x119e <transmitUartInt>
		transmitUartString("\r\n");			// uart debug information string
     56e:	8e e3       	ldi	r24, 0x3E	; 62
     570:	91 e0       	ldi	r25, 0x01	; 1
     572:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
}
     576:	08 95       	ret

00000578 <volumeMute>:
/************************************
**** VOLUME MUTE/UNMUTE FUNCTION ****
************************************/
void volumeMute(void)
{
	if(flagStatusBits->flagMute == 0)
     578:	e0 91 b1 07 	lds	r30, 0x07B1
     57c:	f0 91 b2 07 	lds	r31, 0x07B2
     580:	80 81       	ld	r24, Z
     582:	81 fd       	sbrc	r24, 1
     584:	0c c0       	rjmp	.+24     	; 0x59e <volumeMute+0x26>
	{
		volumeBuffer = volumeIndex;		// strore volume volue
     586:	80 91 95 07 	lds	r24, 0x0795
     58a:	80 93 94 07 	sts	0x0794, r24
		volumeIndex = VOLUME_MUTE;		// MUTE ON
     58e:	10 92 95 07 	sts	0x0795, r1
		flagStatusBits->flagMute = 1;	// MUTE ON
     592:	80 81       	ld	r24, Z
     594:	82 60       	ori	r24, 0x02	; 2
     596:	80 83       	st	Z, r24
		#ifdef DEBUG_INFO
			transmitUartString("[UART INFO] Volume mute is on\r\n");
     598:	82 e5       	ldi	r24, 0x52	; 82
     59a:	93 e0       	ldi	r25, 0x03	; 3
     59c:	0b c0       	rjmp	.+22     	; 0x5b4 <volumeMute+0x3c>
		#endif
	}
	else
	{
		volumeIndex = volumeBuffer;		// MUTE OFF
     59e:	80 91 94 07 	lds	r24, 0x0794
     5a2:	80 93 95 07 	sts	0x0795, r24
		volumeBuffer = VOLUME_MUTE;		// clear volume volue
     5a6:	10 92 94 07 	sts	0x0794, r1
		flagStatusBits->flagMute = 0;	// MUTE OFF
     5aa:	80 81       	ld	r24, Z
     5ac:	8d 7f       	andi	r24, 0xFD	; 253
     5ae:	80 83       	st	Z, r24
		#ifdef DEBUG_INFO
			transmitUartString("[UART INFO] Volume mute is off\r\n");
     5b0:	82 e7       	ldi	r24, 0x72	; 114
     5b2:	93 e0       	ldi	r25, 0x03	; 3
     5b4:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		#endif
	}
	volumeUpdate();
     5b8:	0e 94 92 02 	call	0x524	; 0x524 <volumeUpdate>
}
     5bc:	08 95       	ret

000005be <volumeProcessRemote>:
/********************************************
**** VOLUME PROCESS FUNCTION FROM REMOTE ****
********************************************/
void volumeProcessRemote(signed char temp)
{
	if(-1==temp)
     5be:	8f 3f       	cpi	r24, 0xFF	; 255
     5c0:	69 f4       	brne	.+26     	; 0x5dc <volumeProcessRemote+0x1e>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     5c2:	80 91 95 07 	lds	r24, 0x0795
     5c6:	88 23       	and	r24, r24
     5c8:	19 f4       	brne	.+6      	; 0x5d0 <volumeProcessRemote+0x12>
		{
			volumeIndex = VOLUME_MUTE;
     5ca:	10 92 95 07 	sts	0x0795, r1
     5ce:	03 c0       	rjmp	.+6      	; 0x5d6 <volumeProcessRemote+0x18>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     5d0:	81 50       	subi	r24, 0x01	; 1
     5d2:	80 93 95 07 	sts	0x0795, r24
		}
		volumeUpdate();
     5d6:	0e 94 92 02 	call	0x524	; 0x524 <volumeUpdate>
     5da:	08 95       	ret
	}
	else if(1==temp)
     5dc:	81 30       	cpi	r24, 0x01	; 1
     5de:	59 f4       	brne	.+22     	; 0x5f6 <volumeProcessRemote+0x38>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     5e0:	80 91 95 07 	lds	r24, 0x0795
     5e4:	83 31       	cpi	r24, 0x13	; 19
     5e6:	10 f0       	brcs	.+4      	; 0x5ec <volumeProcessRemote+0x2e>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     5e8:	83 e1       	ldi	r24, 0x13	; 19
     5ea:	01 c0       	rjmp	.+2      	; 0x5ee <volumeProcessRemote+0x30>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     5ec:	8f 5f       	subi	r24, 0xFF	; 255
     5ee:	80 93 95 07 	sts	0x0795, r24
		}
		volumeUpdate();
     5f2:	0e 94 92 02 	call	0x524	; 0x524 <volumeUpdate>
     5f6:	08 95       	ret

000005f8 <volumeProcess>:
**** VOLUME PROCESS FUNCTION FROM ENCODER ****
*********************************************/
void volumeProcess(void)
{
	signed char temp = 0;//, tempEnc = 0, tempRem = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     5f8:	0e 94 8a 09 	call	0x1314	; 0x1314 <rotaryEncoderNikBarzakov>
	if(0==temp)
     5fc:	88 23       	and	r24, r24
     5fe:	e1 f0       	breq	.+56     	; 0x638 <volumeProcess+0x40>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     600:	8f 3f       	cpi	r24, 0xFF	; 255
     602:	69 f4       	brne	.+26     	; 0x61e <volumeProcess+0x26>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     604:	80 91 95 07 	lds	r24, 0x0795
     608:	88 23       	and	r24, r24
     60a:	19 f4       	brne	.+6      	; 0x612 <volumeProcess+0x1a>
		{
			volumeIndex = VOLUME_MUTE;
     60c:	10 92 95 07 	sts	0x0795, r1
     610:	03 c0       	rjmp	.+6      	; 0x618 <volumeProcess+0x20>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     612:	81 50       	subi	r24, 0x01	; 1
     614:	80 93 95 07 	sts	0x0795, r24
		}
		volumeUpdate();
     618:	0e 94 92 02 	call	0x524	; 0x524 <volumeUpdate>
     61c:	08 95       	ret
	}
	else if(1==temp)
     61e:	81 30       	cpi	r24, 0x01	; 1
     620:	59 f4       	brne	.+22     	; 0x638 <volumeProcess+0x40>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     622:	80 91 95 07 	lds	r24, 0x0795
     626:	83 31       	cpi	r24, 0x13	; 19
     628:	10 f0       	brcs	.+4      	; 0x62e <volumeProcess+0x36>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     62a:	83 e1       	ldi	r24, 0x13	; 19
     62c:	01 c0       	rjmp	.+2      	; 0x630 <volumeProcess+0x38>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     62e:	8f 5f       	subi	r24, 0xFF	; 255
     630:	80 93 95 07 	sts	0x0795, r24
		}
		volumeUpdate();
     634:	0e 94 92 02 	call	0x524	; 0x524 <volumeUpdate>
     638:	08 95       	ret

0000063a <ampliferOff>:
/*********************
**** AMPLIFER OFF ****
*********************/
void ampliferOff(void)
{
	flagStatusBits->flagPower = 0;		// flag for amplifer off
     63a:	e0 91 b1 07 	lds	r30, 0x07B1
     63e:	f0 91 b2 07 	lds	r31, 0x07B2
     642:	80 81       	ld	r24, Z
     644:	8e 7f       	andi	r24, 0xFE	; 254
     646:	80 83       	st	Z, r24

	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     648:	80 e0       	ldi	r24, 0x00	; 0
     64a:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer Off    ");	// 20 symbols
     64e:	83 e9       	ldi	r24, 0x93	; 147
     650:	93 e0       	ldi	r25, 0x03	; 3
     652:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>

	LCD_COMMAND(LCD_OFF);						// LCD ON without CURSOR
     656:	88 e0       	ldi	r24, 0x08	; 8
     658:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>

//			FAN_low();		// PORTD5 - FAN OFF (logic "0")  NON PWM, NON TIMER1

// RELAYS OFF FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays out for all 6 channels\r\n");		// uart debug information string
     65c:	88 ea       	ldi	r24, 0xA8	; 168
     65e:	93 e0       	ldi	r25, 0x03	; 3
     660:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
	relays_out_off();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     664:	0e 94 2e 0a 	call	0x145c	; 0x145c <relays_out_off>
     668:	88 e5       	ldi	r24, 0x58	; 88
     66a:	9b e1       	ldi	r25, 0x1B	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     66c:	20 e9       	ldi	r18, 0x90	; 144
     66e:	31 e0       	ldi	r19, 0x01	; 1
     670:	f9 01       	movw	r30, r18
     672:	31 97       	sbiw	r30, 0x01	; 1
     674:	f1 f7       	brne	.-4      	; 0x672 <ampliferOff+0x38>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     676:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     678:	d9 f7       	brne	.-10     	; 0x670 <ampliferOff+0x36>
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays in for all 6 channels\r\n");		// uart debug information string
     67a:	86 ee       	ldi	r24, 0xE6	; 230
     67c:	93 e0       	ldi	r25, 0x03	; 3
     67e:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
	relays_in_off();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     682:	0e 94 07 0a 	call	0x140e	; 0x140e <relays_in_off>
     686:	88 e5       	ldi	r24, 0x58	; 88
     688:	9b e1       	ldi	r25, 0x1B	; 27
     68a:	20 e9       	ldi	r18, 0x90	; 144
     68c:	31 e0       	ldi	r19, 0x01	; 1
     68e:	f9 01       	movw	r30, r18
     690:	31 97       	sbiw	r30, 0x01	; 1
     692:	f1 f7       	brne	.-4      	; 0x690 <ampliferOff+0x56>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     694:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     696:	d9 f7       	brne	.-10     	; 0x68e <ampliferOff+0x54>
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays for power 220V\r\n");		// uart debug information string
     698:	83 e2       	ldi	r24, 0x23	; 35
     69a:	94 e0       	ldi	r25, 0x04	; 4
     69c:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
	REL_POWER_low();// RELAY POWER OFF				// PESHO COMMENT 14.08.2015, 21:10
     6a0:	aa 98       	cbi	0x15, 2	; 21

// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan is off\r\n");
     6a2:	89 e5       	ldi	r24, 0x59	; 89
     6a4:	94 e0       	ldi	r25, 0x04	; 4
     6a6:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}

void timer1_off(void)
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     6aa:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     6ac:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     6ae:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     6b0:	1a bc       	out	0x2a, r1	; 42
		transmitUartString("[UART INFO] Fan is off\r\n");
	#endif
	fan_pwm_off();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1

// FANS FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();
     6b2:	0e 94 2e 07 	call	0xe5c	; 0xe5c <LCD_CLEAR_CONTAIN>
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display off and status led on\r\n");
     6b6:	82 e7       	ldi	r24, 0x72	; 114
     6b8:	94 e0       	ldi	r25, 0x04	; 4
     6ba:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif

// LED ON FUNC
	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     6be:	94 9a       	sbi	0x12, 4	; 18

// UART MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Amplifer is off\r\n");
     6c0:	8e e9       	ldi	r24, 0x9E	; 158
     6c2:	94 e0       	ldi	r25, 0x04	; 4
     6c4:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
     6c8:	88 e8       	ldi	r24, 0x88	; 136
     6ca:	93 e1       	ldi	r25, 0x13	; 19
     6cc:	20 e9       	ldi	r18, 0x90	; 144
     6ce:	31 e0       	ldi	r19, 0x01	; 1
     6d0:	f9 01       	movw	r30, r18
     6d2:	31 97       	sbiw	r30, 0x01	; 1
     6d4:	f1 f7       	brne	.-4      	; 0x6d2 <ampliferOff+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6d6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     6d8:	d9 f7       	brne	.-10     	; 0x6d0 <ampliferOff+0x96>
	#endif

	_delay_ms(500);	// izchakvane pri natiskane za izkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton
}
     6da:	08 95       	ret

000006dc <ampliferOn>:
/********************
**** AMPLIFER ON ****
********************/
void ampliferOn(void)
{
	flagStatusBits->flagPower = 1;		// flag for amplifer on
     6dc:	e0 91 b1 07 	lds	r30, 0x07B1
     6e0:	f0 91 b2 07 	lds	r31, 0x07B2
     6e4:	80 81       	ld	r24, Z
     6e6:	81 60       	ori	r24, 0x01	; 1
     6e8:	80 83       	st	Z, r24

// UART MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Amplifer is on\r\n");
     6ea:	8c eb       	ldi	r24, 0xBC	; 188
     6ec:	94 e0       	ldi	r25, 0x04	; 4
     6ee:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display on and status led off\r\n");
     6f2:	89 ed       	ldi	r24, 0xD9	; 217
     6f4:	94 e0       	ldi	r25, 0x04	; 4
     6f6:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif

// LED OFF FUNC
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     6fa:	94 98       	cbi	0x12, 4	; 18

// LCD FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();						// clear all contain on display
     6fc:	0e 94 2e 07 	call	0xe5c	; 0xe5c <LCD_CLEAR_CONTAIN>
	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer On     ");	// 20 symbols
     706:	85 e0       	ldi	r24, 0x05	; 5
     708:	95 e0       	ldi	r25, 0x05	; 5
     70a:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);				// select row 2
     70e:	80 ec       	ldi	r24, 0xC0	; 192
     710:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
	LCD_DATA_STRING("P.UPINOV  P.STOYANOV");	// 20 symbols //	LCD_EXECUTE_DATA("P.UPINOV  P.STOYANOV",20);	// char "DATA", int 13 of chars of "DATA"
     714:	8a e1       	ldi	r24, 0x1A	; 26
     716:	95 e0       	ldi	r25, 0x05	; 5
     718:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     71c:	8c e0       	ldi	r24, 0x0C	; 12
     71e:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>

// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan is on\r\n");
     722:	8f e2       	ldi	r24, 0x2F	; 47
     724:	95 e0       	ldi	r25, 0x05	; 5
     726:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartString("[UART INFO] Fan rotation with max speed\r\n");
     72a:	87 e4       	ldi	r24, 0x47	; 71
     72c:	95 e0       	ldi	r25, 0x05	; 5
     72e:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartString("[UART INFO] Fan is always on, it isn't sensitive to temperature, because DS18S20 is disabling\r\n");
     732:	81 e7       	ldi	r24, 0x71	; 113
     734:	95 e0       	ldi	r25, 0x05	; 5
     736:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
//	FAN_high();			// PORTD5 - FAN ON (logic "1")	NON PWM, NON TIMER1	
	fanSpeed = FAN_SPEED_MAX;	// amplifer run with max fan speed
     73a:	87 e0       	ldi	r24, 0x07	; 7
     73c:	80 93 4f 07 	sts	0x074F, r24
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     740:	81 ea       	ldi	r24, 0xA1	; 161
     742:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     748:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     74a:	80 91 57 07 	lds	r24, 0x0757
     74e:	8a bd       	out	0x2a, r24	; 42
	fanSpeed = FAN_SPEED_MAX;	// amplifer run with max fan speed
	fan_pwm_control_speed();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1

// RELAYS ON FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays for power 220V\r\n");		// uart debug information string
     750:	81 ed       	ldi	r24, 0xD1	; 209
     752:	95 e0       	ldi	r25, 0x05	; 5
     754:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
	REL_POWER_high();// RELAY POWER ON TRAFs		// PESHO COMMENT 14.08.2015, 21:10
     758:	aa 9a       	sbi	0x15, 2	; 21
     75a:	80 e4       	ldi	r24, 0x40	; 64
     75c:	9c e9       	ldi	r25, 0x9C	; 156
     75e:	20 e9       	ldi	r18, 0x90	; 144
     760:	31 e0       	ldi	r19, 0x01	; 1
     762:	f9 01       	movw	r30, r18
     764:	31 97       	sbiw	r30, 0x01	; 1
     766:	f1 f7       	brne	.-4      	; 0x764 <ampliferOn+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     768:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     76a:	d9 f7       	brne	.-10     	; 0x762 <ampliferOn+0x86>
	_delay_ms(4000);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays in for all 6 channels\r\n");		// uart debug information string
     76c:	86 e0       	ldi	r24, 0x06	; 6
     76e:	96 e0       	ldi	r25, 0x06	; 6
     770:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
	relays_in1_6ch();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     774:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <relays_in1_6ch>
     778:	88 e5       	ldi	r24, 0x58	; 88
     77a:	9b e1       	ldi	r25, 0x1B	; 27
     77c:	20 e9       	ldi	r18, 0x90	; 144
     77e:	31 e0       	ldi	r19, 0x01	; 1
     780:	f9 01       	movw	r30, r18
     782:	31 97       	sbiw	r30, 0x01	; 1
     784:	f1 f7       	brne	.-4      	; 0x782 <ampliferOn+0xa6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     786:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     788:	d9 f7       	brne	.-10     	; 0x780 <ampliferOn+0xa4>
	_delay_ms(700);									// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays out for all 6 channels\r\n");		// uart debug information string
     78a:	82 e4       	ldi	r24, 0x42	; 66
     78c:	96 e0       	ldi	r25, 0x06	; 6
     78e:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif
	relays_out_6ch();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     792:	0e 94 2a 0a 	call	0x1454	; 0x1454 <relays_out_6ch>
     796:	80 e1       	ldi	r24, 0x10	; 16
     798:	97 e2       	ldi	r25, 0x27	; 39
     79a:	20 e9       	ldi	r18, 0x90	; 144
     79c:	31 e0       	ldi	r19, 0x01	; 1
     79e:	f9 01       	movw	r30, r18
     7a0:	31 97       	sbiw	r30, 0x01	; 1
     7a2:	f1 f7       	brne	.-4      	; 0x7a0 <ampliferOn+0xc4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7a4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7a6:	d9 f7       	brne	.-10     	; 0x79e <ampliferOn+0xc2>
	_delay_ms(1000);	// izchakvane pri natiskane za vkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton

// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan rotation with min speed\r\n");
     7a8:	8f e7       	ldi	r24, 0x7F	; 127
     7aa:	96 e0       	ldi	r25, 0x06	; 6
     7ac:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
		transmitUartString("[UART INFO] Fan manual controlling with remote menu up to speed step up and menu down button to speed step down\r\n");
     7b0:	89 ea       	ldi	r24, 0xA9	; 169
     7b2:	96 e0       	ldi	r25, 0x06	; 6
     7b4:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
	#endif	
	fanSpeed = FAN_SPEED_MIN;	// amplifer works with min fan speed
     7b8:	81 e0       	ldi	r24, 0x01	; 1
     7ba:	80 93 4f 07 	sts	0x074F, r24
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     7be:	91 ea       	ldi	r25, 0xA1	; 161
     7c0:	9f bd       	out	0x2f, r25	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     7c2:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     7c4:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     7c6:	80 91 51 07 	lds	r24, 0x0751
     7ca:	8a bd       	out	0x2a, r24	; 42
		transmitUartString("[UART INFO] Fan rotation with min speed\r\n");
		transmitUartString("[UART INFO] Fan manual controlling with remote menu up to speed step up and menu down button to speed step down\r\n");
	#endif	
	fanSpeed = FAN_SPEED_MIN;	// amplifer works with min fan speed
	fan_pwm_control_speed();
}
     7cc:	08 95       	ret

000007ce <buttons_press>:


}

void buttons_press()
{
     7ce:	cf 93       	push	r28
     7d0:	df 93       	push	r29
	flagStatusBits = &fSB;
     7d2:	89 eb       	ldi	r24, 0xB9	; 185
     7d4:	97 e0       	ldi	r25, 0x07	; 7
     7d6:	90 93 b2 07 	sts	0x07B2, r25
     7da:	80 93 b1 07 	sts	0x07B1, r24
	flagStatusBits->flagPower=0;	// inicializirane s nuli, no nai veroqtno poradi tova che e globalna stru
     7de:	80 91 b9 07 	lds	r24, 0x07B9
	flagStatusBits->flagMute=0;		// inicializirane
     7e2:	8c 7f       	andi	r24, 0xFC	; 252
     7e4:	80 93 b9 07 	sts	0x07B9, r24
     7e8:	c0 e9       	ldi	r28, 0x90	; 144
     7ea:	d1 e0       	ldi	r29, 0x01	; 1
		LCD_DATA_INT(flagStatusBits->flagMute);		// 20 symbols
	_delay_ms(2000);
*/
	while(1)
	{
		if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)	// obj ptr flagStatusBtnRegister from struct flagStatusBtnOnOff
     7ec:	b1 99       	sbic	0x16, 1	; 22
     7ee:	0a c0       	rjmp	.+20     	; 0x804 <buttons_press+0x36>
     7f0:	e0 91 b1 07 	lds	r30, 0x07B1
     7f4:	f0 91 b2 07 	lds	r31, 0x07B2
     7f8:	80 81       	ld	r24, Z
     7fa:	80 fd       	sbrc	r24, 0
     7fc:	03 c0       	rjmp	.+6      	; 0x804 <buttons_press+0x36>
		{
//			flagStatusBits->flagPower = 1;			// filter za buton ON
			ampliferOn();
     7fe:	0e 94 6e 03 	call	0x6dc	; 0x6dc <ampliferOn>
     802:	f4 cf       	rjmp	.-24     	; 0x7ec <buttons_press+0x1e>
//			_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
		}
		else if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     804:	b1 99       	sbic	0x16, 1	; 22
     806:	0a c0       	rjmp	.+20     	; 0x81c <buttons_press+0x4e>
     808:	e0 91 b1 07 	lds	r30, 0x07B1
     80c:	f0 91 b2 07 	lds	r31, 0x07B2
     810:	80 81       	ld	r24, Z
     812:	80 ff       	sbrs	r24, 0
     814:	03 c0       	rjmp	.+6      	; 0x81c <buttons_press+0x4e>
		{
//			flagStatusBits->flagPower = 0;			// filter za buton OFF
			ampliferOff();
     816:	0e 94 1d 03 	call	0x63a	; 0x63a <ampliferOff>
     81a:	e8 cf       	rjmp	.-48     	; 0x7ec <buttons_press+0x1e>
		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     81c:	b2 99       	sbic	0x16, 2	; 22
     81e:	11 c0       	rjmp	.+34     	; 0x842 <buttons_press+0x74>
     820:	e0 91 b1 07 	lds	r30, 0x07B1
     824:	f0 91 b2 07 	lds	r31, 0x07B2
     828:	80 81       	ld	r24, Z
     82a:	80 ff       	sbrs	r24, 0
     82c:	0a c0       	rjmp	.+20     	; 0x842 <buttons_press+0x74>
		{
//			LCD_DATA_STRING("PRESSED BTN ESCAPE  ");	// 20 symbols
//			LCD_COMMAND(LCD_ON);
			LCD_CLEAR_CONTAIN();
     82e:	0e 94 2e 07 	call	0xe5c	; 0xe5c <LCD_CLEAR_CONTAIN>
     832:	88 e8       	ldi	r24, 0x88	; 136
     834:	93 e1       	ldi	r25, 0x13	; 19
     836:	fe 01       	movw	r30, r28
     838:	31 97       	sbiw	r30, 0x01	; 1
     83a:	f1 f7       	brne	.-4      	; 0x838 <buttons_press+0x6a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     83c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     83e:	d9 f7       	brne	.-10     	; 0x836 <buttons_press+0x68>
     840:	d5 cf       	rjmp	.-86     	; 0x7ec <buttons_press+0x1e>
			_delay_ms(500);
//			volumeUp();
//			_delay_ms(200);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     842:	83 99       	sbic	0x10, 3	; 16
     844:	0f c0       	rjmp	.+30     	; 0x864 <__stack+0x5>
     846:	e0 91 b1 07 	lds	r30, 0x07B1
     84a:	f0 91 b2 07 	lds	r31, 0x07B2
     84e:	80 81       	ld	r24, Z
     850:	80 ff       	sbrs	r24, 0
     852:	08 c0       	rjmp	.+16     	; 0x864 <__stack+0x5>
     854:	88 e8       	ldi	r24, 0x88	; 136
     856:	93 e1       	ldi	r25, 0x13	; 19
     858:	fe 01       	movw	r30, r28
     85a:	31 97       	sbiw	r30, 0x01	; 1
     85c:	f1 f7       	brne	.-4      	; 0x85a <buttons_press+0x8c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     85e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     860:	d9 f7       	brne	.-10     	; 0x858 <buttons_press+0x8a>
     862:	c4 cf       	rjmp	.-120    	; 0x7ec <buttons_press+0x1e>
			_delay_ms(500);
//			volumeDown();
//			_delay_ms(200);

		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     864:	b2 99       	sbic	0x16, 2	; 22
     866:	0f c0       	rjmp	.+30     	; 0x886 <__stack+0x27>
     868:	e0 91 b1 07 	lds	r30, 0x07B1
     86c:	f0 91 b2 07 	lds	r31, 0x07B2
     870:	80 81       	ld	r24, Z
     872:	80 fd       	sbrc	r24, 0
     874:	08 c0       	rjmp	.+16     	; 0x886 <__stack+0x27>
     876:	88 e8       	ldi	r24, 0x88	; 136
     878:	93 e1       	ldi	r25, 0x13	; 19
     87a:	fe 01       	movw	r30, r28
     87c:	31 97       	sbiw	r30, 0x01	; 1
     87e:	f1 f7       	brne	.-4      	; 0x87c <__stack+0x1d>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     880:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     882:	d9 f7       	brne	.-10     	; 0x87a <__stack+0x1b>
     884:	b3 cf       	rjmp	.-154    	; 0x7ec <buttons_press+0x1e>
//			LCD_COMMAND(LCD_ON);
			_delay_ms(500);
//			setupMode();
//			_delay_ms(1000);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     886:	83 99       	sbic	0x10, 3	; 16
     888:	11 c0       	rjmp	.+34     	; 0x8ac <__stack+0x4d>
     88a:	e0 91 b1 07 	lds	r30, 0x07B1
     88e:	f0 91 b2 07 	lds	r31, 0x07B2
     892:	80 81       	ld	r24, Z
     894:	80 fd       	sbrc	r24, 0
     896:	0a c0       	rjmp	.+20     	; 0x8ac <__stack+0x4d>
		{
			temperature();
     898:	0e 94 ca 01 	call	0x394	; 0x394 <temperature>
     89c:	88 e8       	ldi	r24, 0x88	; 136
     89e:	93 e1       	ldi	r25, 0x13	; 19
     8a0:	fe 01       	movw	r30, r28
     8a2:	31 97       	sbiw	r30, 0x01	; 1
     8a4:	f1 f7       	brne	.-4      	; 0x8a2 <__stack+0x43>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8a6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8a8:	d9 f7       	brne	.-10     	; 0x8a0 <__stack+0x41>
     8aa:	a0 cf       	rjmp	.-192    	; 0x7ec <buttons_press+0x1e>
//			LCD_COMMAND(LCD_OFF);
			_delay_ms(500);
//			about();
//			_delay_ms(1000);
		}
		else if(flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     8ac:	e0 91 b1 07 	lds	r30, 0x07B1
     8b0:	f0 91 b2 07 	lds	r31, 0x07B2
     8b4:	80 81       	ld	r24, Z
     8b6:	80 ff       	sbrs	r24, 0
     8b8:	99 cf       	rjmp	.-206    	; 0x7ec <buttons_press+0x1e>
		{
			volumeProcess();
     8ba:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <volumeProcess>
     8be:	96 cf       	rjmp	.-212    	; 0x7ec <buttons_press+0x1e>

000008c0 <main>:
******************************** START OF MAIN APPLICATION **********************************
********************************************************************************************/

int main(void)
{
	init_all();				// inicializacia na vsichko
     8c0:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <init_all>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     8c4:	80 e4       	ldi	r24, 0x40	; 64
     8c6:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     8c8:	8a bf       	out	0x3a, r24	; 58
{
	init_all();				// inicializacia na vsichko
	ext0_intrpt_on();		// ENABLE interrupts to access IR DETECTION as call to function "IR_DECODER()" for -> SONY IR REMOTE
//	ext2_intrpt_on();

	sei();							// file "avr/interrupt.h"
     8ca:	78 94       	sei
//	SREG = (1<<I);

	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     8cc:	94 9a       	sbi	0x12, 4	; 18
	while(1)
	{		
		buttons_press();	// izchakvane za natiskane na buton
     8ce:	0e 94 e7 03 	call	0x7ce	; 0x7ce <buttons_press>
     8d2:	fd cf       	rjmp	.-6      	; 0x8ce <main+0xe>

000008d4 <irDecode>:
************************************/
void irDecode(void)
{
//	byte byteSS0, byteSS1, byteMM0, byteMM1, byteHH0, byteHH1, byteDD0, byteDD1, byteMont0, byteMont1, byteYY0, byteYY1; // variables for convert DEC to BCD for LCD and UART for Time and Date

	GetSIRC12();
     8d4:	0e 94 36 0a 	call	0x146c	; 0x146c <GetSIRC12>
	if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 0)		// IR POWER -> ON
     8d8:	90 91 b5 07 	lds	r25, 0x07B5
     8dc:	91 30       	cpi	r25, 0x01	; 1
     8de:	29 f4       	brne	.+10     	; 0x8ea <irDecode+0x16>
     8e0:	80 91 b0 07 	lds	r24, 0x07B0
     8e4:	85 31       	cpi	r24, 0x15	; 21
     8e6:	99 f4       	brne	.+38     	; 0x90e <irDecode+0x3a>
     8e8:	06 c0       	rjmp	.+12     	; 0x8f6 <irDecode+0x22>
     8ea:	94 30       	cpi	r25, 0x04	; 4
     8ec:	29 f5       	brne	.+74     	; 0x938 <irDecode+0x64>
     8ee:	80 91 b0 07 	lds	r24, 0x07B0
     8f2:	8d 30       	cpi	r24, 0x0D	; 13
     8f4:	99 f4       	brne	.+38     	; 0x91c <irDecode+0x48>
     8f6:	e0 91 b1 07 	lds	r30, 0x07B1
     8fa:	f0 91 b2 07 	lds	r31, 0x07B2
     8fe:	80 81       	ld	r24, Z
     900:	80 fd       	sbrc	r24, 0
     902:	03 c0       	rjmp	.+6      	; 0x90a <irDecode+0x36>
	{		
		ampliferOn();
     904:	0e 94 6e 03 	call	0x6dc	; 0x6dc <ampliferOn>
     908:	a6 c0       	rjmp	.+332    	; 0xa56 <irDecode+0x182>
//		_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 1)	// IR POWER -> OFF
     90a:	91 30       	cpi	r25, 0x01	; 1
     90c:	29 f4       	brne	.+10     	; 0x918 <irDecode+0x44>
     90e:	80 91 b0 07 	lds	r24, 0x07B0
     912:	85 31       	cpi	r24, 0x15	; 21
     914:	b1 f4       	brne	.+44     	; 0x942 <irDecode+0x6e>
     916:	06 c0       	rjmp	.+12     	; 0x924 <irDecode+0x50>
     918:	94 30       	cpi	r25, 0x04	; 4
     91a:	71 f4       	brne	.+28     	; 0x938 <irDecode+0x64>
     91c:	80 91 b0 07 	lds	r24, 0x07B0
     920:	8d 30       	cpi	r24, 0x0D	; 13
     922:	79 f4       	brne	.+30     	; 0x942 <irDecode+0x6e>
     924:	e0 91 b1 07 	lds	r30, 0x07B1
     928:	f0 91 b2 07 	lds	r31, 0x07B2
     92c:	80 81       	ld	r24, Z
     92e:	80 ff       	sbrs	r24, 0
     930:	03 c0       	rjmp	.+6      	; 0x938 <irDecode+0x64>
	{
		ampliferOff();
     932:	0e 94 1d 03 	call	0x63a	; 0x63a <ampliferOff>
     936:	8f c0       	rjmp	.+286    	; 0xa56 <irDecode+0x182>
//		flagPower = 0;			// filter za buton OFF
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLUP)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME UP"
     938:	91 30       	cpi	r25, 0x01	; 1
     93a:	19 f0       	breq	.+6      	; 0x942 <irDecode+0x6e>
     93c:	94 30       	cpi	r25, 0x04	; 4
     93e:	09 f0       	breq	.+2      	; 0x942 <irDecode+0x6e>
     940:	8a c0       	rjmp	.+276    	; 0xa56 <irDecode+0x182>
     942:	20 91 b0 07 	lds	r18, 0x07B0
     946:	22 31       	cpi	r18, 0x12	; 18
     948:	49 f4       	brne	.+18     	; 0x95c <irDecode+0x88>
     94a:	e0 91 b1 07 	lds	r30, 0x07B1
     94e:	f0 91 b2 07 	lds	r31, 0x07B2
     952:	80 81       	ld	r24, Z
     954:	80 ff       	sbrs	r24, 0
     956:	02 c0       	rjmp	.+4      	; 0x95c <irDecode+0x88>
	{	// VOLUME UP
		volumeProcessRemote(REMOTE_VOLUME_UP);
     958:	81 e0       	ldi	r24, 0x01	; 1
     95a:	0f c0       	rjmp	.+30     	; 0x97a <irDecode+0xa6>
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLDN)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME DOWN"
     95c:	91 30       	cpi	r25, 0x01	; 1
     95e:	19 f0       	breq	.+6      	; 0x966 <irDecode+0x92>
     960:	94 30       	cpi	r25, 0x04	; 4
     962:	09 f0       	breq	.+2      	; 0x966 <irDecode+0x92>
     964:	78 c0       	rjmp	.+240    	; 0xa56 <irDecode+0x182>
     966:	23 31       	cpi	r18, 0x13	; 19
     968:	59 f4       	brne	.+22     	; 0x980 <irDecode+0xac>
     96a:	e0 91 b1 07 	lds	r30, 0x07B1
     96e:	f0 91 b2 07 	lds	r31, 0x07B2
     972:	80 81       	ld	r24, Z
     974:	80 ff       	sbrs	r24, 0
     976:	04 c0       	rjmp	.+8      	; 0x980 <irDecode+0xac>
	{	// VOLUME DOWN
		volumeProcessRemote(REMOTE_VOLUME_DOWN);
     978:	8f ef       	ldi	r24, 0xFF	; 255
     97a:	0e 94 df 02 	call	0x5be	; 0x5be <volumeProcessRemote>
     97e:	6b c0       	rjmp	.+214    	; 0xa56 <irDecode+0x182>
//		break;
	}

	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_ATT)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     980:	91 30       	cpi	r25, 0x01	; 1
     982:	19 f0       	breq	.+6      	; 0x98a <irDecode+0xb6>
     984:	94 30       	cpi	r25, 0x04	; 4
     986:	09 f0       	breq	.+2      	; 0x98a <irDecode+0xb6>
     988:	66 c0       	rjmp	.+204    	; 0xa56 <irDecode+0x182>
     98a:	24 31       	cpi	r18, 0x14	; 20
     98c:	51 f4       	brne	.+20     	; 0x9a2 <irDecode+0xce>
     98e:	e0 91 b1 07 	lds	r30, 0x07B1
     992:	f0 91 b2 07 	lds	r31, 0x07B2
     996:	80 81       	ld	r24, Z
     998:	80 ff       	sbrs	r24, 0
     99a:	03 c0       	rjmp	.+6      	; 0x9a2 <irDecode+0xce>
	{	// MUTE
		volumeMute();
     99c:	0e 94 bc 02 	call	0x578	; 0x578 <volumeMute>
     9a0:	5a c0       	rjmp	.+180    	; 0xa56 <irDecode+0x182>
//		break;
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_DOWN)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     9a2:	94 30       	cpi	r25, 0x04	; 4
     9a4:	09 f0       	breq	.+2      	; 0x9a8 <irDecode+0xd4>
     9a6:	57 c0       	rjmp	.+174    	; 0xa56 <irDecode+0x182>
     9a8:	22 33       	cpi	r18, 0x32	; 50
     9aa:	81 f4       	brne	.+32     	; 0x9cc <irDecode+0xf8>
     9ac:	e0 91 b1 07 	lds	r30, 0x07B1
     9b0:	f0 91 b2 07 	lds	r31, 0x07B2
     9b4:	80 81       	ld	r24, Z
     9b6:	80 ff       	sbrs	r24, 0
     9b8:	4e c0       	rjmp	.+156    	; 0xa56 <irDecode+0x182>
	{	// FAN STEP UP
		if(fanSpeed < FAN_SPEED_ABSOLUTE_MIN + 1)//0)
     9ba:	80 91 4f 07 	lds	r24, 0x074F
     9be:	88 23       	and	r24, r24
     9c0:	19 f4       	brne	.+6      	; 0x9c8 <irDecode+0xf4>
		{
			fanSpeed = FAN_SPEED_ABSOLUTE_MIN;	//0;	// 0-7
     9c2:	10 92 4f 07 	sts	0x074F, r1
     9c6:	14 c0       	rjmp	.+40     	; 0x9f0 <irDecode+0x11c>
		}
		else
		{
			fanSpeed--;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     9c8:	81 50       	subi	r24, 0x01	; 1
     9ca:	10 c0       	rjmp	.+32     	; 0x9ec <irDecode+0x118>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
		LCD_DATA_STRING(" or ");
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
		fan_pwm_control_speed();
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_UP)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     9cc:	23 33       	cpi	r18, 0x33	; 51
     9ce:	b1 f5       	brne	.+108    	; 0xa3c <irDecode+0x168>
     9d0:	e0 91 b1 07 	lds	r30, 0x07B1
     9d4:	f0 91 b2 07 	lds	r31, 0x07B2
     9d8:	80 81       	ld	r24, Z
     9da:	80 ff       	sbrs	r24, 0
     9dc:	3c c0       	rjmp	.+120    	; 0xa56 <irDecode+0x182>
	{	// FAN STEP DOWN
		if(fanSpeed > FAN_LIMIT_POSITIONS - 2)//7)
     9de:	80 91 4f 07 	lds	r24, 0x074F
     9e2:	87 30       	cpi	r24, 0x07	; 7
     9e4:	10 f0       	brcs	.+4      	; 0x9ea <irDecode+0x116>
		{
			fanSpeed = FAN_LIMIT_POSITIONS - 1;	//7;	// 0-7
     9e6:	87 e0       	ldi	r24, 0x07	; 7
     9e8:	01 c0       	rjmp	.+2      	; 0x9ec <irDecode+0x118>
		}
		else
		{
			fanSpeed++;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     9ea:	8f 5f       	subi	r24, 0xFF	; 255
     9ec:	80 93 4f 07 	sts	0x074F, r24
		}
//		fanSpeedStep [fanSpeed];// = { 0x00, 100, 125, 150, 175, 200, 225, 250 };
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     9f0:	84 ed       	ldi	r24, 0xD4	; 212
     9f2:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
		LCD_DATA_STRING("Fan Step: ");	// 20 symbols			
     9f6:	8b e1       	ldi	r24, 0x1B	; 27
     9f8:	97 e0       	ldi	r25, 0x07	; 7
     9fa:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
     9fe:	80 91 4f 07 	lds	r24, 0x074F
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <LCD_DATA_INT>
		LCD_DATA_STRING(" or ");
     a08:	86 e2       	ldi	r24, 0x26	; 38
     a0a:	97 e0       	ldi	r25, 0x07	; 7
     a0c:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
     a10:	e0 91 4f 07 	lds	r30, 0x074F
     a14:	f0 e0       	ldi	r31, 0x00	; 0
     a16:	e0 5b       	subi	r30, 0xB0	; 176
     a18:	f8 4f       	sbci	r31, 0xF8	; 248
     a1a:	80 81       	ld	r24, Z
     a1c:	90 e0       	ldi	r25, 0x00	; 0
     a1e:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <LCD_DATA_INT>
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     a22:	81 ea       	ldi	r24, 0xA1	; 161
     a24:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     a2a:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     a2c:	e0 91 4f 07 	lds	r30, 0x074F
     a30:	f0 e0       	ldi	r31, 0x00	; 0
     a32:	e0 5b       	subi	r30, 0xB0	; 176
     a34:	f8 4f       	sbci	r31, 0xF8	; 248
     a36:	80 81       	ld	r24, Z
     a38:	8a bd       	out	0x2a, r24	; 42
     a3a:	0d c0       	rjmp	.+26     	; 0xa56 <irDecode+0x182>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
		LCD_DATA_STRING(" or ");
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
		fan_pwm_control_speed();
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_SCRL)) && (flagStatusBits->flagPower == 0 || flagStatusBits->flagPower == 1))						// Sony CarAudio IR Remote Device - "SCRL" -> TEMPERATURE
     a3c:	23 32       	cpi	r18, 0x23	; 35
     a3e:	59 f4       	brne	.+22     	; 0xa56 <irDecode+0x182>
	{
		temperature();
     a40:	0e 94 ca 01 	call	0x394	; 0x394 <temperature>
     a44:	80 ed       	ldi	r24, 0xD0	; 208
     a46:	97 e0       	ldi	r25, 0x07	; 7
     a48:	20 e9       	ldi	r18, 0x90	; 144
     a4a:	31 e0       	ldi	r19, 0x01	; 1
     a4c:	f9 01       	movw	r30, r18
     a4e:	31 97       	sbiw	r30, 0x01	; 1
     a50:	f1 f7       	brne	.-4      	; 0xa4e <irDecode+0x17a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     a52:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     a54:	d9 f7       	brne	.-10     	; 0xa4c <irDecode+0x178>
     a56:	80 ed       	ldi	r24, 0xD0	; 208
     a58:	97 e0       	ldi	r25, 0x07	; 7
     a5a:	20 e9       	ldi	r18, 0x90	; 144
     a5c:	31 e0       	ldi	r19, 0x01	; 1
     a5e:	f9 01       	movw	r30, r18
     a60:	31 97       	sbiw	r30, 0x01	; 1
     a62:	f1 f7       	brne	.-4      	; 0xa60 <irDecode+0x18c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     a64:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     a66:	d9 f7       	brne	.-10     	; 0xa5e <irDecode+0x18a>
	else
	{
		// DO NOTING
	}
	_delay_ms(200);
}
     a68:	08 95       	ret

00000a6a <__vector_1>:

/*****************************************
**** EXTERNAL INTERRUPT 0 VECTOR 01 ******
*****************************************/
ISR(INT0_vect)
{
     a6a:	1f 92       	push	r1
     a6c:	0f 92       	push	r0
     a6e:	0f b6       	in	r0, 0x3f	; 63
     a70:	0f 92       	push	r0
     a72:	11 24       	eor	r1, r1
     a74:	2f 93       	push	r18
     a76:	3f 93       	push	r19
     a78:	4f 93       	push	r20
     a7a:	5f 93       	push	r21
     a7c:	6f 93       	push	r22
     a7e:	7f 93       	push	r23
     a80:	8f 93       	push	r24
     a82:	9f 93       	push	r25
     a84:	af 93       	push	r26
     a86:	bf 93       	push	r27
     a88:	ef 93       	push	r30
     a8a:	ff 93       	push	r31
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     a8c:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     a8e:	80 e4       	ldi	r24, 0x40	; 64
     a90:	8a bf       	out	0x3a, r24	; 58
	ext0_intrpt_off();	// DISABLE new IR DETECTION

// LOGIC CHECK BEGIN
// VERIFY PRESSED IR BUTTON and switch to low line of IR pin PD2
	unsigned char low_level = 0;
    if(irPin == 0)
     a92:	82 99       	sbic	0x10, 2	; 16
     a94:	0b c0       	rjmp	.+22     	; 0xaac <__vector_1+0x42>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     a96:	8a e0       	ldi	r24, 0x0A	; 10
     a98:	98 2f       	mov	r25, r24
     a9a:	9a 95       	dec	r25
     a9c:	f1 f7       	brne	.-4      	; 0xa9a <__vector_1+0x30>
     a9e:	98 2f       	mov	r25, r24
     aa0:	9a 95       	dec	r25
     aa2:	f1 f7       	brne	.-4      	; 0xaa0 <__vector_1+0x36>
     aa4:	8a 95       	dec	r24
     aa6:	f1 f7       	brne	.-4      	; 0xaa4 <__vector_1+0x3a>
			_delay_us(2);	//2uS delay
		}

		if(low_level == 3)
		{
			irDecode();
     aa8:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <irDecode>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     aac:	80 e4       	ldi	r24, 0x40	; 64
     aae:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     ab0:	8a bf       	out	0x3a, r24	; 58
		}
    }
// LOGIC CHECK END

	ext0_intrpt_on();	// ENABLE new IR DETECTION
}
     ab2:	ff 91       	pop	r31
     ab4:	ef 91       	pop	r30
     ab6:	bf 91       	pop	r27
     ab8:	af 91       	pop	r26
     aba:	9f 91       	pop	r25
     abc:	8f 91       	pop	r24
     abe:	7f 91       	pop	r23
     ac0:	6f 91       	pop	r22
     ac2:	5f 91       	pop	r21
     ac4:	4f 91       	pop	r20
     ac6:	3f 91       	pop	r19
     ac8:	2f 91       	pop	r18
     aca:	0f 90       	pop	r0
     acc:	0f be       	out	0x3f, r0	; 63
     ace:	0f 90       	pop	r0
     ad0:	1f 90       	pop	r1
     ad2:	18 95       	reti

00000ad4 <eeprom_24c64_read>:
	// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
	// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !
	
	byte eepromReceiveByte0, eepromReceiveByte1, eepromReceiveByte2, eepromReceiveByte3, eepromReceiveByte4, eepromReceiveByte5;
// EEPROM READ
	i2c_start();
     ad4:	0e 94 78 06 	call	0xcf0	; 0xcf0 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);		// EEPROM 24C64 ADDRESS ACCESS WRITE
     ad8:	80 ea       	ldi	r24, 0xA0	; 160
     ada:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     ade:	80 e0       	ldi	r24, 0x00	; 0
     ae0:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     ae4:	80 e0       	ldi	r24, 0x00	; 0
     ae6:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>

	i2c_start();
     aea:	0e 94 78 06 	call	0xcf0	; 0xcf0 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_READ);		// EEPROM 24C64 ADDRESS ACCESS READ
     aee:	81 ea       	ldi	r24, 0xA1	; 161
     af0:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
	eepromReceiveByte0	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     af4:	80 e0       	ldi	r24, 0x00	; 0
     af6:	0e 94 88 06 	call	0xd10	; 0xd10 <i2c_read>
	eepromReceiveByte1	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     afa:	80 e0       	ldi	r24, 0x00	; 0
     afc:	0e 94 88 06 	call	0xd10	; 0xd10 <i2c_read>
	eepromReceiveByte2	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b00:	80 e0       	ldi	r24, 0x00	; 0
     b02:	0e 94 88 06 	call	0xd10	; 0xd10 <i2c_read>
	eepromReceiveByte3	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b06:	80 e0       	ldi	r24, 0x00	; 0
     b08:	0e 94 88 06 	call	0xd10	; 0xd10 <i2c_read>
	eepromReceiveByte4	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	0e 94 88 06 	call	0xd10	; 0xd10 <i2c_read>
	eepromReceiveByte5	= i2c_read(1);				// EEPROM DATA READ BYTE	// i2c_read(1) parametar razlichen ot 0 spira komunikaciqta NACK
     b12:	81 e0       	ldi	r24, 0x01	; 1
     b14:	0e 94 88 06 	call	0xd10	; 0xd10 <i2c_read>
	i2c_stop();
     b18:	0e 94 7e 06 	call	0xcfc	; 0xcfc <i2c_stop>
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte2);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte3);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte4);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte5);
*/
}
     b1c:	08 95       	ret

00000b1e <eeprom_24c64_write>:
// Za da se vijda tova koeto se e zapisalo v pametta, a ne ot tozi bibliotechen fail !!!!!!!!!
// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !

// EEPROM WRITE
	i2c_start();
     b1e:	0e 94 78 06 	call	0xcf0	; 0xcf0 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     b22:	80 ea       	ldi	r24, 0xA0	; 160
     b24:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     b28:	80 e0       	ldi	r24, 0x00	; 0
     b2a:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b2e:	80 e0       	ldi	r24, 0x00	; 0
     b30:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
// Write data
	i2c_write(0x30);	// Data is stored: 0x30 - '0'
     b34:	80 e3       	ldi	r24, 0x30	; 48
     b36:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
	i2c_write(0x31);	// Data is stored: 0x31 - '1'
     b3a:	81 e3       	ldi	r24, 0x31	; 49
     b3c:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
	i2c_write(0x32);	// Data is stored: 0x32 - '2'
     b40:	82 e3       	ldi	r24, 0x32	; 50
     b42:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
	i2c_write(0x33);	// Data is stored: 0x33 - '3'
     b46:	83 e3       	ldi	r24, 0x33	; 51
     b48:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
	i2c_write(0x34);	// Data is stored: 0x34 - '4'
     b4c:	84 e3       	ldi	r24, 0x34	; 52
     b4e:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
	i2c_stop();
     b52:	0e 94 7e 06 	call	0xcfc	; 0xcfc <i2c_stop>
}
     b56:	08 95       	ret

00000b58 <eeprom_24c64_reset>:

/*************************************
** RESET AND ZERO FILL EEPROM 24C64 **
*************************************/
void eeprom_24c64_reset()
{
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
	unsigned int i;	// 16 bits
// EEPROM WRITE
	i2c_start();
     b5c:	0e 94 78 06 	call	0xcf0	; 0xcf0 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     b60:	80 ea       	ldi	r24, 0xA0	; 160
     b62:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     b66:	80 e0       	ldi	r24, 0x00	; 0
     b68:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b6c:	80 e0       	ldi	r24, 0x00	; 0
     b6e:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
     b72:	c0 e0       	ldi	r28, 0x00	; 0
     b74:	d0 e0       	ldi	r29, 0x00	; 0
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
     b76:	80 e0       	ldi	r24, 0x00	; 0
     b78:	0e 94 81 06 	call	0xd02	; 0xd02 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
     b7c:	21 96       	adiw	r28, 0x01	; 1
     b7e:	8f e1       	ldi	r24, 0x1F	; 31
     b80:	cf 3f       	cpi	r28, 0xFF	; 255
     b82:	d8 07       	cpc	r29, r24
     b84:	c1 f7       	brne	.-16     	; 0xb76 <eeprom_24c64_reset+0x1e>
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
	}
	i2c_stop();
     b86:	0e 94 7e 06 	call	0xcfc	; 0xcfc <i2c_stop>
}
     b8a:	df 91       	pop	r29
     b8c:	cf 91       	pop	r28
     b8e:	08 95       	ret

00000b90 <reset>:
}
*/

unsigned char reset(void)
{
    DDRx |= (1<<Px);            //Ausgang
     b90:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     b92:	c0 98       	cbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     b94:	80 e8       	ldi	r24, 0x80	; 128
     b96:	97 e0       	ldi	r25, 0x07	; 7
     b98:	01 97       	sbiw	r24, 0x01	; 1
     b9a:	f1 f7       	brne	.-4      	; 0xb98 <reset+0x8>
    _delay_us(480);
	DDRx &= ~(1<<Px);
     b9c:	b8 98       	cbi	0x17, 0	; 23
     b9e:	80 e4       	ldi	r24, 0x40	; 64
     ba0:	91 e0       	ldi	r25, 0x01	; 1
     ba2:	01 97       	sbiw	r24, 0x01	; 1
     ba4:	f1 f7       	brne	.-4      	; 0xba2 <reset+0x12>
    _delay_us(80);
	if(!(PINx & (1<<Px)))     //Prüfe Slave-Antwort
     ba6:	b0 9b       	sbis	0x16, 0	; 22
     ba8:	02 c0       	rjmp	.+4      	; 0xbae <reset+0x1e>
     baa:	80 e0       	ldi	r24, 0x00	; 0
     bac:	08 95       	ret
     bae:	88 e0       	ldi	r24, 0x08	; 8
     bb0:	97 e0       	ldi	r25, 0x07	; 7
     bb2:	01 97       	sbiw	r24, 0x01	; 1
     bb4:	f1 f7       	brne	.-4      	; 0xbb2 <reset+0x22>
     bb6:	81 e0       	ldi	r24, 0x01	; 1
	}
    else
	{
        return 0;
	}
}
     bb8:	08 95       	ret

00000bba <read_bit>:

unsigned char read_bit(void)
{
    DDRx |= (1<<Px);            //Ausgang
     bba:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     bbc:	c0 98       	cbi	0x18, 0	; 24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     bbe:	85 e0       	ldi	r24, 0x05	; 5
     bc0:	8a 95       	dec	r24
     bc2:	f1 f7       	brne	.-4      	; 0xbc0 <read_bit+0x6>
    _delay_us(1);
	DDRx &= ~(1<<Px);
     bc4:	b8 98       	cbi	0x17, 0	; 23
     bc6:	80 e4       	ldi	r24, 0x40	; 64
     bc8:	8a 95       	dec	r24
     bca:	f1 f7       	brne	.-4      	; 0xbc8 <read_bit+0xe>
    _delay_us(12);
    if(!(PINx & (1<<Px)))       //Abtastung innerhalb von 15µs
     bcc:	86 b3       	in	r24, 0x16	; 22
	}
	else
    {
		return 1;
	}
}
     bce:	81 70       	andi	r24, 0x01	; 1
     bd0:	08 95       	ret

00000bd2 <write_bit>:

void write_bit(unsigned char bitval)    //kann 0 oder 1 sein
{
    DDRx |= (1<<Px);            //Ausgang
     bd2:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     bd4:	c0 98       	cbi	0x18, 0	; 24
    if(bitval)
     bd6:	81 11       	cpse	r24, r1
	{
        PORTx |= (1<<Px);      //H-Pegel
     bd8:	c0 9a       	sbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     bda:	88 eb       	ldi	r24, 0xB8	; 184
     bdc:	91 e0       	ldi	r25, 0x01	; 1
     bde:	01 97       	sbiw	r24, 0x01	; 1
     be0:	f1 f7       	brne	.-4      	; 0xbde <write_bit+0xc>
    }
	_delay_us(110);        
    DDRx &= ~(1<<Px);
     be2:	b8 98       	cbi	0x17, 0	; 23
    PORTx &= ~(1<<Px);
     be4:	c0 98       	cbi	0x18, 0	; 24
}
     be6:	08 95       	ret

00000be8 <read_byte>:

unsigned char read_byte(void)
{
     be8:	cf 92       	push	r12
     bea:	df 92       	push	r13
     bec:	ef 92       	push	r14
     bee:	ff 92       	push	r15
     bf0:	1f 93       	push	r17
     bf2:	cf 93       	push	r28
     bf4:	df 93       	push	r29
     bf6:	10 e0       	ldi	r17, 0x00	; 0
     bf8:	c0 e0       	ldi	r28, 0x00	; 0
     bfa:	d0 e0       	ldi	r29, 0x00	; 0
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
		{
            byte |= (1<<i);
     bfc:	91 e0       	ldi	r25, 0x01	; 1
     bfe:	c9 2e       	mov	r12, r25
     c00:	d1 2c       	mov	r13, r1
     c02:	80 ee       	ldi	r24, 0xE0	; 224
     c04:	e8 2e       	mov	r14, r24
     c06:	81 e0       	ldi	r24, 0x01	; 1
     c08:	f8 2e       	mov	r15, r24
unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
     c0a:	0e 94 dd 05 	call	0xbba	; 0xbba <read_bit>
     c0e:	88 23       	and	r24, r24
     c10:	41 f0       	breq	.+16     	; 0xc22 <read_byte+0x3a>
		{
            byte |= (1<<i);
     c12:	c6 01       	movw	r24, r12
     c14:	0c 2e       	mov	r0, r28
     c16:	02 c0       	rjmp	.+4      	; 0xc1c <read_byte+0x34>
     c18:	88 0f       	add	r24, r24
     c1a:	99 1f       	adc	r25, r25
     c1c:	0a 94       	dec	r0
     c1e:	e2 f7       	brpl	.-8      	; 0xc18 <read_byte+0x30>
     c20:	18 2b       	or	r17, r24
     c22:	c7 01       	movw	r24, r14
     c24:	01 97       	sbiw	r24, 0x01	; 1
     c26:	f1 f7       	brne	.-4      	; 0xc24 <read_byte+0x3c>
     c28:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
     c2a:	c8 30       	cpi	r28, 0x08	; 8
     c2c:	d1 05       	cpc	r29, r1
     c2e:	69 f7       	brne	.-38     	; 0xc0a <read_byte+0x22>
            byte |= (1<<i);
		}
        _delay_us(120);
    }
    return byte;
}
     c30:	81 2f       	mov	r24, r17
     c32:	df 91       	pop	r29
     c34:	cf 91       	pop	r28
     c36:	1f 91       	pop	r17
     c38:	ff 90       	pop	r15
     c3a:	ef 90       	pop	r14
     c3c:	df 90       	pop	r13
     c3e:	cf 90       	pop	r12
     c40:	08 95       	ret

00000c42 <write_byte>:

void write_byte(unsigned char byte)
{
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
     c4a:	c0 e0       	ldi	r28, 0x00	; 0
     c4c:	d0 e0       	ldi	r29, 0x00	; 0
    for(unsigned char i=0; i<8; i++)
	{
        if(byte & (1<<i))
     c4e:	08 2f       	mov	r16, r24
     c50:	10 e0       	ldi	r17, 0x00	; 0
     c52:	c8 01       	movw	r24, r16
     c54:	0c 2e       	mov	r0, r28
     c56:	02 c0       	rjmp	.+4      	; 0xc5c <write_byte+0x1a>
     c58:	95 95       	asr	r25
     c5a:	87 95       	ror	r24
     c5c:	0a 94       	dec	r0
     c5e:	e2 f7       	brpl	.-8      	; 0xc58 <write_byte+0x16>
     c60:	80 ff       	sbrs	r24, 0
     c62:	02 c0       	rjmp	.+4      	; 0xc68 <write_byte+0x26>
		{
			write_bit(1);
     c64:	81 e0       	ldi	r24, 0x01	; 1
     c66:	01 c0       	rjmp	.+2      	; 0xc6a <write_byte+0x28>
		}
        else
		{
            write_bit(0);
     c68:	80 e0       	ldi	r24, 0x00	; 0
     c6a:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <write_bit>
     c6e:	21 96       	adiw	r28, 0x01	; 1
    return byte;
}

void write_byte(unsigned char byte)
{
    for(unsigned char i=0; i<8; i++)
     c70:	c8 30       	cpi	r28, 0x08	; 8
     c72:	d1 05       	cpc	r29, r1
     c74:	71 f7       	brne	.-36     	; 0xc52 <write_byte+0x10>
     c76:	80 ee       	ldi	r24, 0xE0	; 224
     c78:	91 e0       	ldi	r25, 0x01	; 1
     c7a:	01 97       	sbiw	r24, 0x01	; 1
     c7c:	f1 f7       	brne	.-4      	; 0xc7a <write_byte+0x38>
		{
            write_bit(0);
		}
	}
    _delay_us(120);
}  
     c7e:	df 91       	pop	r29
     c80:	cf 91       	pop	r28
     c82:	1f 91       	pop	r17
     c84:	0f 91       	pop	r16
     c86:	08 95       	ret

00000c88 <wait_ready>:
	return 0;
}

void wait_ready(void)
{
	while(!(read_bit()));
     c88:	0e 94 dd 05 	call	0xbba	; 0xbba <read_bit>
     c8c:	88 23       	and	r24, r24
     c8e:	e1 f3       	breq	.-8      	; 0xc88 <wait_ready>
}
     c90:	08 95       	ret

00000c92 <read_scratchpad>:
	}
    _delay_us(120);
}  

unsigned char read_scratchpad(void)
{
     c92:	cf 93       	push	r28
     c94:	df 93       	push	r29

	if(reset())
     c96:	0e 94 c8 05 	call	0xb90	; 0xb90 <reset>
     c9a:	88 23       	and	r24, r24
     c9c:	e9 f0       	breq	.+58     	; 0xcd8 <read_scratchpad+0x46>
	{
		write_byte(0xCC);
     c9e:	8c ec       	ldi	r24, 0xCC	; 204
     ca0:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
		write_byte(0x44);
     ca4:	84 e4       	ldi	r24, 0x44	; 68
     ca6:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
		wait_ready();
     caa:	0e 94 44 06 	call	0xc88	; 0xc88 <wait_ready>
		if(reset())
     cae:	0e 94 c8 05 	call	0xb90	; 0xb90 <reset>
     cb2:	88 23       	and	r24, r24
     cb4:	89 f0       	breq	.+34     	; 0xcd8 <read_scratchpad+0x46>
		{
			write_byte(0xCC);
     cb6:	8c ec       	ldi	r24, 0xCC	; 204
     cb8:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
			write_byte(0xBE);
     cbc:	8e eb       	ldi	r24, 0xBE	; 190
     cbe:	0e 94 21 06 	call	0xc42	; 0xc42 <write_byte>
     cc2:	c1 ea       	ldi	r28, 0xA1	; 161
     cc4:	d7 e0       	ldi	r29, 0x07	; 7
			for(unsigned char i=0; i<9; i++)
			{
				scratchpad [i] = read_byte();
     cc6:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <read_byte>
     cca:	89 93       	st	Y+, r24
		wait_ready();
		if(reset())
		{
			write_byte(0xCC);
			write_byte(0xBE);
			for(unsigned char i=0; i<9; i++)
     ccc:	87 e0       	ldi	r24, 0x07	; 7
     cce:	ca 3a       	cpi	r28, 0xAA	; 170
     cd0:	d8 07       	cpc	r29, r24
     cd2:	c9 f7       	brne	.-14     	; 0xcc6 <read_scratchpad+0x34>
     cd4:	81 e0       	ldi	r24, 0x01	; 1
     cd6:	01 c0       	rjmp	.+2      	; 0xcda <read_scratchpad+0x48>
     cd8:	80 e0       	ldi	r24, 0x00	; 0
			}
			return 1;
		}
	}
	return 0;
}
     cda:	df 91       	pop	r29
     cdc:	cf 91       	pop	r28
     cde:	08 95       	ret

00000ce0 <i2c_init>:
|== TWPS = 1 => (4^TWPS)= 4  // TWSR = (0<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx01 => TWSR = 1 (DEC) => 4^1 =  4 =|
|== TWPS = 2 => (4^TWPS)=16  // TWSR = (1<<TWPS1)|(0<<TWPS0) => TWSR = 0bxxxxxx10 => TWSR = 2 (DEC) => 4^2 = 16 =|
|== TWPS = 3 => (4^TWPS)=64  // TWSR = (1<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx11 => TWSR = 3 (DEC) => 4^3 = 64 =|
|===============================================================================================================*/

	TWBR = 0b00010010;	// HEX=0x12	or DEC=18	// FCPU = 16 000 000 |-> SCL = 16000000 / (16+(2*TWBR*(4^TWPS)) = 16000000 / (16+(2*18*(4))) = 16000000 / 160 = 100 000 Hz = 100 kHz
     ce0:	82 e1       	ldi	r24, 0x12	; 18
     ce2:	80 b9       	out	0x00, r24	; 0
	TWSR = (0<<TWPS1)|(1<<TWPS0);	// SCL = 16 000 000 / 64  = 250 000 = 250kHz
     ce4:	81 e0       	ldi	r24, 0x01	; 1
     ce6:	81 b9       	out	0x01, r24	; 1
	TWCR = (1<<TWEN);	//	TWCR = 0x04; // TWCR = (x<<TWINT)|(x<<TWEA)|(x<<TWSTA)|(x<<TWSTO)|(x<<TWEN)|(x<<TWIE);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz
     ce8:	84 e0       	ldi	r24, 0x04	; 4
     cea:	86 bf       	out	0x36, r24	; 54
	TWDR = 0b00000000;
     cec:	13 b8       	out	0x03, r1	; 3
}
     cee:	08 95       	ret

00000cf0 <i2c_start>:
/*****************************************
** START CONDITION OF I2C COMMUNICATION **
*****************************************/
void i2c_start(void)
{
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     cf0:	84 ea       	ldi	r24, 0xA4	; 164
     cf2:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     cf4:	06 b6       	in	r0, 0x36	; 54
     cf6:	07 fe       	sbrs	r0, 7
     cf8:	fd cf       	rjmp	.-6      	; 0xcf4 <i2c_start+0x4>
	{
	}
}
     cfa:	08 95       	ret

00000cfc <i2c_stop>:
/****************************************
** STOP CONDITION OF I2C COMMUNICATION **
****************************************/
void i2c_stop()
{
	TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     cfc:	84 e9       	ldi	r24, 0x94	; 148
     cfe:	86 bf       	out	0x36, r24	; 54
}
     d00:	08 95       	ret

00000d02 <i2c_write>:
/*******************************************
** WRITE/SEND 1 BYTE OF I2C COMMUNICATION **
*******************************************/
void i2c_write(unsigned char data)
{
	TWDR = data;
     d02:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT)|(1<<TWEN);
     d04:	84 e8       	ldi	r24, 0x84	; 132
     d06:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     d08:	06 b6       	in	r0, 0x36	; 54
     d0a:	07 fe       	sbrs	r0, 7
     d0c:	fd cf       	rjmp	.-6      	; 0xd08 <i2c_write+0x6>
	{
	}
}
     d0e:	08 95       	ret

00000d10 <i2c_read>:
/**********************************************
** READ/RECEIVE BYTE(S) OF I2C COMMUNICATION **
**********************************************/
unsigned char i2c_read(unsigned char isLast)
{
	if(isLast == 0 )
     d10:	88 23       	and	r24, r24
     d12:	11 f4       	brne	.+4      	; 0xd18 <i2c_read+0x8>
	{
		TWCR = (1<<TWINT)|(1<<TWEA)|(1<<TWEN);	// to next receive byte
     d14:	84 ec       	ldi	r24, 0xC4	; 196
     d16:	01 c0       	rjmp	.+2      	; 0xd1a <i2c_read+0xa>
	}
	else
	{
		TWCR = (1<<TWINT)|(1<<TWEN);			// to end of communication
     d18:	84 e8       	ldi	r24, 0x84	; 132
     d1a:	86 bf       	out	0x36, r24	; 54
	}
	
	while((TWCR & (1<<TWINT)) == 0)
     d1c:	06 b6       	in	r0, 0x36	; 54
     d1e:	07 fe       	sbrs	r0, 7
     d20:	fd cf       	rjmp	.-6      	; 0xd1c <i2c_read+0xc>
	{
	}
	return TWDR;
     d22:	83 b1       	in	r24, 0x03	; 3
}
     d24:	08 95       	ret

00000d26 <LCD_EXECUTE_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_EXECUTE_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     d26:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     d28:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     d2a:	87 ff       	sbrs	r24, 7
     d2c:	02 c0       	rjmp	.+4      	; 0xd32 <LCD_EXECUTE_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     d2e:	d8 9a       	sbi	0x1b, 0	; 27
     d30:	01 c0       	rjmp	.+2      	; 0xd34 <LCD_EXECUTE_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     d32:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     d34:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     d36:	9f 5f       	subi	r25, 0xFF	; 255
     d38:	98 30       	cpi	r25, 0x08	; 8
     d3a:	11 f0       	breq	.+4      	; 0xd40 <LCD_EXECUTE_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     d3c:	88 0f       	add	r24, r24
     d3e:	f4 cf       	rjmp	.-24     	; 0xd28 <LCD_EXECUTE_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     d40:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     d42:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     d44:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     d46:	da 98       	cbi	0x1b, 2	; 27
     d48:	88 ea       	ldi	r24, 0xA8	; 168
     d4a:	92 e0       	ldi	r25, 0x02	; 2
     d4c:	fc 01       	movw	r30, r24
     d4e:	31 97       	sbiw	r30, 0x01	; 1
     d50:	f1 f7       	brne	.-4      	; 0xd4e <LCD_EXECUTE_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     d52:	da 9a       	sbi	0x1b, 2	; 27
     d54:	01 97       	sbiw	r24, 0x01	; 1
     d56:	f1 f7       	brne	.-4      	; 0xd54 <LCD_EXECUTE_COMMAND+0x2e>
	LCD_REGSELECT_low();	// RS = 0
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);			//rcall 180 us
*/
	LCD_ENABLE_low();		// EN = 0
     d58:	db 98       	cbi	0x1b, 3	; 27
     d5a:	80 e9       	ldi	r24, 0x90	; 144
     d5c:	91 e0       	ldi	r25, 0x01	; 1
     d5e:	01 97       	sbiw	r24, 0x01	; 1
     d60:	f1 f7       	brne	.-4      	; 0xd5e <LCD_EXECUTE_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us

}
     d62:	08 95       	ret

00000d64 <LCD_EXECUTE_DATA>:

/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
     d64:	cf 93       	push	r28
     d66:	df 93       	push	r29
     d68:	40 e0       	ldi	r20, 0x00	; 0
     d6a:	50 e0       	ldi	r21, 0x00	; 0
     d6c:	a8 ea       	ldi	r26, 0xA8	; 168
     d6e:	b2 e0       	ldi	r27, 0x02	; 2
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];
     d70:	c0 e9       	ldi	r28, 0x90	; 144
     d72:	d1 e0       	ldi	r29, 0x01	; 1
     d74:	22 c0       	rjmp	.+68     	; 0xdba <LCD_EXECUTE_DATA+0x56>
     d76:	fc 01       	movw	r30, r24
     d78:	e4 0f       	add	r30, r20
     d7a:	f5 1f       	adc	r31, r21
     d7c:	e0 81       	ld	r30, Z
     d7e:	20 e0       	ldi	r18, 0x00	; 0

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     d80:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     d82:	e7 ff       	sbrs	r30, 7
     d84:	02 c0       	rjmp	.+4      	; 0xd8a <LCD_EXECUTE_DATA+0x26>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     d86:	d8 9a       	sbi	0x1b, 0	; 27
     d88:	01 c0       	rjmp	.+2      	; 0xd8c <LCD_EXECUTE_DATA+0x28>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     d8a:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     d8c:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     d8e:	2f 5f       	subi	r18, 0xFF	; 255
     d90:	28 30       	cpi	r18, 0x08	; 8
     d92:	11 f0       	breq	.+4      	; 0xd98 <LCD_EXECUTE_DATA+0x34>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     d94:	ee 0f       	add	r30, r30
     d96:	f4 cf       	rjmp	.-24     	; 0xd80 <LCD_EXECUTE_DATA+0x1c>
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     d98:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     d9a:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     d9c:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     d9e:	da 98       	cbi	0x1b, 2	; 27
     da0:	fd 01       	movw	r30, r26
     da2:	31 97       	sbiw	r30, 0x01	; 1
     da4:	f1 f7       	brne	.-4      	; 0xda2 <LCD_EXECUTE_DATA+0x3e>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     da6:	da 9a       	sbi	0x1b, 2	; 27
     da8:	fd 01       	movw	r30, r26
     daa:	31 97       	sbiw	r30, 0x01	; 1
     dac:	f1 f7       	brne	.-4      	; 0xdaa <LCD_EXECUTE_DATA+0x46>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     dae:	db 98       	cbi	0x1b, 3	; 27
     db0:	fe 01       	movw	r30, r28
     db2:	31 97       	sbiw	r30, 0x01	; 1
     db4:	f1 f7       	brne	.-4      	; 0xdb2 <LCD_EXECUTE_DATA+0x4e>
/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
     db6:	4f 5f       	subi	r20, 0xFF	; 255
     db8:	5f 4f       	sbci	r21, 0xFF	; 255
     dba:	46 17       	cp	r20, r22
     dbc:	57 07       	cpc	r21, r23
     dbe:	dc f2       	brlt	.-74     	; 0xd76 <LCD_EXECUTE_DATA+0x12>
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}

//	LCD_EXECUTE_DATA_LAST();	// flush -> posleden simvol ili gore v cikala count_ns < numsymbols+1 ili count_ns <= numsymbols
}
     dc0:	df 91       	pop	r29
     dc2:	cf 91       	pop	r28
     dc4:	08 95       	ret

00000dc6 <LCD_EXECUTE_DATA_ONE>:

/************************************************
** WRITE/TRANSMIT ONE DATA BYTE TO LCD DISPLAY **
************************************************/
void LCD_EXECUTE_DATA_ONE(unsigned char data)	// HELP: LCD_EXECUTE_DATA(unsigned char data_byte_symbols) // LCD shift left out, msb is first
{
     dc6:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     dc8:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     dca:	87 ff       	sbrs	r24, 7
     dcc:	02 c0       	rjmp	.+4      	; 0xdd2 <LCD_EXECUTE_DATA_ONE+0xc>
		{
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     dce:	d8 9a       	sbi	0x1b, 0	; 27
     dd0:	01 c0       	rjmp	.+2      	; 0xdd4 <LCD_EXECUTE_DATA_ONE+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     dd2:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     dd4:	d9 9a       	sbi	0x1b, 1	; 27
{
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     dd6:	9f 5f       	subi	r25, 0xFF	; 255
     dd8:	98 30       	cpi	r25, 0x08	; 8
     dda:	11 f0       	breq	.+4      	; 0xde0 <LCD_EXECUTE_DATA_ONE+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     ddc:	88 0f       	add	r24, r24
     dde:	f4 cf       	rjmp	.-24     	; 0xdc8 <LCD_EXECUTE_DATA_ONE+0x2>
	}
//update from down comment
	LCD_REGSELECT_high();	// RS = 1
     de0:	dd 9a       	sbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     de2:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     de4:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment

	LCD_RCK_low();
     de6:	da 98       	cbi	0x1b, 2	; 27
     de8:	88 ea       	ldi	r24, 0xA8	; 168
     dea:	92 e0       	ldi	r25, 0x02	; 2
     dec:	fc 01       	movw	r30, r24
     dee:	31 97       	sbiw	r30, 0x01	; 1
     df0:	f1 f7       	brne	.-4      	; 0xdee <LCD_EXECUTE_DATA_ONE+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     df2:	da 9a       	sbi	0x1b, 2	; 27
     df4:	01 97       	sbiw	r24, 0x01	; 1
     df6:	f1 f7       	brne	.-4      	; 0xdf4 <LCD_EXECUTE_DATA_ONE+0x2e>
	LCD_REGSELECT_high();	// RS = 1
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);
*/
	LCD_ENABLE_low();		// EN = 0
     df8:	db 98       	cbi	0x1b, 3	; 27
     dfa:	80 e9       	ldi	r24, 0x90	; 144
     dfc:	91 e0       	ldi	r25, 0x01	; 1
     dfe:	01 97       	sbiw	r24, 0x01	; 1
     e00:	f1 f7       	brne	.-4      	; 0xdfe <LCD_EXECUTE_DATA_ONE+0x38>
	_delay_us(100);
}
     e02:	08 95       	ret

00000e04 <LCD_EXECUTE_DATA_LAST>:
/*****************************************************************************
** WRITE/TRANSMIT LAST DATA BYTE TO LCD DISPLAY AND FLUSH SN74HC595 BUFFER  **
*****************************************************************************/
void LCD_EXECUTE_DATA_LAST()	// flush -> izchistvane na bufer - prinuditelno izpisvane na posleden simvol
{
	LCD_ENABLE_low();
     e04:	db 98       	cbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     e06:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     e08:	dd 9a       	sbi	0x1b, 5	; 27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     e0a:	85 ed       	ldi	r24, 0xD5	; 213
     e0c:	98 2f       	mov	r25, r24
     e0e:	9a 95       	dec	r25
     e10:	f1 f7       	brne	.-4      	; 0xe0e <LCD_EXECUTE_DATA_LAST+0xa>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
	LCD_ENABLE_high();
     e12:	db 9a       	sbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     e14:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     e16:	dd 9a       	sbi	0x1b, 5	; 27
     e18:	8a 95       	dec	r24
     e1a:	f1 f7       	brne	.-4      	; 0xe18 <LCD_EXECUTE_DATA_LAST+0x14>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
}
     e1c:	08 95       	ret

00000e1e <LCD_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     e1e:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     e20:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     e22:	87 ff       	sbrs	r24, 7
     e24:	02 c0       	rjmp	.+4      	; 0xe2a <LCD_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     e26:	d8 9a       	sbi	0x1b, 0	; 27
     e28:	01 c0       	rjmp	.+2      	; 0xe2c <LCD_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     e2a:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     e2c:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     e2e:	9f 5f       	subi	r25, 0xFF	; 255
     e30:	98 30       	cpi	r25, 0x08	; 8
     e32:	11 f0       	breq	.+4      	; 0xe38 <LCD_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     e34:	88 0f       	add	r24, r24
     e36:	f4 cf       	rjmp	.-24     	; 0xe20 <LCD_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     e38:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     e3a:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     e3c:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     e3e:	da 98       	cbi	0x1b, 2	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     e40:	88 ea       	ldi	r24, 0xA8	; 168
     e42:	92 e0       	ldi	r25, 0x02	; 2
     e44:	fc 01       	movw	r30, r24
     e46:	31 97       	sbiw	r30, 0x01	; 1
     e48:	f1 f7       	brne	.-4      	; 0xe46 <LCD_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     e4a:	da 9a       	sbi	0x1b, 2	; 27
     e4c:	01 97       	sbiw	r24, 0x01	; 1
     e4e:	f1 f7       	brne	.-4      	; 0xe4c <LCD_COMMAND+0x2e>
	_delay_us(170);			//rcall 180 us

	LCD_ENABLE_low();		// EN = 0
     e50:	db 98       	cbi	0x1b, 3	; 27
     e52:	80 e9       	ldi	r24, 0x90	; 144
     e54:	91 e0       	ldi	r25, 0x01	; 1
     e56:	01 97       	sbiw	r24, 0x01	; 1
     e58:	f1 f7       	brne	.-4      	; 0xe56 <LCD_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us
}
     e5a:	08 95       	ret

00000e5c <LCD_CLEAR_CONTAIN>:
/**************************************
** CLEAR ALL CONTAINS ON LCD DISPLAY **
**************************************/
void LCD_CLEAR_CONTAIN()
{
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 1. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     e5c:	81 e0       	ldi	r24, 0x01	; 1
     e5e:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
     e62:	80 ec       	ldi	r24, 0xC0	; 192
     e64:	92 e1       	ldi	r25, 0x12	; 18
     e66:	01 97       	sbiw	r24, 0x01	; 1
     e68:	f1 f7       	brne	.-4      	; 0xe66 <LCD_CLEAR_CONTAIN+0xa>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
}
     e6a:	08 95       	ret

00000e6c <LCD_INIT>:
/**********************************
** INITIZLIZATION OF LCD DISPLAY **
**********************************/
void LCD_INIT()
{
	LCD_COMMAND(LCD_8BIT_2ROWS_FONT5X7);		// 0b00111000	// 1. Function set: 8-bit interface data (DL = 1), 2-line display (N = 1), 5 x 7 dot character font (F = 0)
     e6c:	88 e3       	ldi	r24, 0x38	; 56
     e6e:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_ENTRY_MODE_INC_NOSHIFT);	// 0b00000110	// 2. Entry mode set: Increment by 1 (I/D = 1), No shift (S = 0)
     e72:	86 e0       	ldi	r24, 0x06	; 6
     e74:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_MOVE_FIRST);								// 3.
     e78:	82 e0       	ldi	r24, 0x02	; 2
     e7a:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 4. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	0e 94 0f 07 	call	0xe1e	; 0xe1e <LCD_COMMAND>
     e84:	80 ec       	ldi	r24, 0xC0	; 192
     e86:	92 e1       	ldi	r25, 0x12	; 18
     e88:	01 97       	sbiw	r24, 0x01	; 1
     e8a:	f1 f7       	brne	.-4      	; 0xe88 <LCD_INIT+0x1c>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
//	LCD_COMMAND(LCD_ON_BLINK_CURSOR);			// 0b00001111	// 5. Display on/off control: Display on (D = 1), Cursor on (C = 1), Blinking on (B = 1)
//	_delay_us(40);	// 37 uS	// comment for simulation
//	LCD_COMMAND(LCD_OFF);										// 5. Display off
}
     e8c:	08 95       	ret

00000e8e <LCD_DATA_STRING>:

/*********************************************************
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
     e8e:	fc 01       	movw	r30, r24
     e90:	28 ea       	ldi	r18, 0xA8	; 168
     e92:	32 e0       	ldi	r19, 0x02	; 2
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     e94:	40 e9       	ldi	r20, 0x90	; 144
     e96:	51 e0       	ldi	r21, 0x01	; 1
     e98:	1d c0       	rjmp	.+58     	; 0xed4 <LCD_DATA_STRING+0x46>
     e9a:	90 e0       	ldi	r25, 0x00	; 0
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     e9c:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     e9e:	87 ff       	sbrs	r24, 7
     ea0:	02 c0       	rjmp	.+4      	; 0xea6 <LCD_DATA_STRING+0x18>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     ea2:	d8 9a       	sbi	0x1b, 0	; 27
     ea4:	01 c0       	rjmp	.+2      	; 0xea8 <LCD_DATA_STRING+0x1a>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     ea6:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     ea8:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     eaa:	9f 5f       	subi	r25, 0xFF	; 255
     eac:	98 30       	cpi	r25, 0x08	; 8
     eae:	11 f0       	breq	.+4      	; 0xeb4 <LCD_DATA_STRING+0x26>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     eb0:	88 0f       	add	r24, r24
     eb2:	f4 cf       	rjmp	.-24     	; 0xe9c <LCD_DATA_STRING+0xe>
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;
     eb4:	31 96       	adiw	r30, 0x01	; 1
			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     eb6:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     eb8:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     eba:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     ebc:	da 98       	cbi	0x1b, 2	; 27
     ebe:	c9 01       	movw	r24, r18
     ec0:	01 97       	sbiw	r24, 0x01	; 1
     ec2:	f1 f7       	brne	.-4      	; 0xec0 <LCD_DATA_STRING+0x32>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     ec4:	da 9a       	sbi	0x1b, 2	; 27
     ec6:	c9 01       	movw	r24, r18
     ec8:	01 97       	sbiw	r24, 0x01	; 1
     eca:	f1 f7       	brne	.-4      	; 0xec8 <LCD_DATA_STRING+0x3a>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     ecc:	db 98       	cbi	0x1b, 3	; 27
     ece:	ca 01       	movw	r24, r20
     ed0:	01 97       	sbiw	r24, 0x01	; 1
     ed2:	f1 f7       	brne	.-4      	; 0xed0 <LCD_DATA_STRING+0x42>
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     ed4:	80 81       	ld	r24, Z
     ed6:	88 23       	and	r24, r24
     ed8:	01 f7       	brne	.-64     	; 0xe9a <LCD_DATA_STRING+0xc>
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}
}
     eda:	08 95       	ret

00000edc <LCD_CGRAM_CUSTOM_SYMBOLS>:
	 { 0x0E, 0x1B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F },	// Battery Charging  80%	// addr40-47
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
     edc:	cf 93       	push	r28
     ede:	df 93       	push	r29
	for(rows=0; rows<7; rows++)
     ee0:	10 92 bc 07 	sts	0x07BC, r1
     ee4:	10 92 bb 07 	sts	0x07BB, r1
     ee8:	25 c0       	rjmp	.+74     	; 0xf34 <LCD_CGRAM_CUSTOM_SYMBOLS+0x58>
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
     eea:	08 96       	adiw	r24, 0x08	; 8
     eec:	88 0f       	add	r24, r24
     eee:	88 0f       	add	r24, r24
     ef0:	88 0f       	add	r24, r24
     ef2:	0e 94 93 06 	call	0xd26	; 0xd26 <LCD_EXECUTE_COMMAND>
     ef6:	c0 e0       	ldi	r28, 0x00	; 0
     ef8:	d0 e0       	ldi	r29, 0x00	; 0
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
     efa:	e0 91 bb 07 	lds	r30, 0x07BB
     efe:	f0 91 bc 07 	lds	r31, 0x07BC
     f02:	83 e0       	ldi	r24, 0x03	; 3
     f04:	ee 0f       	add	r30, r30
     f06:	ff 1f       	adc	r31, r31
     f08:	8a 95       	dec	r24
     f0a:	e1 f7       	brne	.-8      	; 0xf04 <LCD_CGRAM_CUSTOM_SYMBOLS+0x28>
     f0c:	ec 0f       	add	r30, r28
     f0e:	fd 1f       	adc	r31, r29
     f10:	e8 5a       	subi	r30, 0xA8	; 168
     f12:	f8 4f       	sbci	r31, 0xF8	; 248
     f14:	80 81       	ld	r24, Z
     f16:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <LCD_EXECUTE_DATA_ONE>
void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
     f1a:	21 96       	adiw	r28, 0x01	; 1
     f1c:	c8 30       	cpi	r28, 0x08	; 8
     f1e:	d1 05       	cpc	r29, r1
     f20:	61 f7       	brne	.-40     	; 0xefa <LCD_CGRAM_CUSTOM_SYMBOLS+0x1e>
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
     f22:	80 91 bb 07 	lds	r24, 0x07BB
     f26:	90 91 bc 07 	lds	r25, 0x07BC
     f2a:	01 96       	adiw	r24, 0x01	; 1
     f2c:	90 93 bc 07 	sts	0x07BC, r25
     f30:	80 93 bb 07 	sts	0x07BB, r24
     f34:	80 91 bb 07 	lds	r24, 0x07BB
     f38:	90 91 bc 07 	lds	r25, 0x07BC
     f3c:	87 30       	cpi	r24, 0x07	; 7
     f3e:	91 05       	cpc	r25, r1
     f40:	a4 f2       	brlt	.-88     	; 0xeea <LCD_CGRAM_CUSTOM_SYMBOLS+0xe>
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
		}
	}
}
     f42:	df 91       	pop	r29
     f44:	cf 91       	pop	r28
     f46:	08 95       	ret

00000f48 <LCD_DATA_ULONG>:
/****************************************************************
** WRITE/TRANSMIT MORE DATA UNSIGNED LONG BYTES TO LCD DISPLAY **
****************************************************************/
// USE THIS: lcdDataULong( (unsigned long)k + 1 );
void LCD_DATA_ULONG(unsigned long data)		// void lcdDataULong(const unsigned long data)
{
     f48:	df 93       	push	r29
     f4a:	cf 93       	push	r28
     f4c:	cd b7       	in	r28, 0x3d	; 61
     f4e:	de b7       	in	r29, 0x3e	; 62
     f50:	2a 97       	sbiw	r28, 0x0a	; 10
     f52:	0f b6       	in	r0, 0x3f	; 63
     f54:	f8 94       	cli
     f56:	de bf       	out	0x3e, r29	; 62
     f58:	0f be       	out	0x3f, r0	; 63
     f5a:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ultoa(data, buffer, 10));	// 10 -> DECIMAL
     f5c:	ae 01       	movw	r20, r28
     f5e:	4f 5f       	subi	r20, 0xFF	; 255
     f60:	5f 4f       	sbci	r21, 0xFF	; 255
     f62:	2a e0       	ldi	r18, 0x0A	; 10
     f64:	30 e0       	ldi	r19, 0x00	; 0
     f66:	0e 94 9e 0b 	call	0x173c	; 0x173c <ultoa>
     f6a:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
}
     f6e:	2a 96       	adiw	r28, 0x0a	; 10
     f70:	0f b6       	in	r0, 0x3f	; 63
     f72:	f8 94       	cli
     f74:	de bf       	out	0x3e, r29	; 62
     f76:	0f be       	out	0x3f, r0	; 63
     f78:	cd bf       	out	0x3d, r28	; 61
     f7a:	cf 91       	pop	r28
     f7c:	df 91       	pop	r29
     f7e:	08 95       	ret

00000f80 <LCD_DATA_LONG>:
/*******************************************************
** WRITE/TRANSMIT MORE DATA LONG BYTES TO LCD DISPLAY **
*******************************************************/
// USE THIS: lcdDataLong( (long)k + 1 );
void LCD_DATA_LONG(long data)		// void lcdDataLong(const long data)
{
     f80:	df 93       	push	r29
     f82:	cf 93       	push	r28
     f84:	cd b7       	in	r28, 0x3d	; 61
     f86:	de b7       	in	r29, 0x3e	; 62
     f88:	2a 97       	sbiw	r28, 0x0a	; 10
     f8a:	0f b6       	in	r0, 0x3f	; 63
     f8c:	f8 94       	cli
     f8e:	de bf       	out	0x3e, r29	; 62
     f90:	0f be       	out	0x3f, r0	; 63
     f92:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ltoa(data, buffer, 10));	// 10 -> DECIMAL
     f94:	ae 01       	movw	r20, r28
     f96:	4f 5f       	subi	r20, 0xFF	; 255
     f98:	5f 4f       	sbci	r21, 0xFF	; 255
     f9a:	2a e0       	ldi	r18, 0x0A	; 10
     f9c:	30 e0       	ldi	r19, 0x00	; 0
     f9e:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <ltoa>
     fa2:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
}
     fa6:	2a 96       	adiw	r28, 0x0a	; 10
     fa8:	0f b6       	in	r0, 0x3f	; 63
     faa:	f8 94       	cli
     fac:	de bf       	out	0x3e, r29	; 62
     fae:	0f be       	out	0x3f, r0	; 63
     fb0:	cd bf       	out	0x3d, r28	; 61
     fb2:	cf 91       	pop	r28
     fb4:	df 91       	pop	r29
     fb6:	08 95       	ret

00000fb8 <LCD_DATA_INT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataInt( (int)k + 1 );
void LCD_DATA_INT(int data)		// void lcdDataInt(const int data)
{
     fb8:	df 93       	push	r29
     fba:	cf 93       	push	r28
     fbc:	cd b7       	in	r28, 0x3d	; 61
     fbe:	de b7       	in	r29, 0x3e	; 62
     fc0:	2a 97       	sbiw	r28, 0x0a	; 10
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	f8 94       	cli
     fc6:	de bf       	out	0x3e, r29	; 62
     fc8:	0f be       	out	0x3f, r0	; 63
     fca:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(itoa(data, buffer, 10));	// 10 -> DECIMAL
     fcc:	be 01       	movw	r22, r28
     fce:	6f 5f       	subi	r22, 0xFF	; 255
     fd0:	7f 4f       	sbci	r23, 0xFF	; 255
     fd2:	4a e0       	ldi	r20, 0x0A	; 10
     fd4:	50 e0       	ldi	r21, 0x00	; 0
     fd6:	0e 94 49 0b 	call	0x1692	; 0x1692 <itoa>
     fda:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
}
     fde:	2a 96       	adiw	r28, 0x0a	; 10
     fe0:	0f b6       	in	r0, 0x3f	; 63
     fe2:	f8 94       	cli
     fe4:	de bf       	out	0x3e, r29	; 62
     fe6:	0f be       	out	0x3f, r0	; 63
     fe8:	cd bf       	out	0x3d, r28	; 61
     fea:	cf 91       	pop	r28
     fec:	df 91       	pop	r29
     fee:	08 95       	ret

00000ff0 <LCD_DATA_UINT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataUInt( (unsigned int)k + 1 );
void LCD_DATA_UINT(unsigned int data)		// void lcdDataUInt(const unsigned int data)
{
     ff0:	df 93       	push	r29
     ff2:	cf 93       	push	r28
     ff4:	cd b7       	in	r28, 0x3d	; 61
     ff6:	de b7       	in	r29, 0x3e	; 62
     ff8:	2a 97       	sbiw	r28, 0x0a	; 10
     ffa:	0f b6       	in	r0, 0x3f	; 63
     ffc:	f8 94       	cli
     ffe:	de bf       	out	0x3e, r29	; 62
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(utoa(data, buffer, 10));	// 10 -> DECIMAL
    1004:	be 01       	movw	r22, r28
    1006:	6f 5f       	subi	r22, 0xFF	; 255
    1008:	7f 4f       	sbci	r23, 0xFF	; 255
    100a:	4a e0       	ldi	r20, 0x0A	; 10
    100c:	50 e0       	ldi	r21, 0x00	; 0
    100e:	0e 94 c3 0b 	call	0x1786	; 0x1786 <utoa>
    1012:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_DATA_STRING>
}
    1016:	2a 96       	adiw	r28, 0x0a	; 10
    1018:	0f b6       	in	r0, 0x3f	; 63
    101a:	f8 94       	cli
    101c:	de bf       	out	0x3e, r29	; 62
    101e:	0f be       	out	0x3f, r0	; 63
    1020:	cd bf       	out	0x3d, r28	; 61
    1022:	cf 91       	pop	r28
    1024:	df 91       	pop	r29
    1026:	08 95       	ret

00001028 <PGA2310_Volume_Update>:

/*************************************
** DEFINITION PGA2310 VOLUME UPDATE **
*************************************/
void PGA2310_Volume_Update(unsigned char pgaVolumeLeft, unsigned char pgaVolumeRight)
{
    1028:	0f 93       	push	r16
    102a:	1f 93       	push	r17
    102c:	18 2f       	mov	r17, r24
    102e:	06 2f       	mov	r16, r22
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    1030:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    1032:	0e 94 18 09 	call	0x1230	; 0x1230 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    1036:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1038:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    103a:	81 2f       	mov	r24, r17
    103c:	60 2f       	mov	r22, r16
    103e:	0e 94 18 09 	call	0x1230	; 0x1230 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    1042:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA7 - /SS ENABLE
    1044:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    1046:	81 2f       	mov	r24, r17
    1048:	60 2f       	mov	r22, r16
    104a:	0e 94 18 09 	call	0x1230	; 0x1230 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    104e:	df 9a       	sbi	0x1b, 7	; 27

//	return SUCCESS;
}
    1050:	1f 91       	pop	r17
    1052:	0f 91       	pop	r16
    1054:	08 95       	ret

00001056 <pga2310_init>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_init()
{
	spi_init();
    1056:	0e 94 07 09 	call	0x120e	; 0x120e <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    105a:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    105c:	80 e0       	ldi	r24, 0x00	; 0
    105e:	60 e0       	ldi	r22, 0x00	; 0
    1060:	0e 94 18 09 	call	0x1230	; 0x1230 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    1064:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1066:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1068:	80 e0       	ldi	r24, 0x00	; 0
    106a:	60 e0       	ldi	r22, 0x00	; 0
    106c:	0e 94 18 09 	call	0x1230	; 0x1230 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    1070:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1072:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1074:	80 e0       	ldi	r24, 0x00	; 0
    1076:	60 e0       	ldi	r22, 0x00	; 0
    1078:	0e 94 18 09 	call	0x1230	; 0x1230 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    107c:	df 9a       	sbi	0x1b, 7	; 27
}
    107e:	08 95       	ret

00001080 <pga2310_reset>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_reset()
{
	spi_init();
    1080:	0e 94 07 09 	call	0x120e	; 0x120e <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    1084:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1086:	80 e0       	ldi	r24, 0x00	; 0
    1088:	60 e0       	ldi	r22, 0x00	; 0
    108a:	0e 94 18 09 	call	0x1230	; 0x1230 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    108e:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1090:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1092:	80 e0       	ldi	r24, 0x00	; 0
    1094:	60 e0       	ldi	r22, 0x00	; 0
    1096:	0e 94 18 09 	call	0x1230	; 0x1230 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    109a:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    109c:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    109e:	80 e0       	ldi	r24, 0x00	; 0
    10a0:	60 e0       	ldi	r22, 0x00	; 0
    10a2:	0e 94 18 09 	call	0x1230	; 0x1230 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    10a6:	df 9a       	sbi	0x1b, 7	; 27
}
    10a8:	08 95       	ret

000010aa <uart_transmit>:

/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
    10aa:	ac 01       	movw	r20, r24
    10ac:	20 e0       	ldi	r18, 0x00	; 0
    10ae:	30 e0       	ldi	r19, 0x00	; 0
    10b0:	09 c0       	rjmp	.+18     	; 0x10c4 <uart_transmit+0x1a>
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		//UDR = uart_data[count_ns];
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10b2:	5d 9b       	sbis	0x0b, 5	; 11
    10b4:	fe cf       	rjmp	.-4      	; 0x10b2 <uart_transmit+0x8>
		{
		}
		UDR = uart_data[count_ns];
    10b6:	fa 01       	movw	r30, r20
    10b8:	e2 0f       	add	r30, r18
    10ba:	f3 1f       	adc	r31, r19
    10bc:	80 81       	ld	r24, Z
    10be:	8c b9       	out	0x0c, r24	; 12
/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
    10c0:	2f 5f       	subi	r18, 0xFF	; 255
    10c2:	3f 4f       	sbci	r19, 0xFF	; 255
    10c4:	26 17       	cp	r18, r22
    10c6:	37 07       	cpc	r19, r23
    10c8:	a4 f3       	brlt	.-24     	; 0x10b2 <uart_transmit+0x8>
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
		{
		}
		UDR = uart_data[count_ns];
	}
}
    10ca:	08 95       	ret

000010cc <uart_transmit_one>:
/***************************************
** TRANSMIT/SEND 1 BYTE OF UART/USART **
***************************************/
void uart_transmit_one(unsigned char uart_data)
{
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10cc:	5d 9b       	sbis	0x0b, 5	; 11
    10ce:	fe cf       	rjmp	.-4      	; 0x10cc <uart_transmit_one>
	{
	}
	UDR = uart_data;
    10d0:	8c b9       	out	0x0c, r24	; 12
}
    10d2:	08 95       	ret

000010d4 <uart_transmit_DEC_to_BCD>:

/*****************************************************************		// NOT FINISHED
** TRANSMIT/SEND 1 BYTE CONVERTED FROM DEC TO BCD OF UART/USART **		// NOT FINISHED
*****************************************************************/		// NOT FINISHED
void uart_transmit_DEC_to_BCD(unsigned char dec_to_bcd_data)
{// pravi se preobrazuvane ot DEC to BCD i preobrazuvane za izvejdane na parviq simvol s filtar
    10d4:	98 2f       	mov	r25, r24
	
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10d6:	5d 9b       	sbis	0x0b, 5	; 11
    10d8:	fe cf       	rjmp	.-4      	; 0x10d6 <uart_transmit_DEC_to_BCD+0x2>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data>>4));
    10da:	89 2f       	mov	r24, r25
    10dc:	82 95       	swap	r24
    10de:	8f 70       	andi	r24, 0x0F	; 15
    10e0:	80 5d       	subi	r24, 0xD0	; 208
    10e2:	8c b9       	out	0x0c, r24	; 12

	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10e4:	5d 9b       	sbis	0x0b, 5	; 11
    10e6:	fe cf       	rjmp	.-4      	; 0x10e4 <uart_transmit_DEC_to_BCD+0x10>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data & 0x0F));
    10e8:	9f 70       	andi	r25, 0x0F	; 15
    10ea:	90 5d       	subi	r25, 0xD0	; 208
    10ec:	9c b9       	out	0x0c, r25	; 12
	byte bcdToDec(byte val)
	{
  		return ( (val/16*10) + (val%16) );
	}
*/
}
    10ee:	08 95       	ret

000010f0 <transmitUart>:
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
    10f0:	5d 9b       	sbis	0x0b, 5	; 11
    10f2:	fe cf       	rjmp	.-4      	; 0x10f0 <transmitUart>
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
    10f4:	8c b9       	out	0x0c, r24	; 12
}
    10f6:	08 95       	ret

000010f8 <transmitUartString>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
    10f8:	fc 01       	movw	r30, r24
    10fa:	04 c0       	rjmp	.+8      	; 0x1104 <transmitUartString+0xc>
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
    10fc:	5d 9b       	sbis	0x0b, 5	; 11
    10fe:	fe cf       	rjmp	.-4      	; 0x10fc <transmitUartString+0x4>
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
	{
		transmitUart(*data++);
    1100:	31 96       	adiw	r30, 0x01	; 1
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
    1102:	8c b9       	out	0x0c, r24	; 12
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
    1104:	80 81       	ld	r24, Z
    1106:	88 23       	and	r24, r24
    1108:	c9 f7       	brne	.-14     	; 0x10fc <transmitUartString+0x4>
	{
		transmitUart(*data++);
	}
}
    110a:	08 95       	ret

0000110c <uart_init>:
{
	switch(F_CPU)
	{
		case 16000000UL:
		{
			UBRRL = 103;	// Baudrate: 9600; (Error = 0.2%; 16MHz)
    110c:	87 e6       	ldi	r24, 0x67	; 103
    110e:	89 b9       	out	0x09, r24	; 9
			UBRRH = 0;
    1110:	10 bc       	out	0x20, r1	; 32
	LCD_DATA_STRING(" MHz");		// 20 symbols
#endif
	// Razpoznavane na baudrate (skorost): 1. Izprashta se byte. 2. Poluchava se byte. 3. Sravnqva se polucheniq byte == izprateniq byte. // This is LOOP TX->RX
	// 4. Ako byte pri sravnqvaneto e edin i sasht to skorostta e izbranata v momenta, ako byte e razlichen - da se probva sas sledvashta baudrate.

	UCSRC = 0b10000110;		// URSEL = 1 (Accessing to UBRRH or UCSRC, is read as zero when reading UBRRH. The URSEL must be zero when writing the UBRRH.); UMSEL = 0 (Asynchronous Operation); UPM1 = 0, UPM0 = 0 (Parity Mode Disabled); USBS = 0 (1-Stop Bit); UCSZ2 = 0, UCSZ1 = 1, UCSZ0 = 1 (8-DataBits); UCPOL = 0 Polarity TX & RX (Rising XCK Edge -> Transmitted Data Changed (Output of TxDPin), Falling XCK Edge -> Received Data Sampled (Input on RxDPin))
    1112:	86 e8       	ldi	r24, 0x86	; 134
    1114:	80 bd       	out	0x20, r24	; 32
	UCSRB = 0b00001000;		// Enable only TXEN	- Transmitting Uart/Usart	// UCSRB = 0b10011000;		// Enable TXEN,RXEN,RXCIE	Transmitting and Receiving Uart/Usart
    1116:	88 e0       	ldi	r24, 0x08	; 8
    1118:	8a b9       	out	0x0a, r24	; 10
	UDR = 0b00000000;		// INITIALIZATION NULL OF UART DATA
    111a:	1c b8       	out	0x0c, r1	; 12

#ifdef DEBUG_INFO
	transmitUartString("\r\n");
    111c:	80 e9       	ldi	r24, 0x90	; 144
    111e:	97 e0       	ldi	r25, 0x07	; 7
    1120:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
#endif
#if DEBUG_SETTING
	transmitUartString("[UART INFO] Serial Port Settings - Baud rate: 9600, Data bits: 8 bits, Stop bits: 1 bit, Parity: None, Flow control: None or XON/XOFF\r\n");
#endif
}
    1124:	08 95       	ret

00001126 <receiveUart>:
/**************************************************		// NOT FINISHED
** RECEIVE/READ unsigned char BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
unsigned char receiveUart(void)
{
	while (!(UCSRA & (1<<RXC)))
    1126:	5f 9b       	sbis	0x0b, 7	; 11
    1128:	fe cf       	rjmp	.-4      	; 0x1126 <receiveUart>
	{};							/* Wait for data to be received */
	return UDR;					/* Get and return received data from buffer */
    112a:	8c b1       	in	r24, 0x0c	; 12
}
    112c:	08 95       	ret

0000112e <transmitUartLong>:
/******************************************		// NOT FINISHED
** TRANSMIT/SEND long BYTE OF UART/USART **		// NOT FINISHED
******************************************/		// NOT FINISHED
// USE THIS: transmitUartLong( (long)k + 1 );
void transmitUartLong(long data)		// void transmitUartLong(const long data)
{
    112e:	df 93       	push	r29
    1130:	cf 93       	push	r28
    1132:	cd b7       	in	r28, 0x3d	; 61
    1134:	de b7       	in	r29, 0x3e	; 62
    1136:	2a 97       	sbiw	r28, 0x0a	; 10
    1138:	0f b6       	in	r0, 0x3f	; 63
    113a:	f8 94       	cli
    113c:	de bf       	out	0x3e, r29	; 62
    113e:	0f be       	out	0x3f, r0	; 63
    1140:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ltoa(data, buffer, 10));		// 10 -> DECIMAL
    1142:	ae 01       	movw	r20, r28
    1144:	4f 5f       	subi	r20, 0xFF	; 255
    1146:	5f 4f       	sbci	r21, 0xFF	; 255
    1148:	2a e0       	ldi	r18, 0x0A	; 10
    114a:	30 e0       	ldi	r19, 0x00	; 0
    114c:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <ltoa>
    1150:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
}
    1154:	2a 96       	adiw	r28, 0x0a	; 10
    1156:	0f b6       	in	r0, 0x3f	; 63
    1158:	f8 94       	cli
    115a:	de bf       	out	0x3e, r29	; 62
    115c:	0f be       	out	0x3f, r0	; 63
    115e:	cd bf       	out	0x3d, r28	; 61
    1160:	cf 91       	pop	r28
    1162:	df 91       	pop	r29
    1164:	08 95       	ret

00001166 <transmitUartULong>:
/***************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned long BYTE OF UART/USART **		// NOT FINISHED
***************************************************/		// NOT FINISHED
// USE THIS: transmitUartULong( (unsigned long)k + 1 );
void transmitUartULong(unsigned long data)		// void transmitUartULong(const unsigned long data)
{
    1166:	df 93       	push	r29
    1168:	cf 93       	push	r28
    116a:	cd b7       	in	r28, 0x3d	; 61
    116c:	de b7       	in	r29, 0x3e	; 62
    116e:	2a 97       	sbiw	r28, 0x0a	; 10
    1170:	0f b6       	in	r0, 0x3f	; 63
    1172:	f8 94       	cli
    1174:	de bf       	out	0x3e, r29	; 62
    1176:	0f be       	out	0x3f, r0	; 63
    1178:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ultoa(data, buffer, 10));		// 10 -> DECIMAL
    117a:	ae 01       	movw	r20, r28
    117c:	4f 5f       	subi	r20, 0xFF	; 255
    117e:	5f 4f       	sbci	r21, 0xFF	; 255
    1180:	2a e0       	ldi	r18, 0x0A	; 10
    1182:	30 e0       	ldi	r19, 0x00	; 0
    1184:	0e 94 9e 0b 	call	0x173c	; 0x173c <ultoa>
    1188:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
}
    118c:	2a 96       	adiw	r28, 0x0a	; 10
    118e:	0f b6       	in	r0, 0x3f	; 63
    1190:	f8 94       	cli
    1192:	de bf       	out	0x3e, r29	; 62
    1194:	0f be       	out	0x3f, r0	; 63
    1196:	cd bf       	out	0x3d, r28	; 61
    1198:	cf 91       	pop	r28
    119a:	df 91       	pop	r29
    119c:	08 95       	ret

0000119e <transmitUartInt>:
/*****************************************		// NOT FINISHED
** TRANSMIT/SEND int BYTE OF UART/USART **		// NOT FINISHED
*****************************************/		// NOT FINISHED
// USE THIS: transmitUartInt( (int)k + 1 );
void transmitUartInt(int data)		// void transmitUartInt(const int data)
{
    119e:	df 93       	push	r29
    11a0:	cf 93       	push	r28
    11a2:	cd b7       	in	r28, 0x3d	; 61
    11a4:	de b7       	in	r29, 0x3e	; 62
    11a6:	2a 97       	sbiw	r28, 0x0a	; 10
    11a8:	0f b6       	in	r0, 0x3f	; 63
    11aa:	f8 94       	cli
    11ac:	de bf       	out	0x3e, r29	; 62
    11ae:	0f be       	out	0x3f, r0	; 63
    11b0:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(itoa(data, buffer, 10));		// 10 -> DECIMAL
    11b2:	be 01       	movw	r22, r28
    11b4:	6f 5f       	subi	r22, 0xFF	; 255
    11b6:	7f 4f       	sbci	r23, 0xFF	; 255
    11b8:	4a e0       	ldi	r20, 0x0A	; 10
    11ba:	50 e0       	ldi	r21, 0x00	; 0
    11bc:	0e 94 49 0b 	call	0x1692	; 0x1692 <itoa>
    11c0:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
}
    11c4:	2a 96       	adiw	r28, 0x0a	; 10
    11c6:	0f b6       	in	r0, 0x3f	; 63
    11c8:	f8 94       	cli
    11ca:	de bf       	out	0x3e, r29	; 62
    11cc:	0f be       	out	0x3f, r0	; 63
    11ce:	cd bf       	out	0x3d, r28	; 61
    11d0:	cf 91       	pop	r28
    11d2:	df 91       	pop	r29
    11d4:	08 95       	ret

000011d6 <transmitUartUInt>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned int BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: transmitUartUInt( (unsigned int)k + 1 );
void transmitUartUInt(unsigned int data)		// void transmitUartUInt(const unsigned int data)
{
    11d6:	df 93       	push	r29
    11d8:	cf 93       	push	r28
    11da:	cd b7       	in	r28, 0x3d	; 61
    11dc:	de b7       	in	r29, 0x3e	; 62
    11de:	2a 97       	sbiw	r28, 0x0a	; 10
    11e0:	0f b6       	in	r0, 0x3f	; 63
    11e2:	f8 94       	cli
    11e4:	de bf       	out	0x3e, r29	; 62
    11e6:	0f be       	out	0x3f, r0	; 63
    11e8:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(utoa(data, buffer, 10));		// 10 -> DECIMAL
    11ea:	be 01       	movw	r22, r28
    11ec:	6f 5f       	subi	r22, 0xFF	; 255
    11ee:	7f 4f       	sbci	r23, 0xFF	; 255
    11f0:	4a e0       	ldi	r20, 0x0A	; 10
    11f2:	50 e0       	ldi	r21, 0x00	; 0
    11f4:	0e 94 c3 0b 	call	0x1786	; 0x1786 <utoa>
    11f8:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <transmitUartString>
}
    11fc:	2a 96       	adiw	r28, 0x0a	; 10
    11fe:	0f b6       	in	r0, 0x3f	; 63
    1200:	f8 94       	cli
    1202:	de bf       	out	0x3e, r29	; 62
    1204:	0f be       	out	0x3f, r0	; 63
    1206:	cd bf       	out	0x3d, r28	; 61
    1208:	cf 91       	pop	r28
    120a:	df 91       	pop	r29
    120c:	08 95       	ret

0000120e <spi_init>:
/**************************
** INITIZLIZATION OF SPI **
***************************/
void spi_init()
{
	SPSR = (0<<SPIF)|(0<<WCOL)|(0<<SPI2X);
    120e:	1e b8       	out	0x0e, r1	; 14
//	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);			//0b01010010	// SPR1   = 1 - 16 000 000 / 64  = 250 000 = 250kHz  // KOMENTAR ZARADI SIMULACIQTA - PROTEUS BLOKIRANE ZARADI BIT V REGISTAR
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz	 // KAKVA KOMBINACIQ OT 4-te BITa VODI DO RAZBLOKIRANETO ???
    1210:	83 e5       	ldi	r24, 0x53	; 83
    1212:	8d b9       	out	0x0d, r24	; 13
	SPDR = 0b00000000;
    1214:	1f b8       	out	0x0f, r1	; 15

	PGA2310_U8_SPI_CS_high();	// /SS - DISABLE
	PGA2310_U8_SPI(0b00000000, 0b00000000);
	*/

	SPCR = (0<<SPE);
    1216:	1d b8       	out	0x0d, r1	; 13
}
    1218:	08 95       	ret

0000121a <spi_start>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    121a:	83 e5       	ldi	r24, 0x53	; 83
    121c:	8d b9       	out	0x0d, r24	; 13
}
    121e:	08 95       	ret

00001220 <spi_stop>:
/**************************************
** DEFINITION SPI FUNCTION STOP ONLY **
**************************************/
void spi_stop()
{
	SPCR = (0<<SPE);
    1220:	1d b8       	out	0x0d, r1	; 13
}
    1222:	08 95       	ret

00001224 <spi_write_one_byte>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1224:	93 e5       	ldi	r25, 0x53	; 83
    1226:	9d b9       	out	0x0d, r25	; 13
void spi_write_one_byte(unsigned char data)	// void PGA2310_U7_SPI(byte volume_left, byte volume_right)	//PGA2310_U7_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data;				//volume_right;
    1228:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    122a:	77 9b       	sbis	0x0e, 7	; 14
    122c:	fe cf       	rjmp	.-4      	; 0x122a <spi_write_one_byte+0x6>
	{
	}
}
    122e:	08 95       	ret

00001230 <spi_write_two_bytes>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1230:	93 e5       	ldi	r25, 0x53	; 83
    1232:	9d b9       	out	0x0d, r25	; 13
void spi_write_two_bytes(unsigned char data1, unsigned char data2)	// void PGA2310_U6_SPI(byte volume_left, byte volume_right)	//PGA2310_U6_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data1;				//volume_left;
    1234:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    1236:	77 9b       	sbis	0x0e, 7	; 14
    1238:	fe cf       	rjmp	.-4      	; 0x1236 <spi_write_two_bytes+0x6>
	{
	}

//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data2;				//volume_right;
    123a:	6f b9       	out	0x0f, r22	; 15
	while(!(SPSR & (1<<SPIF)))
    123c:	77 9b       	sbis	0x0e, 7	; 14
    123e:	fe cf       	rjmp	.-4      	; 0x123c <spi_write_two_bytes+0xc>
	{
	}
}
    1240:	08 95       	ret

00001242 <spi_write_more_bytes>:

/*********************************************
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
    1242:	fc 01       	movw	r30, r24
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1244:	93 e5       	ldi	r25, 0x53	; 83
    1246:	06 c0       	rjmp	.+12     	; 0x1254 <spi_write_more_bytes+0x12>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    1248:	31 96       	adiw	r30, 0x01	; 1
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    124a:	9d b9       	out	0x0d, r25	; 13
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
	{
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
		spi_start();
		SPDR = *data;			//volume_left;
    124c:	80 81       	ld	r24, Z
    124e:	8f b9       	out	0x0f, r24	; 15
		while(!(SPSR & (1<<SPIF)))
    1250:	77 9b       	sbis	0x0e, 7	; 14
    1252:	fe cf       	rjmp	.-4      	; 0x1250 <spi_write_more_bytes+0xe>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    1254:	80 81       	ld	r24, Z
    1256:	88 23       	and	r24, r24
    1258:	b9 f7       	brne	.-18     	; 0x1248 <spi_write_more_bytes+0x6>
		SPDR = *data;			//volume_left;
		while(!(SPSR & (1<<SPIF)))
		{
		}
	}
}
    125a:	08 95       	ret

0000125c <spi_read_more_bytes>:
unsigned char spi_read_more_bytes()	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
	unsigned char data = 0b00000000;
	//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data;			//volume_left;
    125c:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF)))
    125e:	77 9b       	sbis	0x0e, 7	; 14
    1260:	fe cf       	rjmp	.-4      	; 0x125e <spi_read_more_bytes+0x2>
	{
	}
	return data;
}
    1262:	80 e0       	ldi	r24, 0x00	; 0
    1264:	08 95       	ret

00001266 <decToBcd>:

/**************************************************************
**** CONVERT NORMAL DECIMAL NUMBERS TO BINARY CODED DECIMAL ***
**************************************************************/
unsigned char decToBcd(unsigned char val)
{
    1266:	48 2f       	mov	r20, r24
    1268:	6a e0       	ldi	r22, 0x0A	; 10
    126a:	0e 94 16 0b 	call	0x162c	; 0x162c <__udivmodqi4>
    126e:	28 2f       	mov	r18, r24
    1270:	30 e0       	ldi	r19, 0x00	; 0
    1272:	84 e0       	ldi	r24, 0x04	; 4
    1274:	22 0f       	add	r18, r18
    1276:	33 1f       	adc	r19, r19
    1278:	8a 95       	dec	r24
    127a:	e1 f7       	brne	.-8      	; 0x1274 <decToBcd+0xe>
    127c:	84 2f       	mov	r24, r20
    127e:	0e 94 16 0b 	call	0x162c	; 0x162c <__udivmodqi4>
	return ( (val/10*16) + (val%10) );	// Get DEC format -> convert DEC to HEX
}
    1282:	89 2f       	mov	r24, r25
    1284:	82 0f       	add	r24, r18
    1286:	08 95       	ret

00001288 <bcdToDec>:

/**************************************************************
**** CONVERT BINARY CODED DECIMAL TO NORMAL DECIMAL NUMBERS ***
**************************************************************/
unsigned char bcdToDec(unsigned char val)
{
    1288:	28 2f       	mov	r18, r24
    128a:	22 95       	swap	r18
    128c:	2f 70       	andi	r18, 0x0F	; 15
    128e:	9a e0       	ldi	r25, 0x0A	; 10
    1290:	29 9f       	mul	r18, r25
    1292:	90 01       	movw	r18, r0
    1294:	11 24       	eor	r1, r1
    1296:	8f 70       	andi	r24, 0x0F	; 15
	return ( (val/16*10) + (val%16) );	// Get HEX format -> convert HEX to DEC
}
    1298:	82 0f       	add	r24, r18
    129a:	08 95       	ret

0000129c <shiftRightOutLsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    129c:	a0 9a       	sbi	0x14, 0	; 20
    129e:	94 e4       	ldi	r25, 0x44	; 68
    12a0:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regALSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    12a2:	90 ff       	sbrs	r25, 0
    12a4:	02 c0       	rjmp	.+4      	; 0x12aa <shiftRightOutLsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v LSB
    12a6:	a8 9a       	sbi	0x15, 0	; 21
    12a8:	01 c0       	rjmp	.+2      	; 0x12ac <shiftRightOutLsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
    12aa:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12ac:	8f 5f       	subi	r24, 0xFF	; 255
    12ae:	88 30       	cpi	r24, 0x08	; 8
    12b0:	11 f0       	breq	.+4      	; 0x12b6 <shiftRightOutLsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
		}
		
		regALSB = regALSB >> 1;	// shiftvane na >> nadqsno
    12b2:	96 95       	lsr	r25
    12b4:	f6 cf       	rjmp	.-20     	; 0x12a2 <shiftRightOutLsbFirst+0x6>
    12b6:	08 95       	ret

000012b8 <shiftLeftOutMsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    12b8:	a0 9a       	sbi	0x14, 0	; 20
    12ba:	94 e4       	ldi	r25, 0x44	; 68
    12bc:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regAMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
    12be:	97 ff       	sbrs	r25, 7
    12c0:	02 c0       	rjmp	.+4      	; 0x12c6 <shiftLeftOutMsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v MSB
    12c2:	a8 9a       	sbi	0x15, 0	; 21
    12c4:	01 c0       	rjmp	.+2      	; 0x12c8 <shiftLeftOutMsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
    12c6:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12c8:	8f 5f       	subi	r24, 0xFF	; 255
    12ca:	88 30       	cpi	r24, 0x08	; 8
    12cc:	11 f0       	breq	.+4      	; 0x12d2 <shiftLeftOutMsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
		}
		
		regAMSB = regAMSB << 1;	// shiftvane na << nalqvo
    12ce:	99 0f       	add	r25, r25
    12d0:	f6 cf       	rjmp	.-20     	; 0x12be <shiftLeftOutMsbFirst+0x6>
    12d2:	08 95       	ret

000012d4 <shiftRightInLsbFirst>:
void shiftRightInLsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    12d4:	a0 98       	cbi	0x14, 0	; 20
    12d6:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
    12d8:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12da:	8f 5f       	subi	r24, 0xFF	; 255
    12dc:	88 30       	cpi	r24, 0x08	; 8
    12de:	e1 f7       	brne	.-8      	; 0x12d8 <shiftRightInLsbFirst+0x4>
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
	}

}
    12e0:	08 95       	ret

000012e2 <shiftLeftInMsbFirst>:
void shiftLeftInMsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    12e2:	a0 98       	cbi	0x14, 0	; 20
    12e4:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
    12e6:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12e8:	8f 5f       	subi	r24, 0xFF	; 255
    12ea:	88 30       	cpi	r24, 0x08	; 8
    12ec:	e1 f7       	brne	.-8      	; 0x12e6 <shiftLeftInMsbFirst+0x4>
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
	}

}
    12ee:	08 95       	ret

000012f0 <delay_ms>:

/*************************************************************
*********** FUNCTION SOFTWARE DELAY IN MILISECONDS ***********
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
    12f0:	40 e0       	ldi	r20, 0x00	; 0
    12f2:	50 e0       	ldi	r21, 0x00	; 0
    12f4:	0b c0       	rjmp	.+22     	; 0x130c <delay_ms+0x1c>
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    12f6:	20 e0       	ldi	r18, 0x00	; 0
    12f8:	30 e0       	ldi	r19, 0x00	; 0
	{
		for(j=0;j<100;j++)
		{
		  asm("nop");
    12fa:	00 00       	nop
		  asm("nop");
    12fc:	00 00       	nop
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
	{
		for(j=0;j<100;j++)
    12fe:	2f 5f       	subi	r18, 0xFF	; 255
    1300:	3f 4f       	sbci	r19, 0xFF	; 255
    1302:	24 36       	cpi	r18, 0x64	; 100
    1304:	31 05       	cpc	r19, r1
    1306:	c9 f7       	brne	.-14     	; 0x12fa <delay_ms+0xa>
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1308:	4f 5f       	subi	r20, 0xFF	; 255
    130a:	5f 4f       	sbci	r21, 0xFF	; 255
    130c:	48 17       	cp	r20, r24
    130e:	59 07       	cpc	r21, r25
    1310:	94 f3       	brlt	.-28     	; 0x12f6 <delay_ms+0x6>
		{
		  asm("nop");
		  asm("nop");
		}
	}
}
    1312:	08 95       	ret

00001314 <rotaryEncoderNikBarzakov>:
** READ/SCAN ROTARY ENCODER OF NIK BARZAKOV **
*********************************************/
char rotaryEncoderNikBarzakov()
{
	char tempEncoder = 0;
	if((ENCODER_A_low()) && (ENCODER_B_low()))			// A0, B0
    1314:	9d 99       	sbic	0x13, 5	; 19
    1316:	0e c0       	rjmp	.+28     	; 0x1334 <rotaryEncoderNikBarzakov+0x20>
    1318:	9c 99       	sbic	0x13, 4	; 19
    131a:	0c c0       	rjmp	.+24     	; 0x1334 <rotaryEncoderNikBarzakov+0x20>
    131c:	88 ec       	ldi	r24, 0xC8	; 200
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	01 97       	sbiw	r24, 0x01	; 1
    1322:	f1 f7       	brne	.-4      	; 0x1320 <rotaryEncoderNikBarzakov+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_high()) && (ENCODER_B_low()))		// A1, B0
    1324:	9d 9b       	sbis	0x13, 5	; 19
    1326:	14 c0       	rjmp	.+40     	; 0x1350 <rotaryEncoderNikBarzakov+0x3c>
    1328:	83 b3       	in	r24, 0x13	; 19
    132a:	82 95       	swap	r24
    132c:	8f 70       	andi	r24, 0x0F	; 15
    132e:	80 95       	com	r24
    1330:	81 70       	andi	r24, 0x01	; 1
    1332:	08 95       	ret
// VOLUME UP
			tempEncoder = 1;	//	tempEncoder++;
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}
	}
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    1334:	9d 9b       	sbis	0x13, 5	; 19
    1336:	0c c0       	rjmp	.+24     	; 0x1350 <rotaryEncoderNikBarzakov+0x3c>
    1338:	9c 99       	sbic	0x13, 4	; 19
    133a:	0a c0       	rjmp	.+20     	; 0x1350 <rotaryEncoderNikBarzakov+0x3c>
    133c:	88 ec       	ldi	r24, 0xC8	; 200
    133e:	90 e0       	ldi	r25, 0x00	; 0
    1340:	01 97       	sbiw	r24, 0x01	; 1
    1342:	f1 f7       	brne	.-4      	; 0x1340 <rotaryEncoderNikBarzakov+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    1344:	9d 99       	sbic	0x13, 5	; 19
    1346:	04 c0       	rjmp	.+8      	; 0x1350 <rotaryEncoderNikBarzakov+0x3c>
    1348:	9c 99       	sbic	0x13, 4	; 19
    134a:	02 c0       	rjmp	.+4      	; 0x1350 <rotaryEncoderNikBarzakov+0x3c>
    134c:	8f ef       	ldi	r24, 0xFF	; 255
    134e:	08 95       	ret
    1350:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    1352:	08 95       	ret

00001354 <rotaryEncoderVer1>:
** READ/SCAN ROTARY ENCODER VERSION 1 / MODEL 1 **
*************************************************/
char rotaryEncoderVer1()	// Check imediate now bits in PIN register.
{
	char tempEncoder = 0;							// A1, B1
	if((ENCODER_A_low()) && (ENCODER_B_high()))			// A0, B1
    1354:	9d 99       	sbic	0x13, 5	; 19
    1356:	0e c0       	rjmp	.+28     	; 0x1374 <rotaryEncoderVer1+0x20>
    1358:	9c 9b       	sbis	0x13, 4	; 19
    135a:	0c c0       	rjmp	.+24     	; 0x1374 <rotaryEncoderVer1+0x20>
    135c:	88 ec       	ldi	r24, 0xC8	; 200
    135e:	90 e0       	ldi	r25, 0x00	; 0
    1360:	01 97       	sbiw	r24, 0x01	; 1
    1362:	f1 f7       	brne	.-4      	; 0x1360 <rotaryEncoderVer1+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    1364:	9d 99       	sbic	0x13, 5	; 19
    1366:	14 c0       	rjmp	.+40     	; 0x1390 <rotaryEncoderVer1+0x3c>
    1368:	83 b3       	in	r24, 0x13	; 19
    136a:	82 95       	swap	r24
    136c:	8f 70       	andi	r24, 0x0F	; 15
    136e:	80 95       	com	r24
    1370:	81 70       	andi	r24, 0x01	; 1
    1372:	08 95       	ret
//			PORTD = volumeMassive[volumeIndex];
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}

	}													// A1. B1
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    1374:	9d 9b       	sbis	0x13, 5	; 19
    1376:	0c c0       	rjmp	.+24     	; 0x1390 <rotaryEncoderVer1+0x3c>
    1378:	9c 99       	sbic	0x13, 4	; 19
    137a:	0a c0       	rjmp	.+20     	; 0x1390 <rotaryEncoderVer1+0x3c>
    137c:	88 ec       	ldi	r24, 0xC8	; 200
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	01 97       	sbiw	r24, 0x01	; 1
    1382:	f1 f7       	brne	.-4      	; 0x1380 <rotaryEncoderVer1+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    1384:	9d 99       	sbic	0x13, 5	; 19
    1386:	04 c0       	rjmp	.+8      	; 0x1390 <rotaryEncoderVer1+0x3c>
    1388:	9c 99       	sbic	0x13, 4	; 19
    138a:	02 c0       	rjmp	.+4      	; 0x1390 <rotaryEncoderVer1+0x3c>
    138c:	8f ef       	ldi	r24, 0xFF	; 255
    138e:	08 95       	ret
    1390:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    1392:	08 95       	ret

00001394 <rotaryEncoderVer2>:
    1394:	88 ec       	ldi	r24, 0xC8	; 200
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	fc 01       	movw	r30, r24
    139a:	31 97       	sbiw	r30, 0x01	; 1
    139c:	f1 f7       	brne	.-4      	; 0x139a <rotaryEncoderVer2+0x6>
    139e:	fc 01       	movw	r30, r24
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	f1 f7       	brne	.-4      	; 0x13a0 <rotaryEncoderVer2+0xc>
    13a4:	01 97       	sbiw	r24, 0x01	; 1
    13a6:	f1 f7       	brne	.-4      	; 0x13a4 <rotaryEncoderVer2+0x10>
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    13a8:	80 e0       	ldi	r24, 0x00	; 0
    13aa:	08 95       	ret

000013ac <RELAYS_IN_INIT>:
/*********************************************
** INITIZLIZATION OF SHIFT REGISTER 74HC595 **
*********************************************/
void RELAYS_IN_INIT()
{
}
    13ac:	08 95       	ret

000013ae <RELAYS_OUT_INIT>:

void RELAYS_OUT_INIT()
{
}
    13ae:	08 95       	ret

000013b0 <RELAYS_IN_CHOOSE>:

/****************************************************************************************************************
** DEFINITION RELAYS IN FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS IN **
****************************************************************************************************************/
void RELAYS_IN_CHOOSE(unsigned char rel_in)	// HELP: RELAYS_IN_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    13b0:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELIN_SCK_low();
    13b2:	ae 98       	cbi	0x15, 6	; 21

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    13b4:	80 ff       	sbrs	r24, 0
    13b6:	02 c0       	rjmp	.+4      	; 0x13bc <RELAYS_IN_CHOOSE+0xc>
		{
			RELIN_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    13b8:	af 9a       	sbi	0x15, 7	; 21
    13ba:	01 c0       	rjmp	.+2      	; 0x13be <RELAYS_IN_CHOOSE+0xe>
		}
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    13bc:	af 98       	cbi	0x15, 7	; 21
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELIN_SCK_high();
    13be:	ae 9a       	sbi	0x15, 6	; 21
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    13c0:	9f 5f       	subi	r25, 0xFF	; 255
    13c2:	98 30       	cpi	r25, 0x08	; 8
    13c4:	11 f0       	breq	.+4      	; 0x13ca <RELAYS_IN_CHOOSE+0x1a>
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    13c6:	86 95       	lsr	r24
    13c8:	f4 cf       	rjmp	.-24     	; 0x13b2 <RELAYS_IN_CHOOSE+0x2>

		RELIN_SCK_high();
	}

	RELIN_RCK_low();
    13ca:	ab 98       	cbi	0x15, 3	; 21
    13cc:	88 ea       	ldi	r24, 0xA8	; 168
    13ce:	92 e0       	ldi	r25, 0x02	; 2
    13d0:	fc 01       	movw	r30, r24
    13d2:	31 97       	sbiw	r30, 0x01	; 1
    13d4:	f1 f7       	brne	.-4      	; 0x13d2 <RELAYS_IN_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELIN_RCK_high();
    13d6:	ab 9a       	sbi	0x15, 3	; 21
    13d8:	01 97       	sbiw	r24, 0x01	; 1
    13da:	f1 f7       	brne	.-4      	; 0x13d8 <RELAYS_IN_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    13dc:	08 95       	ret

000013de <relays_in1_2ch>:

void relays_in1_2ch()
{
	RELAYS_IN_CHOOSE(0b00100000);	// RELE 1
    13de:	80 e2       	ldi	r24, 0x20	; 32
    13e0:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <RELAYS_IN_CHOOSE>
}
    13e4:	08 95       	ret

000013e6 <relays_in1_6ch>:

void relays_in1_6ch()
{
	RELAYS_IN_CHOOSE(0b01100001);	// RELE 1,2,3
    13e6:	81 e6       	ldi	r24, 0x61	; 97
    13e8:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <RELAYS_IN_CHOOSE>
}
    13ec:	08 95       	ret

000013ee <relays_in2_2ch>:

void relays_in2_2ch()
{
	RELAYS_IN_CHOOSE(0b00001010);	// RELE 4,5
    13ee:	8a e0       	ldi	r24, 0x0A	; 10
    13f0:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <RELAYS_IN_CHOOSE>
}
    13f4:	08 95       	ret

000013f6 <relays_in2_6ch>:

void relays_in2_6ch()
{
	RELAYS_IN_CHOOSE(0b10011010);	// RELE 4,5,6,7
    13f6:	8a e9       	ldi	r24, 0x9A	; 154
    13f8:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <RELAYS_IN_CHOOSE>
}
    13fc:	08 95       	ret

000013fe <relays_in3_2ch>:

void relays_in3_2ch()
{
	RELAYS_IN_CHOOSE(0b00001100);	// RELE 8,5
    13fe:	8c e0       	ldi	r24, 0x0C	; 12
    1400:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <RELAYS_IN_CHOOSE>
}
    1404:	08 95       	ret

00001406 <relays_in3_6ch>:

void relays_in3_6ch()
{
	RELAYS_IN_CHOOSE(0b10011100);	// RELE 8,5,6,7
    1406:	8c e9       	ldi	r24, 0x9C	; 156
    1408:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <RELAYS_IN_CHOOSE>
}
    140c:	08 95       	ret

0000140e <relays_in_off>:

void relays_in_off()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    140e:	80 e0       	ldi	r24, 0x00	; 0
    1410:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <RELAYS_IN_CHOOSE>
}
    1414:	08 95       	ret

00001416 <relays_in_init>:

void relays_in_init()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    1416:	80 e0       	ldi	r24, 0x00	; 0
    1418:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <RELAYS_IN_CHOOSE>
}
    141c:	08 95       	ret

0000141e <RELAYS_OUT_CHOOSE>:
/******************************************************************************************************************
** DEFINITION RELAYS OUT FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS OUT **
******************************************************************************************************************/
void RELAYS_OUT_CHOOSE(unsigned char rel_out)	// HELP: RELAYS_OUT_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    141e:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELOUT_SCK_low();
    1420:	96 98       	cbi	0x12, 6	; 18

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1422:	80 ff       	sbrs	r24, 0
    1424:	02 c0       	rjmp	.+4      	; 0x142a <RELAYS_OUT_CHOOSE+0xc>
		{
			RELOUT_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    1426:	c4 9a       	sbi	0x18, 4	; 24
    1428:	01 c0       	rjmp	.+2      	; 0x142c <RELAYS_OUT_CHOOSE+0xe>
		}
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    142a:	c4 98       	cbi	0x18, 4	; 24
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELOUT_SCK_high();
    142c:	96 9a       	sbi	0x12, 6	; 18
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    142e:	9f 5f       	subi	r25, 0xFF	; 255
    1430:	98 30       	cpi	r25, 0x08	; 8
    1432:	11 f0       	breq	.+4      	; 0x1438 <RELAYS_OUT_CHOOSE+0x1a>
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    1434:	86 95       	lsr	r24
    1436:	f4 cf       	rjmp	.-24     	; 0x1420 <RELAYS_OUT_CHOOSE+0x2>

		RELOUT_SCK_high();
	}

	RELOUT_RCK_low();
    1438:	97 98       	cbi	0x12, 7	; 18
    143a:	88 ea       	ldi	r24, 0xA8	; 168
    143c:	92 e0       	ldi	r25, 0x02	; 2
    143e:	fc 01       	movw	r30, r24
    1440:	31 97       	sbiw	r30, 0x01	; 1
    1442:	f1 f7       	brne	.-4      	; 0x1440 <RELAYS_OUT_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELOUT_RCK_high();
    1444:	97 9a       	sbi	0x12, 7	; 18
    1446:	01 97       	sbiw	r24, 0x01	; 1
    1448:	f1 f7       	brne	.-4      	; 0x1446 <RELAYS_OUT_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    144a:	08 95       	ret

0000144c <relays_out_1ch>:

void relays_out_1ch()
{
	RELAYS_OUT_CHOOSE(0b10000000);	// RELE 1
    144c:	80 e8       	ldi	r24, 0x80	; 128
    144e:	0e 94 0f 0a 	call	0x141e	; 0x141e <RELAYS_OUT_CHOOSE>
}
    1452:	08 95       	ret

00001454 <relays_out_6ch>:

void relays_out_6ch()
{
	RELAYS_OUT_CHOOSE(0b11111100);	// RELE 1,2,3,4,5,6
    1454:	8c ef       	ldi	r24, 0xFC	; 252
    1456:	0e 94 0f 0a 	call	0x141e	; 0x141e <RELAYS_OUT_CHOOSE>
}
    145a:	08 95       	ret

0000145c <relays_out_off>:
void relays_out_off()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    145c:	80 e0       	ldi	r24, 0x00	; 0
    145e:	0e 94 0f 0a 	call	0x141e	; 0x141e <RELAYS_OUT_CHOOSE>
}
    1462:	08 95       	ret

00001464 <relays_out_init>:
void relays_out_init()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    1464:	80 e0       	ldi	r24, 0x00	; 0
    1466:	0e 94 0f 0a 	call	0x141e	; 0x141e <RELAYS_OUT_CHOOSE>
}
    146a:	08 95       	ret

0000146c <GetSIRC12>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    146c:	10 92 b0 07 	sts	0x07B0, r1
    1470:	10 92 b5 07 	sts	0x07B5, r1

	while(irPin);				//wait for it to be low
    1474:	82 99       	sbic	0x10, 2	; 16
    1476:	fe cf       	rjmp	.-4      	; 0x1474 <GetSIRC12+0x8>
    1478:	20 e0       	ldi	r18, 0x00	; 0
    147a:	40 e2       	ldi	r20, 0x20	; 32
    147c:	53 e0       	ldi	r21, 0x03	; 3
    147e:	04 c0       	rjmp	.+8      	; 0x1488 <GetSIRC12+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    1480:	2f 5f       	subi	r18, 0xFF	; 255
    1482:	ca 01       	movw	r24, r20
    1484:	01 97       	sbiw	r24, 0x01	; 1
    1486:	f1 f7       	brne	.-4      	; 0x1484 <GetSIRC12+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    1488:	82 9b       	sbis	0x10, 2	; 16
    148a:	fa cf       	rjmp	.-12     	; 0x1480 <GetSIRC12+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    148c:	2b 50       	subi	r18, 0x0B	; 11
    148e:	23 30       	cpi	r18, 0x03	; 3
    1490:	70 f5       	brcc	.+92     	; 0x14ee <GetSIRC12+0x82>
	{
		return;		//goto StartLook;
    1492:	40 e0       	ldi	r20, 0x00	; 0
    1494:	30 e0       	ldi	r19, 0x00	; 0
    1496:	60 e2       	ldi	r22, 0x20	; 32
    1498:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    149a:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    149c:	82 99       	sbic	0x10, 2	; 16
    149e:	fe cf       	rjmp	.-4      	; 0x149c <GetSIRC12+0x30>
    14a0:	20 e0       	ldi	r18, 0x00	; 0
    14a2:	04 c0       	rjmp	.+8      	; 0x14ac <GetSIRC12+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    14a4:	2f 5f       	subi	r18, 0xFF	; 255
    14a6:	cb 01       	movw	r24, r22
    14a8:	01 97       	sbiw	r24, 0x01	; 1
    14aa:	f1 f7       	brne	.-4      	; 0x14a8 <GetSIRC12+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    14ac:	82 9b       	sbis	0x10, 2	; 16
    14ae:	fa cf       	rjmp	.-12     	; 0x14a4 <GetSIRC12+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    14b0:	26 30       	cpi	r18, 0x06	; 6
    14b2:	08 f0       	brcs	.+2      	; 0x14b6 <GetSIRC12+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    14b4:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    14b6:	4f 5f       	subi	r20, 0xFF	; 255
    14b8:	47 30       	cpi	r20, 0x07	; 7
    14ba:	79 f7       	brne	.-34     	; 0x149a <GetSIRC12+0x2e>
    14bc:	30 93 b0 07 	sts	0x07B0, r19
    14c0:	40 e0       	ldi	r20, 0x00	; 0
    14c2:	30 e0       	ldi	r19, 0x00	; 0
    14c4:	60 e2       	ldi	r22, 0x20	; 32
    14c6:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    14c8:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    14ca:	82 99       	sbic	0x10, 2	; 16
    14cc:	fe cf       	rjmp	.-4      	; 0x14ca <GetSIRC12+0x5e>
    14ce:	20 e0       	ldi	r18, 0x00	; 0
    14d0:	04 c0       	rjmp	.+8      	; 0x14da <GetSIRC12+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    14d2:	2f 5f       	subi	r18, 0xFF	; 255
    14d4:	cb 01       	movw	r24, r22
    14d6:	01 97       	sbiw	r24, 0x01	; 1
    14d8:	f1 f7       	brne	.-4      	; 0x14d6 <GetSIRC12+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    14da:	82 9b       	sbis	0x10, 2	; 16
    14dc:	fa cf       	rjmp	.-12     	; 0x14d2 <GetSIRC12+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    14de:	26 30       	cpi	r18, 0x06	; 6
    14e0:	08 f0       	brcs	.+2      	; 0x14e4 <GetSIRC12+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    14e2:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
    14e4:	4f 5f       	subi	r20, 0xFF	; 255
    14e6:	45 30       	cpi	r20, 0x05	; 5
    14e8:	79 f7       	brne	.-34     	; 0x14c8 <GetSIRC12+0x5c>
    14ea:	30 93 b5 07 	sts	0x07B5, r19
    14ee:	08 95       	ret

000014f0 <GetSIRC15>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    14f0:	10 92 b0 07 	sts	0x07B0, r1
    14f4:	10 92 b5 07 	sts	0x07B5, r1

	while(irPin);				//wait for it to be low
    14f8:	82 99       	sbic	0x10, 2	; 16
    14fa:	fe cf       	rjmp	.-4      	; 0x14f8 <GetSIRC15+0x8>
    14fc:	20 e0       	ldi	r18, 0x00	; 0
    14fe:	40 e2       	ldi	r20, 0x20	; 32
    1500:	53 e0       	ldi	r21, 0x03	; 3
    1502:	04 c0       	rjmp	.+8      	; 0x150c <GetSIRC15+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    1504:	2f 5f       	subi	r18, 0xFF	; 255
    1506:	ca 01       	movw	r24, r20
    1508:	01 97       	sbiw	r24, 0x01	; 1
    150a:	f1 f7       	brne	.-4      	; 0x1508 <GetSIRC15+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    150c:	82 9b       	sbis	0x10, 2	; 16
    150e:	fa cf       	rjmp	.-12     	; 0x1504 <GetSIRC15+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1510:	2b 50       	subi	r18, 0x0B	; 11
    1512:	23 30       	cpi	r18, 0x03	; 3
    1514:	70 f5       	brcc	.+92     	; 0x1572 <GetSIRC15+0x82>
	{
		return;		//goto StartLook;
    1516:	40 e0       	ldi	r20, 0x00	; 0
    1518:	30 e0       	ldi	r19, 0x00	; 0
    151a:	60 e2       	ldi	r22, 0x20	; 32
    151c:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    151e:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1520:	82 99       	sbic	0x10, 2	; 16
    1522:	fe cf       	rjmp	.-4      	; 0x1520 <GetSIRC15+0x30>
    1524:	20 e0       	ldi	r18, 0x00	; 0
    1526:	04 c0       	rjmp	.+8      	; 0x1530 <GetSIRC15+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    1528:	2f 5f       	subi	r18, 0xFF	; 255
    152a:	cb 01       	movw	r24, r22
    152c:	01 97       	sbiw	r24, 0x01	; 1
    152e:	f1 f7       	brne	.-4      	; 0x152c <GetSIRC15+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1530:	82 9b       	sbis	0x10, 2	; 16
    1532:	fa cf       	rjmp	.-12     	; 0x1528 <GetSIRC15+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1534:	26 30       	cpi	r18, 0x06	; 6
    1536:	08 f0       	brcs	.+2      	; 0x153a <GetSIRC15+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    1538:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    153a:	4f 5f       	subi	r20, 0xFF	; 255
    153c:	47 30       	cpi	r20, 0x07	; 7
    153e:	79 f7       	brne	.-34     	; 0x151e <GetSIRC15+0x2e>
    1540:	30 93 b0 07 	sts	0x07B0, r19
    1544:	40 e0       	ldi	r20, 0x00	; 0
    1546:	30 e0       	ldi	r19, 0x00	; 0
    1548:	60 e2       	ldi	r22, 0x20	; 32
    154a:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    154c:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    154e:	82 99       	sbic	0x10, 2	; 16
    1550:	fe cf       	rjmp	.-4      	; 0x154e <GetSIRC15+0x5e>
    1552:	20 e0       	ldi	r18, 0x00	; 0
    1554:	04 c0       	rjmp	.+8      	; 0x155e <GetSIRC15+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1556:	2f 5f       	subi	r18, 0xFF	; 255
    1558:	cb 01       	movw	r24, r22
    155a:	01 97       	sbiw	r24, 0x01	; 1
    155c:	f1 f7       	brne	.-4      	; 0x155a <GetSIRC15+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    155e:	82 9b       	sbis	0x10, 2	; 16
    1560:	fa cf       	rjmp	.-12     	; 0x1556 <GetSIRC15+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1562:	26 30       	cpi	r18, 0x06	; 6
    1564:	08 f0       	brcs	.+2      	; 0x1568 <GetSIRC15+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1566:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
    1568:	4f 5f       	subi	r20, 0xFF	; 255
    156a:	48 30       	cpi	r20, 0x08	; 8
    156c:	79 f7       	brne	.-34     	; 0x154c <GetSIRC15+0x5c>
    156e:	30 93 b5 07 	sts	0x07B5, r19
    1572:	08 95       	ret

00001574 <GetSIRC20>:
{
	char x;
	char lTime;

//StartLook:
	irExtended = irAddress = irCommand = 0;
    1574:	10 92 b0 07 	sts	0x07B0, r1
    1578:	10 92 b5 07 	sts	0x07B5, r1
    157c:	10 92 b7 07 	sts	0x07B7, r1

	while(irPin);				//wait for it to be low
    1580:	82 99       	sbic	0x10, 2	; 16
    1582:	fe cf       	rjmp	.-4      	; 0x1580 <GetSIRC20+0xc>
    1584:	20 e0       	ldi	r18, 0x00	; 0
    1586:	40 e2       	ldi	r20, 0x20	; 32
    1588:	53 e0       	ldi	r21, 0x03	; 3
    158a:	04 c0       	rjmp	.+8      	; 0x1594 <GetSIRC20+0x20>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    158c:	2f 5f       	subi	r18, 0xFF	; 255
    158e:	ca 01       	movw	r24, r20
    1590:	01 97       	sbiw	r24, 0x01	; 1
    1592:	f1 f7       	brne	.-4      	; 0x1590 <GetSIRC20+0x1c>
	irExtended = irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    1594:	82 9b       	sbis	0x10, 2	; 16
    1596:	fa cf       	rjmp	.-12     	; 0x158c <GetSIRC20+0x18>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1598:	2b 50       	subi	r18, 0x0B	; 11
    159a:	23 30       	cpi	r18, 0x03	; 3
    159c:	08 f0       	brcs	.+2      	; 0x15a0 <GetSIRC20+0x2c>
    159e:	45 c0       	rjmp	.+138    	; 0x162a <GetSIRC20+0xb6>
	{
		return;		//goto StartLook;
    15a0:	40 e0       	ldi	r20, 0x00	; 0
    15a2:	30 e0       	ldi	r19, 0x00	; 0
    15a4:	60 e2       	ldi	r22, 0x20	; 32
    15a6:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    15a8:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    15aa:	82 99       	sbic	0x10, 2	; 16
    15ac:	fe cf       	rjmp	.-4      	; 0x15aa <GetSIRC20+0x36>
    15ae:	20 e0       	ldi	r18, 0x00	; 0
    15b0:	04 c0       	rjmp	.+8      	; 0x15ba <GetSIRC20+0x46>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    15b2:	2f 5f       	subi	r18, 0xFF	; 255
    15b4:	cb 01       	movw	r24, r22
    15b6:	01 97       	sbiw	r24, 0x01	; 1
    15b8:	f1 f7       	brne	.-4      	; 0x15b6 <GetSIRC20+0x42>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    15ba:	82 9b       	sbis	0x10, 2	; 16
    15bc:	fa cf       	rjmp	.-12     	; 0x15b2 <GetSIRC20+0x3e>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    15be:	26 30       	cpi	r18, 0x06	; 6
    15c0:	08 f0       	brcs	.+2      	; 0x15c4 <GetSIRC20+0x50>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    15c2:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    15c4:	4f 5f       	subi	r20, 0xFF	; 255
    15c6:	47 30       	cpi	r20, 0x07	; 7
    15c8:	79 f7       	brne	.-34     	; 0x15a8 <GetSIRC20+0x34>
    15ca:	30 93 b0 07 	sts	0x07B0, r19
    15ce:	40 e0       	ldi	r20, 0x00	; 0
    15d0:	30 e0       	ldi	r19, 0x00	; 0
    15d2:	60 e2       	ldi	r22, 0x20	; 32
    15d4:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    15d6:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    15d8:	82 99       	sbic	0x10, 2	; 16
    15da:	fe cf       	rjmp	.-4      	; 0x15d8 <GetSIRC20+0x64>
    15dc:	20 e0       	ldi	r18, 0x00	; 0
    15de:	04 c0       	rjmp	.+8      	; 0x15e8 <GetSIRC20+0x74>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    15e0:	2f 5f       	subi	r18, 0xFF	; 255
    15e2:	cb 01       	movw	r24, r22
    15e4:	01 97       	sbiw	r24, 0x01	; 1
    15e6:	f1 f7       	brne	.-4      	; 0x15e4 <GetSIRC20+0x70>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    15e8:	82 9b       	sbis	0x10, 2	; 16
    15ea:	fa cf       	rjmp	.-12     	; 0x15e0 <GetSIRC20+0x6c>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    15ec:	26 30       	cpi	r18, 0x06	; 6
    15ee:	08 f0       	brcs	.+2      	; 0x15f2 <GetSIRC20+0x7e>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    15f0:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
    15f2:	4f 5f       	subi	r20, 0xFF	; 255
    15f4:	45 30       	cpi	r20, 0x05	; 5
    15f6:	79 f7       	brne	.-34     	; 0x15d6 <GetSIRC20+0x62>
    15f8:	30 93 b5 07 	sts	0x07B5, r19
    15fc:	40 e0       	ldi	r20, 0x00	; 0
    15fe:	30 e0       	ldi	r19, 0x00	; 0
    1600:	60 e2       	ldi	r22, 0x20	; 32
    1602:	73 e0       	ldi	r23, 0x03	; 3
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
		{
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1604:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1606:	82 99       	sbic	0x10, 2	; 16
    1608:	fe cf       	rjmp	.-4      	; 0x1606 <GetSIRC20+0x92>
    160a:	20 e0       	ldi	r18, 0x00	; 0
    160c:	04 c0       	rjmp	.+8      	; 0x1616 <GetSIRC20+0xa2>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    160e:	2f 5f       	subi	r18, 0xFF	; 255
    1610:	cb 01       	movw	r24, r22
    1612:	01 97       	sbiw	r24, 0x01	; 1
    1614:	f1 f7       	brne	.-4      	; 0x1612 <GetSIRC20+0x9e>
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1616:	82 9b       	sbis	0x10, 2	; 16
    1618:	fa cf       	rjmp	.-12     	; 0x160e <GetSIRC20+0x9a>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    161a:	26 30       	cpi	r18, 0x06	; 6
    161c:	08 f0       	brcs	.+2      	; 0x1620 <GetSIRC20+0xac>
				irExtended |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    161e:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
    1620:	4f 5f       	subi	r20, 0xFF	; 255
    1622:	48 30       	cpi	r20, 0x08	; 8
    1624:	79 f7       	brne	.-34     	; 0x1604 <GetSIRC20+0x90>
    1626:	30 93 b7 07 	sts	0x07B7, r19
    162a:	08 95       	ret

0000162c <__udivmodqi4>:
    162c:	99 1b       	sub	r25, r25
    162e:	79 e0       	ldi	r23, 0x09	; 9
    1630:	04 c0       	rjmp	.+8      	; 0x163a <__udivmodqi4_ep>

00001632 <__udivmodqi4_loop>:
    1632:	99 1f       	adc	r25, r25
    1634:	96 17       	cp	r25, r22
    1636:	08 f0       	brcs	.+2      	; 0x163a <__udivmodqi4_ep>
    1638:	96 1b       	sub	r25, r22

0000163a <__udivmodqi4_ep>:
    163a:	88 1f       	adc	r24, r24
    163c:	7a 95       	dec	r23
    163e:	c9 f7       	brne	.-14     	; 0x1632 <__udivmodqi4_loop>
    1640:	80 95       	com	r24
    1642:	08 95       	ret

00001644 <__divmodhi4>:
    1644:	97 fb       	bst	r25, 7
    1646:	09 2e       	mov	r0, r25
    1648:	07 26       	eor	r0, r23
    164a:	0a d0       	rcall	.+20     	; 0x1660 <__divmodhi4_neg1>
    164c:	77 fd       	sbrc	r23, 7
    164e:	04 d0       	rcall	.+8      	; 0x1658 <__divmodhi4_neg2>
    1650:	0c d0       	rcall	.+24     	; 0x166a <__udivmodhi4>
    1652:	06 d0       	rcall	.+12     	; 0x1660 <__divmodhi4_neg1>
    1654:	00 20       	and	r0, r0
    1656:	1a f4       	brpl	.+6      	; 0x165e <__divmodhi4_exit>

00001658 <__divmodhi4_neg2>:
    1658:	70 95       	com	r23
    165a:	61 95       	neg	r22
    165c:	7f 4f       	sbci	r23, 0xFF	; 255

0000165e <__divmodhi4_exit>:
    165e:	08 95       	ret

00001660 <__divmodhi4_neg1>:
    1660:	f6 f7       	brtc	.-4      	; 0x165e <__divmodhi4_exit>
    1662:	90 95       	com	r25
    1664:	81 95       	neg	r24
    1666:	9f 4f       	sbci	r25, 0xFF	; 255
    1668:	08 95       	ret

0000166a <__udivmodhi4>:
    166a:	aa 1b       	sub	r26, r26
    166c:	bb 1b       	sub	r27, r27
    166e:	51 e1       	ldi	r21, 0x11	; 17
    1670:	07 c0       	rjmp	.+14     	; 0x1680 <__udivmodhi4_ep>

00001672 <__udivmodhi4_loop>:
    1672:	aa 1f       	adc	r26, r26
    1674:	bb 1f       	adc	r27, r27
    1676:	a6 17       	cp	r26, r22
    1678:	b7 07       	cpc	r27, r23
    167a:	10 f0       	brcs	.+4      	; 0x1680 <__udivmodhi4_ep>
    167c:	a6 1b       	sub	r26, r22
    167e:	b7 0b       	sbc	r27, r23

00001680 <__udivmodhi4_ep>:
    1680:	88 1f       	adc	r24, r24
    1682:	99 1f       	adc	r25, r25
    1684:	5a 95       	dec	r21
    1686:	a9 f7       	brne	.-22     	; 0x1672 <__udivmodhi4_loop>
    1688:	80 95       	com	r24
    168a:	90 95       	com	r25
    168c:	bc 01       	movw	r22, r24
    168e:	cd 01       	movw	r24, r26
    1690:	08 95       	ret

00001692 <itoa>:
    1692:	fb 01       	movw	r30, r22
    1694:	9f 01       	movw	r18, r30
    1696:	e8 94       	clt
    1698:	42 30       	cpi	r20, 0x02	; 2
    169a:	c4 f0       	brlt	.+48     	; 0x16cc <itoa+0x3a>
    169c:	45 32       	cpi	r20, 0x25	; 37
    169e:	b4 f4       	brge	.+44     	; 0x16cc <itoa+0x3a>
    16a0:	4a 30       	cpi	r20, 0x0A	; 10
    16a2:	29 f4       	brne	.+10     	; 0x16ae <itoa+0x1c>
    16a4:	97 fb       	bst	r25, 7
    16a6:	1e f4       	brtc	.+6      	; 0x16ae <itoa+0x1c>
    16a8:	90 95       	com	r25
    16aa:	81 95       	neg	r24
    16ac:	9f 4f       	sbci	r25, 0xFF	; 255
    16ae:	64 2f       	mov	r22, r20
    16b0:	77 27       	eor	r23, r23
    16b2:	0e 94 35 0b 	call	0x166a	; 0x166a <__udivmodhi4>
    16b6:	80 5d       	subi	r24, 0xD0	; 208
    16b8:	8a 33       	cpi	r24, 0x3A	; 58
    16ba:	0c f0       	brlt	.+2      	; 0x16be <itoa+0x2c>
    16bc:	89 5d       	subi	r24, 0xD9	; 217
    16be:	81 93       	st	Z+, r24
    16c0:	cb 01       	movw	r24, r22
    16c2:	00 97       	sbiw	r24, 0x00	; 0
    16c4:	a1 f7       	brne	.-24     	; 0x16ae <itoa+0x1c>
    16c6:	16 f4       	brtc	.+4      	; 0x16cc <itoa+0x3a>
    16c8:	5d e2       	ldi	r21, 0x2D	; 45
    16ca:	51 93       	st	Z+, r21
    16cc:	10 82       	st	Z, r1
    16ce:	c9 01       	movw	r24, r18
    16d0:	0c 94 d9 0b 	jmp	0x17b2	; 0x17b2 <strrev>

000016d4 <ltoa>:
    16d4:	fa 01       	movw	r30, r20
    16d6:	cf 93       	push	r28
    16d8:	ff 93       	push	r31
    16da:	ef 93       	push	r30
    16dc:	22 30       	cpi	r18, 0x02	; 2
    16de:	44 f1       	brlt	.+80     	; 0x1730 <ltoa+0x5c>
    16e0:	25 32       	cpi	r18, 0x25	; 37
    16e2:	34 f5       	brge	.+76     	; 0x1730 <ltoa+0x5c>
    16e4:	c2 2f       	mov	r28, r18
    16e6:	e8 94       	clt
    16e8:	ca 30       	cpi	r28, 0x0A	; 10
    16ea:	49 f4       	brne	.+18     	; 0x16fe <ltoa+0x2a>
    16ec:	97 fb       	bst	r25, 7
    16ee:	3e f4       	brtc	.+14     	; 0x16fe <ltoa+0x2a>
    16f0:	90 95       	com	r25
    16f2:	80 95       	com	r24
    16f4:	70 95       	com	r23
    16f6:	61 95       	neg	r22
    16f8:	7f 4f       	sbci	r23, 0xFF	; 255
    16fa:	8f 4f       	sbci	r24, 0xFF	; 255
    16fc:	9f 4f       	sbci	r25, 0xFF	; 255
    16fe:	2c 2f       	mov	r18, r28
    1700:	33 27       	eor	r19, r19
    1702:	44 27       	eor	r20, r20
    1704:	55 27       	eor	r21, r21
    1706:	ff 93       	push	r31
    1708:	ef 93       	push	r30
    170a:	0e 94 e9 0b 	call	0x17d2	; 0x17d2 <__udivmodsi4>
    170e:	ef 91       	pop	r30
    1710:	ff 91       	pop	r31
    1712:	60 5d       	subi	r22, 0xD0	; 208
    1714:	6a 33       	cpi	r22, 0x3A	; 58
    1716:	0c f0       	brlt	.+2      	; 0x171a <ltoa+0x46>
    1718:	69 5d       	subi	r22, 0xD9	; 217
    171a:	61 93       	st	Z+, r22
    171c:	b9 01       	movw	r22, r18
    171e:	ca 01       	movw	r24, r20
    1720:	60 50       	subi	r22, 0x00	; 0
    1722:	70 40       	sbci	r23, 0x00	; 0
    1724:	80 40       	sbci	r24, 0x00	; 0
    1726:	90 40       	sbci	r25, 0x00	; 0
    1728:	51 f7       	brne	.-44     	; 0x16fe <ltoa+0x2a>
    172a:	16 f4       	brtc	.+4      	; 0x1730 <ltoa+0x5c>
    172c:	cd e2       	ldi	r28, 0x2D	; 45
    172e:	c1 93       	st	Z+, r28
    1730:	10 82       	st	Z, r1
    1732:	8f 91       	pop	r24
    1734:	9f 91       	pop	r25
    1736:	cf 91       	pop	r28
    1738:	0c 94 d9 0b 	jmp	0x17b2	; 0x17b2 <strrev>

0000173c <ultoa>:
    173c:	fa 01       	movw	r30, r20
    173e:	cf 93       	push	r28
    1740:	ff 93       	push	r31
    1742:	ef 93       	push	r30
    1744:	22 30       	cpi	r18, 0x02	; 2
    1746:	cc f0       	brlt	.+50     	; 0x177a <ultoa+0x3e>
    1748:	25 32       	cpi	r18, 0x25	; 37
    174a:	bc f4       	brge	.+46     	; 0x177a <ultoa+0x3e>
    174c:	c2 2f       	mov	r28, r18
    174e:	2c 2f       	mov	r18, r28
    1750:	33 27       	eor	r19, r19
    1752:	44 27       	eor	r20, r20
    1754:	55 27       	eor	r21, r21
    1756:	ff 93       	push	r31
    1758:	ef 93       	push	r30
    175a:	0e 94 e9 0b 	call	0x17d2	; 0x17d2 <__udivmodsi4>
    175e:	ef 91       	pop	r30
    1760:	ff 91       	pop	r31
    1762:	60 5d       	subi	r22, 0xD0	; 208
    1764:	6a 33       	cpi	r22, 0x3A	; 58
    1766:	0c f0       	brlt	.+2      	; 0x176a <ultoa+0x2e>
    1768:	69 5d       	subi	r22, 0xD9	; 217
    176a:	61 93       	st	Z+, r22
    176c:	b9 01       	movw	r22, r18
    176e:	ca 01       	movw	r24, r20
    1770:	60 50       	subi	r22, 0x00	; 0
    1772:	70 40       	sbci	r23, 0x00	; 0
    1774:	80 40       	sbci	r24, 0x00	; 0
    1776:	90 40       	sbci	r25, 0x00	; 0
    1778:	51 f7       	brne	.-44     	; 0x174e <ultoa+0x12>
    177a:	10 82       	st	Z, r1
    177c:	8f 91       	pop	r24
    177e:	9f 91       	pop	r25
    1780:	cf 91       	pop	r28
    1782:	0c 94 d9 0b 	jmp	0x17b2	; 0x17b2 <strrev>

00001786 <utoa>:
    1786:	fb 01       	movw	r30, r22
    1788:	9f 01       	movw	r18, r30
    178a:	42 30       	cpi	r20, 0x02	; 2
    178c:	74 f0       	brlt	.+28     	; 0x17aa <utoa+0x24>
    178e:	45 32       	cpi	r20, 0x25	; 37
    1790:	64 f4       	brge	.+24     	; 0x17aa <utoa+0x24>
    1792:	64 2f       	mov	r22, r20
    1794:	77 27       	eor	r23, r23
    1796:	0e 94 35 0b 	call	0x166a	; 0x166a <__udivmodhi4>
    179a:	80 5d       	subi	r24, 0xD0	; 208
    179c:	8a 33       	cpi	r24, 0x3A	; 58
    179e:	0c f0       	brlt	.+2      	; 0x17a2 <utoa+0x1c>
    17a0:	89 5d       	subi	r24, 0xD9	; 217
    17a2:	81 93       	st	Z+, r24
    17a4:	cb 01       	movw	r24, r22
    17a6:	00 97       	sbiw	r24, 0x00	; 0
    17a8:	a1 f7       	brne	.-24     	; 0x1792 <utoa+0xc>
    17aa:	10 82       	st	Z, r1
    17ac:	c9 01       	movw	r24, r18
    17ae:	0c 94 d9 0b 	jmp	0x17b2	; 0x17b2 <strrev>

000017b2 <strrev>:
    17b2:	dc 01       	movw	r26, r24
    17b4:	fc 01       	movw	r30, r24
    17b6:	67 2f       	mov	r22, r23
    17b8:	71 91       	ld	r23, Z+
    17ba:	77 23       	and	r23, r23
    17bc:	e1 f7       	brne	.-8      	; 0x17b6 <strrev+0x4>
    17be:	32 97       	sbiw	r30, 0x02	; 2
    17c0:	04 c0       	rjmp	.+8      	; 0x17ca <strrev+0x18>
    17c2:	7c 91       	ld	r23, X
    17c4:	6d 93       	st	X+, r22
    17c6:	70 83       	st	Z, r23
    17c8:	62 91       	ld	r22, -Z
    17ca:	ae 17       	cp	r26, r30
    17cc:	bf 07       	cpc	r27, r31
    17ce:	c8 f3       	brcs	.-14     	; 0x17c2 <strrev+0x10>
    17d0:	08 95       	ret

000017d2 <__udivmodsi4>:
    17d2:	a1 e2       	ldi	r26, 0x21	; 33
    17d4:	1a 2e       	mov	r1, r26
    17d6:	aa 1b       	sub	r26, r26
    17d8:	bb 1b       	sub	r27, r27
    17da:	fd 01       	movw	r30, r26
    17dc:	0d c0       	rjmp	.+26     	; 0x17f8 <__udivmodsi4_ep>

000017de <__udivmodsi4_loop>:
    17de:	aa 1f       	adc	r26, r26
    17e0:	bb 1f       	adc	r27, r27
    17e2:	ee 1f       	adc	r30, r30
    17e4:	ff 1f       	adc	r31, r31
    17e6:	a2 17       	cp	r26, r18
    17e8:	b3 07       	cpc	r27, r19
    17ea:	e4 07       	cpc	r30, r20
    17ec:	f5 07       	cpc	r31, r21
    17ee:	20 f0       	brcs	.+8      	; 0x17f8 <__udivmodsi4_ep>
    17f0:	a2 1b       	sub	r26, r18
    17f2:	b3 0b       	sbc	r27, r19
    17f4:	e4 0b       	sbc	r30, r20
    17f6:	f5 0b       	sbc	r31, r21

000017f8 <__udivmodsi4_ep>:
    17f8:	66 1f       	adc	r22, r22
    17fa:	77 1f       	adc	r23, r23
    17fc:	88 1f       	adc	r24, r24
    17fe:	99 1f       	adc	r25, r25
    1800:	1a 94       	dec	r1
    1802:	69 f7       	brne	.-38     	; 0x17de <__udivmodsi4_loop>
    1804:	60 95       	com	r22
    1806:	70 95       	com	r23
    1808:	80 95       	com	r24
    180a:	90 95       	com	r25
    180c:	9b 01       	movw	r18, r22
    180e:	ac 01       	movw	r20, r24
    1810:	bd 01       	movw	r22, r26
    1812:	cf 01       	movw	r24, r30
    1814:	08 95       	ret

00001816 <_exit>:
    1816:	f8 94       	cli

00001818 <__stop_program>:
    1818:	ff cf       	rjmp	.-2      	; 0x1818 <__stop_program>
