
ATmega32A_GCC_DigitalControlAudioSystem_pLibs.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001976  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000518  00800060  00001976  00001a0a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002d  00800578  00800578  00001f22  2**0
                  ALLOC
  3 .stab         00001404  00000000  00000000  00001f24  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000209  00000000  00000000  00003328  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00003531  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000188  00000000  00000000  00003542  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000040dd  00000000  00000000  000036ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001181  00000000  00000000  000077a7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000fa1  00000000  00000000  00008928  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a3c  00000000  00000000  000098cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000d51  00000000  00000000  0000a308  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000219f  00000000  00000000  0000b059  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000030  00000000  00000000  0000d1f8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 77 04 	jmp	0x8ee	; 0x8ee <__vector_1>
       8:	0c 94 af 04 	jmp	0x95e	; 0x95e <__vector_2>
       c:	0c 94 b9 04 	jmp	0x972	; 0x972 <__vector_3>
      10:	0c 94 c3 04 	jmp	0x986	; 0x986 <__vector_4>
      14:	0c 94 12 05 	jmp	0xa24	; 0xa24 <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	15 e0       	ldi	r17, 0x05	; 5
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e7       	ldi	r30, 0x76	; 118
      68:	f9 e1       	ldi	r31, 0x19	; 25
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 37       	cpi	r26, 0x78	; 120
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a8 e7       	ldi	r26, 0x78	; 120
      7a:	b5 e0       	ldi	r27, 0x05	; 5
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 3a       	cpi	r26, 0xA5	; 165
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 75 0b 	call	0x16ea	; 0x16ea <main>
      8a:	0c 94 b9 0c 	jmp	0x1972	; 0x1972 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <port_init>:
*****************************************/
void port_init(void)
{	

// PORT A connections
	DDRA  = 0b11111111;		//  PA7:U8/PGA2310,CS; PA6:U7/PGA2310,CS; PA5:CON2LCD,RS; PA4:CON2LCD,RW; PA3:CON2LCD,E; PA2:U2/74HC595,RCLK(LCD); PA1:U2/74HC595,SCLK(LCD); PA0:U2/74HC595,DATA(LCD);
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	8a bb       	out	0x1a, r24	; 26
	PORTA = 0b00000000;		//	Interfaces: NOT USED. PULLUP DISABLE in PORTA.
      96:	1b ba       	out	0x1b, r1	; 27

// PORT B connections
	DDRB  = 0b10111000;		//  PB7:U6,U7,U8/PGA2310,SCLK; PB6:U6,U7,U8/PGA2310,SDO(CON33,36,39); PB5:U6,U7,U8/PGA2310,SDI; PB4:U12/74HC595,DATA(REL_OUT); PB3:U6/PGA2310,CS; PB2:CON8/BUTTON,"ESCAPE",INT2; PB1:CON5/BUTTON,"ON/OFF"; PB0:CON14TempSensor/DS18S20,DQ,IN/OUT;
      98:	88 eb       	ldi	r24, 0xB8	; 184
      9a:	87 bb       	out	0x17, r24	; 23
	PORTB = 0b00000111;		//	Interfaces: EXTERNAL INTERRUPT 2; SPI. set pullup to IRTSOP2240 / BUTTON(on/off) / DS18s20.
      9c:	87 e0       	ldi	r24, 0x07	; 7
      9e:	88 bb       	out	0x18, r24	; 24

// PORT C connections
	DDRC  = 0b11001100;		//  PC7:U10/74HC595,DATA(REL_IN); PC6:U10/74HC595,SCLK(REL_IN); PC5:EncoderED1112S,A; PC4:EncoderED1112S,B; PC3:U10/74HC595,RCLK(REL_IN); PC2:Q2/BD237(RELAY_POWER_SUPPLY); PC1:DS1307/24C64,I2C/SDA; PC0:DS1307/24C64,I2C/SCL;
      a0:	8c ec       	ldi	r24, 0xCC	; 204
      a2:	84 bb       	out	0x14, r24	; 20
	PORTC = 0b00000000;		//	Interfaces: I2C. PULLUP DISABLE in PORTC.
      a4:	15 ba       	out	0x15, r1	; 21

// PORT D connections
	DDRD  = 0b11110000;		//  PD7:U12/74HC595,RCLK(REL_OUT); PD6:U12/74HC595,SCLK(REL_OUT); PD5:Q1/BD237(FAN_CONTROL_PWM); PD4:LED5/"ON/OFF AUDIO SYSTEM"; PD3:CON11/EncoderBUTTON,"MENU/ENTER"/INT1; PD2:CON12/IR/TSOP2240,/INT0; PD1:CON14/MAX232,UART/TXD; PD0:CON14/MAX232,UART/RXD;
      a6:	80 ef       	ldi	r24, 0xF0	; 240
      a8:	81 bb       	out	0x11, r24	; 17
	PORTD = 0b00001100;		//	Interfaces: TIMER1; UART/USART; EXTERNAL INTERRUPT 0, 1. PULLUP DISABLE in PORTD.
      aa:	8c e0       	ldi	r24, 0x0C	; 12
      ac:	82 bb       	out	0x12, r24	; 18
      ae:	08 95       	ret

000000b0 <ext0_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 0 **
*******************************************/
void ext0_intrpt_init(void)
{
	MCUCR = 0b00000010;	// SETUP EXT INT 0, ISC01 = 1, ISC00 = 0: Falling edge on INT0 activates the interrupt; ISC01 = 1, ISC00 = 1: Rising edge on INT0 activates the interrupt;
      b0:	82 e0       	ldi	r24, 0x02	; 2
      b2:	85 bf       	out	0x35, r24	; 53
      b4:	08 95       	ret

000000b6 <ext0_intrpt_on>:
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR |= 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      b6:	8b b7       	in	r24, 0x3b	; 59
      b8:	80 64       	ori	r24, 0x40	; 64
      ba:	8b bf       	out	0x3b, r24	; 59
	GIFR |= 0b01000000;	// Clear INT0 flag.
      bc:	8a b7       	in	r24, 0x3a	; 58
      be:	80 64       	ori	r24, 0x40	; 64
      c0:	8a bf       	out	0x3a, r24	; 58
      c2:	08 95       	ret

000000c4 <ext0_intrpt_off>:
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR |= 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      c4:	8b b7       	in	r24, 0x3b	; 59
      c6:	8b bf       	out	0x3b, r24	; 59
	GIFR |= 0b01000000;	// Clear INT0 flag.
      c8:	8a b7       	in	r24, 0x3a	; 58
      ca:	80 64       	ori	r24, 0x40	; 64
      cc:	8a bf       	out	0x3a, r24	; 58
      ce:	08 95       	ret

000000d0 <ext1_intrpt_init>:

/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 1 **
*******************************************/
void ext1_intrpt_init(void)
{
      d0:	08 95       	ret

000000d2 <ext2_intrpt_init>:

/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 2 **
*******************************************/
void ext2_intrpt_init(void)
{
      d2:	08 95       	ret

000000d4 <timer1_init>:
*****************************/
void timer1_init(void)
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  |= 0b00000000;	// maskov registar za prekasvaniq, ne e nujno da ima prekasvane po timer1, izpolzvame go samo za rabota po izvod
      d4:	89 b7       	in	r24, 0x39	; 57
      d6:	89 bf       	out	0x39, r24	; 57
	TCNT1H = 0b00000000;
      d8:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
      da:	1c bc       	out	0x2c, r1	; 44
      dc:	08 95       	ret

000000de <timer2Internal_intrpt_off>:
//	sei();								// enable global interrupts
	// initialize overflow counter variable
	isr2 = 0;
}
void timer2Internal_intrpt_off(void)
{
      de:	08 95       	ret

000000e0 <timer2Internal_intrpt_on>:
//	TIMSK |= 0b00000000;		// OCIE2 [bit7] = 0: Disable Internal Interrupt on Timer2CompareMatch; OCIE2 [bit7] = 1: Enable Internal Interrupt on Timer2CompareMatch;
//	TIFR  |= 0b10000000;		// OCF2  [bit7] = 1: Clear Timer2CompareMatch flag.
}

void timer2Internal_intrpt_on(void)
{
      e0:	08 95       	ret

000000e2 <timer1_on_speed>:
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; ne e nujno da ima prekasvane
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      e2:	81 ea       	ldi	r24, 0xA1	; 161
      e4:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
      e6:	81 e0       	ldi	r24, 0x01	; 1
      e8:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
      ea:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
      ec:	e0 91 68 00 	lds	r30, 0x0068
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	e0 5a       	subi	r30, 0xA0	; 160
      f4:	ff 4f       	sbci	r31, 0xFF	; 255
      f6:	80 81       	ld	r24, Z
      f8:	8a bd       	out	0x2a, r24	; 42
      fa:	08 95       	ret

000000fc <timer2_init>:
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Fan is on\r\n");
	transmitUartString("[UART INFO] Fan rotation with max speed\r\n");
#endif
//	FAN_high();			// PORTD5 - FAN ON (logic "1")	NON PWM, NON TIMER1
fanSpeed = FAN_SPEED_MAX-FAN_SPEED_MIN;	// amplifer run with max fan speed
      fc:	87 e0       	ldi	r24, 0x07	; 7
      fe:	80 93 68 00 	sts	0x0068, r24
/***********************************
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
     102:	0e 94 71 00 	call	0xe2	; 0xe2 <timer1_on_speed>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     106:	2f ef       	ldi	r18, 0xFF	; 255
     108:	8b e7       	ldi	r24, 0x7B	; 123
     10a:	92 e9       	ldi	r25, 0x92	; 146
     10c:	21 50       	subi	r18, 0x01	; 1
     10e:	80 40       	sbci	r24, 0x00	; 0
     110:	90 40       	sbci	r25, 0x00	; 0
     112:	e1 f7       	brne	.-8      	; 0x10c <timer2_init+0x10>
     114:	00 c0       	rjmp	.+0      	; 0x116 <timer2_init+0x1a>
     116:	00 00       	nop
fanSpeed = FAN_SPEED_MAX-FAN_SPEED_MIN;	// amplifer run with max fan speed
fan_pwm_control_speed();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1
_delay_ms(3000);			// wait 3 seconds for maximum rotating fans

#ifdef DEBUG_ERROR
	transmitUartString("[UART INFO] Speed of fans are controlled by auto program\r\n");
     118:	85 ec       	ldi	r24, 0xC5	; 197
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
#endif
//==================================================================================================================
	TCNT2 &= 0b00000000;	// Clear Counter Timer2
     120:	84 b5       	in	r24, 0x24	; 36
     122:	14 bc       	out	0x24, r1	; 36
//   TCCR2 = FOC | WGM20 | COM21 | COM20 | WGM21 | CS22 | CS21 | CS20 |
	TCCR2 = 0b00001010;	// 0b00001xxx, xxx = 001 /1, 010 /8, 011 /32, 100 /64, 101 /128, 110 /256, 111 /1024			//   TCCR2 |= (1 << WGM21) | (1 << CS22) | (1 << CS21) | (1 << CS20); // configure timer2 for CTC mode(WGM21), 1024 prescaller (CS20,21,22)
     124:	8a e0       	ldi	r24, 0x0A	; 10
     126:	85 bd       	out	0x25, r24	; 37
	TIMSK |= (1 << OCIE2); // enable the CTC interrupt	//	TIMSK |= 0b01000000;	// TIMSK |= (1 << TOIE2); // Disable Internal Interrupts on Timer2
     128:	89 b7       	in	r24, 0x39	; 57
     12a:	80 68       	ori	r24, 0x80	; 128
     12c:	89 bf       	out	0x39, r24	; 57

	OCR2 = 255;	//255;
     12e:	8f ef       	ldi	r24, 0xFF	; 255
     130:	83 bd       	out	0x23, r24	; 35
//	TCCR2 |= (1 << CS22)|(1 << CS21);  	// set up timer with prescaler = 256
//	TCNT2 = 0;							// initialize counter
//	TIMSK |= (1 << TOIE2);				// enable overflow interrupt
//	sei();								// enable global interrupts
	// initialize overflow counter variable
	isr2 = 0;
     132:	10 92 a0 05 	sts	0x05A0, r1
     136:	10 92 9f 05 	sts	0x059F, r1
     13a:	08 95       	ret

0000013c <timer1_off>:
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}

void timer1_off(void)
{
	TCCR1A = 0b00000000;	// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     13c:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;	//
     13e:	1e bc       	out	0x2e, r1	; 46
	SFIOR |= 0b00000001;	// Prescaler Reset Timer1/0 (bit0  PSR10)
     140:	80 b7       	in	r24, 0x30	; 48
     142:	81 60       	ori	r24, 0x01	; 1
     144:	80 bf       	out	0x30, r24	; 48



	OCR1AH = 0; // FAN PWM OFF
     146:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     148:	1a bc       	out	0x2a, r1	; 42
     14a:	08 95       	ret

0000014c <timer2_on>:

/***************************************
******** DEFINITIONS OF TIMER 2 ********
***************************************/
void timer2_on(void)
{
     14c:	08 95       	ret

0000014e <timer2_off>:
//   TCCR2 = 0b00001010;	// 0b00001xxx, xxx = 001 /1, 010 /8, 011 /32, 100 /64, 101 /128, 110 /256, 111 /1024			//   TCCR2 |= (1 << WGM21) | (1 << CS22) | (1 << CS21) | (1 << CS20); // configure timer2 for CTC mode(WGM21), 1024 prescaller (CS20,21,22)
//   OCR2 = 255;			//255;
}

void timer2_off(void)
{
     14e:	08 95       	ret

00000150 <fan_pwm_control_speed>:
/***********************************
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
     150:	0c 94 71 00 	jmp	0xe2	; 0xe2 <timer1_on_speed>

00000154 <fan_pwm_off>:
}
void fan_pwm_off(void)
{
	timer1_off();
     154:	0c 94 9e 00 	jmp	0x13c	; 0x13c <timer1_off>

00000158 <ampliferOn>:
/********************
**** AMPLIFER ON ****
********************/
void ampliferOn(void)
{
	flagStatusBits->flagPower = 1;		// flag for amplifer on
     158:	e0 91 95 05 	lds	r30, 0x0595
     15c:	f0 91 96 05 	lds	r31, 0x0596
     160:	80 81       	ld	r24, Z
     162:	81 60       	ori	r24, 0x01	; 1
     164:	80 83       	st	Z, r24
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display on and status led off\r\n");
	#endif

// LED OFF FUNC
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     166:	94 98       	cbi	0x12, 4	; 18

// LCD FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();						// clear all contain on display
     168:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <LCD_CLEAR_CONTAIN>
	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     16c:	80 e0       	ldi	r24, 0x00	; 0
     16e:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer On     ");	// 20 symbols
     172:	80 e0       	ldi	r24, 0x00	; 0
     174:	91 e0       	ldi	r25, 0x01	; 1
     176:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);				// select row 2
     17a:	80 ec       	ldi	r24, 0xC0	; 192
     17c:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
	LCD_DATA_STRING("P.UPINOV  P.STOYANOV");	// 20 symbols //	LCD_EXECUTE_DATA("P.UPINOV  P.STOYANOV",20);	// char "DATA", int 13 of chars of "DATA"
     180:	85 e1       	ldi	r24, 0x15	; 21
     182:	91 e0       	ldi	r25, 0x01	; 1
     184:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     188:	8c e0       	ldi	r24, 0x0C	; 12
     18a:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>

// RELAYS ON FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays for power 220V\r\n");		// uart debug information string
	#endif
	REL_POWER_high();// RELAY POWER ON TRAFs		// PESHO COMMENT 14.08.2015, 21:10
     18e:	aa 9a       	sbi	0x15, 2	; 21
     190:	2f ef       	ldi	r18, 0xFF	; 255
     192:	8f e4       	ldi	r24, 0x4F	; 79
     194:	93 ec       	ldi	r25, 0xC3	; 195
     196:	21 50       	subi	r18, 0x01	; 1
     198:	80 40       	sbci	r24, 0x00	; 0
     19a:	90 40       	sbci	r25, 0x00	; 0
     19c:	e1 f7       	brne	.-8      	; 0x196 <ampliferOn+0x3e>
     19e:	00 c0       	rjmp	.+0      	; 0x1a0 <ampliferOn+0x48>
     1a0:	00 00       	nop
	_delay_ms(4000);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays in for all 6 channels\r\n");		// uart debug information string
	#endif
	relays_in1_6ch();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     1a2:	0e 94 34 0a 	call	0x1468	; 0x1468 <relays_in1_6ch>
     1a6:	2f ef       	ldi	r18, 0xFF	; 255
     1a8:	8d e2       	ldi	r24, 0x2D	; 45
     1aa:	92 e2       	ldi	r25, 0x22	; 34
     1ac:	21 50       	subi	r18, 0x01	; 1
     1ae:	80 40       	sbci	r24, 0x00	; 0
     1b0:	90 40       	sbci	r25, 0x00	; 0
     1b2:	e1 f7       	brne	.-8      	; 0x1ac <ampliferOn+0x54>
     1b4:	00 c0       	rjmp	.+0      	; 0x1b6 <ampliferOn+0x5e>
     1b6:	00 00       	nop
	_delay_ms(700);									// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays out for all 6 channels\r\n");		// uart debug information string
	#endif
	relays_out_6ch();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     1b8:	0e 94 66 0a 	call	0x14cc	; 0x14cc <relays_out_6ch>
     1bc:	2f ef       	ldi	r18, 0xFF	; 255
     1be:	83 ed       	ldi	r24, 0xD3	; 211
     1c0:	90 e3       	ldi	r25, 0x30	; 48
     1c2:	21 50       	subi	r18, 0x01	; 1
     1c4:	80 40       	sbci	r24, 0x00	; 0
     1c6:	90 40       	sbci	r25, 0x00	; 0
     1c8:	e1 f7       	brne	.-8      	; 0x1c2 <ampliferOn+0x6a>
     1ca:	00 c0       	rjmp	.+0      	; 0x1cc <ampliferOn+0x74>
     1cc:	00 00       	nop
//		transmitUartString("[UART INFO] Fan manual controlling with remote menu up to speed step up and menu down button to speed step down\r\n");
//	#endif
//	fanSpeed = FAN_SPEED_MIN;	// amplifer works with min fan speed
//	fan_pwm_control_speed();
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Amplifer is auto controlling fans!\r\n");
     1ce:	8a e2       	ldi	r24, 0x2A	; 42
     1d0:	91 e0       	ldi	r25, 0x01	; 1
     1d2:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
	#endif
//	timer2_init();	// Fan controlling, when the fan will be setup, this init to be moved in init_all();

	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Amplifer was switched on!\r\n");
     1d6:	8b e5       	ldi	r24, 0x5B	; 91
     1d8:	91 e0       	ldi	r25, 0x01	; 1
     1da:	0c 94 a0 08 	jmp	0x1140	; 0x1140 <transmitUartString>

000001de <ampliferOff>:
/*********************
**** AMPLIFER OFF ****
*********************/
void ampliferOff(void)
{
	flagStatusBits->flagPower = 0;		// flag for amplifer off
     1de:	e0 91 95 05 	lds	r30, 0x0595
     1e2:	f0 91 96 05 	lds	r31, 0x0596
     1e6:	80 81       	ld	r24, Z
     1e8:	8e 7f       	andi	r24, 0xFE	; 254
     1ea:	80 83       	st	Z, r24

	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     1ec:	80 e0       	ldi	r24, 0x00	; 0
     1ee:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer Off    ");	// 20 symbols
     1f2:	83 e8       	ldi	r24, 0x83	; 131
     1f4:	91 e0       	ldi	r25, 0x01	; 1
     1f6:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>

	LCD_COMMAND(LCD_OFF);						// LCD ON without CURSOR
     1fa:	88 e0       	ldi	r24, 0x08	; 8
     1fc:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>

// RELAYS OFF FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays out for all 6 channels\r\n");		// uart debug information string
	#endif
	relays_out_off();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     200:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <relays_out_off>
     204:	2f ef       	ldi	r18, 0xFF	; 255
     206:	8d e2       	ldi	r24, 0x2D	; 45
     208:	92 e2       	ldi	r25, 0x22	; 34
     20a:	21 50       	subi	r18, 0x01	; 1
     20c:	80 40       	sbci	r24, 0x00	; 0
     20e:	90 40       	sbci	r25, 0x00	; 0
     210:	e1 f7       	brne	.-8      	; 0x20a <ampliferOff+0x2c>
     212:	00 c0       	rjmp	.+0      	; 0x214 <ampliferOff+0x36>
     214:	00 00       	nop
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays in for all 6 channels\r\n");		// uart debug information string
	#endif
	relays_in_off();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     216:	0e 94 43 0a 	call	0x1486	; 0x1486 <relays_in_off>
     21a:	2f ef       	ldi	r18, 0xFF	; 255
     21c:	8d e2       	ldi	r24, 0x2D	; 45
     21e:	92 e2       	ldi	r25, 0x22	; 34
     220:	21 50       	subi	r18, 0x01	; 1
     222:	80 40       	sbci	r24, 0x00	; 0
     224:	90 40       	sbci	r25, 0x00	; 0
     226:	e1 f7       	brne	.-8      	; 0x220 <ampliferOff+0x42>
     228:	00 c0       	rjmp	.+0      	; 0x22a <ampliferOff+0x4c>
     22a:	00 00       	nop
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays for power 220V\r\n");		// uart debug information string
	#endif
	REL_POWER_low();// RELAY POWER OFF				// PESHO COMMENT 14.08.2015, 21:10
     22c:	aa 98       	cbi	0x15, 2	; 21

// FANS FUNC & MESSAGE
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Fan is off\r\n");
     22e:	88 e9       	ldi	r24, 0x98	; 152
     230:	91 e0       	ldi	r25, 0x01	; 1
     232:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
{
	timer1_on_speed();
}
void fan_pwm_off(void)
{
	timer1_off();
     236:	0e 94 9e 00 	call	0x13c	; 0x13c <timer1_off>
		transmitUartString("[UART INFO] Fan is off\r\n");
	#endif
	fan_pwm_off();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1

// FANS FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();
     23a:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <LCD_CLEAR_CONTAIN>
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display off and status led on\r\n");
	#endif

// LED ON FUNC
	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     23e:	94 9a       	sbi	0x12, 4	; 18
     240:	2f ef       	ldi	r18, 0xFF	; 255
     242:	89 e6       	ldi	r24, 0x69	; 105
     244:	98 e1       	ldi	r25, 0x18	; 24
     246:	21 50       	subi	r18, 0x01	; 1
     248:	80 40       	sbci	r24, 0x00	; 0
     24a:	90 40       	sbci	r25, 0x00	; 0
     24c:	e1 f7       	brne	.-8      	; 0x246 <ampliferOff+0x68>
     24e:	00 c0       	rjmp	.+0      	; 0x250 <ampliferOff+0x72>
     250:	00 00       	nop
     252:	08 95       	ret

00000254 <volumeUpdate>:
/*************************************
**** VOLUME UPDATE and LCD UPDATE ****
*************************************/
void volumeUpdate(void)
{
	PGA2310_Volume_Update(volumeValue[volumeIndex], volumeValue[volumeIndex]);	// update volume value on all channels
     254:	e0 91 82 05 	lds	r30, 0x0582
     258:	f0 e0       	ldi	r31, 0x00	; 0
     25a:	e7 58       	subi	r30, 0x87	; 135
     25c:	ff 4f       	sbci	r31, 0xFF	; 255
     25e:	80 81       	ld	r24, Z
     260:	68 2f       	mov	r22, r24
     262:	0e 94 5e 08 	call	0x10bc	; 0x10bc <PGA2310_Volume_Update>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     266:	84 ed       	ldi	r24, 0xD4	; 212
     268:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
//		LCD_DATA_STRING("Volume: ");	// 20 symbols
	if (volumeIndex > 9)
     26c:	80 91 82 05 	lds	r24, 0x0582
     270:	8a 30       	cpi	r24, 0x0A	; 10
     272:	18 f0       	brcs	.+6      	; 0x27a <volumeUpdate+0x26>
	{
		LCD_DATA_STRING("Volume: ");	// 20 symbols
     274:	87 ec       	ldi	r24, 0xC7	; 199
     276:	91 e0       	ldi	r25, 0x01	; 1
     278:	02 c0       	rjmp	.+4      	; 0x27e <volumeUpdate+0x2a>
	}
	else
	{
		LCD_DATA_STRING("Volume: 0");	// 20 symbols
     27a:	81 eb       	ldi	r24, 0xB1	; 177
     27c:	91 e0       	ldi	r25, 0x01	; 1
     27e:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
	}
	LCD_DATA_INT(volumeIndex);			// 20 symbols
     282:	80 91 82 05 	lds	r24, 0x0582
     286:	90 e0       	ldi	r25, 0x00	; 0
     288:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_DATA_INT>
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Volume: ");		// uart debug information string
     28c:	8b eb       	ldi	r24, 0xBB	; 187
     28e:	91 e0       	ldi	r25, 0x01	; 1
     290:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(volumeIndex);		// uart debug information string 
     294:	80 91 82 05 	lds	r24, 0x0582
     298:	90 e0       	ldi	r25, 0x00	; 0
     29a:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString("\r\n");			// uart debug information string
     29e:	88 eb       	ldi	r24, 0xB8	; 184
     2a0:	93 e0       	ldi	r25, 0x03	; 3
     2a2:	0c 94 a0 08 	jmp	0x1140	; 0x1140 <transmitUartString>

000002a6 <volumeProcess>:
**** VOLUME PROCESS FUNCTION FROM ENCODER ****
*********************************************/
void volumeProcess(void)
{
	signed char temp = 0;//, tempEnc = 0, tempRem = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     2a6:	0e 94 b3 09 	call	0x1366	; 0x1366 <rotaryEncoderNikBarzakov>
	if(0==temp)
     2aa:	88 23       	and	r24, r24
     2ac:	a9 f0       	breq	.+42     	; 0x2d8 <volumeProcess+0x32>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     2ae:	8f 3f       	cpi	r24, 0xFF	; 255
     2b0:	49 f4       	brne	.+18     	; 0x2c4 <volumeProcess+0x1e>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     2b2:	80 91 82 05 	lds	r24, 0x0582
     2b6:	88 23       	and	r24, r24
     2b8:	19 f0       	breq	.+6      	; 0x2c0 <volumeProcess+0x1a>
		{
			volumeIndex = VOLUME_MUTE;
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     2ba:	81 50       	subi	r24, 0x01	; 1
     2bc:	80 93 82 05 	sts	0x0582, r24
		}
		volumeUpdate();
     2c0:	0c 94 2a 01 	jmp	0x254	; 0x254 <volumeUpdate>
	}
	else if(1==temp)
     2c4:	81 30       	cpi	r24, 0x01	; 1
     2c6:	41 f4       	brne	.+16     	; 0x2d8 <volumeProcess+0x32>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     2c8:	80 91 82 05 	lds	r24, 0x0582
     2cc:	83 31       	cpi	r24, 0x13	; 19
     2ce:	10 f0       	brcs	.+4      	; 0x2d4 <volumeProcess+0x2e>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     2d0:	83 e1       	ldi	r24, 0x13	; 19
     2d2:	f4 cf       	rjmp	.-24     	; 0x2bc <volumeProcess+0x16>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     2d4:	8f 5f       	subi	r24, 0xFF	; 255
     2d6:	f2 cf       	rjmp	.-28     	; 0x2bc <volumeProcess+0x16>
     2d8:	08 95       	ret

000002da <volumeMute>:
/************************************
**** VOLUME MUTE/UNMUTE FUNCTION ****
************************************/
void volumeMute(void)
{
	if(flagStatusBits->flagMute == 0)
     2da:	e0 91 95 05 	lds	r30, 0x0595
     2de:	f0 91 96 05 	lds	r31, 0x0596
     2e2:	80 81       	ld	r24, Z
     2e4:	81 fd       	sbrc	r24, 1
     2e6:	09 c0       	rjmp	.+18     	; 0x2fa <volumeMute+0x20>
	{
		volumeBuffer = volumeIndex;		// strore volume volue
     2e8:	80 91 82 05 	lds	r24, 0x0582
     2ec:	80 93 83 05 	sts	0x0583, r24
		volumeIndex = VOLUME_MUTE;		// MUTE ON
     2f0:	10 92 82 05 	sts	0x0582, r1
		flagStatusBits->flagMute = 1;	// MUTE ON
     2f4:	80 81       	ld	r24, Z
     2f6:	82 60       	ori	r24, 0x02	; 2
     2f8:	08 c0       	rjmp	.+16     	; 0x30a <volumeMute+0x30>
			transmitUartString("[UART INFO] Volume mute is on\r\n");
		#endif
	}
	else
	{
		volumeIndex = volumeBuffer;		// MUTE OFF
     2fa:	80 91 83 05 	lds	r24, 0x0583
     2fe:	80 93 82 05 	sts	0x0582, r24
		volumeBuffer = VOLUME_MUTE;		// clear volume volue
     302:	10 92 83 05 	sts	0x0583, r1
		flagStatusBits->flagMute = 0;	// MUTE OFF
     306:	80 81       	ld	r24, Z
     308:	8d 7f       	andi	r24, 0xFD	; 253
     30a:	80 83       	st	Z, r24
		#ifdef DEBUG_INFO
			transmitUartString("[UART INFO] Volume mute is off\r\n");
		#endif
	}
	volumeUpdate();
     30c:	0c 94 2a 01 	jmp	0x254	; 0x254 <volumeUpdate>

00000310 <volumeProcessRemote>:
/********************************************
**** VOLUME PROCESS FUNCTION FROM REMOTE ****
********************************************/
void volumeProcessRemote(signed char temp)
{
	if(-1==temp)
     310:	8f 3f       	cpi	r24, 0xFF	; 255
     312:	49 f4       	brne	.+18     	; 0x326 <volumeProcessRemote+0x16>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     314:	80 91 82 05 	lds	r24, 0x0582
     318:	88 23       	and	r24, r24
     31a:	19 f0       	breq	.+6      	; 0x322 <volumeProcessRemote+0x12>
		{
			volumeIndex = VOLUME_MUTE;
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     31c:	81 50       	subi	r24, 0x01	; 1
     31e:	80 93 82 05 	sts	0x0582, r24
		}
		volumeUpdate();
     322:	0c 94 2a 01 	jmp	0x254	; 0x254 <volumeUpdate>
	}
	else if(1==temp)
     326:	81 30       	cpi	r24, 0x01	; 1
     328:	41 f4       	brne	.+16     	; 0x33a <volumeProcessRemote+0x2a>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     32a:	80 91 82 05 	lds	r24, 0x0582
     32e:	83 31       	cpi	r24, 0x13	; 19
     330:	10 f0       	brcs	.+4      	; 0x336 <volumeProcessRemote+0x26>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     332:	83 e1       	ldi	r24, 0x13	; 19
     334:	f4 cf       	rjmp	.-24     	; 0x31e <volumeProcessRemote+0xe>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     336:	8f 5f       	subi	r24, 0xFF	; 255
     338:	f2 cf       	rjmp	.-28     	; 0x31e <volumeProcessRemote+0xe>
     33a:	08 95       	ret

0000033c <commonEncoder>:
**********************************************/
void commonEncoder(void)	// not finished
{
	static signed char saveValue = 0;	// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!! static ???
	signed char temp = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     33c:	0e 94 b3 09 	call	0x1366	; 0x1366 <rotaryEncoderNikBarzakov>
	if(0==temp)
     340:	88 23       	and	r24, r24
     342:	79 f1       	breq	.+94     	; 0x3a2 <commonEncoder+0x66>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     344:	8f 3f       	cpi	r24, 0xFF	; 255
     346:	41 f4       	brne	.+16     	; 0x358 <commonEncoder+0x1c>
	{
		// encoder is decrement
		if(saveValue < -127)
     348:	80 91 84 05 	lds	r24, 0x0584
     34c:	80 38       	cpi	r24, 0x80	; 128
     34e:	11 f4       	brne	.+4      	; 0x354 <commonEncoder+0x18>
		{
			saveValue = 127;	// SIGNED CHAR MIN VALUE = -127
     350:	8f e7       	ldi	r24, 0x7F	; 127
     352:	07 c0       	rjmp	.+14     	; 0x362 <commonEncoder+0x26>
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     354:	81 50       	subi	r24, 0x01	; 1
     356:	05 c0       	rjmp	.+10     	; 0x362 <commonEncoder+0x26>
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
	}
	else if(1==temp)
     358:	81 30       	cpi	r24, 0x01	; 1
     35a:	19 f5       	brne	.+70     	; 0x3a2 <commonEncoder+0x66>
		{
			saveValue = 128;	// SIGNED CHAR MAX VALUE = +128
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     35c:	80 91 84 05 	lds	r24, 0x0584
     360:	8f 5f       	subi	r24, 0xFF	; 255
     362:	80 93 84 05 	sts	0x0584, r24
		}

	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     366:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     368:	8c e0       	ldi	r24, 0x0C	; 12
     36a:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     36e:	84 ed       	ldi	r24, 0xD4	; 212
     370:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
		if (saveValue > 99)
     374:	80 91 84 05 	lds	r24, 0x0584
     378:	84 36       	cpi	r24, 0x64	; 100
     37a:	1c f0       	brlt	.+6      	; 0x382 <commonEncoder+0x46>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     37c:	87 ec       	ldi	r24, 0xC7	; 199
     37e:	91 e0       	ldi	r25, 0x01	; 1
     380:	07 c0       	rjmp	.+14     	; 0x390 <commonEncoder+0x54>
		}
		else if (saveValue > 9)
     382:	8a 30       	cpi	r24, 0x0A	; 10
     384:	1c f0       	brlt	.+6      	; 0x38c <commonEncoder+0x50>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     386:	81 eb       	ldi	r24, 0xB1	; 177
     388:	91 e0       	ldi	r25, 0x01	; 1
     38a:	02 c0       	rjmp	.+4      	; 0x390 <commonEncoder+0x54>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     38c:	80 ed       	ldi	r24, 0xD0	; 208
     38e:	91 e0       	ldi	r25, 0x01	; 1
     390:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     394:	80 91 84 05 	lds	r24, 0x0584
     398:	99 27       	eor	r25, r25
     39a:	87 fd       	sbrc	r24, 7
     39c:	90 95       	com	r25
     39e:	0c 94 aa 07 	jmp	0xf54	; 0xf54 <LCD_DATA_INT>
     3a2:	08 95       	ret

000003a4 <oneWireLeft>:

/*******************************************
**** 1-WIRE DS18x20 Temperature Sensors ****
*******************************************/
unsigned char oneWireLeft()
{
     3a4:	cf 93       	push	r28
     3a6:	df 93       	push	r29

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT ROMCODE: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     3a8:	0e 94 d0 05 	call	0xba0	; 0xba0 <reset>
     3ac:	81 11       	cpse	r24, r1
     3ae:	02 c0       	rjmp	.+4      	; 0x3b4 <oneWireLeft+0x10>
			return 1;
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
     3b0:	80 e0       	ldi	r24, 0x00	; 0
     3b2:	2e c0       	rjmp	.+92     	; 0x410 <oneWireLeft+0x6c>
		transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT ROMCODE: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
	{
		write_byte(0x55);	// Master issues Match ROM command.
     3b4:	85 e5       	ldi	r24, 0x55	; 85
     3b6:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
     3ba:	c1 e7       	ldi	r28, 0x71	; 113
     3bc:	d0 e0       	ldi	r29, 0x00	; 0
		for(i=0; i<8; i++)
		{
			write_byte(leftTempSensorRomCode[i]);	// 64-bit ROM CODE
     3be:	89 91       	ld	r24, Y+
     3c0:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
	{
		write_byte(0x55);	// Master issues Match ROM command.
		for(i=0; i<8; i++)
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	c9 37       	cpi	r28, 0x79	; 121
     3c8:	d8 07       	cpc	r29, r24
     3ca:	c9 f7       	brne	.-14     	; 0x3be <oneWireLeft+0x1a>
		write_byte(0x08);	// Byte 5
		write_byte(0x00);	// Byte 6
		write_byte(0xC1);	// Byte 7
		// 64-bit ROM CODE
*/
		write_byte(0x44);	// Master issues Convert T command.
     3cc:	84 e4       	ldi	r24, 0x44	; 68
     3ce:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     3d2:	0e 94 50 06 	call	0xca0	; 0xca0 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     3d6:	0e 94 d0 05 	call	0xba0	; 0xba0 <reset>
     3da:	88 23       	and	r24, r24
     3dc:	49 f3       	breq	.-46     	; 0x3b0 <oneWireLeft+0xc>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     3de:	85 e5       	ldi	r24, 0x55	; 85
     3e0:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
     3e4:	c1 e7       	ldi	r28, 0x71	; 113
     3e6:	d0 e0       	ldi	r29, 0x00	; 0
			for(i=0; i<8; i++)
			{
				write_byte(leftTempSensorRomCode[i]);	// 64-bit ROM CODE
     3e8:	89 91       	ld	r24, Y+
     3ea:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
		write_byte(0x44);	// Master issues Convert T command.
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
		{
			write_byte(0x55);	// Master issues Match ROM command.
			for(i=0; i<8; i++)
     3ee:	80 e0       	ldi	r24, 0x00	; 0
     3f0:	c9 37       	cpi	r28, 0x79	; 121
     3f2:	d8 07       	cpc	r29, r24
     3f4:	c9 f7       	brne	.-14     	; 0x3e8 <oneWireLeft+0x44>
			write_byte(0x08);	// Byte 5
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
     3f6:	8e eb       	ldi	r24, 0xBE	; 190
     3f8:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
     3fc:	c8 e7       	ldi	r28, 0x78	; 120
     3fe:	d5 e0       	ldi	r29, 0x05	; 5
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     400:	0e 94 05 06 	call	0xc0a	; 0xc0a <read_byte>
     404:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     406:	85 e0       	ldi	r24, 0x05	; 5
     408:	c1 38       	cpi	r28, 0x81	; 129
     40a:	d8 07       	cpc	r29, r24
     40c:	c9 f7       	brne	.-14     	; 0x400 <oneWireLeft+0x5c>
     40e:	81 e0       	ldi	r24, 0x01	; 1
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     410:	df 91       	pop	r29
     412:	cf 91       	pop	r28
     414:	08 95       	ret

00000416 <oneWireRight>:

unsigned char oneWireRight()
{
     416:	cf 93       	push	r28
     418:	df 93       	push	r29

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT ROMCODE: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     41a:	0e 94 d0 05 	call	0xba0	; 0xba0 <reset>
     41e:	81 11       	cpse	r24, r1
     420:	02 c0       	rjmp	.+4      	; 0x426 <oneWireRight+0x10>
			return 1;
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
     422:	80 e0       	ldi	r24, 0x00	; 0
     424:	2e c0       	rjmp	.+92     	; 0x482 <oneWireRight+0x6c>
		transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT ROMCODE: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
	{
		write_byte(0x55);	// Master issues Match ROM command.
     426:	85 e5       	ldi	r24, 0x55	; 85
     428:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
     42c:	c9 e6       	ldi	r28, 0x69	; 105
     42e:	d0 e0       	ldi	r29, 0x00	; 0
		for(i=0; i<8; i++)
		{
			write_byte(rightTempSensorRomCode[i]);	// 64-bit ROM CODE
     430:	89 91       	ld	r24, Y+
     432:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
		transmitUartString("[UART INFO] TEMP REGISTERS DATA RAW DUMP\r\n");		// uart debug information string
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
	{
		write_byte(0x55);	// Master issues Match ROM command.
		for(i=0; i<8; i++)
     436:	80 e0       	ldi	r24, 0x00	; 0
     438:	c1 37       	cpi	r28, 0x71	; 113
     43a:	d8 07       	cpc	r29, r24
     43c:	c9 f7       	brne	.-14     	; 0x430 <oneWireRight+0x1a>
		write_byte(0x08);	// Byte 5
		write_byte(0x00);	// Byte 6
		write_byte(0xB1);	// Byte 7
		// 64-bit ROM CODE
*/
		write_byte(0x44);	// Master issues Convert T command.
     43e:	84 e4       	ldi	r24, 0x44	; 68
     440:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     444:	0e 94 50 06 	call	0xca0	; 0xca0 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     448:	0e 94 d0 05 	call	0xba0	; 0xba0 <reset>
     44c:	88 23       	and	r24, r24
     44e:	49 f3       	breq	.-46     	; 0x422 <oneWireRight+0xc>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     450:	85 e5       	ldi	r24, 0x55	; 85
     452:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
     456:	c9 e6       	ldi	r28, 0x69	; 105
     458:	d0 e0       	ldi	r29, 0x00	; 0
			for(i=0; i<8; i++)
			{
				write_byte(rightTempSensorRomCode[i]);	// 64-bit ROM CODE
     45a:	89 91       	ld	r24, Y+
     45c:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
		write_byte(0x44);	// Master issues Convert T command.
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
		{
			write_byte(0x55);	// Master issues Match ROM command.
			for(i=0; i<8; i++)
     460:	80 e0       	ldi	r24, 0x00	; 0
     462:	c1 37       	cpi	r28, 0x71	; 113
     464:	d8 07       	cpc	r29, r24
     466:	c9 f7       	brne	.-14     	; 0x45a <oneWireRight+0x44>
			write_byte(0x08);	// Byte 5
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
     468:	8e eb       	ldi	r24, 0xBE	; 190
     46a:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
     46e:	c8 e7       	ldi	r28, 0x78	; 120
     470:	d5 e0       	ldi	r29, 0x05	; 5
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     472:	0e 94 05 06 	call	0xc0a	; 0xc0a <read_byte>
     476:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE
*/
			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     478:	85 e0       	ldi	r24, 0x05	; 5
     47a:	c1 38       	cpi	r28, 0x81	; 129
     47c:	d8 07       	cpc	r29, r24
     47e:	c9 f7       	brne	.-14     	; 0x472 <oneWireRight+0x5c>
     480:	81 e0       	ldi	r24, 0x01	; 1
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     482:	df 91       	pop	r29
     484:	cf 91       	pop	r28
     486:	08 95       	ret

00000488 <temperMeasur>:

char temperMeasur(unsigned char byte0, unsigned char byte1, unsigned char byte6, unsigned char byte7)
{
     488:	0f 93       	push	r16
     48a:	1f 93       	push	r17
     48c:	cf 93       	push	r28
     48e:	df 93       	push	r29
	char tC = 0;
	char temper = 0;
	double k = 0;
	double j = 0;

	byte0 = storeTemp [0];
     490:	80 91 78 05 	lds	r24, 0x0578
	byte1 = storeTemp [1];
     494:	90 91 79 05 	lds	r25, 0x0579
	byte6 = storeTemp [6];
	byte7 = storeTemp [7];

	k = ((byte7 - byte6) / byte7) + 0.25;

	if((byte1 == 0x00) && (byte0 == 0x00))
     498:	91 11       	cpse	r25, r1
     49a:	1d c0       	rjmp	.+58     	; 0x4d6 <temperMeasur+0x4e>
     49c:	81 11       	cpse	r24, r1
     49e:	0a c0       	rjmp	.+20     	; 0x4b4 <temperMeasur+0x2c>
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
		transmitUartInt(tC);		// uart debug information string 
		transmitUartString(".0 C\r\n");			// uart debug information string
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     4a0:	80 e0       	ldi	r24, 0x00	; 0
     4a2:	90 e0       	ldi	r25, 0x00	; 0
     4a4:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_DATA_INT>
	LCD_DATA_STRING(".0 C");		//
     4a8:	8b ed       	ldi	r24, 0xDB	; 219
     4aa:	91 e0       	ldi	r25, 0x01	; 1
     4ac:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>

	k = ((byte7 - byte6) / byte7) + 0.25;

	if((byte1 == 0x00) && (byte0 == 0x00))
	{
		tC = (byte0/2);
     4b0:	80 e0       	ldi	r24, 0x00	; 0
		transmitUartInt(tC);		// uart debug information string 
		transmitUartString(".0 C\r\n");			// uart debug information string
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
	LCD_DATA_STRING(".0 C");		//
     4b2:	2c c0       	rjmp	.+88     	; 0x50c <temperMeasur+0x84>
	}
	else if((byte1 == 0x00) && (byte0 != 0x00))
	{
//		transmitUartString("+");		// POSITIVE TEMPERATURE
		tC = (byte0/2);
     4b4:	c8 2f       	mov	r28, r24
     4b6:	c6 95       	lsr	r28
		j = tC - k;
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Temperature: +");		// uart debug information string
     4b8:	80 ee       	ldi	r24, 0xE0	; 224
     4ba:	91 e0       	ldi	r25, 0x01	; 1
     4bc:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     4c0:	0c 2f       	mov	r16, r28
     4c2:	10 e0       	ldi	r17, 0x00	; 0
     4c4:	c8 01       	movw	r24, r16
     4c6:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString(".0 C\r\n");			// uart debug information string
     4ca:	8b ef       	ldi	r24, 0xFB	; 251
     4cc:	91 e0       	ldi	r25, 0x01	; 1
     4ce:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     4d2:	c8 01       	movw	r24, r16
     4d4:	0e c0       	rjmp	.+28     	; 0x4f2 <temperMeasur+0x6a>
	LCD_DATA_STRING(".0 C");		//
	}
	else if((byte1 == 0xFF) && (byte0 != 0x00))
     4d6:	9f 3f       	cpi	r25, 0xFF	; 255
     4d8:	a1 f4       	brne	.+40     	; 0x502 <temperMeasur+0x7a>
     4da:	88 23       	and	r24, r24
     4dc:	91 f0       	breq	.+36     	; 0x502 <temperMeasur+0x7a>
	{
//		transmitUartString("-");		// NEGATIVE TEMPERATURE
//		tC = ((byte0 - 255.5) / 2);		// ne e dobre obraboteno za otricatelni chisla
		tC = ((byte0 - 255) / 2);
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	8f 5f       	subi	r24, 0xFF	; 255
     4e2:	91 09       	sbc	r25, r1
     4e4:	97 fd       	sbrc	r25, 7
     4e6:	01 96       	adiw	r24, 0x01	; 1
     4e8:	ec 01       	movw	r28, r24
     4ea:	d5 95       	asr	r29
     4ec:	c7 95       	ror	r28
		transmitUartString("[UART INFO] Temperature: -");		// uart debug information string
		transmitUartInt(tC);		// uart debug information string 
		transmitUartString(".0 C\r\n");			// uart debug information string
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     4ee:	ce 01       	movw	r24, r28
     4f0:	99 27       	eor	r25, r25
     4f2:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_DATA_INT>
	LCD_DATA_STRING(".0 C");		//
     4f6:	8b ed       	ldi	r24, 0xDB	; 219
     4f8:	91 e0       	ldi	r25, 0x01	; 1
     4fa:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
	}
	else if((byte1 == 0xFF) && (byte0 != 0x00))
	{
//		transmitUartString("-");		// NEGATIVE TEMPERATURE
//		tC = ((byte0 - 255.5) / 2);		// ne e dobre obraboteno za otricatelni chisla
		tC = ((byte0 - 255) / 2);
     4fe:	8c 2f       	mov	r24, r28
		transmitUartInt(tC);		// uart debug information string 
		transmitUartString(".0 C\r\n");			// uart debug information string
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
	LCD_DATA_STRING(".0 C");		//
     500:	05 c0       	rjmp	.+10     	; 0x50c <temperMeasur+0x84>
	}
	else
	{
		//lcdDataString("ERROR!");	// ERROR not return to display!!!!
	#ifdef DEBUG_ERROR
		transmitUartString("[UART ERROR] ERROR TEMPERATURE\r\n");		// uart debug information string
     502:	82 e0       	ldi	r24, 0x02	; 2
     504:	92 e0       	ldi	r25, 0x02	; 2
     506:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
	#endif
		return 1;
     50a:	81 e0       	ldi	r24, 0x01	; 1
	}
	temper = tC;

	return temper;
}
     50c:	df 91       	pop	r29
     50e:	cf 91       	pop	r28
     510:	1f 91       	pop	r17
     512:	0f 91       	pop	r16
     514:	08 95       	ret

00000516 <temperature>:

/*****************************
**** TEMPERATURE FUNCTION ****
*****************************/
void temperature()
{
     516:	0f 93       	push	r16
     518:	1f 93       	push	r17
     51a:	cf 93       	push	r28
     51c:	df 93       	push	r29
	unsigned char i;
//	LED_low_DISPLAYLED_high();
//	LCD_INIT();								// LCD INITIZLIZATION
	LCD_CLEAR_CONTAIN();
     51e:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <LCD_CLEAR_CONTAIN>

	LCD_COMMAND(LCD_SELECT_1ROW);	// select row 1
     522:	80 e0       	ldi	r24, 0x00	; 0
     524:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
	LCD_DATA_STRING("     TEMERATURE     ");		//
     528:	83 e2       	ldi	r24, 0x23	; 35
     52a:	92 e0       	ldi	r25, 0x02	; 2
     52c:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
     530:	80 ec       	ldi	r24, 0xC0	; 192
     532:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
	LCD_DATA_STRING("LEFT  SENSOR: ");				//
     536:	88 e3       	ldi	r24, 0x38	; 56
     538:	92 e0       	ldi	r25, 0x02	; 2
     53a:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>

	oneWireLeft();
     53e:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <oneWireLeft>
     542:	08 e7       	ldi	r16, 0x78	; 120
     544:	15 e0       	ldi	r17, 0x05	; 5
     546:	c0 e0       	ldi	r28, 0x00	; 0
     548:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] byte ");
     54a:	87 e4       	ldi	r24, 0x47	; 71
     54c:	92 e0       	ldi	r25, 0x02	; 2
     54e:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(i);
     552:	ce 01       	movw	r24, r28
     554:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString(" : ");
     558:	89 e5       	ldi	r24, 0x59	; 89
     55a:	92 e0       	ldi	r25, 0x02	; 2
     55c:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(storeTemp[i]);
     560:	f8 01       	movw	r30, r16
     562:	81 91       	ld	r24, Z+
     564:	8f 01       	movw	r16, r30
     566:	90 e0       	ldi	r25, 0x00	; 0
     568:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString("\r\n");
     56c:	88 eb       	ldi	r24, 0xB8	; 184
     56e:	93 e0       	ldi	r25, 0x03	; 3
     570:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
     574:	21 96       	adiw	r28, 0x01	; 1
	LCD_DATA_STRING("     TEMERATURE     ");		//
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
	LCD_DATA_STRING("LEFT  SENSOR: ");				//

	oneWireLeft();
	for(i=0; i<9; i++)
     576:	c9 30       	cpi	r28, 0x09	; 9
     578:	d1 05       	cpc	r29, r1
     57a:	39 f7       	brne	.-50     	; 0x54a <temperature+0x34>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     57c:	20 91 8f 05 	lds	r18, 0x058F
     580:	40 91 92 05 	lds	r20, 0x0592
     584:	60 91 93 05 	lds	r22, 0x0593
     588:	80 91 97 05 	lds	r24, 0x0597
     58c:	0e 94 44 02 	call	0x488	; 0x488 <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
     590:	84 e9       	ldi	r24, 0x94	; 148
     592:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
     596:	8d e5       	ldi	r24, 0x5D	; 93
     598:	92 e0       	ldi	r25, 0x02	; 2
     59a:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
	oneWireRight();
     59e:	0e 94 0b 02 	call	0x416	; 0x416 <oneWireRight>
     5a2:	08 e7       	ldi	r16, 0x78	; 120
     5a4:	15 e0       	ldi	r17, 0x05	; 5
     5a6:	c0 e0       	ldi	r28, 0x00	; 0
     5a8:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] byte ");
     5aa:	87 e4       	ldi	r24, 0x47	; 71
     5ac:	92 e0       	ldi	r25, 0x02	; 2
     5ae:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(i);
     5b2:	ce 01       	movw	r24, r28
     5b4:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString(" : ");
     5b8:	89 e5       	ldi	r24, 0x59	; 89
     5ba:	92 e0       	ldi	r25, 0x02	; 2
     5bc:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(storeTemp[i]);
     5c0:	f8 01       	movw	r30, r16
     5c2:	81 91       	ld	r24, Z+
     5c4:	8f 01       	movw	r16, r30
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString("\r\n");
     5cc:	88 eb       	ldi	r24, 0xB8	; 184
     5ce:	93 e0       	ldi	r25, 0x03	; 3
     5d0:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
     5d4:	21 96       	adiw	r28, 0x01	; 1
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
	oneWireRight();
	for(i=0; i<9; i++)
     5d6:	c9 30       	cpi	r28, 0x09	; 9
     5d8:	d1 05       	cpc	r29, r1
     5da:	39 f7       	brne	.-50     	; 0x5aa <temperature+0x94>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     5dc:	20 91 8f 05 	lds	r18, 0x058F
     5e0:	40 91 92 05 	lds	r20, 0x0592
     5e4:	60 91 93 05 	lds	r22, 0x0593
     5e8:	80 91 97 05 	lds	r24, 0x0597
     5ec:	0e 94 44 02 	call	0x488	; 0x488 <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
     5f0:	84 ed       	ldi	r24, 0xD4	; 212
     5f2:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
	LCD_DATA_STRING("             DS18x20");		//
     5f6:	8c e6       	ldi	r24, 0x6C	; 108
     5f8:	92 e0       	ldi	r25, 0x02	; 2
}
     5fa:	df 91       	pop	r29
     5fc:	cf 91       	pop	r28
     5fe:	1f 91       	pop	r17
     600:	0f 91       	pop	r16
	}
	temperMeasur(byte0, byte1, byte6, byte7);
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_STRING("             DS18x20");		//
     602:	0c 94 64 07 	jmp	0xec8	; 0xec8 <LCD_DATA_STRING>

00000606 <irDecode>:
************************************/
void irDecode(void)
{
//	byte byteSS0, byteSS1, byteMM0, byteMM1, byteHH0, byteHH1, byteDD0, byteDD1, byteMont0, byteMont1, byteYY0, byteYY1; // variables for convert DEC to BCD for LCD and UART for Time and Date

	GetSIRC12();
     606:	0e 94 6f 0a 	call	0x14de	; 0x14de <GetSIRC12>
	if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 0)		// IR POWER -> ON
     60a:	80 91 99 05 	lds	r24, 0x0599
     60e:	81 30       	cpi	r24, 0x01	; 1
     610:	29 f4       	brne	.+10     	; 0x61c <irDecode+0x16>
     612:	90 91 94 05 	lds	r25, 0x0594
     616:	95 31       	cpi	r25, 0x15	; 21
     618:	a1 f4       	brne	.+40     	; 0x642 <irDecode+0x3c>
     61a:	07 c0       	rjmp	.+14     	; 0x62a <irDecode+0x24>
     61c:	84 30       	cpi	r24, 0x04	; 4
     61e:	09 f0       	breq	.+2      	; 0x622 <irDecode+0x1c>
     620:	bc c0       	rjmp	.+376    	; 0x79a <irDecode+0x194>
     622:	90 91 94 05 	lds	r25, 0x0594
     626:	9d 30       	cpi	r25, 0x0D	; 13
     628:	a1 f4       	brne	.+40     	; 0x652 <irDecode+0x4c>
     62a:	e0 91 95 05 	lds	r30, 0x0595
     62e:	f0 91 96 05 	lds	r31, 0x0596
     632:	90 81       	ld	r25, Z
     634:	90 fd       	sbrc	r25, 0
     636:	03 c0       	rjmp	.+6      	; 0x63e <irDecode+0x38>
	{		
		ampliferOn();
     638:	0e 94 ac 00 	call	0x158	; 0x158 <ampliferOn>
     63c:	a4 c0       	rjmp	.+328    	; 0x786 <irDecode+0x180>
//		_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 1)	// IR POWER -> OFF
     63e:	81 30       	cpi	r24, 0x01	; 1
     640:	29 f4       	brne	.+10     	; 0x64c <irDecode+0x46>
     642:	90 91 94 05 	lds	r25, 0x0594
     646:	95 31       	cpi	r25, 0x15	; 21
     648:	b9 f4       	brne	.+46     	; 0x678 <irDecode+0x72>
     64a:	07 c0       	rjmp	.+14     	; 0x65a <irDecode+0x54>
     64c:	84 30       	cpi	r24, 0x04	; 4
     64e:	09 f0       	breq	.+2      	; 0x652 <irDecode+0x4c>
     650:	a4 c0       	rjmp	.+328    	; 0x79a <irDecode+0x194>
     652:	90 91 94 05 	lds	r25, 0x0594
     656:	9d 30       	cpi	r25, 0x0D	; 13
     658:	79 f4       	brne	.+30     	; 0x678 <irDecode+0x72>
     65a:	e0 91 95 05 	lds	r30, 0x0595
     65e:	f0 91 96 05 	lds	r31, 0x0596
     662:	90 81       	ld	r25, Z
     664:	90 ff       	sbrs	r25, 0
     666:	03 c0       	rjmp	.+6      	; 0x66e <irDecode+0x68>
	{
		ampliferOff();
     668:	0e 94 ef 00 	call	0x1de	; 0x1de <ampliferOff>
     66c:	8c c0       	rjmp	.+280    	; 0x786 <irDecode+0x180>
//		flagPower = 0;			// filter za buton OFF
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLUP)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME UP"
     66e:	81 30       	cpi	r24, 0x01	; 1
     670:	19 f0       	breq	.+6      	; 0x678 <irDecode+0x72>
     672:	84 30       	cpi	r24, 0x04	; 4
     674:	09 f0       	breq	.+2      	; 0x678 <irDecode+0x72>
     676:	87 c0       	rjmp	.+270    	; 0x786 <irDecode+0x180>
     678:	90 91 94 05 	lds	r25, 0x0594
     67c:	92 31       	cpi	r25, 0x12	; 18
     67e:	99 f4       	brne	.+38     	; 0x6a6 <irDecode+0xa0>
     680:	e0 91 95 05 	lds	r30, 0x0595
     684:	f0 91 96 05 	lds	r31, 0x0596
     688:	20 81       	ld	r18, Z
     68a:	20 ff       	sbrs	r18, 0
     68c:	0c c0       	rjmp	.+24     	; 0x6a6 <irDecode+0xa0>
		volumeUpdate();
	}
	else if(1==temp)
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     68e:	80 91 82 05 	lds	r24, 0x0582
     692:	83 31       	cpi	r24, 0x13	; 19
     694:	10 f0       	brcs	.+4      	; 0x69a <irDecode+0x94>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     696:	83 e1       	ldi	r24, 0x13	; 19
     698:	01 c0       	rjmp	.+2      	; 0x69c <irDecode+0x96>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     69a:	8f 5f       	subi	r24, 0xFF	; 255
     69c:	80 93 82 05 	sts	0x0582, r24
		}
		volumeUpdate();
     6a0:	0e 94 2a 01 	call	0x254	; 0x254 <volumeUpdate>
     6a4:	70 c0       	rjmp	.+224    	; 0x786 <irDecode+0x180>
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLUP)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME UP"
	{	// VOLUME UP
		volumeProcessRemote(REMOTE_VOLUME_UP);
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLDN)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME DOWN"
     6a6:	81 30       	cpi	r24, 0x01	; 1
     6a8:	19 f0       	breq	.+6      	; 0x6b0 <irDecode+0xaa>
     6aa:	84 30       	cpi	r24, 0x04	; 4
     6ac:	09 f0       	breq	.+2      	; 0x6b0 <irDecode+0xaa>
     6ae:	6b c0       	rjmp	.+214    	; 0x786 <irDecode+0x180>
     6b0:	93 31       	cpi	r25, 0x13	; 19
     6b2:	59 f4       	brne	.+22     	; 0x6ca <irDecode+0xc4>
     6b4:	e0 91 95 05 	lds	r30, 0x0595
     6b8:	f0 91 96 05 	lds	r31, 0x0596
     6bc:	20 81       	ld	r18, Z
     6be:	20 ff       	sbrs	r18, 0
     6c0:	04 c0       	rjmp	.+8      	; 0x6ca <irDecode+0xc4>
	{	// VOLUME DOWN
		volumeProcessRemote(REMOTE_VOLUME_DOWN);
     6c2:	8f ef       	ldi	r24, 0xFF	; 255
     6c4:	0e 94 88 01 	call	0x310	; 0x310 <volumeProcessRemote>
     6c8:	5e c0       	rjmp	.+188    	; 0x786 <irDecode+0x180>
//		break;
	}

	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_ATT)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     6ca:	81 30       	cpi	r24, 0x01	; 1
     6cc:	19 f0       	breq	.+6      	; 0x6d4 <irDecode+0xce>
     6ce:	84 30       	cpi	r24, 0x04	; 4
     6d0:	09 f0       	breq	.+2      	; 0x6d4 <irDecode+0xce>
     6d2:	59 c0       	rjmp	.+178    	; 0x786 <irDecode+0x180>
     6d4:	94 31       	cpi	r25, 0x14	; 20
     6d6:	51 f4       	brne	.+20     	; 0x6ec <irDecode+0xe6>
     6d8:	e0 91 95 05 	lds	r30, 0x0595
     6dc:	f0 91 96 05 	lds	r31, 0x0596
     6e0:	80 81       	ld	r24, Z
     6e2:	80 ff       	sbrs	r24, 0
     6e4:	50 c0       	rjmp	.+160    	; 0x786 <irDecode+0x180>
	{	// MUTE
		volumeMute();
     6e6:	0e 94 6d 01 	call	0x2da	; 0x2da <volumeMute>
     6ea:	4d c0       	rjmp	.+154    	; 0x786 <irDecode+0x180>
//		break;
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_DOWN)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     6ec:	84 30       	cpi	r24, 0x04	; 4
     6ee:	09 f0       	breq	.+2      	; 0x6f2 <irDecode+0xec>
     6f0:	4a c0       	rjmp	.+148    	; 0x786 <irDecode+0x180>
     6f2:	92 33       	cpi	r25, 0x32	; 50
     6f4:	69 f4       	brne	.+26     	; 0x710 <irDecode+0x10a>
     6f6:	e0 91 95 05 	lds	r30, 0x0595
     6fa:	f0 91 96 05 	lds	r31, 0x0596
     6fe:	80 81       	ld	r24, Z
     700:	80 ff       	sbrs	r24, 0
     702:	41 c0       	rjmp	.+130    	; 0x786 <irDecode+0x180>
	{	// FAN STEP UP
		if(fanSpeed < FAN_SPEED_ABSOLUTE_MIN + 1)//0)
     704:	80 91 68 00 	lds	r24, 0x0068
     708:	88 23       	and	r24, r24
     70a:	a1 f0       	breq	.+40     	; 0x734 <irDecode+0x12e>
		{
			fanSpeed = FAN_SPEED_ABSOLUTE_MIN;	//0;	// 0-7
		}
		else
		{
			fanSpeed--;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     70c:	81 50       	subi	r24, 0x01	; 1
     70e:	10 c0       	rjmp	.+32     	; 0x730 <irDecode+0x12a>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
		LCD_DATA_STRING(" or ");
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
		fan_pwm_control_speed();
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_UP)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     710:	93 33       	cpi	r25, 0x33	; 51
     712:	61 f5       	brne	.+88     	; 0x76c <irDecode+0x166>
     714:	e0 91 95 05 	lds	r30, 0x0595
     718:	f0 91 96 05 	lds	r31, 0x0596
     71c:	80 81       	ld	r24, Z
     71e:	80 ff       	sbrs	r24, 0
     720:	32 c0       	rjmp	.+100    	; 0x786 <irDecode+0x180>
	{	// FAN STEP DOWN
		if(fanSpeed > FAN_LIMIT_POSITIONS - 2)//7)
     722:	80 91 68 00 	lds	r24, 0x0068
     726:	87 30       	cpi	r24, 0x07	; 7
     728:	10 f0       	brcs	.+4      	; 0x72e <irDecode+0x128>
		{
			fanSpeed = FAN_LIMIT_POSITIONS - 1;	//7;	// 0-7
     72a:	87 e0       	ldi	r24, 0x07	; 7
     72c:	01 c0       	rjmp	.+2      	; 0x730 <irDecode+0x12a>
		}
		else
		{
			fanSpeed++;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     72e:	8f 5f       	subi	r24, 0xFF	; 255
     730:	80 93 68 00 	sts	0x0068, r24
		}
//		fanSpeedStep [fanSpeed];// = { 0x00, 100, 125, 150, 175, 200, 225, 250 };
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     734:	84 ed       	ldi	r24, 0xD4	; 212
     736:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
		LCD_DATA_STRING("Fan Step: ");	// 20 symbols			
     73a:	81 e8       	ldi	r24, 0x81	; 129
     73c:	92 e0       	ldi	r25, 0x02	; 2
     73e:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
     742:	80 91 68 00 	lds	r24, 0x0068
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_DATA_INT>
		LCD_DATA_STRING(" or ");
     74c:	8c e8       	ldi	r24, 0x8C	; 140
     74e:	92 e0       	ldi	r25, 0x02	; 2
     750:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
     754:	e0 91 68 00 	lds	r30, 0x0068
     758:	f0 e0       	ldi	r31, 0x00	; 0
     75a:	e0 5a       	subi	r30, 0xA0	; 160
     75c:	ff 4f       	sbci	r31, 0xFF	; 255
     75e:	80 81       	ld	r24, Z
     760:	90 e0       	ldi	r25, 0x00	; 0
     762:	0e 94 aa 07 	call	0xf54	; 0xf54 <LCD_DATA_INT>
/***********************************
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
     766:	0e 94 71 00 	call	0xe2	; 0xe2 <timer1_on_speed>
     76a:	0d c0       	rjmp	.+26     	; 0x786 <irDecode+0x180>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
		LCD_DATA_STRING(" or ");
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
		fan_pwm_control_speed();
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_SCRL)) && (flagStatusBits->flagPower == 0 || flagStatusBits->flagPower == 1))						// Sony CarAudio IR Remote Device - "SCRL" -> TEMPERATURE
     76c:	93 32       	cpi	r25, 0x23	; 35
     76e:	59 f4       	brne	.+22     	; 0x786 <irDecode+0x180>
	{
		temperature();
     770:	0e 94 8b 02 	call	0x516	; 0x516 <temperature>
     774:	2f ef       	ldi	r18, 0xFF	; 255
     776:	83 ec       	ldi	r24, 0xC3	; 195
     778:	99 e0       	ldi	r25, 0x09	; 9
     77a:	21 50       	subi	r18, 0x01	; 1
     77c:	80 40       	sbci	r24, 0x00	; 0
     77e:	90 40       	sbci	r25, 0x00	; 0
     780:	e1 f7       	brne	.-8      	; 0x77a <irDecode+0x174>
     782:	00 c0       	rjmp	.+0      	; 0x784 <irDecode+0x17e>
     784:	00 00       	nop
     786:	2f ef       	ldi	r18, 0xFF	; 255
     788:	83 ec       	ldi	r24, 0xC3	; 195
     78a:	99 e0       	ldi	r25, 0x09	; 9
     78c:	21 50       	subi	r18, 0x01	; 1
     78e:	80 40       	sbci	r24, 0x00	; 0
     790:	90 40       	sbci	r25, 0x00	; 0
     792:	e1 f7       	brne	.-8      	; 0x78c <irDecode+0x186>
     794:	00 c0       	rjmp	.+0      	; 0x796 <irDecode+0x190>
     796:	00 00       	nop
     798:	08 95       	ret
	{
		ampliferOff();
//		flagPower = 0;			// filter za buton OFF
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLUP)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME UP"
     79a:	81 30       	cpi	r24, 0x01	; 1
     79c:	a1 f7       	brne	.-24     	; 0x786 <irDecode+0x180>
     79e:	6c cf       	rjmp	.-296    	; 0x678 <irDecode+0x72>

000007a0 <autoControlTemperature>:
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_STRING("             DS18x20");		//
}

void autoControlTemperature()
{
     7a0:	cf 93       	push	r28
     7a2:	df 93       	push	r29
	unsigned char i;
	char resultL, resultR, resultCompare;

	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Left Temperature Sensor\r\n");
     7a4:	81 e9       	ldi	r24, 0x91	; 145
     7a6:	92 e0       	ldi	r25, 0x02	; 2
     7a8:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
	#endif
	oneWireLeft();
     7ac:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <oneWireLeft>
	resultL = temperMeasur(byte0, byte1, byte6, byte7);
     7b0:	20 91 8f 05 	lds	r18, 0x058F
     7b4:	40 91 92 05 	lds	r20, 0x0592
     7b8:	60 91 93 05 	lds	r22, 0x0593
     7bc:	80 91 97 05 	lds	r24, 0x0597
     7c0:	0e 94 44 02 	call	0x488	; 0x488 <temperMeasur>
     7c4:	d8 2f       	mov	r29, r24
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] RESULT LEFT Sensor = ");
     7c6:	87 eb       	ldi	r24, 0xB7	; 183
     7c8:	92 e0       	ldi	r25, 0x02	; 2
     7ca:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(resultL);
     7ce:	8d 2f       	mov	r24, r29
     7d0:	90 e0       	ldi	r25, 0x00	; 0
     7d2:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString("\r\n");
     7d6:	88 eb       	ldi	r24, 0xB8	; 184
     7d8:	93 e0       	ldi	r25, 0x03	; 3
     7da:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
	#endif

	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Right Temperature Sensor\r\n");
     7de:	89 ed       	ldi	r24, 0xD9	; 217
     7e0:	92 e0       	ldi	r25, 0x02	; 2
     7e2:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
	#endif
	oneWireRight();
     7e6:	0e 94 0b 02 	call	0x416	; 0x416 <oneWireRight>
	resultR = temperMeasur(byte0, byte1, byte6, byte7);
     7ea:	20 91 8f 05 	lds	r18, 0x058F
     7ee:	40 91 92 05 	lds	r20, 0x0592
     7f2:	60 91 93 05 	lds	r22, 0x0593
     7f6:	80 91 97 05 	lds	r24, 0x0597
     7fa:	0e 94 44 02 	call	0x488	; 0x488 <temperMeasur>
     7fe:	c8 2f       	mov	r28, r24
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] RESULT RIGHT Sensor = ");
     800:	80 e0       	ldi	r24, 0x00	; 0
     802:	93 e0       	ldi	r25, 0x03	; 3
     804:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(resultR);
     808:	8c 2f       	mov	r24, r28
     80a:	90 e0       	ldi	r25, 0x00	; 0
     80c:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString("\r\n");
     810:	88 eb       	ldi	r24, 0xB8	; 184
     812:	93 e0       	ldi	r25, 0x03	; 3
     814:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
	#endif

	resultCompare = resultL > resultR ? resultL : resultR;
     818:	cd 17       	cp	r28, r29
     81a:	08 f4       	brcc	.+2      	; 0x81e <autoControlTemperature+0x7e>
     81c:	cd 2f       	mov	r28, r29
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] Bigger temperature value between left or right sensors is: resultCompare = ");
     81e:	83 e2       	ldi	r24, 0x23	; 35
     820:	93 e0       	ldi	r25, 0x03	; 3
     822:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(resultCompare);
     826:	8c 2f       	mov	r24, r28
     828:	90 e0       	ldi	r25, 0x00	; 0
     82a:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString("\r\n");
     82e:	88 eb       	ldi	r24, 0xB8	; 184
     830:	93 e0       	ldi	r25, 0x03	; 3
     832:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
	#endif

//	{ 0x00, 150, 175, 200, 220, 230, 240, 250 };
	if((resultCompare <= 1) || (resultCompare <= 20))
     836:	c5 31       	cpi	r28, 0x15	; 21
     838:	18 f4       	brcc	.+6      	; 0x840 <autoControlTemperature+0xa0>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_0]; // fan value = 0
     83a:	80 91 60 00 	lds	r24, 0x0060
     83e:	20 c0       	rjmp	.+64     	; 0x880 <__stack+0x21>
	}
	else if((resultCompare <= 21) || (resultCompare <= 26))
     840:	cb 31       	cpi	r28, 0x1B	; 27
     842:	18 f4       	brcc	.+6      	; 0x84a <autoControlTemperature+0xaa>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_1]; // fan value = 150
     844:	80 91 61 00 	lds	r24, 0x0061
     848:	1b c0       	rjmp	.+54     	; 0x880 <__stack+0x21>
	}
	else if((resultCompare <= 27) || (resultCompare <= 29)) //35
     84a:	ce 31       	cpi	r28, 0x1E	; 30
     84c:	18 f4       	brcc	.+6      	; 0x854 <autoControlTemperature+0xb4>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_2]; // fan value = 175
     84e:	80 91 62 00 	lds	r24, 0x0062
     852:	16 c0       	rjmp	.+44     	; 0x880 <__stack+0x21>
	}
	else if((resultCompare <= 30) || (resultCompare <= 32)) //40
     854:	c1 32       	cpi	r28, 0x21	; 33
     856:	18 f4       	brcc	.+6      	; 0x85e <autoControlTemperature+0xbe>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_3]; // fan value = 200
     858:	80 91 63 00 	lds	r24, 0x0063
     85c:	11 c0       	rjmp	.+34     	; 0x880 <__stack+0x21>
	}
	else if((resultCompare <= 33) || (resultCompare <= 35))//50
     85e:	c4 32       	cpi	r28, 0x24	; 36
     860:	18 f4       	brcc	.+6      	; 0x868 <__stack+0x9>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_4]; // fan value = 220
     862:	80 91 64 00 	lds	r24, 0x0064
     866:	0c c0       	rjmp	.+24     	; 0x880 <__stack+0x21>
	}
	else if((resultCompare <= 36) || (resultCompare <= 37))//55
     868:	c6 32       	cpi	r28, 0x26	; 38
     86a:	18 f4       	brcc	.+6      	; 0x872 <__stack+0x13>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_5]; // fan value = 230
     86c:	80 91 65 00 	lds	r24, 0x0065
     870:	07 c0       	rjmp	.+14     	; 0x880 <__stack+0x21>
	}
	else if((resultCompare <= 38) || (resultCompare <= 40))//60
     872:	c9 32       	cpi	r28, 0x29	; 41
     874:	18 f4       	brcc	.+6      	; 0x87c <__stack+0x1d>
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_6]; // fan value = 240
     876:	80 91 66 00 	lds	r24, 0x0066
     87a:	02 c0       	rjmp	.+4      	; 0x880 <__stack+0x21>
	}
	else if(resultCompare > 40)//65
	{
		fanSpeed = fanSpeedStep[FAN_SPEED_7]; // fan value = 250
     87c:	80 91 67 00 	lds	r24, 0x0067
     880:	80 93 68 00 	sts	0x0068, r24
			transmitUartString("\r\n");
		#endif
	}

	#ifdef DEBUG_ERROR
		transmitUartString("Auto controlled fan value step. Set value: ");
     884:	8b e7       	ldi	r24, 0x7B	; 123
     886:	93 e0       	ldi	r25, 0x03	; 3
     888:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartString(" fanSpeedStep[");
     88c:	87 ea       	ldi	r24, 0xA7	; 167
     88e:	93 e0       	ldi	r25, 0x03	; 3
     890:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(fanSpeed);
     894:	80 91 68 00 	lds	r24, 0x0068
     898:	90 e0       	ldi	r25, 0x00	; 0
     89a:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString("] \r\n");
     89e:	86 eb       	ldi	r24, 0xB6	; 182
     8a0:	93 e0       	ldi	r25, 0x03	; 3
     8a2:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
	#endif
	fan_pwm_control_speed();	// update fan speed
}
     8a6:	df 91       	pop	r29
     8a8:	cf 91       	pop	r28
/***********************************
******** DEFINITIONS OF FAN ********
***********************************/
void fan_pwm_control_speed(void)
{
	timer1_on_speed();
     8aa:	0c 94 71 00 	jmp	0xe2	; 0xe2 <timer1_on_speed>

000008ae <about>:
}

void about(void)
{
	#ifdef DEBUG_ERROR
		transmitUartString("[UART INFO] =====================================================\r\n");
     8ae:	8b eb       	ldi	r24, 0xBB	; 187
     8b0:	93 e0       	ldi	r25, 0x03	; 3
     8b2:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartString("[UART INFO] \tAuthors and creators: P.Upinov and P.Stoyanov\r\n");
     8b6:	8f ef       	ldi	r24, 0xFF	; 255
     8b8:	93 e0       	ldi	r25, 0x03	; 3
     8ba:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartString("[UART INFO] \tDevice name: Digital Control Audio System\r\n");
     8be:	8c e3       	ldi	r24, 0x3C	; 60
     8c0:	94 e0       	ldi	r25, 0x04	; 4
     8c2:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartString("[UART INFO] \tFirmware version beta ");
     8c6:	85 e7       	ldi	r24, 0x75	; 117
     8c8:	94 e0       	ldi	r25, 0x04	; 4
     8ca:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartInt(FIRMWARE_VERSION);
     8ce:	80 e2       	ldi	r24, 0x20	; 32
     8d0:	90 e0       	ldi	r25, 0x00	; 0
     8d2:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
		transmitUartString("\r\n");
     8d6:	88 eb       	ldi	r24, 0xB8	; 184
     8d8:	93 e0       	ldi	r25, 0x03	; 3
     8da:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartString("[UART INFO] =====================================================\r\n");
     8de:	8b eb       	ldi	r24, 0xBB	; 187
     8e0:	93 e0       	ldi	r25, 0x03	; 3
     8e2:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		transmitUartString("[UART INFO] Da dobavq upravlenie na:\
     8e6:	89 e9       	ldi	r24, 0x99	; 153
     8e8:	94 e0       	ldi	r25, 0x04	; 4
     8ea:	0c 94 a0 08 	jmp	0x1140	; 0x1140 <transmitUartString>

000008ee <__vector_1>:

/*****************************************
**** EXTERNAL INTERRUPT 0 VECTOR 01 ******
*****************************************/
ISR(INT0_vect)
{
     8ee:	1f 92       	push	r1
     8f0:	0f 92       	push	r0
     8f2:	0f b6       	in	r0, 0x3f	; 63
     8f4:	0f 92       	push	r0
     8f6:	11 24       	eor	r1, r1
     8f8:	2f 93       	push	r18
     8fa:	3f 93       	push	r19
     8fc:	4f 93       	push	r20
     8fe:	5f 93       	push	r21
     900:	6f 93       	push	r22
     902:	7f 93       	push	r23
     904:	8f 93       	push	r24
     906:	9f 93       	push	r25
     908:	af 93       	push	r26
     90a:	bf 93       	push	r27
     90c:	ef 93       	push	r30
     90e:	ff 93       	push	r31
	ext0_intrpt_off();	// DISABLE new IR DETECTION
     910:	0e 94 62 00 	call	0xc4	; 0xc4 <ext0_intrpt_off>
	cli();				//	SREG &= ~(1 << I);
     914:	f8 94       	cli

// LOGIC CHECK BEGIN
// VERIFY PRESSED IR BUTTON and switch to low line of IR pin PD2

	unsigned char low_level = 0;
    if(irPin == 0)
     916:	82 99       	sbic	0x10, 2	; 16
     918:	0e c0       	rjmp	.+28     	; 0x936 <__vector_1+0x48>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     91a:	8a e0       	ldi	r24, 0x0A	; 10
     91c:	8a 95       	dec	r24
     91e:	f1 f7       	brne	.-4      	; 0x91c <__vector_1+0x2e>
     920:	00 c0       	rjmp	.+0      	; 0x922 <__vector_1+0x34>
     922:	8a e0       	ldi	r24, 0x0A	; 10
     924:	8a 95       	dec	r24
     926:	f1 f7       	brne	.-4      	; 0x924 <__vector_1+0x36>
     928:	00 c0       	rjmp	.+0      	; 0x92a <__vector_1+0x3c>
     92a:	8a e0       	ldi	r24, 0x0A	; 10
     92c:	8a 95       	dec	r24
     92e:	f1 f7       	brne	.-4      	; 0x92c <__vector_1+0x3e>
     930:	00 c0       	rjmp	.+0      	; 0x932 <__vector_1+0x44>
			_delay_us(2);	//2uS delay
		}

		if(low_level == 3)
		{
			irDecode();
     932:	0e 94 03 03 	call	0x606	; 0x606 <irDecode>
		else
		{
		}
    }
// LOGIC CHECK END
    sei();				//	SREG |= (1 << I);
     936:	78 94       	sei
	ext0_intrpt_on();	// ENABLE new IR DETECTION
     938:	0e 94 5b 00 	call	0xb6	; 0xb6 <ext0_intrpt_on>
}
     93c:	ff 91       	pop	r31
     93e:	ef 91       	pop	r30
     940:	bf 91       	pop	r27
     942:	af 91       	pop	r26
     944:	9f 91       	pop	r25
     946:	8f 91       	pop	r24
     948:	7f 91       	pop	r23
     94a:	6f 91       	pop	r22
     94c:	5f 91       	pop	r21
     94e:	4f 91       	pop	r20
     950:	3f 91       	pop	r19
     952:	2f 91       	pop	r18
     954:	0f 90       	pop	r0
     956:	0f be       	out	0x3f, r0	; 63
     958:	0f 90       	pop	r0
     95a:	1f 90       	pop	r1
     95c:	18 95       	reti

0000095e <__vector_2>:

/*****************************************
**** EXTERNAL INTERRUPT 1 VECTOR 02 ******
*****************************************/
ISR(INT1_vect)
{
     95e:	1f 92       	push	r1
     960:	0f 92       	push	r0
     962:	0f b6       	in	r0, 0x3f	; 63
     964:	0f 92       	push	r0
     966:	11 24       	eor	r1, r1
}
     968:	0f 90       	pop	r0
     96a:	0f be       	out	0x3f, r0	; 63
     96c:	0f 90       	pop	r0
     96e:	1f 90       	pop	r1
     970:	18 95       	reti

00000972 <__vector_3>:

/*****************************************
**** EXTERNAL INTERRUPT 2 VECTOR 03 ******
*****************************************/
ISR(INT2_vect)
{
     972:	1f 92       	push	r1
     974:	0f 92       	push	r0
     976:	0f b6       	in	r0, 0x3f	; 63
     978:	0f 92       	push	r0
     97a:	11 24       	eor	r1, r1
}
     97c:	0f 90       	pop	r0
     97e:	0f be       	out	0x3f, r0	; 63
     980:	0f 90       	pop	r0
     982:	1f 90       	pop	r1
     984:	18 95       	reti

00000986 <__vector_4>:

/*****************************************
**** TIMER 2 OUTPUT COMPARE VECTOR 04 ****
*****************************************/
ISR(TIMER2_COMP_vect)
{
     986:	1f 92       	push	r1
     988:	0f 92       	push	r0
     98a:	0f b6       	in	r0, 0x3f	; 63
     98c:	0f 92       	push	r0
     98e:	11 24       	eor	r1, r1
     990:	2f 93       	push	r18
     992:	3f 93       	push	r19
     994:	4f 93       	push	r20
     996:	5f 93       	push	r21
     998:	6f 93       	push	r22
     99a:	7f 93       	push	r23
     99c:	8f 93       	push	r24
     99e:	9f 93       	push	r25
     9a0:	af 93       	push	r26
     9a2:	bf 93       	push	r27
     9a4:	ef 93       	push	r30
     9a6:	ff 93       	push	r31
	//	timer2Internal_intrpt_off();	// DISABLE new INTERNAL TIMER 2 INTERRUPT
	TIMSK &= ~(1 << OCIE2); // enable the CTC interrupt
     9a8:	89 b7       	in	r24, 0x39	; 57
     9aa:	8f 77       	andi	r24, 0x7F	; 127
     9ac:	89 bf       	out	0x39, r24	; 57
	// LOGIC CHECK BEGIN

	isr2++;
     9ae:	80 91 9f 05 	lds	r24, 0x059F
     9b2:	90 91 a0 05 	lds	r25, 0x05A0
     9b6:	01 96       	adiw	r24, 0x01	; 1
     9b8:	90 93 a0 05 	sts	0x05A0, r25
     9bc:	80 93 9f 05 	sts	0x059F, r24
	if(isr2 == 2)	// isr = 2, TCCR = 0x----1111; isr = 62, TCCR = 0x----1001
     9c0:	82 30       	cpi	r24, 0x02	; 2
     9c2:	91 05       	cpc	r25, r1
     9c4:	a9 f4       	brne	.+42     	; 0x9f0 <__vector_4+0x6a>
	{
		#ifdef DEBUG_ERROR
			transmitUartString("[UART INFO] Timer2_COMP isr2 = ");
     9c6:	8d e4       	ldi	r24, 0x4D	; 77
     9c8:	95 e0       	ldi	r25, 0x05	; 5
     9ca:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
			transmitUartInt(isr2);
     9ce:	80 91 9f 05 	lds	r24, 0x059F
     9d2:	90 91 a0 05 	lds	r25, 0x05A0
     9d6:	0e 94 c8 08 	call	0x1190	; 0x1190 <transmitUartInt>
			transmitUartString(", time = ");
     9da:	8d e6       	ldi	r24, 0x6D	; 109
     9dc:	95 e0       	ldi	r25, 0x05	; 5
     9de:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
			transmitUartString(" \r\n");
     9e2:	87 eb       	ldi	r24, 0xB7	; 183
     9e4:	93 e0       	ldi	r25, 0x03	; 3
     9e6:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
		#endif

		autoControlTemperature();
     9ea:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <autoControlTemperature>
     9ee:	06 c0       	rjmp	.+12     	; 0x9fc <__vector_4+0x76>
	}
	else if(isr2 >= 65535)
     9f0:	01 96       	adiw	r24, 0x01	; 1
     9f2:	21 f4       	brne	.+8      	; 0x9fc <__vector_4+0x76>
	{
		isr2 = 0;
     9f4:	10 92 a0 05 	sts	0x05A0, r1
     9f8:	10 92 9f 05 	sts	0x059F, r1
	}

	TIMSK |= (1 << OCIE2); // enable the CTC interrupt
     9fc:	89 b7       	in	r24, 0x39	; 57
     9fe:	80 68       	ori	r24, 0x80	; 128
     a00:	89 bf       	out	0x39, r24	; 57
	// LOGIC CHECK END
	//	timer2Internal_intrpt_on();		// ENABLE new INTERNAL TIMER 2 INTERRUPT
}
     a02:	ff 91       	pop	r31
     a04:	ef 91       	pop	r30
     a06:	bf 91       	pop	r27
     a08:	af 91       	pop	r26
     a0a:	9f 91       	pop	r25
     a0c:	8f 91       	pop	r24
     a0e:	7f 91       	pop	r23
     a10:	6f 91       	pop	r22
     a12:	5f 91       	pop	r21
     a14:	4f 91       	pop	r20
     a16:	3f 91       	pop	r19
     a18:	2f 91       	pop	r18
     a1a:	0f 90       	pop	r0
     a1c:	0f be       	out	0x3f, r0	; 63
     a1e:	0f 90       	pop	r0
     a20:	1f 90       	pop	r1
     a22:	18 95       	reti

00000a24 <__vector_5>:

/*****************************************
**** TIMER 2 OVERFLOW VECTOR 05 **********
*****************************************/
ISR(TIMER2_OVF_vect)
{
     a24:	1f 92       	push	r1
     a26:	0f 92       	push	r0
     a28:	0f b6       	in	r0, 0x3f	; 63
     a2a:	0f 92       	push	r0
     a2c:	11 24       	eor	r1, r1
}
     a2e:	0f 90       	pop	r0
     a30:	0f be       	out	0x3f, r0	; 63
     a32:	0f 90       	pop	r0
     a34:	1f 90       	pop	r1
     a36:	18 95       	reti

00000a38 <init_all>:
*********************************** START OF APPLICATION ************************************
********************************************************************************************/

void init_all()
{
	port_init();		// 1. IO init and configure all port
     a38:	0e 94 49 00 	call	0x92	; 0x92 <port_init>
	LCD_INIT();			// 2. LCD init and reset all lcd contain
     a3c:	0e 94 47 07 	call	0xe8e	; 0xe8e <LCD_INIT>
	uart_init();		// 3. UART debug init
     a40:	0e 94 75 08 	call	0x10ea	; 0x10ea <uart_init>
	timer1_init();		// 4. FAN INIT
     a44:	0e 94 6a 00 	call	0xd4	; 0xd4 <timer1_init>
	timer2_init();		// 5. Auto controlled fan by temperature sensors when timer2 is interrupted
     a48:	0e 94 7e 00 	call	0xfc	; 0xfc <timer2_init>
	about();			// x. Any debug important information
     a4c:	0e 94 57 04 	call	0x8ae	; 0x8ae <about>

	pga2310_init();		// SPI init and reset all (U6, U7, U8) PGA2310 volume values to null
     a50:	0e 94 49 08 	call	0x1092	; 0x1092 <pga2310_init>
	relays_in_init();	// nujno e daden reset be da bade izkliuche usilvatelq, togava reletata za vhod i izhod (bez power relay) sa ostanali vkliucheni
     a54:	0e 94 46 0a 	call	0x148c	; 0x148c <relays_in_init>
	relays_out_init();	// nujno e daden reset be da bade izkliuche usilvatelq, togava reletata za vhod i izhod (bez power relay)sa ostanali vkliucheni
     a58:	0c 94 6c 0a 	jmp	0x14d8	; 0x14d8 <relays_out_init>

00000a5c <buttons_press>:

}

void buttons_press()
{
	flagStatusBits = &fSB;
     a5c:	8d e9       	ldi	r24, 0x9D	; 157
     a5e:	95 e0       	ldi	r25, 0x05	; 5
     a60:	90 93 96 05 	sts	0x0596, r25
     a64:	80 93 95 05 	sts	0x0595, r24
	flagStatusBits->flagPower=0;	// inicializirane s nuli, no nai veroqtno poradi tova che e globalna stru
     a68:	80 91 9d 05 	lds	r24, 0x059D
	flagStatusBits->flagMute=0;		// inicializirane
     a6c:	8e 7f       	andi	r24, 0xFE	; 254
     a6e:	8d 7f       	andi	r24, 0xFD	; 253
     a70:	80 93 9d 05 	sts	0x059D, r24
     a74:	e0 91 95 05 	lds	r30, 0x0595
     a78:	f0 91 96 05 	lds	r31, 0x0596
		LCD_DATA_INT(flagStatusBits->flagMute);		// 20 symbols
	_delay_ms(2000);
*/
	while(1)
	{
		if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)	// obj ptr flagStatusBtnRegister from struct flagStatusBtnOnOff
     a7c:	b1 99       	sbic	0x16, 1	; 22
     a7e:	06 c0       	rjmp	.+12     	; 0xa8c <buttons_press+0x30>
     a80:	80 81       	ld	r24, Z
     a82:	80 fd       	sbrc	r24, 0
     a84:	03 c0       	rjmp	.+6      	; 0xa8c <buttons_press+0x30>
		{
//			flagStatusBits->flagPower = 1;			// filter za buton ON
			ampliferOn();
     a86:	0e 94 ac 00 	call	0x158	; 0x158 <ampliferOn>
     a8a:	f4 cf       	rjmp	.-24     	; 0xa74 <buttons_press+0x18>
//			_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
		}
		else if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     a8c:	b1 99       	sbic	0x16, 1	; 22
     a8e:	06 c0       	rjmp	.+12     	; 0xa9c <buttons_press+0x40>
     a90:	80 81       	ld	r24, Z
     a92:	80 ff       	sbrs	r24, 0
     a94:	03 c0       	rjmp	.+6      	; 0xa9c <buttons_press+0x40>
		{
//			flagStatusBits->flagPower = 0;			// filter za buton OFF
			ampliferOff();
     a96:	0e 94 ef 00 	call	0x1de	; 0x1de <ampliferOff>
     a9a:	ec cf       	rjmp	.-40     	; 0xa74 <buttons_press+0x18>
		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     a9c:	b2 99       	sbic	0x16, 2	; 22
     a9e:	06 c0       	rjmp	.+12     	; 0xaac <buttons_press+0x50>
     aa0:	80 81       	ld	r24, Z
     aa2:	80 ff       	sbrs	r24, 0
     aa4:	03 c0       	rjmp	.+6      	; 0xaac <buttons_press+0x50>
		{
//			LCD_DATA_STRING("PRESSED BTN ESCAPE  ");	// 20 symbols
//			LCD_COMMAND(LCD_ON);
			LCD_CLEAR_CONTAIN();
     aa6:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <LCD_CLEAR_CONTAIN>
     aaa:	11 c0       	rjmp	.+34     	; 0xace <buttons_press+0x72>
			_delay_ms(500);
//			volumeUp();
//			_delay_ms(200);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     aac:	83 99       	sbic	0x10, 3	; 16
     aae:	03 c0       	rjmp	.+6      	; 0xab6 <buttons_press+0x5a>
     ab0:	80 81       	ld	r24, Z
     ab2:	80 fd       	sbrc	r24, 0
     ab4:	0c c0       	rjmp	.+24     	; 0xace <buttons_press+0x72>
			_delay_ms(500);
//			volumeDown();
//			_delay_ms(200);

		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     ab6:	b2 99       	sbic	0x16, 2	; 22
     ab8:	03 c0       	rjmp	.+6      	; 0xac0 <buttons_press+0x64>
     aba:	80 81       	ld	r24, Z
     abc:	80 ff       	sbrs	r24, 0
     abe:	07 c0       	rjmp	.+14     	; 0xace <buttons_press+0x72>
//			LCD_COMMAND(LCD_ON);
			_delay_ms(500);
//			setupMode();
//			_delay_ms(1000);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     ac0:	83 99       	sbic	0x10, 3	; 16
     ac2:	0f c0       	rjmp	.+30     	; 0xae2 <buttons_press+0x86>
     ac4:	80 81       	ld	r24, Z
     ac6:	80 fd       	sbrc	r24, 0
     ac8:	0c c0       	rjmp	.+24     	; 0xae2 <buttons_press+0x86>
		{
			temperature();
     aca:	0e 94 8b 02 	call	0x516	; 0x516 <temperature>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     ace:	2f ef       	ldi	r18, 0xFF	; 255
     ad0:	89 e6       	ldi	r24, 0x69	; 105
     ad2:	98 e1       	ldi	r25, 0x18	; 24
     ad4:	21 50       	subi	r18, 0x01	; 1
     ad6:	80 40       	sbci	r24, 0x00	; 0
     ad8:	90 40       	sbci	r25, 0x00	; 0
     ada:	e1 f7       	brne	.-8      	; 0xad4 <buttons_press+0x78>
     adc:	00 c0       	rjmp	.+0      	; 0xade <buttons_press+0x82>
     ade:	00 00       	nop
     ae0:	c9 cf       	rjmp	.-110    	; 0xa74 <buttons_press+0x18>
//			LCD_COMMAND(LCD_OFF);
			_delay_ms(500);
//			about();
//			_delay_ms(1000);
		}
		else if(flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     ae2:	80 81       	ld	r24, Z
     ae4:	80 ff       	sbrs	r24, 0
     ae6:	c6 cf       	rjmp	.-116    	; 0xa74 <buttons_press+0x18>
		{
			volumeProcess();
     ae8:	0e 94 53 01 	call	0x2a6	; 0x2a6 <volumeProcess>
     aec:	c3 cf       	rjmp	.-122    	; 0xa74 <buttons_press+0x18>

00000aee <eeprom_24c64_reset>:

/*************************************
** RESET AND ZERO FILL EEPROM 24C64 **
*************************************/
void eeprom_24c64_reset()
{
     aee:	cf 93       	push	r28
     af0:	df 93       	push	r29
	unsigned int i;	// 16 bits
// EEPROM WRITE
	i2c_start();
     af2:	0e 94 84 06 	call	0xd08	; 0xd08 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     af6:	80 ea       	ldi	r24, 0xA0	; 160
     af8:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     afc:	80 e0       	ldi	r24, 0x00	; 0
     afe:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b02:	80 e0       	ldi	r24, 0x00	; 0
     b04:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
     b08:	cf ef       	ldi	r28, 0xFF	; 255
     b0a:	df e1       	ldi	r29, 0x1F	; 31
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
     b12:	21 97       	sbiw	r28, 0x01	; 1
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
     b14:	20 97       	sbiw	r28, 0x00	; 0
     b16:	d1 f7       	brne	.-12     	; 0xb0c <eeprom_24c64_reset+0x1e>
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
	}
	i2c_stop();
}
     b18:	df 91       	pop	r29
     b1a:	cf 91       	pop	r28
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
	}
	i2c_stop();
     b1c:	0c 94 8a 06 	jmp	0xd14	; 0xd14 <i2c_stop>

00000b20 <eeprom_24c64_write>:
// Za da se vijda tova koeto se e zapisalo v pametta, a ne ot tozi bibliotechen fail !!!!!!!!!
// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !

// EEPROM WRITE
	i2c_start();
     b20:	0e 94 84 06 	call	0xd08	; 0xd08 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     b24:	80 ea       	ldi	r24, 0xA0	; 160
     b26:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     b2a:	80 e0       	ldi	r24, 0x00	; 0
     b2c:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b30:	80 e0       	ldi	r24, 0x00	; 0
     b32:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
// Write data
	i2c_write(0x30);	// Data is stored: 0x30 - '0'
     b36:	80 e3       	ldi	r24, 0x30	; 48
     b38:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
	i2c_write(0x31);	// Data is stored: 0x31 - '1'
     b3c:	81 e3       	ldi	r24, 0x31	; 49
     b3e:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
	i2c_write(0x32);	// Data is stored: 0x32 - '2'
     b42:	82 e3       	ldi	r24, 0x32	; 50
     b44:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
	i2c_write(0x33);	// Data is stored: 0x33 - '3'
     b48:	83 e3       	ldi	r24, 0x33	; 51
     b4a:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
	i2c_write(0x34);	// Data is stored: 0x34 - '4'
     b4e:	84 e3       	ldi	r24, 0x34	; 52
     b50:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
	i2c_stop();
     b54:	0c 94 8a 06 	jmp	0xd14	; 0xd14 <i2c_stop>

00000b58 <eeprom_24c64_read>:
	// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
	// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !
	
	byte eepromReceiveByte0, eepromReceiveByte1, eepromReceiveByte2, eepromReceiveByte3, eepromReceiveByte4, eepromReceiveByte5;
// EEPROM READ
	i2c_start();
     b58:	0e 94 84 06 	call	0xd08	; 0xd08 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);		// EEPROM 24C64 ADDRESS ACCESS WRITE
     b5c:	80 ea       	ldi	r24, 0xA0	; 160
     b5e:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     b62:	80 e0       	ldi	r24, 0x00	; 0
     b64:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b68:	80 e0       	ldi	r24, 0x00	; 0
     b6a:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>

	i2c_start();
     b6e:	0e 94 84 06 	call	0xd08	; 0xd08 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_READ);		// EEPROM 24C64 ADDRESS ACCESS READ
     b72:	81 ea       	ldi	r24, 0xA1	; 161
     b74:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_write>
	eepromReceiveByte0	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b78:	80 e0       	ldi	r24, 0x00	; 0
     b7a:	0e 94 94 06 	call	0xd28	; 0xd28 <i2c_read>
	eepromReceiveByte1	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	0e 94 94 06 	call	0xd28	; 0xd28 <i2c_read>
	eepromReceiveByte2	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b84:	80 e0       	ldi	r24, 0x00	; 0
     b86:	0e 94 94 06 	call	0xd28	; 0xd28 <i2c_read>
	eepromReceiveByte3	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b8a:	80 e0       	ldi	r24, 0x00	; 0
     b8c:	0e 94 94 06 	call	0xd28	; 0xd28 <i2c_read>
	eepromReceiveByte4	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b90:	80 e0       	ldi	r24, 0x00	; 0
     b92:	0e 94 94 06 	call	0xd28	; 0xd28 <i2c_read>
	eepromReceiveByte5	= i2c_read(1);				// EEPROM DATA READ BYTE	// i2c_read(1) parametar razlichen ot 0 spira komunikaciqta NACK
     b96:	81 e0       	ldi	r24, 0x01	; 1
     b98:	0e 94 94 06 	call	0xd28	; 0xd28 <i2c_read>
	i2c_stop();
     b9c:	0c 94 8a 06 	jmp	0xd14	; 0xd14 <i2c_stop>

00000ba0 <reset>:
}
*/

unsigned char reset(void)
{
    DDRx |= (1<<Px);            //Ausgang
     ba0:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     ba2:	c0 98       	cbi	0x18, 0	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     ba4:	8f e7       	ldi	r24, 0x7F	; 127
     ba6:	97 e0       	ldi	r25, 0x07	; 7
     ba8:	01 97       	sbiw	r24, 0x01	; 1
     baa:	f1 f7       	brne	.-4      	; 0xba8 <reset+0x8>
     bac:	00 c0       	rjmp	.+0      	; 0xbae <reset+0xe>
     bae:	00 00       	nop
    _delay_us(480);
	DDRx &= ~(1<<Px);
     bb0:	b8 98       	cbi	0x17, 0	; 23
     bb2:	8f e3       	ldi	r24, 0x3F	; 63
     bb4:	91 e0       	ldi	r25, 0x01	; 1
     bb6:	01 97       	sbiw	r24, 0x01	; 1
     bb8:	f1 f7       	brne	.-4      	; 0xbb6 <reset+0x16>
     bba:	00 c0       	rjmp	.+0      	; 0xbbc <reset+0x1c>
     bbc:	00 00       	nop
    _delay_us(80);
	if(!(PINx & (1<<Px)))     //Prfe Slave-Antwort
     bbe:	b0 99       	sbic	0x16, 0	; 22
     bc0:	08 c0       	rjmp	.+16     	; 0xbd2 <reset+0x32>
     bc2:	87 e0       	ldi	r24, 0x07	; 7
     bc4:	97 e0       	ldi	r25, 0x07	; 7
     bc6:	01 97       	sbiw	r24, 0x01	; 1
     bc8:	f1 f7       	brne	.-4      	; 0xbc6 <reset+0x26>
     bca:	00 c0       	rjmp	.+0      	; 0xbcc <reset+0x2c>
     bcc:	00 00       	nop
	{	
		_delay_us(450);
        return 1;
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	08 95       	ret
	}
    else
	{
        return 0;
     bd2:	80 e0       	ldi	r24, 0x00	; 0
	}
}
     bd4:	08 95       	ret

00000bd6 <read_bit>:

unsigned char read_bit(void)
{
    DDRx |= (1<<Px);            //Ausgang
     bd6:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     bd8:	c0 98       	cbi	0x18, 0	; 24
     bda:	85 e0       	ldi	r24, 0x05	; 5
     bdc:	8a 95       	dec	r24
     bde:	f1 f7       	brne	.-4      	; 0xbdc <read_bit+0x6>
     be0:	00 00       	nop
    _delay_us(1);
	DDRx &= ~(1<<Px);
     be2:	b8 98       	cbi	0x17, 0	; 23
     be4:	80 e4       	ldi	r24, 0x40	; 64
     be6:	8a 95       	dec	r24
     be8:	f1 f7       	brne	.-4      	; 0xbe6 <read_bit+0x10>
    _delay_us(12);
    if(!(PINx & (1<<Px)))       //Abtastung innerhalb von 15s
     bea:	86 b3       	in	r24, 0x16	; 22
	}
	else
    {
		return 1;
	}
}
     bec:	81 70       	andi	r24, 0x01	; 1
     bee:	08 95       	ret

00000bf0 <write_bit>:

void write_bit(unsigned char bitval)    //kann 0 oder 1 sein
{
    DDRx |= (1<<Px);            //Ausgang
     bf0:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     bf2:	c0 98       	cbi	0x18, 0	; 24
    if(bitval)
     bf4:	81 11       	cpse	r24, r1
	{
        PORTx |= (1<<Px);      //H-Pegel
     bf6:	c0 9a       	sbi	0x18, 0	; 24
     bf8:	87 eb       	ldi	r24, 0xB7	; 183
     bfa:	91 e0       	ldi	r25, 0x01	; 1
     bfc:	01 97       	sbiw	r24, 0x01	; 1
     bfe:	f1 f7       	brne	.-4      	; 0xbfc <write_bit+0xc>
     c00:	00 c0       	rjmp	.+0      	; 0xc02 <write_bit+0x12>
     c02:	00 00       	nop
    }
	_delay_us(110);        
    DDRx &= ~(1<<Px);
     c04:	b8 98       	cbi	0x17, 0	; 23
    PORTx &= ~(1<<Px);
     c06:	c0 98       	cbi	0x18, 0	; 24
     c08:	08 95       	ret

00000c0a <read_byte>:
}

unsigned char read_byte(void)
{
     c0a:	ff 92       	push	r15
     c0c:	0f 93       	push	r16
     c0e:	1f 93       	push	r17
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	c0 e0       	ldi	r28, 0x00	; 0
     c16:	d0 e0       	ldi	r29, 0x00	; 0
    unsigned char byte = 0;
     c18:	f1 2c       	mov	r15, r1
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
		{
            byte |= (1<<i);
     c1a:	01 e0       	ldi	r16, 0x01	; 1
     c1c:	10 e0       	ldi	r17, 0x00	; 0
unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
     c1e:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <read_bit>
     c22:	88 23       	and	r24, r24
     c24:	39 f0       	breq	.+14     	; 0xc34 <read_byte+0x2a>
		{
            byte |= (1<<i);
     c26:	98 01       	movw	r18, r16
     c28:	0c 2e       	mov	r0, r28
     c2a:	01 c0       	rjmp	.+2      	; 0xc2e <read_byte+0x24>
     c2c:	22 0f       	add	r18, r18
     c2e:	0a 94       	dec	r0
     c30:	ea f7       	brpl	.-6      	; 0xc2c <read_byte+0x22>
     c32:	f2 2a       	or	r15, r18
     c34:	8f ed       	ldi	r24, 0xDF	; 223
     c36:	91 e0       	ldi	r25, 0x01	; 1
     c38:	01 97       	sbiw	r24, 0x01	; 1
     c3a:	f1 f7       	brne	.-4      	; 0xc38 <read_byte+0x2e>
     c3c:	00 c0       	rjmp	.+0      	; 0xc3e <read_byte+0x34>
     c3e:	00 00       	nop
     c40:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
     c42:	c8 30       	cpi	r28, 0x08	; 8
     c44:	d1 05       	cpc	r29, r1
     c46:	59 f7       	brne	.-42     	; 0xc1e <read_byte+0x14>
            byte |= (1<<i);
		}
        _delay_us(120);
    }
    return byte;
}
     c48:	8f 2d       	mov	r24, r15
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	1f 91       	pop	r17
     c50:	0f 91       	pop	r16
     c52:	ff 90       	pop	r15
     c54:	08 95       	ret

00000c56 <write_byte>:

void write_byte(unsigned char byte)
{
     c56:	0f 93       	push	r16
     c58:	1f 93       	push	r17
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
     c5e:	c0 e0       	ldi	r28, 0x00	; 0
     c60:	d0 e0       	ldi	r29, 0x00	; 0
    for(unsigned char i=0; i<8; i++)
	{
        if(byte & (1<<i))
     c62:	08 2f       	mov	r16, r24
     c64:	10 e0       	ldi	r17, 0x00	; 0
     c66:	c8 01       	movw	r24, r16
     c68:	0c 2e       	mov	r0, r28
     c6a:	02 c0       	rjmp	.+4      	; 0xc70 <write_byte+0x1a>
     c6c:	95 95       	asr	r25
     c6e:	87 95       	ror	r24
     c70:	0a 94       	dec	r0
     c72:	e2 f7       	brpl	.-8      	; 0xc6c <write_byte+0x16>
     c74:	80 ff       	sbrs	r24, 0
     c76:	02 c0       	rjmp	.+4      	; 0xc7c <write_byte+0x26>
		{
			write_bit(1);
     c78:	81 e0       	ldi	r24, 0x01	; 1
     c7a:	01 c0       	rjmp	.+2      	; 0xc7e <write_byte+0x28>
		}
        else
		{
            write_bit(0);
     c7c:	80 e0       	ldi	r24, 0x00	; 0
     c7e:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <write_bit>
     c82:	21 96       	adiw	r28, 0x01	; 1
    return byte;
}

void write_byte(unsigned char byte)
{
    for(unsigned char i=0; i<8; i++)
     c84:	c8 30       	cpi	r28, 0x08	; 8
     c86:	d1 05       	cpc	r29, r1
     c88:	71 f7       	brne	.-36     	; 0xc66 <write_byte+0x10>
     c8a:	8f ed       	ldi	r24, 0xDF	; 223
     c8c:	91 e0       	ldi	r25, 0x01	; 1
     c8e:	01 97       	sbiw	r24, 0x01	; 1
     c90:	f1 f7       	brne	.-4      	; 0xc8e <write_byte+0x38>
     c92:	00 c0       	rjmp	.+0      	; 0xc94 <write_byte+0x3e>
     c94:	00 00       	nop
		{
            write_bit(0);
		}
	}
    _delay_us(120);
}  
     c96:	df 91       	pop	r29
     c98:	cf 91       	pop	r28
     c9a:	1f 91       	pop	r17
     c9c:	0f 91       	pop	r16
     c9e:	08 95       	ret

00000ca0 <wait_ready>:
	return 0;
}

void wait_ready(void)
{
	while(!(read_bit()));
     ca0:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <read_bit>
     ca4:	88 23       	and	r24, r24
     ca6:	e1 f3       	breq	.-8      	; 0xca0 <wait_ready>
}
     ca8:	08 95       	ret

00000caa <read_scratchpad>:
	}
    _delay_us(120);
}  

unsigned char read_scratchpad(void)
{
     caa:	cf 93       	push	r28
     cac:	df 93       	push	r29

	if(reset())
     cae:	0e 94 d0 05 	call	0xba0	; 0xba0 <reset>
     cb2:	81 11       	cpse	r24, r1
     cb4:	02 c0       	rjmp	.+4      	; 0xcba <read_scratchpad+0x10>
				scratchpad [i] = read_byte();
			}
			return 1;
		}
	}
	return 0;
     cb6:	80 e0       	ldi	r24, 0x00	; 0
     cb8:	1c c0       	rjmp	.+56     	; 0xcf2 <read_scratchpad+0x48>
unsigned char read_scratchpad(void)
{

	if(reset())
	{
		write_byte(0xCC);
     cba:	8c ec       	ldi	r24, 0xCC	; 204
     cbc:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
		write_byte(0x44);
     cc0:	84 e4       	ldi	r24, 0x44	; 68
     cc2:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
		wait_ready();
     cc6:	0e 94 50 06 	call	0xca0	; 0xca0 <wait_ready>
		if(reset())
     cca:	0e 94 d0 05 	call	0xba0	; 0xba0 <reset>
     cce:	88 23       	and	r24, r24
     cd0:	91 f3       	breq	.-28     	; 0xcb6 <read_scratchpad+0xc>
		{
			write_byte(0xCC);
     cd2:	8c ec       	ldi	r24, 0xCC	; 204
     cd4:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
			write_byte(0xBE);
     cd8:	8e eb       	ldi	r24, 0xBE	; 190
     cda:	0e 94 2b 06 	call	0xc56	; 0xc56 <write_byte>
     cde:	c5 e8       	ldi	r28, 0x85	; 133
     ce0:	d5 e0       	ldi	r29, 0x05	; 5
			for(unsigned char i=0; i<9; i++)
			{
				scratchpad [i] = read_byte();
     ce2:	0e 94 05 06 	call	0xc0a	; 0xc0a <read_byte>
     ce6:	89 93       	st	Y+, r24
		wait_ready();
		if(reset())
		{
			write_byte(0xCC);
			write_byte(0xBE);
			for(unsigned char i=0; i<9; i++)
     ce8:	85 e0       	ldi	r24, 0x05	; 5
     cea:	ce 38       	cpi	r28, 0x8E	; 142
     cec:	d8 07       	cpc	r29, r24
     cee:	c9 f7       	brne	.-14     	; 0xce2 <read_scratchpad+0x38>
			{
				scratchpad [i] = read_byte();
			}
			return 1;
     cf0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	return 0;
}
     cf2:	df 91       	pop	r29
     cf4:	cf 91       	pop	r28
     cf6:	08 95       	ret

00000cf8 <i2c_init>:
|== TWPS = 1 => (4^TWPS)= 4  // TWSR = (0<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx01 => TWSR = 1 (DEC) => 4^1 =  4 =|
|== TWPS = 2 => (4^TWPS)=16  // TWSR = (1<<TWPS1)|(0<<TWPS0) => TWSR = 0bxxxxxx10 => TWSR = 2 (DEC) => 4^2 = 16 =|
|== TWPS = 3 => (4^TWPS)=64  // TWSR = (1<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx11 => TWSR = 3 (DEC) => 4^3 = 64 =|
|===============================================================================================================*/

	TWBR = 0b00010010;	// HEX=0x12	or DEC=18	// FCPU = 16 000 000 |-> SCL = 16000000 / (16+(2*TWBR*(4^TWPS)) = 16000000 / (16+(2*18*(4))) = 16000000 / 160 = 100 000 Hz = 100 kHz
     cf8:	82 e1       	ldi	r24, 0x12	; 18
     cfa:	80 b9       	out	0x00, r24	; 0
	TWSR = (0<<TWPS1)|(1<<TWPS0);	// SCL = 16 000 000 / 64  = 250 000 = 250kHz
     cfc:	81 e0       	ldi	r24, 0x01	; 1
     cfe:	81 b9       	out	0x01, r24	; 1
	TWCR = (1<<TWEN);	//	TWCR = 0x04; // TWCR = (x<<TWINT)|(x<<TWEA)|(x<<TWSTA)|(x<<TWSTO)|(x<<TWEN)|(x<<TWIE);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz
     d00:	84 e0       	ldi	r24, 0x04	; 4
     d02:	86 bf       	out	0x36, r24	; 54
	TWDR = 0b00000000;
     d04:	13 b8       	out	0x03, r1	; 3
     d06:	08 95       	ret

00000d08 <i2c_start>:
/*****************************************
** START CONDITION OF I2C COMMUNICATION **
*****************************************/
void i2c_start(void)
{
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     d08:	84 ea       	ldi	r24, 0xA4	; 164
     d0a:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     d0c:	06 b6       	in	r0, 0x36	; 54
     d0e:	07 fe       	sbrs	r0, 7
     d10:	fd cf       	rjmp	.-6      	; 0xd0c <i2c_start+0x4>
	{
	}
}
     d12:	08 95       	ret

00000d14 <i2c_stop>:
/****************************************
** STOP CONDITION OF I2C COMMUNICATION **
****************************************/
void i2c_stop()
{
	TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     d14:	84 e9       	ldi	r24, 0x94	; 148
     d16:	86 bf       	out	0x36, r24	; 54
     d18:	08 95       	ret

00000d1a <i2c_write>:
/*******************************************
** WRITE/SEND 1 BYTE OF I2C COMMUNICATION **
*******************************************/
void i2c_write(unsigned char data)
{
	TWDR = data;
     d1a:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT)|(1<<TWEN);
     d1c:	84 e8       	ldi	r24, 0x84	; 132
     d1e:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     d20:	06 b6       	in	r0, 0x36	; 54
     d22:	07 fe       	sbrs	r0, 7
     d24:	fd cf       	rjmp	.-6      	; 0xd20 <i2c_write+0x6>
	{
	}
}
     d26:	08 95       	ret

00000d28 <i2c_read>:
/**********************************************
** READ/RECEIVE BYTE(S) OF I2C COMMUNICATION **
**********************************************/
unsigned char i2c_read(unsigned char isLast)
{
	if(isLast == 0 )
     d28:	81 11       	cpse	r24, r1
     d2a:	02 c0       	rjmp	.+4      	; 0xd30 <i2c_read+0x8>
	{
		TWCR = (1<<TWINT)|(1<<TWEA)|(1<<TWEN);	// to next receive byte
     d2c:	84 ec       	ldi	r24, 0xC4	; 196
     d2e:	01 c0       	rjmp	.+2      	; 0xd32 <i2c_read+0xa>
	}
	else
	{
		TWCR = (1<<TWINT)|(1<<TWEN);			// to end of communication
     d30:	84 e8       	ldi	r24, 0x84	; 132
     d32:	86 bf       	out	0x36, r24	; 54
	}
	
	while((TWCR & (1<<TWINT)) == 0)
     d34:	06 b6       	in	r0, 0x36	; 54
     d36:	07 fe       	sbrs	r0, 7
     d38:	fd cf       	rjmp	.-6      	; 0xd34 <i2c_read+0xc>
	{
	}
	return TWDR;
     d3a:	83 b1       	in	r24, 0x03	; 3
}
     d3c:	08 95       	ret

00000d3e <LCD_EXECUTE_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_EXECUTE_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     d3e:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     d40:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     d42:	87 ff       	sbrs	r24, 7
     d44:	02 c0       	rjmp	.+4      	; 0xd4a <LCD_EXECUTE_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     d46:	d8 9a       	sbi	0x1b, 0	; 27
     d48:	01 c0       	rjmp	.+2      	; 0xd4c <LCD_EXECUTE_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     d4a:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     d4c:	d9 9a       	sbi	0x1b, 1	; 27

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     d4e:	88 0f       	add	r24, r24
     d50:	91 50       	subi	r25, 0x01	; 1
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     d52:	b1 f7       	brne	.-20     	; 0xd40 <LCD_EXECUTE_COMMAND+0x2>
		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     d54:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     d56:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     d58:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     d5a:	da 98       	cbi	0x1b, 2	; 27
     d5c:	87 ea       	ldi	r24, 0xA7	; 167
     d5e:	92 e0       	ldi	r25, 0x02	; 2
     d60:	01 97       	sbiw	r24, 0x01	; 1
     d62:	f1 f7       	brne	.-4      	; 0xd60 <LCD_EXECUTE_COMMAND+0x22>
     d64:	00 c0       	rjmp	.+0      	; 0xd66 <LCD_EXECUTE_COMMAND+0x28>
     d66:	00 00       	nop
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     d68:	da 9a       	sbi	0x1b, 2	; 27
     d6a:	87 ea       	ldi	r24, 0xA7	; 167
     d6c:	92 e0       	ldi	r25, 0x02	; 2
     d6e:	01 97       	sbiw	r24, 0x01	; 1
     d70:	f1 f7       	brne	.-4      	; 0xd6e <LCD_EXECUTE_COMMAND+0x30>
     d72:	00 c0       	rjmp	.+0      	; 0xd74 <LCD_EXECUTE_COMMAND+0x36>
     d74:	00 00       	nop
	LCD_REGSELECT_low();	// RS = 0
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);			//rcall 180 us
*/
	LCD_ENABLE_low();		// EN = 0
     d76:	db 98       	cbi	0x1b, 3	; 27
     d78:	8f e8       	ldi	r24, 0x8F	; 143
     d7a:	91 e0       	ldi	r25, 0x01	; 1
     d7c:	01 97       	sbiw	r24, 0x01	; 1
     d7e:	f1 f7       	brne	.-4      	; 0xd7c <LCD_EXECUTE_COMMAND+0x3e>
     d80:	00 c0       	rjmp	.+0      	; 0xd82 <LCD_EXECUTE_COMMAND+0x44>
     d82:	00 00       	nop
     d84:	08 95       	ret

00000d86 <LCD_EXECUTE_DATA>:
/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
     d86:	fc 01       	movw	r30, r24
     d88:	9f 01       	movw	r18, r30
     d8a:	28 1b       	sub	r18, r24
     d8c:	39 0b       	sbc	r19, r25
     d8e:	26 17       	cp	r18, r22
     d90:	37 07       	cpc	r19, r23
     d92:	2c f5       	brge	.+74     	; 0xdde <LCD_EXECUTE_DATA+0x58>
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];
     d94:	31 91       	ld	r19, Z+
     d96:	28 e0       	ldi	r18, 0x08	; 8

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     d98:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     d9a:	37 ff       	sbrs	r19, 7
     d9c:	02 c0       	rjmp	.+4      	; 0xda2 <LCD_EXECUTE_DATA+0x1c>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     d9e:	d8 9a       	sbi	0x1b, 0	; 27
     da0:	01 c0       	rjmp	.+2      	; 0xda4 <LCD_EXECUTE_DATA+0x1e>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     da2:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     da4:	d9 9a       	sbi	0x1b, 1	; 27

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     da6:	33 0f       	add	r19, r19
     da8:	21 50       	subi	r18, 0x01	; 1
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     daa:	b1 f7       	brne	.-20     	; 0xd98 <LCD_EXECUTE_DATA+0x12>
			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     dac:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     dae:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     db0:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     db2:	da 98       	cbi	0x1b, 2	; 27
     db4:	a7 ea       	ldi	r26, 0xA7	; 167
     db6:	b2 e0       	ldi	r27, 0x02	; 2
     db8:	11 97       	sbiw	r26, 0x01	; 1
     dba:	f1 f7       	brne	.-4      	; 0xdb8 <LCD_EXECUTE_DATA+0x32>
     dbc:	00 c0       	rjmp	.+0      	; 0xdbe <LCD_EXECUTE_DATA+0x38>
     dbe:	00 00       	nop
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     dc0:	da 9a       	sbi	0x1b, 2	; 27
     dc2:	a7 ea       	ldi	r26, 0xA7	; 167
     dc4:	b2 e0       	ldi	r27, 0x02	; 2
     dc6:	11 97       	sbiw	r26, 0x01	; 1
     dc8:	f1 f7       	brne	.-4      	; 0xdc6 <LCD_EXECUTE_DATA+0x40>
     dca:	00 c0       	rjmp	.+0      	; 0xdcc <LCD_EXECUTE_DATA+0x46>
     dcc:	00 00       	nop
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     dce:	db 98       	cbi	0x1b, 3	; 27
     dd0:	af e8       	ldi	r26, 0x8F	; 143
     dd2:	b1 e0       	ldi	r27, 0x01	; 1
     dd4:	11 97       	sbiw	r26, 0x01	; 1
     dd6:	f1 f7       	brne	.-4      	; 0xdd4 <LCD_EXECUTE_DATA+0x4e>
     dd8:	00 c0       	rjmp	.+0      	; 0xdda <LCD_EXECUTE_DATA+0x54>
     dda:	00 00       	nop
     ddc:	d5 cf       	rjmp	.-86     	; 0xd88 <LCD_EXECUTE_DATA+0x2>
		_delay_us(100);
	}

//	LCD_EXECUTE_DATA_LAST();	// flush -> posleden simvol ili gore v cikala count_ns < numsymbols+1 ili count_ns <= numsymbols
}
     dde:	08 95       	ret

00000de0 <LCD_EXECUTE_DATA_ONE>:

/************************************************
** WRITE/TRANSMIT ONE DATA BYTE TO LCD DISPLAY **
************************************************/
void LCD_EXECUTE_DATA_ONE(unsigned char data)	// HELP: LCD_EXECUTE_DATA(unsigned char data_byte_symbols) // LCD shift left out, msb is first
{
     de0:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     de2:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     de4:	87 ff       	sbrs	r24, 7
     de6:	02 c0       	rjmp	.+4      	; 0xdec <LCD_EXECUTE_DATA_ONE+0xc>
		{
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     de8:	d8 9a       	sbi	0x1b, 0	; 27
     dea:	01 c0       	rjmp	.+2      	; 0xdee <LCD_EXECUTE_DATA_ONE+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     dec:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     dee:	d9 9a       	sbi	0x1b, 1	; 27

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     df0:	88 0f       	add	r24, r24
     df2:	91 50       	subi	r25, 0x01	; 1
{
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     df4:	b1 f7       	brne	.-20     	; 0xde2 <LCD_EXECUTE_DATA_ONE+0x2>
		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
	}
//update from down comment
	LCD_REGSELECT_high();	// RS = 1
     df6:	dd 9a       	sbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     df8:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     dfa:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment

	LCD_RCK_low();
     dfc:	da 98       	cbi	0x1b, 2	; 27
     dfe:	87 ea       	ldi	r24, 0xA7	; 167
     e00:	92 e0       	ldi	r25, 0x02	; 2
     e02:	01 97       	sbiw	r24, 0x01	; 1
     e04:	f1 f7       	brne	.-4      	; 0xe02 <LCD_EXECUTE_DATA_ONE+0x22>
     e06:	00 c0       	rjmp	.+0      	; 0xe08 <LCD_EXECUTE_DATA_ONE+0x28>
     e08:	00 00       	nop
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     e0a:	da 9a       	sbi	0x1b, 2	; 27
     e0c:	87 ea       	ldi	r24, 0xA7	; 167
     e0e:	92 e0       	ldi	r25, 0x02	; 2
     e10:	01 97       	sbiw	r24, 0x01	; 1
     e12:	f1 f7       	brne	.-4      	; 0xe10 <LCD_EXECUTE_DATA_ONE+0x30>
     e14:	00 c0       	rjmp	.+0      	; 0xe16 <LCD_EXECUTE_DATA_ONE+0x36>
     e16:	00 00       	nop
	LCD_REGSELECT_high();	// RS = 1
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);
*/
	LCD_ENABLE_low();		// EN = 0
     e18:	db 98       	cbi	0x1b, 3	; 27
     e1a:	8f e8       	ldi	r24, 0x8F	; 143
     e1c:	91 e0       	ldi	r25, 0x01	; 1
     e1e:	01 97       	sbiw	r24, 0x01	; 1
     e20:	f1 f7       	brne	.-4      	; 0xe1e <LCD_EXECUTE_DATA_ONE+0x3e>
     e22:	00 c0       	rjmp	.+0      	; 0xe24 <LCD_EXECUTE_DATA_ONE+0x44>
     e24:	00 00       	nop
     e26:	08 95       	ret

00000e28 <LCD_EXECUTE_DATA_LAST>:
/*****************************************************************************
** WRITE/TRANSMIT LAST DATA BYTE TO LCD DISPLAY AND FLUSH SN74HC595 BUFFER  **
*****************************************************************************/
void LCD_EXECUTE_DATA_LAST()	// flush -> izchistvane na bufer - prinuditelno izpisvane na posleden simvol
{
	LCD_ENABLE_low();
     e28:	db 98       	cbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     e2a:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     e2c:	dd 9a       	sbi	0x1b, 5	; 27
     e2e:	85 ed       	ldi	r24, 0xD5	; 213
     e30:	8a 95       	dec	r24
     e32:	f1 f7       	brne	.-4      	; 0xe30 <LCD_EXECUTE_DATA_LAST+0x8>
     e34:	00 00       	nop
	_delay_us(40);				// from 100 or 180 //rcall 180 us
	LCD_ENABLE_high();
     e36:	db 9a       	sbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     e38:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     e3a:	dd 9a       	sbi	0x1b, 5	; 27
     e3c:	85 ed       	ldi	r24, 0xD5	; 213
     e3e:	8a 95       	dec	r24
     e40:	f1 f7       	brne	.-4      	; 0xe3e <LCD_EXECUTE_DATA_LAST+0x16>
     e42:	00 00       	nop
     e44:	08 95       	ret

00000e46 <LCD_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     e46:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     e48:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     e4a:	87 ff       	sbrs	r24, 7
     e4c:	02 c0       	rjmp	.+4      	; 0xe52 <LCD_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     e4e:	d8 9a       	sbi	0x1b, 0	; 27
     e50:	01 c0       	rjmp	.+2      	; 0xe54 <LCD_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     e52:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     e54:	d9 9a       	sbi	0x1b, 1	; 27

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     e56:	88 0f       	add	r24, r24
     e58:	91 50       	subi	r25, 0x01	; 1
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     e5a:	b1 f7       	brne	.-20     	; 0xe48 <LCD_COMMAND+0x2>
		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     e5c:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     e5e:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     e60:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     e62:	da 98       	cbi	0x1b, 2	; 27
     e64:	87 ea       	ldi	r24, 0xA7	; 167
     e66:	92 e0       	ldi	r25, 0x02	; 2
     e68:	01 97       	sbiw	r24, 0x01	; 1
     e6a:	f1 f7       	brne	.-4      	; 0xe68 <LCD_COMMAND+0x22>
     e6c:	00 c0       	rjmp	.+0      	; 0xe6e <LCD_COMMAND+0x28>
     e6e:	00 00       	nop
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     e70:	da 9a       	sbi	0x1b, 2	; 27
     e72:	87 ea       	ldi	r24, 0xA7	; 167
     e74:	92 e0       	ldi	r25, 0x02	; 2
     e76:	01 97       	sbiw	r24, 0x01	; 1
     e78:	f1 f7       	brne	.-4      	; 0xe76 <LCD_COMMAND+0x30>
     e7a:	00 c0       	rjmp	.+0      	; 0xe7c <LCD_COMMAND+0x36>
     e7c:	00 00       	nop
	_delay_us(170);			//rcall 180 us

	LCD_ENABLE_low();		// EN = 0
     e7e:	db 98       	cbi	0x1b, 3	; 27
     e80:	8f e8       	ldi	r24, 0x8F	; 143
     e82:	91 e0       	ldi	r25, 0x01	; 1
     e84:	01 97       	sbiw	r24, 0x01	; 1
     e86:	f1 f7       	brne	.-4      	; 0xe84 <LCD_COMMAND+0x3e>
     e88:	00 c0       	rjmp	.+0      	; 0xe8a <LCD_COMMAND+0x44>
     e8a:	00 00       	nop
     e8c:	08 95       	ret

00000e8e <LCD_INIT>:
/**********************************
** INITIZLIZATION OF LCD DISPLAY **
**********************************/
void LCD_INIT()
{
	LCD_COMMAND(LCD_8BIT_2ROWS_FONT5X7);		// 0b00111000	// 1. Function set: 8-bit interface data (DL = 1), 2-line display (N = 1), 5 x 7 dot character font (F = 0)
     e8e:	88 e3       	ldi	r24, 0x38	; 56
     e90:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_ENTRY_MODE_INC_NOSHIFT);	// 0b00000110	// 2. Entry mode set: Increment by 1 (I/D = 1), No shift (S = 0)
     e94:	86 e0       	ldi	r24, 0x06	; 6
     e96:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_MOVE_FIRST);								// 3.
     e9a:	82 e0       	ldi	r24, 0x02	; 2
     e9c:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 4. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     ea0:	81 e0       	ldi	r24, 0x01	; 1
     ea2:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
     ea6:	8f eb       	ldi	r24, 0xBF	; 191
     ea8:	92 e1       	ldi	r25, 0x12	; 18
     eaa:	01 97       	sbiw	r24, 0x01	; 1
     eac:	f1 f7       	brne	.-4      	; 0xeaa <LCD_INIT+0x1c>
     eae:	00 c0       	rjmp	.+0      	; 0xeb0 <LCD_INIT+0x22>
     eb0:	00 00       	nop
     eb2:	08 95       	ret

00000eb4 <LCD_CLEAR_CONTAIN>:
/**************************************
** CLEAR ALL CONTAINS ON LCD DISPLAY **
**************************************/
void LCD_CLEAR_CONTAIN()
{
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 1. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     eb4:	81 e0       	ldi	r24, 0x01	; 1
     eb6:	0e 94 23 07 	call	0xe46	; 0xe46 <LCD_COMMAND>
     eba:	8f eb       	ldi	r24, 0xBF	; 191
     ebc:	92 e1       	ldi	r25, 0x12	; 18
     ebe:	01 97       	sbiw	r24, 0x01	; 1
     ec0:	f1 f7       	brne	.-4      	; 0xebe <LCD_CLEAR_CONTAIN+0xa>
     ec2:	00 c0       	rjmp	.+0      	; 0xec4 <LCD_CLEAR_CONTAIN+0x10>
     ec4:	00 00       	nop
     ec6:	08 95       	ret

00000ec8 <LCD_DATA_STRING>:
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     ec8:	fc 01       	movw	r30, r24
     eca:	21 91       	ld	r18, Z+
     ecc:	cf 01       	movw	r24, r30
     ece:	22 23       	and	r18, r18
     ed0:	21 f1       	breq	.+72     	; 0xf1a <LCD_DATA_STRING+0x52>
     ed2:	38 e0       	ldi	r19, 0x08	; 8
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     ed4:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     ed6:	27 ff       	sbrs	r18, 7
     ed8:	02 c0       	rjmp	.+4      	; 0xede <LCD_DATA_STRING+0x16>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     eda:	d8 9a       	sbi	0x1b, 0	; 27
     edc:	01 c0       	rjmp	.+2      	; 0xee0 <LCD_DATA_STRING+0x18>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     ede:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     ee0:	d9 9a       	sbi	0x1b, 1	; 27

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     ee2:	22 0f       	add	r18, r18
     ee4:	31 50       	subi	r19, 0x01	; 1
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     ee6:	b1 f7       	brne	.-20     	; 0xed4 <LCD_DATA_STRING+0xc>
			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     ee8:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     eea:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     eec:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     eee:	da 98       	cbi	0x1b, 2	; 27
     ef0:	e7 ea       	ldi	r30, 0xA7	; 167
     ef2:	f2 e0       	ldi	r31, 0x02	; 2
     ef4:	31 97       	sbiw	r30, 0x01	; 1
     ef6:	f1 f7       	brne	.-4      	; 0xef4 <LCD_DATA_STRING+0x2c>
     ef8:	00 c0       	rjmp	.+0      	; 0xefa <LCD_DATA_STRING+0x32>
     efa:	00 00       	nop
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     efc:	da 9a       	sbi	0x1b, 2	; 27
     efe:	e7 ea       	ldi	r30, 0xA7	; 167
     f00:	f2 e0       	ldi	r31, 0x02	; 2
     f02:	31 97       	sbiw	r30, 0x01	; 1
     f04:	f1 f7       	brne	.-4      	; 0xf02 <LCD_DATA_STRING+0x3a>
     f06:	00 c0       	rjmp	.+0      	; 0xf08 <LCD_DATA_STRING+0x40>
     f08:	00 00       	nop
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     f0a:	db 98       	cbi	0x1b, 3	; 27
     f0c:	ef e8       	ldi	r30, 0x8F	; 143
     f0e:	f1 e0       	ldi	r31, 0x01	; 1
     f10:	31 97       	sbiw	r30, 0x01	; 1
     f12:	f1 f7       	brne	.-4      	; 0xf10 <LCD_DATA_STRING+0x48>
     f14:	00 c0       	rjmp	.+0      	; 0xf16 <LCD_DATA_STRING+0x4e>
     f16:	00 00       	nop
     f18:	d7 cf       	rjmp	.-82     	; 0xec8 <LCD_DATA_STRING>
		_delay_us(100);
	}
}
     f1a:	08 95       	ret

00000f1c <LCD_DATA_UINT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataUInt( (unsigned int)k + 1 );
void LCD_DATA_UINT(unsigned int data)		// void lcdDataUInt(const unsigned int data)
{
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	cd b7       	in	r28, 0x3d	; 61
     f22:	de b7       	in	r29, 0x3e	; 62
     f24:	2a 97       	sbiw	r28, 0x0a	; 10
     f26:	0f b6       	in	r0, 0x3f	; 63
     f28:	f8 94       	cli
     f2a:	de bf       	out	0x3e, r29	; 62
     f2c:	0f be       	out	0x3f, r0	; 63
     f2e:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(utoa(data, buffer, 10));	// 10 -> DECIMAL
     f30:	4a e0       	ldi	r20, 0x0A	; 10
     f32:	50 e0       	ldi	r21, 0x00	; 0
     f34:	be 01       	movw	r22, r28
     f36:	6f 5f       	subi	r22, 0xFF	; 255
     f38:	7f 4f       	sbci	r23, 0xFF	; 255
     f3a:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <utoa>
     f3e:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
}
     f42:	2a 96       	adiw	r28, 0x0a	; 10
     f44:	0f b6       	in	r0, 0x3f	; 63
     f46:	f8 94       	cli
     f48:	de bf       	out	0x3e, r29	; 62
     f4a:	0f be       	out	0x3f, r0	; 63
     f4c:	cd bf       	out	0x3d, r28	; 61
     f4e:	df 91       	pop	r29
     f50:	cf 91       	pop	r28
     f52:	08 95       	ret

00000f54 <LCD_DATA_INT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataInt( (int)k + 1 );
void LCD_DATA_INT(int data)		// void lcdDataInt(const int data)
{
     f54:	cf 93       	push	r28
     f56:	df 93       	push	r29
     f58:	cd b7       	in	r28, 0x3d	; 61
     f5a:	de b7       	in	r29, 0x3e	; 62
     f5c:	2a 97       	sbiw	r28, 0x0a	; 10
     f5e:	0f b6       	in	r0, 0x3f	; 63
     f60:	f8 94       	cli
     f62:	de bf       	out	0x3e, r29	; 62
     f64:	0f be       	out	0x3f, r0	; 63
     f66:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(itoa(data, buffer, 10));	// 10 -> DECIMAL
     f68:	4a e0       	ldi	r20, 0x0A	; 10
     f6a:	50 e0       	ldi	r21, 0x00	; 0
     f6c:	be 01       	movw	r22, r28
     f6e:	6f 5f       	subi	r22, 0xFF	; 255
     f70:	7f 4f       	sbci	r23, 0xFF	; 255
     f72:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <itoa>
     f76:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
}
     f7a:	2a 96       	adiw	r28, 0x0a	; 10
     f7c:	0f b6       	in	r0, 0x3f	; 63
     f7e:	f8 94       	cli
     f80:	de bf       	out	0x3e, r29	; 62
     f82:	0f be       	out	0x3f, r0	; 63
     f84:	cd bf       	out	0x3d, r28	; 61
     f86:	df 91       	pop	r29
     f88:	cf 91       	pop	r28
     f8a:	08 95       	ret

00000f8c <LCD_DATA_LONG>:
/*******************************************************
** WRITE/TRANSMIT MORE DATA LONG BYTES TO LCD DISPLAY **
*******************************************************/
// USE THIS: lcdDataLong( (long)k + 1 );
void LCD_DATA_LONG(long data)		// void lcdDataLong(const long data)
{
     f8c:	cf 93       	push	r28
     f8e:	df 93       	push	r29
     f90:	cd b7       	in	r28, 0x3d	; 61
     f92:	de b7       	in	r29, 0x3e	; 62
     f94:	2a 97       	sbiw	r28, 0x0a	; 10
     f96:	0f b6       	in	r0, 0x3f	; 63
     f98:	f8 94       	cli
     f9a:	de bf       	out	0x3e, r29	; 62
     f9c:	0f be       	out	0x3f, r0	; 63
     f9e:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ltoa(data, buffer, 10));	// 10 -> DECIMAL
     fa0:	2a e0       	ldi	r18, 0x0A	; 10
     fa2:	30 e0       	ldi	r19, 0x00	; 0
     fa4:	ae 01       	movw	r20, r28
     fa6:	4f 5f       	subi	r20, 0xFF	; 255
     fa8:	5f 4f       	sbci	r21, 0xFF	; 255
     faa:	0e 94 04 0c 	call	0x1808	; 0x1808 <ltoa>
     fae:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
}
     fb2:	2a 96       	adiw	r28, 0x0a	; 10
     fb4:	0f b6       	in	r0, 0x3f	; 63
     fb6:	f8 94       	cli
     fb8:	de bf       	out	0x3e, r29	; 62
     fba:	0f be       	out	0x3f, r0	; 63
     fbc:	cd bf       	out	0x3d, r28	; 61
     fbe:	df 91       	pop	r29
     fc0:	cf 91       	pop	r28
     fc2:	08 95       	ret

00000fc4 <LCD_DATA_ULONG>:
/****************************************************************
** WRITE/TRANSMIT MORE DATA UNSIGNED LONG BYTES TO LCD DISPLAY **
****************************************************************/
// USE THIS: lcdDataULong( (unsigned long)k + 1 );
void LCD_DATA_ULONG(unsigned long data)		// void lcdDataULong(const unsigned long data)
{
     fc4:	cf 93       	push	r28
     fc6:	df 93       	push	r29
     fc8:	cd b7       	in	r28, 0x3d	; 61
     fca:	de b7       	in	r29, 0x3e	; 62
     fcc:	2a 97       	sbiw	r28, 0x0a	; 10
     fce:	0f b6       	in	r0, 0x3f	; 63
     fd0:	f8 94       	cli
     fd2:	de bf       	out	0x3e, r29	; 62
     fd4:	0f be       	out	0x3f, r0	; 63
     fd6:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ultoa(data, buffer, 10));	// 10 -> DECIMAL
     fd8:	2a e0       	ldi	r18, 0x0A	; 10
     fda:	30 e0       	ldi	r19, 0x00	; 0
     fdc:	ae 01       	movw	r20, r28
     fde:	4f 5f       	subi	r20, 0xFF	; 255
     fe0:	5f 4f       	sbci	r21, 0xFF	; 255
     fe2:	0e 94 38 0c 	call	0x1870	; 0x1870 <ultoa>
     fe6:	0e 94 64 07 	call	0xec8	; 0xec8 <LCD_DATA_STRING>
}
     fea:	2a 96       	adiw	r28, 0x0a	; 10
     fec:	0f b6       	in	r0, 0x3f	; 63
     fee:	f8 94       	cli
     ff0:	de bf       	out	0x3e, r29	; 62
     ff2:	0f be       	out	0x3f, r0	; 63
     ff4:	cd bf       	out	0x3d, r28	; 61
     ff6:	df 91       	pop	r29
     ff8:	cf 91       	pop	r28
     ffa:	08 95       	ret

00000ffc <LCD_CGRAM_CUSTOM_SYMBOLS>:
	 { 0x0E, 0x1B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F },	// Battery Charging  80%	// addr40-47
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
     ffc:	cf 93       	push	r28
     ffe:	df 93       	push	r29
	for(rows=0; rows<7; rows++)
    1000:	10 92 a2 05 	sts	0x05A2, r1
    1004:	10 92 a1 05 	sts	0x05A1, r1
    1008:	80 91 a1 05 	lds	r24, 0x05A1
    100c:	90 91 a2 05 	lds	r25, 0x05A2
    1010:	87 30       	cpi	r24, 0x07	; 7
    1012:	91 05       	cpc	r25, r1
    1014:	34 f5       	brge	.+76     	; 0x1062 <LCD_CGRAM_CUSTOM_SYMBOLS+0x66>
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
    1016:	08 96       	adiw	r24, 0x08	; 8
    1018:	88 0f       	add	r24, r24
    101a:	88 0f       	add	r24, r24
    101c:	88 0f       	add	r24, r24
    101e:	0e 94 9f 06 	call	0xd3e	; 0xd3e <LCD_EXECUTE_COMMAND>
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
    1022:	c0 e0       	ldi	r28, 0x00	; 0
    1024:	d0 e0       	ldi	r29, 0x00	; 0
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
    1026:	e0 91 a1 05 	lds	r30, 0x05A1
    102a:	f0 91 a2 05 	lds	r31, 0x05A2
    102e:	83 e0       	ldi	r24, 0x03	; 3
    1030:	ee 0f       	add	r30, r30
    1032:	ff 1f       	adc	r31, r31
    1034:	8a 95       	dec	r24
    1036:	e1 f7       	brne	.-8      	; 0x1030 <LCD_CGRAM_CUSTOM_SYMBOLS+0x34>
    1038:	ec 0f       	add	r30, r28
    103a:	fd 1f       	adc	r31, r29
    103c:	e3 57       	subi	r30, 0x73	; 115
    103e:	ff 4f       	sbci	r31, 0xFF	; 255
    1040:	80 81       	ld	r24, Z
    1042:	0e 94 f0 06 	call	0xde0	; 0xde0 <LCD_EXECUTE_DATA_ONE>
void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
    1046:	21 96       	adiw	r28, 0x01	; 1
    1048:	c8 30       	cpi	r28, 0x08	; 8
    104a:	d1 05       	cpc	r29, r1
    104c:	61 f7       	brne	.-40     	; 0x1026 <LCD_CGRAM_CUSTOM_SYMBOLS+0x2a>
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
    104e:	80 91 a1 05 	lds	r24, 0x05A1
    1052:	90 91 a2 05 	lds	r25, 0x05A2
    1056:	01 96       	adiw	r24, 0x01	; 1
    1058:	90 93 a2 05 	sts	0x05A2, r25
    105c:	80 93 a1 05 	sts	0x05A1, r24
    1060:	d3 cf       	rjmp	.-90     	; 0x1008 <LCD_CGRAM_CUSTOM_SYMBOLS+0xc>
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
		}
	}
}
    1062:	df 91       	pop	r29
    1064:	cf 91       	pop	r28
    1066:	08 95       	ret

00001068 <pga2310_reset>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_reset()
{
	spi_init();
    1068:	0e 94 40 09 	call	0x1280	; 0x1280 <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    106c:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    106e:	60 e0       	ldi	r22, 0x00	; 0
    1070:	80 e0       	ldi	r24, 0x00	; 0
    1072:	0e 94 51 09 	call	0x12a2	; 0x12a2 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    1076:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1078:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    107a:	60 e0       	ldi	r22, 0x00	; 0
    107c:	80 e0       	ldi	r24, 0x00	; 0
    107e:	0e 94 51 09 	call	0x12a2	; 0x12a2 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    1082:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1084:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1086:	60 e0       	ldi	r22, 0x00	; 0
    1088:	80 e0       	ldi	r24, 0x00	; 0
    108a:	0e 94 51 09 	call	0x12a2	; 0x12a2 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    108e:	df 9a       	sbi	0x1b, 7	; 27
    1090:	08 95       	ret

00001092 <pga2310_init>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_init()
{
	spi_init();
    1092:	0e 94 40 09 	call	0x1280	; 0x1280 <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    1096:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1098:	60 e0       	ldi	r22, 0x00	; 0
    109a:	80 e0       	ldi	r24, 0x00	; 0
    109c:	0e 94 51 09 	call	0x12a2	; 0x12a2 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    10a0:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    10a2:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    10a4:	60 e0       	ldi	r22, 0x00	; 0
    10a6:	80 e0       	ldi	r24, 0x00	; 0
    10a8:	0e 94 51 09 	call	0x12a2	; 0x12a2 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    10ac:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    10ae:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    10b0:	60 e0       	ldi	r22, 0x00	; 0
    10b2:	80 e0       	ldi	r24, 0x00	; 0
    10b4:	0e 94 51 09 	call	0x12a2	; 0x12a2 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    10b8:	df 9a       	sbi	0x1b, 7	; 27
    10ba:	08 95       	ret

000010bc <PGA2310_Volume_Update>:

/*************************************
** DEFINITION PGA2310 VOLUME UPDATE **
*************************************/
void PGA2310_Volume_Update(unsigned char pgaVolumeLeft, unsigned char pgaVolumeRight)
{
    10bc:	cf 93       	push	r28
    10be:	df 93       	push	r29
    10c0:	c8 2f       	mov	r28, r24
    10c2:	d6 2f       	mov	r29, r22
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    10c4:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    10c6:	0e 94 51 09 	call	0x12a2	; 0x12a2 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    10ca:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    10cc:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    10ce:	6d 2f       	mov	r22, r29
    10d0:	8c 2f       	mov	r24, r28
    10d2:	0e 94 51 09 	call	0x12a2	; 0x12a2 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    10d6:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA7 - /SS ENABLE
    10d8:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    10da:	6d 2f       	mov	r22, r29
    10dc:	8c 2f       	mov	r24, r28
    10de:	0e 94 51 09 	call	0x12a2	; 0x12a2 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    10e2:	df 9a       	sbi	0x1b, 7	; 27

//	return SUCCESS;
}
    10e4:	df 91       	pop	r29
    10e6:	cf 91       	pop	r28
    10e8:	08 95       	ret

000010ea <uart_init>:
{
	switch(F_CPU)
	{
		case 16000000UL:
		{
			UBRRL = 103;	// Baudrate: 9600; (Error = 0.2%; 16MHz)
    10ea:	87 e6       	ldi	r24, 0x67	; 103
    10ec:	89 b9       	out	0x09, r24	; 9
			UBRRH = 0;
    10ee:	10 bc       	out	0x20, r1	; 32
	LCD_DATA_STRING(" MHz");		// 20 symbols
#endif
	// Razpoznavane na baudrate (skorost): 1. Izprashta se byte. 2. Poluchava se byte. 3. Sravnqva se polucheniq byte == izprateniq byte. // This is LOOP TX->RX
	// 4. Ako byte pri sravnqvaneto e edin i sasht to skorostta e izbranata v momenta, ako byte e razlichen - da se probva sas sledvashta baudrate.

	UCSRC = 0b10000110;		// URSEL = 1 (Accessing to UBRRH or UCSRC, is read as zero when reading UBRRH. The URSEL must be zero when writing the UBRRH.); UMSEL = 0 (Asynchronous Operation); UPM1 = 0, UPM0 = 0 (Parity Mode Disabled); USBS = 0 (1-Stop Bit); UCSZ2 = 0, UCSZ1 = 1, UCSZ0 = 1 (8-DataBits); UCPOL = 0 Polarity TX & RX (Rising XCK Edge -> Transmitted Data Changed (Output of TxDPin), Falling XCK Edge -> Received Data Sampled (Input on RxDPin))
    10f0:	86 e8       	ldi	r24, 0x86	; 134
    10f2:	80 bd       	out	0x20, r24	; 32
	UCSRB = 0b00001000;		// Enable only TXEN	- Transmitting Uart/Usart	// UCSRB = 0b10011000;		// Enable TXEN,RXEN,RXCIE	Transmitting and Receiving Uart/Usart
    10f4:	88 e0       	ldi	r24, 0x08	; 8
    10f6:	8a b9       	out	0x0a, r24	; 10
	UDR = 0b00000000;		// INITIALIZATION NULL OF UART DATA
    10f8:	1c b8       	out	0x0c, r1	; 12
    10fa:	08 95       	ret

000010fc <uart_transmit>:
/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
    10fc:	fc 01       	movw	r30, r24
    10fe:	9f 01       	movw	r18, r30
    1100:	28 1b       	sub	r18, r24
    1102:	39 0b       	sbc	r19, r25
    1104:	26 17       	cp	r18, r22
    1106:	37 07       	cpc	r19, r23
    1108:	2c f4       	brge	.+10     	; 0x1114 <uart_transmit+0x18>
	{
		//UDR = uart_data[count_ns];
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    110a:	5d 9b       	sbis	0x0b, 5	; 11
    110c:	fe cf       	rjmp	.-4      	; 0x110a <uart_transmit+0xe>
		{
		}
		UDR = uart_data[count_ns];
    110e:	21 91       	ld	r18, Z+
    1110:	2c b9       	out	0x0c, r18	; 12
    1112:	f5 cf       	rjmp	.-22     	; 0x10fe <uart_transmit+0x2>
	}
}
    1114:	08 95       	ret

00001116 <uart_transmit_one>:
/***************************************
** TRANSMIT/SEND 1 BYTE OF UART/USART **
***************************************/
void uart_transmit_one(unsigned char uart_data)
{
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    1116:	5d 9b       	sbis	0x0b, 5	; 11
    1118:	fe cf       	rjmp	.-4      	; 0x1116 <uart_transmit_one>
	{
	}
	UDR = uart_data;
    111a:	8c b9       	out	0x0c, r24	; 12
    111c:	08 95       	ret

0000111e <uart_transmit_DEC_to_BCD>:
** TRANSMIT/SEND 1 BYTE CONVERTED FROM DEC TO BCD OF UART/USART **		// NOT FINISHED
*****************************************************************/		// NOT FINISHED
void uart_transmit_DEC_to_BCD(unsigned char dec_to_bcd_data)
{// pravi se preobrazuvane ot DEC to BCD i preobrazuvane za izvejdane na parviq simvol s filtar
	
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    111e:	5d 9b       	sbis	0x0b, 5	; 11
    1120:	fe cf       	rjmp	.-4      	; 0x111e <uart_transmit_DEC_to_BCD>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data>>4));
    1122:	98 2f       	mov	r25, r24
    1124:	92 95       	swap	r25
    1126:	9f 70       	andi	r25, 0x0F	; 15
    1128:	90 5d       	subi	r25, 0xD0	; 208
    112a:	9c b9       	out	0x0c, r25	; 12

	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    112c:	5d 9b       	sbis	0x0b, 5	; 11
    112e:	fe cf       	rjmp	.-4      	; 0x112c <uart_transmit_DEC_to_BCD+0xe>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data & 0x0F));
    1130:	8f 70       	andi	r24, 0x0F	; 15
    1132:	80 5d       	subi	r24, 0xD0	; 208
    1134:	8c b9       	out	0x0c, r24	; 12
    1136:	08 95       	ret

00001138 <transmitUart>:
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
    1138:	5d 9b       	sbis	0x0b, 5	; 11
    113a:	fe cf       	rjmp	.-4      	; 0x1138 <transmitUart>
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
    113c:	8c b9       	out	0x0c, r24	; 12
    113e:	08 95       	ret

00001140 <transmitUartString>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
    1140:	cf 93       	push	r28
    1142:	df 93       	push	r29
    1144:	ec 01       	movw	r28, r24
	while(*data)
    1146:	89 91       	ld	r24, Y+
    1148:	88 23       	and	r24, r24
    114a:	19 f0       	breq	.+6      	; 0x1152 <transmitUartString+0x12>
	{
		transmitUart(*data++);
    114c:	0e 94 9c 08 	call	0x1138	; 0x1138 <transmitUart>
    1150:	fa cf       	rjmp	.-12     	; 0x1146 <transmitUartString+0x6>
	}
}
    1152:	df 91       	pop	r29
    1154:	cf 91       	pop	r28
    1156:	08 95       	ret

00001158 <transmitUartUInt>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned int BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: transmitUartUInt( (unsigned int)k + 1 );
void transmitUartUInt(unsigned int data)		// void transmitUartUInt(const unsigned int data)
{
    1158:	cf 93       	push	r28
    115a:	df 93       	push	r29
    115c:	cd b7       	in	r28, 0x3d	; 61
    115e:	de b7       	in	r29, 0x3e	; 62
    1160:	2a 97       	sbiw	r28, 0x0a	; 10
    1162:	0f b6       	in	r0, 0x3f	; 63
    1164:	f8 94       	cli
    1166:	de bf       	out	0x3e, r29	; 62
    1168:	0f be       	out	0x3f, r0	; 63
    116a:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(utoa(data, buffer, 10));		// 10 -> DECIMAL
    116c:	4a e0       	ldi	r20, 0x0A	; 10
    116e:	50 e0       	ldi	r21, 0x00	; 0
    1170:	be 01       	movw	r22, r28
    1172:	6f 5f       	subi	r22, 0xFF	; 255
    1174:	7f 4f       	sbci	r23, 0xFF	; 255
    1176:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <utoa>
    117a:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
}
    117e:	2a 96       	adiw	r28, 0x0a	; 10
    1180:	0f b6       	in	r0, 0x3f	; 63
    1182:	f8 94       	cli
    1184:	de bf       	out	0x3e, r29	; 62
    1186:	0f be       	out	0x3f, r0	; 63
    1188:	cd bf       	out	0x3d, r28	; 61
    118a:	df 91       	pop	r29
    118c:	cf 91       	pop	r28
    118e:	08 95       	ret

00001190 <transmitUartInt>:
/*****************************************		// NOT FINISHED
** TRANSMIT/SEND int BYTE OF UART/USART **		// NOT FINISHED
*****************************************/		// NOT FINISHED
// USE THIS: transmitUartInt( (int)k + 1 );
void transmitUartInt(int data)		// void transmitUartInt(const int data)
{
    1190:	cf 93       	push	r28
    1192:	df 93       	push	r29
    1194:	cd b7       	in	r28, 0x3d	; 61
    1196:	de b7       	in	r29, 0x3e	; 62
    1198:	2a 97       	sbiw	r28, 0x0a	; 10
    119a:	0f b6       	in	r0, 0x3f	; 63
    119c:	f8 94       	cli
    119e:	de bf       	out	0x3e, r29	; 62
    11a0:	0f be       	out	0x3f, r0	; 63
    11a2:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(itoa(data, buffer, 10));		// 10 -> DECIMAL
    11a4:	4a e0       	ldi	r20, 0x0A	; 10
    11a6:	50 e0       	ldi	r21, 0x00	; 0
    11a8:	be 01       	movw	r22, r28
    11aa:	6f 5f       	subi	r22, 0xFF	; 255
    11ac:	7f 4f       	sbci	r23, 0xFF	; 255
    11ae:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <itoa>
    11b2:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
}
    11b6:	2a 96       	adiw	r28, 0x0a	; 10
    11b8:	0f b6       	in	r0, 0x3f	; 63
    11ba:	f8 94       	cli
    11bc:	de bf       	out	0x3e, r29	; 62
    11be:	0f be       	out	0x3f, r0	; 63
    11c0:	cd bf       	out	0x3d, r28	; 61
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	08 95       	ret

000011c8 <transmitUartULong>:
/***************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned long BYTE OF UART/USART **		// NOT FINISHED
***************************************************/		// NOT FINISHED
// USE THIS: transmitUartULong( (unsigned long)k + 1 );
void transmitUartULong(unsigned long data)		// void transmitUartULong(const unsigned long data)
{
    11c8:	cf 93       	push	r28
    11ca:	df 93       	push	r29
    11cc:	cd b7       	in	r28, 0x3d	; 61
    11ce:	de b7       	in	r29, 0x3e	; 62
    11d0:	2a 97       	sbiw	r28, 0x0a	; 10
    11d2:	0f b6       	in	r0, 0x3f	; 63
    11d4:	f8 94       	cli
    11d6:	de bf       	out	0x3e, r29	; 62
    11d8:	0f be       	out	0x3f, r0	; 63
    11da:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ultoa(data, buffer, 10));		// 10 -> DECIMAL
    11dc:	2a e0       	ldi	r18, 0x0A	; 10
    11de:	30 e0       	ldi	r19, 0x00	; 0
    11e0:	ae 01       	movw	r20, r28
    11e2:	4f 5f       	subi	r20, 0xFF	; 255
    11e4:	5f 4f       	sbci	r21, 0xFF	; 255
    11e6:	0e 94 38 0c 	call	0x1870	; 0x1870 <ultoa>
    11ea:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
}
    11ee:	2a 96       	adiw	r28, 0x0a	; 10
    11f0:	0f b6       	in	r0, 0x3f	; 63
    11f2:	f8 94       	cli
    11f4:	de bf       	out	0x3e, r29	; 62
    11f6:	0f be       	out	0x3f, r0	; 63
    11f8:	cd bf       	out	0x3d, r28	; 61
    11fa:	df 91       	pop	r29
    11fc:	cf 91       	pop	r28
    11fe:	08 95       	ret

00001200 <transmitUartLong>:
/******************************************		// NOT FINISHED
** TRANSMIT/SEND long BYTE OF UART/USART **		// NOT FINISHED
******************************************/		// NOT FINISHED
// USE THIS: transmitUartLong( (long)k + 1 );
void transmitUartLong(long data)		// void transmitUartLong(const long data)
{
    1200:	cf 93       	push	r28
    1202:	df 93       	push	r29
    1204:	cd b7       	in	r28, 0x3d	; 61
    1206:	de b7       	in	r29, 0x3e	; 62
    1208:	2a 97       	sbiw	r28, 0x0a	; 10
    120a:	0f b6       	in	r0, 0x3f	; 63
    120c:	f8 94       	cli
    120e:	de bf       	out	0x3e, r29	; 62
    1210:	0f be       	out	0x3f, r0	; 63
    1212:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ltoa(data, buffer, 10));		// 10 -> DECIMAL
    1214:	2a e0       	ldi	r18, 0x0A	; 10
    1216:	30 e0       	ldi	r19, 0x00	; 0
    1218:	ae 01       	movw	r20, r28
    121a:	4f 5f       	subi	r20, 0xFF	; 255
    121c:	5f 4f       	sbci	r21, 0xFF	; 255
    121e:	0e 94 04 0c 	call	0x1808	; 0x1808 <ltoa>
    1222:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
}
    1226:	2a 96       	adiw	r28, 0x0a	; 10
    1228:	0f b6       	in	r0, 0x3f	; 63
    122a:	f8 94       	cli
    122c:	de bf       	out	0x3e, r29	; 62
    122e:	0f be       	out	0x3f, r0	; 63
    1230:	cd bf       	out	0x3d, r28	; 61
    1232:	df 91       	pop	r29
    1234:	cf 91       	pop	r28
    1236:	08 95       	ret

00001238 <transmitUartDouble>:
/********************************************		// NOT FINISHED
** TRANSMIT/SEND double TYPE OF UART/USART **		// NOT FINISHED
********************************************/		// NOT FINISHED
// USE THIS: transmitUartInt( (int)k + 1 );
void transmitUartDouble(double data)		// void transmitUartInt(const int data)
{
    1238:	cf 93       	push	r28
    123a:	df 93       	push	r29
    123c:	cd b7       	in	r28, 0x3d	; 61
    123e:	de b7       	in	r29, 0x3e	; 62
    1240:	2a 97       	sbiw	r28, 0x0a	; 10
    1242:	0f b6       	in	r0, 0x3f	; 63
    1244:	f8 94       	cli
    1246:	de bf       	out	0x3e, r29	; 62
    1248:	0f be       	out	0x3f, r0	; 63
    124a:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(itoa(data, buffer, 10));		// 10 -> DECIMAL
    124c:	0e 94 89 0b 	call	0x1712	; 0x1712 <__fixsfsi>
    1250:	dc 01       	movw	r26, r24
    1252:	cb 01       	movw	r24, r22
    1254:	4a e0       	ldi	r20, 0x0A	; 10
    1256:	50 e0       	ldi	r21, 0x00	; 0
    1258:	be 01       	movw	r22, r28
    125a:	6f 5f       	subi	r22, 0xFF	; 255
    125c:	7f 4f       	sbci	r23, 0xFF	; 255
    125e:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <itoa>
    1262:	0e 94 a0 08 	call	0x1140	; 0x1140 <transmitUartString>
}
    1266:	2a 96       	adiw	r28, 0x0a	; 10
    1268:	0f b6       	in	r0, 0x3f	; 63
    126a:	f8 94       	cli
    126c:	de bf       	out	0x3e, r29	; 62
    126e:	0f be       	out	0x3f, r0	; 63
    1270:	cd bf       	out	0x3d, r28	; 61
    1272:	df 91       	pop	r29
    1274:	cf 91       	pop	r28
    1276:	08 95       	ret

00001278 <receiveUart>:
/**************************************************		// NOT FINISHED
** RECEIVE/READ unsigned char BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
unsigned char receiveUart(void)
{
	while (!(UCSRA & (1<<RXC)))
    1278:	5f 9b       	sbis	0x0b, 7	; 11
    127a:	fe cf       	rjmp	.-4      	; 0x1278 <receiveUart>
	{};							/* Wait for data to be received */
	return UDR;					/* Get and return received data from buffer */
    127c:	8c b1       	in	r24, 0x0c	; 12
}
    127e:	08 95       	ret

00001280 <spi_init>:
/**************************
** INITIZLIZATION OF SPI **
***************************/
void spi_init()
{
	SPSR = (0<<SPIF)|(0<<WCOL)|(0<<SPI2X);
    1280:	1e b8       	out	0x0e, r1	; 14
//	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);			//0b01010010	// SPR1   = 1 - 16 000 000 / 64  = 250 000 = 250kHz  // KOMENTAR ZARADI SIMULACIQTA - PROTEUS BLOKIRANE ZARADI BIT V REGISTAR
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz	 // KAKVA KOMBINACIQ OT 4-te BITa VODI DO RAZBLOKIRANETO ???
    1282:	83 e5       	ldi	r24, 0x53	; 83
    1284:	8d b9       	out	0x0d, r24	; 13
	SPDR = 0b00000000;
    1286:	1f b8       	out	0x0f, r1	; 15

	PGA2310_U8_SPI_CS_high();	// /SS - DISABLE
	PGA2310_U8_SPI(0b00000000, 0b00000000);
	*/

	SPCR = (0<<SPE);
    1288:	1d b8       	out	0x0d, r1	; 13
    128a:	08 95       	ret

0000128c <spi_start>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    128c:	83 e5       	ldi	r24, 0x53	; 83
    128e:	8d b9       	out	0x0d, r24	; 13
    1290:	08 95       	ret

00001292 <spi_stop>:
/**************************************
** DEFINITION SPI FUNCTION STOP ONLY **
**************************************/
void spi_stop()
{
	SPCR = (0<<SPE);
    1292:	1d b8       	out	0x0d, r1	; 13
    1294:	08 95       	ret

00001296 <spi_write_one_byte>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1296:	93 e5       	ldi	r25, 0x53	; 83
    1298:	9d b9       	out	0x0d, r25	; 13
void spi_write_one_byte(unsigned char data)	// void PGA2310_U7_SPI(byte volume_left, byte volume_right)	//PGA2310_U7_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data;				//volume_right;
    129a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    129c:	77 9b       	sbis	0x0e, 7	; 14
    129e:	fe cf       	rjmp	.-4      	; 0x129c <spi_write_one_byte+0x6>
	{
	}
}
    12a0:	08 95       	ret

000012a2 <spi_write_two_bytes>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    12a2:	93 e5       	ldi	r25, 0x53	; 83
    12a4:	9d b9       	out	0x0d, r25	; 13
void spi_write_two_bytes(unsigned char data1, unsigned char data2)	// void PGA2310_U6_SPI(byte volume_left, byte volume_right)	//PGA2310_U6_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data1;				//volume_left;
    12a6:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    12a8:	77 9b       	sbis	0x0e, 7	; 14
    12aa:	fe cf       	rjmp	.-4      	; 0x12a8 <spi_write_two_bytes+0x6>
	{
	}

//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data2;				//volume_right;
    12ac:	6f b9       	out	0x0f, r22	; 15
	while(!(SPSR & (1<<SPIF)))
    12ae:	77 9b       	sbis	0x0e, 7	; 14
    12b0:	fe cf       	rjmp	.-4      	; 0x12ae <spi_write_two_bytes+0xc>
	{
	}
}
    12b2:	08 95       	ret

000012b4 <spi_write_more_bytes>:

/*********************************************
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
    12b4:	fc 01       	movw	r30, r24
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    12b6:	93 e5       	ldi	r25, 0x53	; 83
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    12b8:	81 91       	ld	r24, Z+
    12ba:	88 23       	and	r24, r24
    12bc:	31 f0       	breq	.+12     	; 0x12ca <spi_write_more_bytes+0x16>
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    12be:	9d b9       	out	0x0d, r25	; 13
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
	{
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
		spi_start();
		SPDR = *data;			//volume_left;
    12c0:	80 81       	ld	r24, Z
    12c2:	8f b9       	out	0x0f, r24	; 15
		while(!(SPSR & (1<<SPIF)))
    12c4:	77 9b       	sbis	0x0e, 7	; 14
    12c6:	fe cf       	rjmp	.-4      	; 0x12c4 <spi_write_more_bytes+0x10>
    12c8:	f7 cf       	rjmp	.-18     	; 0x12b8 <spi_write_more_bytes+0x4>
		{
		}
	}
}
    12ca:	08 95       	ret

000012cc <spi_read_more_bytes>:
unsigned char spi_read_more_bytes()	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
	unsigned char data = 0b00000000;
	//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data;			//volume_left;
    12cc:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF)))
    12ce:	77 9b       	sbis	0x0e, 7	; 14
    12d0:	fe cf       	rjmp	.-4      	; 0x12ce <spi_read_more_bytes+0x2>
	{
	}
	return data;
}
    12d2:	80 e0       	ldi	r24, 0x00	; 0
    12d4:	08 95       	ret

000012d6 <decToBcd>:
/**************************************************************
**** CONVERT NORMAL DECIMAL NUMBERS TO BINARY CODED DECIMAL ***
**************************************************************/
unsigned char decToBcd(unsigned char val)
{
	return ( (val/10*16) + (val%10) );	// Get DEC format -> convert DEC to HEX
    12d6:	6a e0       	ldi	r22, 0x0A	; 10
    12d8:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <__udivmodqi4>
}
    12dc:	20 e1       	ldi	r18, 0x10	; 16
    12de:	82 9f       	mul	r24, r18
    12e0:	90 0d       	add	r25, r0
    12e2:	11 24       	eor	r1, r1
    12e4:	89 2f       	mov	r24, r25
    12e6:	08 95       	ret

000012e8 <bcdToDec>:
/**************************************************************
**** CONVERT BINARY CODED DECIMAL TO NORMAL DECIMAL NUMBERS ***
**************************************************************/
unsigned char bcdToDec(unsigned char val)
{
	return ( (val/16*10) + (val%16) );	// Get HEX format -> convert HEX to DEC
    12e8:	98 2f       	mov	r25, r24
    12ea:	92 95       	swap	r25
    12ec:	9f 70       	andi	r25, 0x0F	; 15
    12ee:	8f 70       	andi	r24, 0x0F	; 15
}
    12f0:	2a e0       	ldi	r18, 0x0A	; 10
    12f2:	92 9f       	mul	r25, r18
    12f4:	80 0d       	add	r24, r0
    12f6:	11 24       	eor	r1, r1
    12f8:	08 95       	ret

000012fa <shiftRightOutLsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    12fa:	a0 9a       	sbi	0x14, 0	; 20
    12fc:	88 e0       	ldi	r24, 0x08	; 8
void shiftRightOutLsbFirst()
{
	unsigned char conbyte = 0x44;
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
    12fe:	94 e4       	ldi	r25, 0x44	; 68
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regALSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1300:	90 ff       	sbrs	r25, 0
    1302:	02 c0       	rjmp	.+4      	; 0x1308 <shiftRightOutLsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v LSB
    1304:	a8 9a       	sbi	0x15, 0	; 21
    1306:	01 c0       	rjmp	.+2      	; 0x130a <shiftRightOutLsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
    1308:	a8 98       	cbi	0x15, 0	; 21
		}
		
		regALSB = regALSB >> 1;	// shiftvane na >> nadqsno
    130a:	96 95       	lsr	r25
    130c:	81 50       	subi	r24, 0x01	; 1
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    130e:	c1 f7       	brne	.-16     	; 0x1300 <shiftRightOutLsbFirst+0x6>
		}
		
		regALSB = regALSB >> 1;	// shiftvane na >> nadqsno
	}

}
    1310:	08 95       	ret

00001312 <shiftLeftOutMsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    1312:	a0 9a       	sbi	0x14, 0	; 20
    1314:	88 e0       	ldi	r24, 0x08	; 8
void shiftLeftOutMsbFirst()
{
	unsigned char conbyte = 0x44;
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
    1316:	94 e4       	ldi	r25, 0x44	; 68
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regAMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
    1318:	97 ff       	sbrs	r25, 7
    131a:	02 c0       	rjmp	.+4      	; 0x1320 <shiftLeftOutMsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v MSB
    131c:	a8 9a       	sbi	0x15, 0	; 21
    131e:	01 c0       	rjmp	.+2      	; 0x1322 <shiftLeftOutMsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
    1320:	a8 98       	cbi	0x15, 0	; 21
		}
		
		regAMSB = regAMSB << 1;	// shiftvane na << nalqvo
    1322:	99 0f       	add	r25, r25
    1324:	81 50       	subi	r24, 0x01	; 1
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1326:	c1 f7       	brne	.-16     	; 0x1318 <shiftLeftOutMsbFirst+0x6>
		}
		
		regAMSB = regAMSB << 1;	// shiftvane na << nalqvo
	}

}
    1328:	08 95       	ret

0000132a <shiftRightInLsbFirst>:
void shiftRightInLsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    132a:	a0 98       	cbi	0x14, 0	; 20
    132c:	88 e0       	ldi	r24, 0x08	; 8

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
    132e:	93 b3       	in	r25, 0x13	; 19
    1330:	81 50       	subi	r24, 0x01	; 1
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1332:	e9 f7       	brne	.-6      	; 0x132e <shiftRightInLsbFirst+0x4>
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
	}

}
    1334:	08 95       	ret

00001336 <shiftLeftInMsbFirst>:
void shiftLeftInMsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    1336:	a0 98       	cbi	0x14, 0	; 20
    1338:	88 e0       	ldi	r24, 0x08	; 8

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
    133a:	93 b3       	in	r25, 0x13	; 19
    133c:	81 50       	subi	r24, 0x01	; 1
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    133e:	e9 f7       	brne	.-6      	; 0x133a <shiftLeftInMsbFirst+0x4>
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
	}

}
    1340:	08 95       	ret

00001342 <delay_ms>:
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1342:	40 e0       	ldi	r20, 0x00	; 0
    1344:	50 e0       	ldi	r21, 0x00	; 0
    1346:	48 17       	cp	r20, r24
    1348:	59 07       	cpc	r21, r25
    134a:	64 f4       	brge	.+24     	; 0x1364 <delay_ms+0x22>
    134c:	24 e6       	ldi	r18, 0x64	; 100
    134e:	30 e0       	ldi	r19, 0x00	; 0
	{
		for(j=0;j<100;j++)
		{
		  asm("nop");
    1350:	00 00       	nop
		  asm("nop");
    1352:	00 00       	nop
    1354:	21 50       	subi	r18, 0x01	; 1
    1356:	31 09       	sbc	r19, r1
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
	{
		for(j=0;j<100;j++)
    1358:	21 15       	cp	r18, r1
    135a:	31 05       	cpc	r19, r1
    135c:	c9 f7       	brne	.-14     	; 0x1350 <delay_ms+0xe>
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    135e:	4f 5f       	subi	r20, 0xFF	; 255
    1360:	5f 4f       	sbci	r21, 0xFF	; 255
    1362:	f1 cf       	rjmp	.-30     	; 0x1346 <delay_ms+0x4>
    1364:	08 95       	ret

00001366 <rotaryEncoderNikBarzakov>:
** READ/SCAN ROTARY ENCODER OF NIK BARZAKOV **
*********************************************/
char rotaryEncoderNikBarzakov()
{
	char tempEncoder = 0;
	if((ENCODER_A_low()) && (ENCODER_B_low()))			// A0, B0
    1366:	9d 99       	sbic	0x13, 5	; 19
    1368:	12 c0       	rjmp	.+36     	; 0x138e <rotaryEncoderNikBarzakov+0x28>
    136a:	9c 99       	sbic	0x13, 4	; 19
    136c:	10 c0       	rjmp	.+32     	; 0x138e <rotaryEncoderNikBarzakov+0x28>
    136e:	87 ec       	ldi	r24, 0xC7	; 199
    1370:	90 e0       	ldi	r25, 0x00	; 0
    1372:	01 97       	sbiw	r24, 0x01	; 1
    1374:	f1 f7       	brne	.-4      	; 0x1372 <rotaryEncoderNikBarzakov+0xc>
    1376:	00 c0       	rjmp	.+0      	; 0x1378 <rotaryEncoderNikBarzakov+0x12>
    1378:	00 00       	nop
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_high()) && (ENCODER_B_low()))		// A1, B0
    137a:	9d 99       	sbic	0x13, 5	; 19
    137c:	02 c0       	rjmp	.+4      	; 0x1382 <rotaryEncoderNikBarzakov+0x1c>
/*********************************************
** READ/SCAN ROTARY ENCODER OF NIK BARZAKOV **
*********************************************/
char rotaryEncoderNikBarzakov()
{
	char tempEncoder = 0;
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	08 95       	ret
	if((ENCODER_A_low()) && (ENCODER_B_low()))			// A0, B0
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_high()) && (ENCODER_B_low()))		// A1, B0
    1382:	83 b3       	in	r24, 0x13	; 19
    1384:	82 95       	swap	r24
    1386:	81 70       	andi	r24, 0x01	; 1
    1388:	91 e0       	ldi	r25, 0x01	; 1
    138a:	89 27       	eor	r24, r25
    138c:	08 95       	ret
// VOLUME UP
			tempEncoder = 1;	//	tempEncoder++;
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}
	}
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    138e:	9d 9b       	sbis	0x13, 5	; 19
    1390:	f6 cf       	rjmp	.-20     	; 0x137e <rotaryEncoderNikBarzakov+0x18>
    1392:	9c 99       	sbic	0x13, 4	; 19
    1394:	f4 cf       	rjmp	.-24     	; 0x137e <rotaryEncoderNikBarzakov+0x18>
    1396:	87 ec       	ldi	r24, 0xC7	; 199
    1398:	90 e0       	ldi	r25, 0x00	; 0
    139a:	01 97       	sbiw	r24, 0x01	; 1
    139c:	f1 f7       	brne	.-4      	; 0x139a <rotaryEncoderNikBarzakov+0x34>
    139e:	00 c0       	rjmp	.+0      	; 0x13a0 <rotaryEncoderNikBarzakov+0x3a>
    13a0:	00 00       	nop
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    13a2:	9d 99       	sbic	0x13, 5	; 19
    13a4:	ec cf       	rjmp	.-40     	; 0x137e <rotaryEncoderNikBarzakov+0x18>
    13a6:	83 b3       	in	r24, 0x13	; 19
    13a8:	82 95       	swap	r24
    13aa:	81 70       	andi	r24, 0x01	; 1
    13ac:	91 e0       	ldi	r25, 0x01	; 1
    13ae:	89 27       	eor	r24, r25
    13b0:	81 95       	neg	r24
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    13b2:	08 95       	ret

000013b4 <rotaryEncoderVer1>:
** READ/SCAN ROTARY ENCODER VERSION 1 / MODEL 1 **
*************************************************/
char rotaryEncoderVer1()	// Check imediate now bits in PIN register.
{
	char tempEncoder = 0;							// A1, B1
	if((ENCODER_A_low()) && (ENCODER_B_high()))			// A0, B1
    13b4:	9d 99       	sbic	0x13, 5	; 19
    13b6:	12 c0       	rjmp	.+36     	; 0x13dc <rotaryEncoderVer1+0x28>
    13b8:	9c 9b       	sbis	0x13, 4	; 19
    13ba:	10 c0       	rjmp	.+32     	; 0x13dc <rotaryEncoderVer1+0x28>
    13bc:	87 ec       	ldi	r24, 0xC7	; 199
    13be:	90 e0       	ldi	r25, 0x00	; 0
    13c0:	01 97       	sbiw	r24, 0x01	; 1
    13c2:	f1 f7       	brne	.-4      	; 0x13c0 <rotaryEncoderVer1+0xc>
    13c4:	00 c0       	rjmp	.+0      	; 0x13c6 <rotaryEncoderVer1+0x12>
    13c6:	00 00       	nop
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    13c8:	9d 9b       	sbis	0x13, 5	; 19
    13ca:	02 c0       	rjmp	.+4      	; 0x13d0 <rotaryEncoderVer1+0x1c>
/*************************************************
** READ/SCAN ROTARY ENCODER VERSION 1 / MODEL 1 **
*************************************************/
char rotaryEncoderVer1()	// Check imediate now bits in PIN register.
{
	char tempEncoder = 0;							// A1, B1
    13cc:	80 e0       	ldi	r24, 0x00	; 0
    13ce:	08 95       	ret
	if((ENCODER_A_low()) && (ENCODER_B_high()))			// A0, B1
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    13d0:	83 b3       	in	r24, 0x13	; 19
    13d2:	82 95       	swap	r24
    13d4:	81 70       	andi	r24, 0x01	; 1
    13d6:	91 e0       	ldi	r25, 0x01	; 1
    13d8:	89 27       	eor	r24, r25
    13da:	08 95       	ret
//			PORTD = volumeMassive[volumeIndex];
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}

	}													// A1. B1
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    13dc:	9d 9b       	sbis	0x13, 5	; 19
    13de:	f6 cf       	rjmp	.-20     	; 0x13cc <rotaryEncoderVer1+0x18>
    13e0:	9c 99       	sbic	0x13, 4	; 19
    13e2:	f4 cf       	rjmp	.-24     	; 0x13cc <rotaryEncoderVer1+0x18>
    13e4:	87 ec       	ldi	r24, 0xC7	; 199
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	01 97       	sbiw	r24, 0x01	; 1
    13ea:	f1 f7       	brne	.-4      	; 0x13e8 <rotaryEncoderVer1+0x34>
    13ec:	00 c0       	rjmp	.+0      	; 0x13ee <rotaryEncoderVer1+0x3a>
    13ee:	00 00       	nop
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    13f0:	9d 99       	sbic	0x13, 5	; 19
    13f2:	ec cf       	rjmp	.-40     	; 0x13cc <rotaryEncoderVer1+0x18>
    13f4:	83 b3       	in	r24, 0x13	; 19
    13f6:	82 95       	swap	r24
    13f8:	81 70       	andi	r24, 0x01	; 1
    13fa:	91 e0       	ldi	r25, 0x01	; 1
    13fc:	89 27       	eor	r24, r25
    13fe:	81 95       	neg	r24
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    1400:	08 95       	ret

00001402 <rotaryEncoderVer2>:
    1402:	87 ec       	ldi	r24, 0xC7	; 199
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	01 97       	sbiw	r24, 0x01	; 1
    1408:	f1 f7       	brne	.-4      	; 0x1406 <rotaryEncoderVer2+0x4>
    140a:	00 c0       	rjmp	.+0      	; 0x140c <rotaryEncoderVer2+0xa>
    140c:	00 00       	nop
    140e:	87 ec       	ldi	r24, 0xC7	; 199
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	01 97       	sbiw	r24, 0x01	; 1
    1414:	f1 f7       	brne	.-4      	; 0x1412 <rotaryEncoderVer2+0x10>
    1416:	00 c0       	rjmp	.+0      	; 0x1418 <rotaryEncoderVer2+0x16>
    1418:	00 00       	nop
    141a:	87 ec       	ldi	r24, 0xC7	; 199
    141c:	90 e0       	ldi	r25, 0x00	; 0
    141e:	01 97       	sbiw	r24, 0x01	; 1
    1420:	f1 f7       	brne	.-4      	; 0x141e <rotaryEncoderVer2+0x1c>
    1422:	00 c0       	rjmp	.+0      	; 0x1424 <rotaryEncoderVer2+0x22>
    1424:	00 00       	nop
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    1426:	80 e0       	ldi	r24, 0x00	; 0
    1428:	08 95       	ret

0000142a <RELAYS_IN_INIT>:

/*********************************************
** INITIZLIZATION OF SHIFT REGISTER 74HC595 **
*********************************************/
void RELAYS_IN_INIT()
{
    142a:	08 95       	ret

0000142c <RELAYS_OUT_INIT>:
}

void RELAYS_OUT_INIT()
{
    142c:	08 95       	ret

0000142e <RELAYS_IN_CHOOSE>:

/****************************************************************************************************************
** DEFINITION RELAYS IN FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS IN **
****************************************************************************************************************/
void RELAYS_IN_CHOOSE(unsigned char rel_in)	// HELP: RELAYS_IN_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    142e:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELIN_SCK_low();
    1430:	ae 98       	cbi	0x15, 6	; 21

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1432:	80 ff       	sbrs	r24, 0
    1434:	02 c0       	rjmp	.+4      	; 0x143a <RELAYS_IN_CHOOSE+0xc>
		{
			RELIN_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    1436:	af 9a       	sbi	0x15, 7	; 21
    1438:	01 c0       	rjmp	.+2      	; 0x143c <RELAYS_IN_CHOOSE+0xe>
		}
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    143a:	af 98       	cbi	0x15, 7	; 21
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    143c:	86 95       	lsr	r24

		RELIN_SCK_high();
    143e:	ae 9a       	sbi	0x15, 6	; 21
    1440:	91 50       	subi	r25, 0x01	; 1
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1442:	b1 f7       	brne	.-20     	; 0x1430 <RELAYS_IN_CHOOSE+0x2>
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELIN_SCK_high();
	}

	RELIN_RCK_low();
    1444:	ab 98       	cbi	0x15, 3	; 21
    1446:	87 ea       	ldi	r24, 0xA7	; 167
    1448:	92 e0       	ldi	r25, 0x02	; 2
    144a:	01 97       	sbiw	r24, 0x01	; 1
    144c:	f1 f7       	brne	.-4      	; 0x144a <RELAYS_IN_CHOOSE+0x1c>
    144e:	00 c0       	rjmp	.+0      	; 0x1450 <RELAYS_IN_CHOOSE+0x22>
    1450:	00 00       	nop
	_delay_us(170);			//rcall 180 us
	RELIN_RCK_high();
    1452:	ab 9a       	sbi	0x15, 3	; 21
    1454:	87 ea       	ldi	r24, 0xA7	; 167
    1456:	92 e0       	ldi	r25, 0x02	; 2
    1458:	01 97       	sbiw	r24, 0x01	; 1
    145a:	f1 f7       	brne	.-4      	; 0x1458 <RELAYS_IN_CHOOSE+0x2a>
    145c:	00 c0       	rjmp	.+0      	; 0x145e <RELAYS_IN_CHOOSE+0x30>
    145e:	00 00       	nop
    1460:	08 95       	ret

00001462 <relays_in1_2ch>:

}

void relays_in1_2ch()
{
	RELAYS_IN_CHOOSE(0b00100000);	// RELE 1
    1462:	80 e2       	ldi	r24, 0x20	; 32
    1464:	0c 94 17 0a 	jmp	0x142e	; 0x142e <RELAYS_IN_CHOOSE>

00001468 <relays_in1_6ch>:
}

void relays_in1_6ch()
{
	RELAYS_IN_CHOOSE(0b01100001);	// RELE 1,2,3
    1468:	81 e6       	ldi	r24, 0x61	; 97
    146a:	0c 94 17 0a 	jmp	0x142e	; 0x142e <RELAYS_IN_CHOOSE>

0000146e <relays_in2_2ch>:
}

void relays_in2_2ch()
{
	RELAYS_IN_CHOOSE(0b00001010);	// RELE 4,5
    146e:	8a e0       	ldi	r24, 0x0A	; 10
    1470:	0c 94 17 0a 	jmp	0x142e	; 0x142e <RELAYS_IN_CHOOSE>

00001474 <relays_in2_6ch>:
}

void relays_in2_6ch()
{
	RELAYS_IN_CHOOSE(0b10011010);	// RELE 4,5,6,7
    1474:	8a e9       	ldi	r24, 0x9A	; 154
    1476:	0c 94 17 0a 	jmp	0x142e	; 0x142e <RELAYS_IN_CHOOSE>

0000147a <relays_in3_2ch>:
}

void relays_in3_2ch()
{
	RELAYS_IN_CHOOSE(0b00001100);	// RELE 8,5
    147a:	8c e0       	ldi	r24, 0x0C	; 12
    147c:	0c 94 17 0a 	jmp	0x142e	; 0x142e <RELAYS_IN_CHOOSE>

00001480 <relays_in3_6ch>:
}

void relays_in3_6ch()
{
	RELAYS_IN_CHOOSE(0b10011100);	// RELE 8,5,6,7
    1480:	8c e9       	ldi	r24, 0x9C	; 156
    1482:	0c 94 17 0a 	jmp	0x142e	; 0x142e <RELAYS_IN_CHOOSE>

00001486 <relays_in_off>:
}

void relays_in_off()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    1486:	80 e0       	ldi	r24, 0x00	; 0
    1488:	0c 94 17 0a 	jmp	0x142e	; 0x142e <RELAYS_IN_CHOOSE>

0000148c <relays_in_init>:
}

void relays_in_init()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    148c:	80 e0       	ldi	r24, 0x00	; 0
    148e:	0c 94 17 0a 	jmp	0x142e	; 0x142e <RELAYS_IN_CHOOSE>

00001492 <RELAYS_OUT_CHOOSE>:
}
/******************************************************************************************************************
** DEFINITION RELAYS OUT FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS OUT **
******************************************************************************************************************/
void RELAYS_OUT_CHOOSE(unsigned char rel_out)	// HELP: RELAYS_OUT_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    1492:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELOUT_SCK_low();
    1494:	96 98       	cbi	0x12, 6	; 18

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1496:	80 ff       	sbrs	r24, 0
    1498:	02 c0       	rjmp	.+4      	; 0x149e <RELAYS_OUT_CHOOSE+0xc>
		{
			RELOUT_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    149a:	c4 9a       	sbi	0x18, 4	; 24
    149c:	01 c0       	rjmp	.+2      	; 0x14a0 <RELAYS_OUT_CHOOSE+0xe>
		}
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    149e:	c4 98       	cbi	0x18, 4	; 24
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    14a0:	86 95       	lsr	r24

		RELOUT_SCK_high();
    14a2:	96 9a       	sbi	0x12, 6	; 18
    14a4:	91 50       	subi	r25, 0x01	; 1
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    14a6:	b1 f7       	brne	.-20     	; 0x1494 <RELAYS_OUT_CHOOSE+0x2>
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELOUT_SCK_high();
	}

	RELOUT_RCK_low();
    14a8:	97 98       	cbi	0x12, 7	; 18
    14aa:	87 ea       	ldi	r24, 0xA7	; 167
    14ac:	92 e0       	ldi	r25, 0x02	; 2
    14ae:	01 97       	sbiw	r24, 0x01	; 1
    14b0:	f1 f7       	brne	.-4      	; 0x14ae <RELAYS_OUT_CHOOSE+0x1c>
    14b2:	00 c0       	rjmp	.+0      	; 0x14b4 <RELAYS_OUT_CHOOSE+0x22>
    14b4:	00 00       	nop
	_delay_us(170);			//rcall 180 us
	RELOUT_RCK_high();
    14b6:	97 9a       	sbi	0x12, 7	; 18
    14b8:	87 ea       	ldi	r24, 0xA7	; 167
    14ba:	92 e0       	ldi	r25, 0x02	; 2
    14bc:	01 97       	sbiw	r24, 0x01	; 1
    14be:	f1 f7       	brne	.-4      	; 0x14bc <RELAYS_OUT_CHOOSE+0x2a>
    14c0:	00 c0       	rjmp	.+0      	; 0x14c2 <RELAYS_OUT_CHOOSE+0x30>
    14c2:	00 00       	nop
    14c4:	08 95       	ret

000014c6 <relays_out_1ch>:

}

void relays_out_1ch()
{
	RELAYS_OUT_CHOOSE(0b10000000);	// RELE 1
    14c6:	80 e8       	ldi	r24, 0x80	; 128
    14c8:	0c 94 49 0a 	jmp	0x1492	; 0x1492 <RELAYS_OUT_CHOOSE>

000014cc <relays_out_6ch>:
}

void relays_out_6ch()
{
	RELAYS_OUT_CHOOSE(0b11111100);	// RELE 1,2,3,4,5,6
    14cc:	8c ef       	ldi	r24, 0xFC	; 252
    14ce:	0c 94 49 0a 	jmp	0x1492	; 0x1492 <RELAYS_OUT_CHOOSE>

000014d2 <relays_out_off>:
}
void relays_out_off()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    14d2:	80 e0       	ldi	r24, 0x00	; 0
    14d4:	0c 94 49 0a 	jmp	0x1492	; 0x1492 <RELAYS_OUT_CHOOSE>

000014d8 <relays_out_init>:
}
void relays_out_init()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    14d8:	80 e0       	ldi	r24, 0x00	; 0
    14da:	0c 94 49 0a 	jmp	0x1492	; 0x1492 <RELAYS_OUT_CHOOSE>

000014de <GetSIRC12>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    14de:	10 92 94 05 	sts	0x0594, r1
    14e2:	10 92 99 05 	sts	0x0599, r1

	while(irPin);				//wait for it to be low
    14e6:	82 99       	sbic	0x10, 2	; 16
    14e8:	fe cf       	rjmp	.-4      	; 0x14e6 <GetSIRC12+0x8>
    14ea:	80 e0       	ldi	r24, 0x00	; 0
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    14ec:	82 99       	sbic	0x10, 2	; 16
    14ee:	08 c0       	rjmp	.+16     	; 0x1500 <GetSIRC12+0x22>
    {
		lTime++;				//increment every 200uS until pin is high
    14f0:	8f 5f       	subi	r24, 0xFF	; 255
    14f2:	ef e1       	ldi	r30, 0x1F	; 31
    14f4:	f3 e0       	ldi	r31, 0x03	; 3
    14f6:	31 97       	sbiw	r30, 0x01	; 1
    14f8:	f1 f7       	brne	.-4      	; 0x14f6 <GetSIRC12+0x18>
    14fa:	00 c0       	rjmp	.+0      	; 0x14fc <GetSIRC12+0x1e>
    14fc:	00 00       	nop
    14fe:	f6 cf       	rjmp	.-20     	; 0x14ec <GetSIRC12+0xe>
		_delay_us(200);			//200uS delay
								// dokato irPin-a e v nisko nivo se lTimer, pri Sony Startovo uslovie e 2400uS low level + 600uS high level
								// t.e. 200uS * lTime, kato toleransa na lTime 10 i 14 ili saotvetno 2000uS i 2800uS
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1500:	8b 50       	subi	r24, 0x0B	; 11
    1502:	83 30       	cpi	r24, 0x03	; 3
    1504:	c0 f5       	brcc	.+112    	; 0x1576 <GetSIRC12+0x98>
    1506:	87 e0       	ldi	r24, 0x07	; 7
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1508:	90 91 94 05 	lds	r25, 0x0594
    150c:	96 95       	lsr	r25
    150e:	90 93 94 05 	sts	0x0594, r25

			while(irPin);			//wait for it to be low
    1512:	82 99       	sbic	0x10, 2	; 16
    1514:	fe cf       	rjmp	.-4      	; 0x1512 <GetSIRC12+0x34>
    1516:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1518:	82 99       	sbic	0x10, 2	; 16
    151a:	08 c0       	rjmp	.+16     	; 0x152c <GetSIRC12+0x4e>
			{
			    lTime++;			//increment every 200uS until pin is high
    151c:	9f 5f       	subi	r25, 0xFF	; 255
    151e:	ef e1       	ldi	r30, 0x1F	; 31
    1520:	f3 e0       	ldi	r31, 0x03	; 3
    1522:	31 97       	sbiw	r30, 0x01	; 1
    1524:	f1 f7       	brne	.-4      	; 0x1522 <GetSIRC12+0x44>
    1526:	00 c0       	rjmp	.+0      	; 0x1528 <GetSIRC12+0x4a>
    1528:	00 00       	nop
    152a:	f6 cf       	rjmp	.-20     	; 0x1518 <GetSIRC12+0x3a>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    152c:	96 30       	cpi	r25, 0x06	; 6
    152e:	28 f0       	brcs	.+10     	; 0x153a <GetSIRC12+0x5c>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    1530:	90 91 94 05 	lds	r25, 0x0594
    1534:	90 64       	ori	r25, 0x40	; 64
    1536:	90 93 94 05 	sts	0x0594, r25
    153a:	81 50       	subi	r24, 0x01	; 1
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    153c:	29 f7       	brne	.-54     	; 0x1508 <GetSIRC12+0x2a>
    153e:	85 e0       	ldi	r24, 0x05	; 5
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1540:	90 91 99 05 	lds	r25, 0x0599
    1544:	96 95       	lsr	r25
    1546:	90 93 99 05 	sts	0x0599, r25

			while(irPin);			//wait for it to be low
    154a:	82 99       	sbic	0x10, 2	; 16
    154c:	fe cf       	rjmp	.-4      	; 0x154a <GetSIRC12+0x6c>
    154e:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1550:	82 99       	sbic	0x10, 2	; 16
    1552:	08 c0       	rjmp	.+16     	; 0x1564 <GetSIRC12+0x86>
			{
				lTime++;			//increment every 200uS until pin is high
    1554:	9f 5f       	subi	r25, 0xFF	; 255
    1556:	ef e1       	ldi	r30, 0x1F	; 31
    1558:	f3 e0       	ldi	r31, 0x03	; 3
    155a:	31 97       	sbiw	r30, 0x01	; 1
    155c:	f1 f7       	brne	.-4      	; 0x155a <GetSIRC12+0x7c>
    155e:	00 c0       	rjmp	.+0      	; 0x1560 <GetSIRC12+0x82>
    1560:	00 00       	nop
    1562:	f6 cf       	rjmp	.-20     	; 0x1550 <GetSIRC12+0x72>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1564:	96 30       	cpi	r25, 0x06	; 6
    1566:	28 f0       	brcs	.+10     	; 0x1572 <GetSIRC12+0x94>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1568:	90 91 99 05 	lds	r25, 0x0599
    156c:	90 61       	ori	r25, 0x10	; 16
    156e:	90 93 99 05 	sts	0x0599, r25
    1572:	81 50       	subi	r24, 0x01	; 1

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
    1574:	29 f7       	brne	.-54     	; 0x1540 <GetSIRC12+0x62>
    1576:	08 95       	ret

00001578 <GetSIRC15>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    1578:	10 92 94 05 	sts	0x0594, r1
    157c:	10 92 99 05 	sts	0x0599, r1

	while(irPin);				//wait for it to be low
    1580:	82 99       	sbic	0x10, 2	; 16
    1582:	fe cf       	rjmp	.-4      	; 0x1580 <GetSIRC15+0x8>
    1584:	80 e0       	ldi	r24, 0x00	; 0
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    1586:	82 99       	sbic	0x10, 2	; 16
    1588:	08 c0       	rjmp	.+16     	; 0x159a <GetSIRC15+0x22>
    {
		lTime++;				//increment every 200uS until pin is high
    158a:	8f 5f       	subi	r24, 0xFF	; 255
    158c:	ef e1       	ldi	r30, 0x1F	; 31
    158e:	f3 e0       	ldi	r31, 0x03	; 3
    1590:	31 97       	sbiw	r30, 0x01	; 1
    1592:	f1 f7       	brne	.-4      	; 0x1590 <GetSIRC15+0x18>
    1594:	00 c0       	rjmp	.+0      	; 0x1596 <GetSIRC15+0x1e>
    1596:	00 00       	nop
    1598:	f6 cf       	rjmp	.-20     	; 0x1586 <GetSIRC15+0xe>
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    159a:	8b 50       	subi	r24, 0x0B	; 11
    159c:	83 30       	cpi	r24, 0x03	; 3
    159e:	c0 f5       	brcc	.+112    	; 0x1610 <GetSIRC15+0x98>
    15a0:	87 e0       	ldi	r24, 0x07	; 7
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    15a2:	90 91 94 05 	lds	r25, 0x0594
    15a6:	96 95       	lsr	r25
    15a8:	90 93 94 05 	sts	0x0594, r25

			while(irPin);			//wait for it to be low
    15ac:	82 99       	sbic	0x10, 2	; 16
    15ae:	fe cf       	rjmp	.-4      	; 0x15ac <GetSIRC15+0x34>
    15b0:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    15b2:	82 99       	sbic	0x10, 2	; 16
    15b4:	08 c0       	rjmp	.+16     	; 0x15c6 <GetSIRC15+0x4e>
			{
			    lTime++;			//increment every 200uS until pin is high
    15b6:	9f 5f       	subi	r25, 0xFF	; 255
    15b8:	ef e1       	ldi	r30, 0x1F	; 31
    15ba:	f3 e0       	ldi	r31, 0x03	; 3
    15bc:	31 97       	sbiw	r30, 0x01	; 1
    15be:	f1 f7       	brne	.-4      	; 0x15bc <GetSIRC15+0x44>
    15c0:	00 c0       	rjmp	.+0      	; 0x15c2 <GetSIRC15+0x4a>
    15c2:	00 00       	nop
    15c4:	f6 cf       	rjmp	.-20     	; 0x15b2 <GetSIRC15+0x3a>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    15c6:	96 30       	cpi	r25, 0x06	; 6
    15c8:	28 f0       	brcs	.+10     	; 0x15d4 <GetSIRC15+0x5c>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    15ca:	90 91 94 05 	lds	r25, 0x0594
    15ce:	90 64       	ori	r25, 0x40	; 64
    15d0:	90 93 94 05 	sts	0x0594, r25
    15d4:	81 50       	subi	r24, 0x01	; 1
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    15d6:	29 f7       	brne	.-54     	; 0x15a2 <GetSIRC15+0x2a>
    15d8:	88 e0       	ldi	r24, 0x08	; 8
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    15da:	90 91 99 05 	lds	r25, 0x0599
    15de:	96 95       	lsr	r25
    15e0:	90 93 99 05 	sts	0x0599, r25

			while(irPin);			//wait for it to be low
    15e4:	82 99       	sbic	0x10, 2	; 16
    15e6:	fe cf       	rjmp	.-4      	; 0x15e4 <GetSIRC15+0x6c>
    15e8:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    15ea:	82 99       	sbic	0x10, 2	; 16
    15ec:	08 c0       	rjmp	.+16     	; 0x15fe <GetSIRC15+0x86>
			{
				lTime++;			//increment every 200uS until pin is high
    15ee:	9f 5f       	subi	r25, 0xFF	; 255
    15f0:	ef e1       	ldi	r30, 0x1F	; 31
    15f2:	f3 e0       	ldi	r31, 0x03	; 3
    15f4:	31 97       	sbiw	r30, 0x01	; 1
    15f6:	f1 f7       	brne	.-4      	; 0x15f4 <GetSIRC15+0x7c>
    15f8:	00 c0       	rjmp	.+0      	; 0x15fa <GetSIRC15+0x82>
    15fa:	00 00       	nop
    15fc:	f6 cf       	rjmp	.-20     	; 0x15ea <GetSIRC15+0x72>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    15fe:	96 30       	cpi	r25, 0x06	; 6
    1600:	28 f0       	brcs	.+10     	; 0x160c <GetSIRC15+0x94>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1602:	90 91 99 05 	lds	r25, 0x0599
    1606:	90 61       	ori	r25, 0x10	; 16
    1608:	90 93 99 05 	sts	0x0599, r25
    160c:	81 50       	subi	r24, 0x01	; 1

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
    160e:	29 f7       	brne	.-54     	; 0x15da <GetSIRC15+0x62>
    1610:	08 95       	ret

00001612 <GetSIRC20>:
{
	char x;
	char lTime;

//StartLook:
	irExtended = irAddress = irCommand = 0;
    1612:	10 92 94 05 	sts	0x0594, r1
    1616:	10 92 99 05 	sts	0x0599, r1
    161a:	10 92 9b 05 	sts	0x059B, r1

	while(irPin);				//wait for it to be low
    161e:	82 99       	sbic	0x10, 2	; 16
    1620:	fe cf       	rjmp	.-4      	; 0x161e <GetSIRC20+0xc>
    1622:	80 e0       	ldi	r24, 0x00	; 0
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    1624:	82 99       	sbic	0x10, 2	; 16
    1626:	08 c0       	rjmp	.+16     	; 0x1638 <GetSIRC20+0x26>
    {
		lTime++;				//increment every 200uS until pin is high
    1628:	8f 5f       	subi	r24, 0xFF	; 255
    162a:	ef e1       	ldi	r30, 0x1F	; 31
    162c:	f3 e0       	ldi	r31, 0x03	; 3
    162e:	31 97       	sbiw	r30, 0x01	; 1
    1630:	f1 f7       	brne	.-4      	; 0x162e <GetSIRC20+0x1c>
    1632:	00 c0       	rjmp	.+0      	; 0x1634 <GetSIRC20+0x22>
    1634:	00 00       	nop
    1636:	f6 cf       	rjmp	.-20     	; 0x1624 <GetSIRC20+0x12>
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1638:	8b 50       	subi	r24, 0x0B	; 11
    163a:	83 30       	cpi	r24, 0x03	; 3
    163c:	08 f0       	brcs	.+2      	; 0x1640 <GetSIRC20+0x2e>
    163e:	54 c0       	rjmp	.+168    	; 0x16e8 <GetSIRC20+0xd6>
    1640:	87 e0       	ldi	r24, 0x07	; 7
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1642:	90 91 94 05 	lds	r25, 0x0594
    1646:	96 95       	lsr	r25
    1648:	90 93 94 05 	sts	0x0594, r25

			while(irPin);			//wait for it to be low
    164c:	82 99       	sbic	0x10, 2	; 16
    164e:	fe cf       	rjmp	.-4      	; 0x164c <GetSIRC20+0x3a>
    1650:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1652:	82 99       	sbic	0x10, 2	; 16
    1654:	08 c0       	rjmp	.+16     	; 0x1666 <GetSIRC20+0x54>
			{
			    lTime++;			//increment every 200uS until pin is high
    1656:	9f 5f       	subi	r25, 0xFF	; 255
    1658:	ef e1       	ldi	r30, 0x1F	; 31
    165a:	f3 e0       	ldi	r31, 0x03	; 3
    165c:	31 97       	sbiw	r30, 0x01	; 1
    165e:	f1 f7       	brne	.-4      	; 0x165c <GetSIRC20+0x4a>
    1660:	00 c0       	rjmp	.+0      	; 0x1662 <GetSIRC20+0x50>
    1662:	00 00       	nop
    1664:	f6 cf       	rjmp	.-20     	; 0x1652 <GetSIRC20+0x40>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1666:	96 30       	cpi	r25, 0x06	; 6
    1668:	28 f0       	brcs	.+10     	; 0x1674 <GetSIRC20+0x62>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    166a:	90 91 94 05 	lds	r25, 0x0594
    166e:	90 64       	ori	r25, 0x40	; 64
    1670:	90 93 94 05 	sts	0x0594, r25
    1674:	81 50       	subi	r24, 0x01	; 1
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    1676:	29 f7       	brne	.-54     	; 0x1642 <GetSIRC20+0x30>
    1678:	85 e0       	ldi	r24, 0x05	; 5
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    167a:	90 91 99 05 	lds	r25, 0x0599
    167e:	96 95       	lsr	r25
    1680:	90 93 99 05 	sts	0x0599, r25

			while(irPin);			//wait for it to be low
    1684:	82 99       	sbic	0x10, 2	; 16
    1686:	fe cf       	rjmp	.-4      	; 0x1684 <GetSIRC20+0x72>
    1688:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    168a:	82 99       	sbic	0x10, 2	; 16
    168c:	08 c0       	rjmp	.+16     	; 0x169e <GetSIRC20+0x8c>
			{
				lTime++;			//increment every 200uS until pin is high
    168e:	9f 5f       	subi	r25, 0xFF	; 255
    1690:	ef e1       	ldi	r30, 0x1F	; 31
    1692:	f3 e0       	ldi	r31, 0x03	; 3
    1694:	31 97       	sbiw	r30, 0x01	; 1
    1696:	f1 f7       	brne	.-4      	; 0x1694 <GetSIRC20+0x82>
    1698:	00 c0       	rjmp	.+0      	; 0x169a <GetSIRC20+0x88>
    169a:	00 00       	nop
    169c:	f6 cf       	rjmp	.-20     	; 0x168a <GetSIRC20+0x78>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    169e:	96 30       	cpi	r25, 0x06	; 6
    16a0:	28 f0       	brcs	.+10     	; 0x16ac <GetSIRC20+0x9a>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    16a2:	90 91 99 05 	lds	r25, 0x0599
    16a6:	90 61       	ori	r25, 0x10	; 16
    16a8:	90 93 99 05 	sts	0x0599, r25
    16ac:	81 50       	subi	r24, 0x01	; 1

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
    16ae:	29 f7       	brne	.-54     	; 0x167a <GetSIRC20+0x68>
    16b0:	88 e0       	ldi	r24, 0x08	; 8
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
		{
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1
    16b2:	90 91 9b 05 	lds	r25, 0x059B
    16b6:	96 95       	lsr	r25
    16b8:	90 93 9b 05 	sts	0x059B, r25

			while(irPin);			//wait for it to be low
    16bc:	82 99       	sbic	0x10, 2	; 16
    16be:	fe cf       	rjmp	.-4      	; 0x16bc <GetSIRC20+0xaa>
    16c0:	90 e0       	ldi	r25, 0x00	; 0
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    16c2:	82 99       	sbic	0x10, 2	; 16
    16c4:	08 c0       	rjmp	.+16     	; 0x16d6 <GetSIRC20+0xc4>
			{
				lTime++;			//increment every 200uS until pin is high
    16c6:	9f 5f       	subi	r25, 0xFF	; 255
    16c8:	ef e1       	ldi	r30, 0x1F	; 31
    16ca:	f3 e0       	ldi	r31, 0x03	; 3
    16cc:	31 97       	sbiw	r30, 0x01	; 1
    16ce:	f1 f7       	brne	.-4      	; 0x16cc <GetSIRC20+0xba>
    16d0:	00 c0       	rjmp	.+0      	; 0x16d2 <GetSIRC20+0xc0>
    16d2:	00 00       	nop
    16d4:	f6 cf       	rjmp	.-20     	; 0x16c2 <GetSIRC20+0xb0>
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    16d6:	96 30       	cpi	r25, 0x06	; 6
    16d8:	28 f0       	brcs	.+10     	; 0x16e4 <GetSIRC20+0xd2>
				irExtended |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    16da:	90 91 9b 05 	lds	r25, 0x059B
    16de:	90 61       	ori	r25, 0x10	; 16
    16e0:	90 93 9b 05 	sts	0x059B, r25
    16e4:	81 50       	subi	r24, 0x01	; 1

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
    16e6:	29 f7       	brne	.-54     	; 0x16b2 <GetSIRC20+0xa0>
    16e8:	08 95       	ret

000016ea <main>:
******************************** START OF MAIN APPLICATION **********************************
********************************************************************************************/

int main(void)
{
	init_all();				// PREDI DA TRAGNEM // inicializacia na vsichko
    16ea:	0e 94 1c 05 	call	0xa38	; 0xa38 <init_all>
	ext0_intrpt_on();		// PREDI DA TRAGNEM // ENABLE interrupts to access IR DETECTION as call to function "IR_DECODER()" for -> SONY IR REMOTE
    16ee:	0e 94 5b 00 	call	0xb6	; 0xb6 <ext0_intrpt_on>
//	ext2_intrpt_on();
//	temperature();

	sei();					// PREDI DA TRAGNEM 		// file "avr/interrupt.h"
    16f2:	78 94       	sei
//	SREG = (1<<I);

	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
    16f4:	94 9a       	sbi	0x12, 4	; 18
	while(1)
	{		
		buttons_press();	// izchakvane za natiskane na buton
    16f6:	0e 94 2e 05 	call	0xa5c	; 0xa5c <buttons_press>

000016fa <__udivmodqi4>:
    16fa:	99 1b       	sub	r25, r25
    16fc:	79 e0       	ldi	r23, 0x09	; 9
    16fe:	04 c0       	rjmp	.+8      	; 0x1708 <__udivmodqi4_ep>

00001700 <__udivmodqi4_loop>:
    1700:	99 1f       	adc	r25, r25
    1702:	96 17       	cp	r25, r22
    1704:	08 f0       	brcs	.+2      	; 0x1708 <__udivmodqi4_ep>
    1706:	96 1b       	sub	r25, r22

00001708 <__udivmodqi4_ep>:
    1708:	88 1f       	adc	r24, r24
    170a:	7a 95       	dec	r23
    170c:	c9 f7       	brne	.-14     	; 0x1700 <__udivmodqi4_loop>
    170e:	80 95       	com	r24
    1710:	08 95       	ret

00001712 <__fixsfsi>:
    1712:	04 d0       	rcall	.+8      	; 0x171c <__fixunssfsi>
    1714:	68 94       	set
    1716:	b1 11       	cpse	r27, r1
    1718:	50 c0       	rjmp	.+160    	; 0x17ba <__fp_szero>
    171a:	08 95       	ret

0000171c <__fixunssfsi>:
    171c:	33 d0       	rcall	.+102    	; 0x1784 <__fp_splitA>
    171e:	88 f0       	brcs	.+34     	; 0x1742 <__fixunssfsi+0x26>
    1720:	9f 57       	subi	r25, 0x7F	; 127
    1722:	90 f0       	brcs	.+36     	; 0x1748 <__fixunssfsi+0x2c>
    1724:	b9 2f       	mov	r27, r25
    1726:	99 27       	eor	r25, r25
    1728:	b7 51       	subi	r27, 0x17	; 23
    172a:	a0 f0       	brcs	.+40     	; 0x1754 <__fixunssfsi+0x38>
    172c:	d1 f0       	breq	.+52     	; 0x1762 <__fixunssfsi+0x46>
    172e:	66 0f       	add	r22, r22
    1730:	77 1f       	adc	r23, r23
    1732:	88 1f       	adc	r24, r24
    1734:	99 1f       	adc	r25, r25
    1736:	1a f0       	brmi	.+6      	; 0x173e <__fixunssfsi+0x22>
    1738:	ba 95       	dec	r27
    173a:	c9 f7       	brne	.-14     	; 0x172e <__fixunssfsi+0x12>
    173c:	12 c0       	rjmp	.+36     	; 0x1762 <__fixunssfsi+0x46>
    173e:	b1 30       	cpi	r27, 0x01	; 1
    1740:	81 f0       	breq	.+32     	; 0x1762 <__fixunssfsi+0x46>
    1742:	3a d0       	rcall	.+116    	; 0x17b8 <__fp_zero>
    1744:	b1 e0       	ldi	r27, 0x01	; 1
    1746:	08 95       	ret
    1748:	37 c0       	rjmp	.+110    	; 0x17b8 <__fp_zero>
    174a:	67 2f       	mov	r22, r23
    174c:	78 2f       	mov	r23, r24
    174e:	88 27       	eor	r24, r24
    1750:	b8 5f       	subi	r27, 0xF8	; 248
    1752:	39 f0       	breq	.+14     	; 0x1762 <__fixunssfsi+0x46>
    1754:	b9 3f       	cpi	r27, 0xF9	; 249
    1756:	cc f3       	brlt	.-14     	; 0x174a <__fixunssfsi+0x2e>
    1758:	86 95       	lsr	r24
    175a:	77 95       	ror	r23
    175c:	67 95       	ror	r22
    175e:	b3 95       	inc	r27
    1760:	d9 f7       	brne	.-10     	; 0x1758 <__fixunssfsi+0x3c>
    1762:	3e f4       	brtc	.+14     	; 0x1772 <__fixunssfsi+0x56>
    1764:	90 95       	com	r25
    1766:	80 95       	com	r24
    1768:	70 95       	com	r23
    176a:	61 95       	neg	r22
    176c:	7f 4f       	sbci	r23, 0xFF	; 255
    176e:	8f 4f       	sbci	r24, 0xFF	; 255
    1770:	9f 4f       	sbci	r25, 0xFF	; 255
    1772:	08 95       	ret

00001774 <__fp_split3>:
    1774:	57 fd       	sbrc	r21, 7
    1776:	90 58       	subi	r25, 0x80	; 128
    1778:	44 0f       	add	r20, r20
    177a:	55 1f       	adc	r21, r21
    177c:	59 f0       	breq	.+22     	; 0x1794 <__fp_splitA+0x10>
    177e:	5f 3f       	cpi	r21, 0xFF	; 255
    1780:	71 f0       	breq	.+28     	; 0x179e <__fp_splitA+0x1a>
    1782:	47 95       	ror	r20

00001784 <__fp_splitA>:
    1784:	88 0f       	add	r24, r24
    1786:	97 fb       	bst	r25, 7
    1788:	99 1f       	adc	r25, r25
    178a:	61 f0       	breq	.+24     	; 0x17a4 <__fp_splitA+0x20>
    178c:	9f 3f       	cpi	r25, 0xFF	; 255
    178e:	79 f0       	breq	.+30     	; 0x17ae <__fp_splitA+0x2a>
    1790:	87 95       	ror	r24
    1792:	08 95       	ret
    1794:	12 16       	cp	r1, r18
    1796:	13 06       	cpc	r1, r19
    1798:	14 06       	cpc	r1, r20
    179a:	55 1f       	adc	r21, r21
    179c:	f2 cf       	rjmp	.-28     	; 0x1782 <__fp_split3+0xe>
    179e:	46 95       	lsr	r20
    17a0:	f1 df       	rcall	.-30     	; 0x1784 <__fp_splitA>
    17a2:	08 c0       	rjmp	.+16     	; 0x17b4 <__fp_splitA+0x30>
    17a4:	16 16       	cp	r1, r22
    17a6:	17 06       	cpc	r1, r23
    17a8:	18 06       	cpc	r1, r24
    17aa:	99 1f       	adc	r25, r25
    17ac:	f1 cf       	rjmp	.-30     	; 0x1790 <__fp_splitA+0xc>
    17ae:	86 95       	lsr	r24
    17b0:	71 05       	cpc	r23, r1
    17b2:	61 05       	cpc	r22, r1
    17b4:	08 94       	sec
    17b6:	08 95       	ret

000017b8 <__fp_zero>:
    17b8:	e8 94       	clt

000017ba <__fp_szero>:
    17ba:	bb 27       	eor	r27, r27
    17bc:	66 27       	eor	r22, r22
    17be:	77 27       	eor	r23, r23
    17c0:	cb 01       	movw	r24, r22
    17c2:	97 f9       	bld	r25, 7
    17c4:	08 95       	ret

000017c6 <itoa>:
    17c6:	fb 01       	movw	r30, r22
    17c8:	9f 01       	movw	r18, r30
    17ca:	e8 94       	clt
    17cc:	42 30       	cpi	r20, 0x02	; 2
    17ce:	c4 f0       	brlt	.+48     	; 0x1800 <itoa+0x3a>
    17d0:	45 32       	cpi	r20, 0x25	; 37
    17d2:	b4 f4       	brge	.+44     	; 0x1800 <itoa+0x3a>
    17d4:	4a 30       	cpi	r20, 0x0A	; 10
    17d6:	29 f4       	brne	.+10     	; 0x17e2 <itoa+0x1c>
    17d8:	97 fb       	bst	r25, 7
    17da:	1e f4       	brtc	.+6      	; 0x17e2 <itoa+0x1c>
    17dc:	90 95       	com	r25
    17de:	81 95       	neg	r24
    17e0:	9f 4f       	sbci	r25, 0xFF	; 255
    17e2:	64 2f       	mov	r22, r20
    17e4:	77 27       	eor	r23, r23
    17e6:	0e 94 83 0c 	call	0x1906	; 0x1906 <__udivmodhi4>
    17ea:	80 5d       	subi	r24, 0xD0	; 208
    17ec:	8a 33       	cpi	r24, 0x3A	; 58
    17ee:	0c f0       	brlt	.+2      	; 0x17f2 <itoa+0x2c>
    17f0:	89 5d       	subi	r24, 0xD9	; 217
    17f2:	81 93       	st	Z+, r24
    17f4:	cb 01       	movw	r24, r22
    17f6:	00 97       	sbiw	r24, 0x00	; 0
    17f8:	a1 f7       	brne	.-24     	; 0x17e2 <itoa+0x1c>
    17fa:	16 f4       	brtc	.+4      	; 0x1800 <itoa+0x3a>
    17fc:	5d e2       	ldi	r21, 0x2D	; 45
    17fe:	51 93       	st	Z+, r21
    1800:	10 82       	st	Z, r1
    1802:	c9 01       	movw	r24, r18
    1804:	0c 94 73 0c 	jmp	0x18e6	; 0x18e6 <strrev>

00001808 <ltoa>:
    1808:	fa 01       	movw	r30, r20
    180a:	cf 93       	push	r28
    180c:	ff 93       	push	r31
    180e:	ef 93       	push	r30
    1810:	22 30       	cpi	r18, 0x02	; 2
    1812:	44 f1       	brlt	.+80     	; 0x1864 <ltoa+0x5c>
    1814:	25 32       	cpi	r18, 0x25	; 37
    1816:	34 f5       	brge	.+76     	; 0x1864 <ltoa+0x5c>
    1818:	c2 2f       	mov	r28, r18
    181a:	e8 94       	clt
    181c:	ca 30       	cpi	r28, 0x0A	; 10
    181e:	49 f4       	brne	.+18     	; 0x1832 <ltoa+0x2a>
    1820:	97 fb       	bst	r25, 7
    1822:	3e f4       	brtc	.+14     	; 0x1832 <ltoa+0x2a>
    1824:	90 95       	com	r25
    1826:	80 95       	com	r24
    1828:	70 95       	com	r23
    182a:	61 95       	neg	r22
    182c:	7f 4f       	sbci	r23, 0xFF	; 255
    182e:	8f 4f       	sbci	r24, 0xFF	; 255
    1830:	9f 4f       	sbci	r25, 0xFF	; 255
    1832:	2c 2f       	mov	r18, r28
    1834:	33 27       	eor	r19, r19
    1836:	44 27       	eor	r20, r20
    1838:	55 27       	eor	r21, r21
    183a:	ff 93       	push	r31
    183c:	ef 93       	push	r30
    183e:	0e 94 97 0c 	call	0x192e	; 0x192e <__udivmodsi4>
    1842:	ef 91       	pop	r30
    1844:	ff 91       	pop	r31
    1846:	60 5d       	subi	r22, 0xD0	; 208
    1848:	6a 33       	cpi	r22, 0x3A	; 58
    184a:	0c f0       	brlt	.+2      	; 0x184e <ltoa+0x46>
    184c:	69 5d       	subi	r22, 0xD9	; 217
    184e:	61 93       	st	Z+, r22
    1850:	b9 01       	movw	r22, r18
    1852:	ca 01       	movw	r24, r20
    1854:	60 50       	subi	r22, 0x00	; 0
    1856:	70 40       	sbci	r23, 0x00	; 0
    1858:	80 40       	sbci	r24, 0x00	; 0
    185a:	90 40       	sbci	r25, 0x00	; 0
    185c:	51 f7       	brne	.-44     	; 0x1832 <ltoa+0x2a>
    185e:	16 f4       	brtc	.+4      	; 0x1864 <ltoa+0x5c>
    1860:	cd e2       	ldi	r28, 0x2D	; 45
    1862:	c1 93       	st	Z+, r28
    1864:	10 82       	st	Z, r1
    1866:	8f 91       	pop	r24
    1868:	9f 91       	pop	r25
    186a:	cf 91       	pop	r28
    186c:	0c 94 73 0c 	jmp	0x18e6	; 0x18e6 <strrev>

00001870 <ultoa>:
    1870:	fa 01       	movw	r30, r20
    1872:	cf 93       	push	r28
    1874:	ff 93       	push	r31
    1876:	ef 93       	push	r30
    1878:	22 30       	cpi	r18, 0x02	; 2
    187a:	cc f0       	brlt	.+50     	; 0x18ae <ultoa+0x3e>
    187c:	25 32       	cpi	r18, 0x25	; 37
    187e:	bc f4       	brge	.+46     	; 0x18ae <ultoa+0x3e>
    1880:	c2 2f       	mov	r28, r18
    1882:	2c 2f       	mov	r18, r28
    1884:	33 27       	eor	r19, r19
    1886:	44 27       	eor	r20, r20
    1888:	55 27       	eor	r21, r21
    188a:	ff 93       	push	r31
    188c:	ef 93       	push	r30
    188e:	0e 94 97 0c 	call	0x192e	; 0x192e <__udivmodsi4>
    1892:	ef 91       	pop	r30
    1894:	ff 91       	pop	r31
    1896:	60 5d       	subi	r22, 0xD0	; 208
    1898:	6a 33       	cpi	r22, 0x3A	; 58
    189a:	0c f0       	brlt	.+2      	; 0x189e <ultoa+0x2e>
    189c:	69 5d       	subi	r22, 0xD9	; 217
    189e:	61 93       	st	Z+, r22
    18a0:	b9 01       	movw	r22, r18
    18a2:	ca 01       	movw	r24, r20
    18a4:	60 50       	subi	r22, 0x00	; 0
    18a6:	70 40       	sbci	r23, 0x00	; 0
    18a8:	80 40       	sbci	r24, 0x00	; 0
    18aa:	90 40       	sbci	r25, 0x00	; 0
    18ac:	51 f7       	brne	.-44     	; 0x1882 <ultoa+0x12>
    18ae:	10 82       	st	Z, r1
    18b0:	8f 91       	pop	r24
    18b2:	9f 91       	pop	r25
    18b4:	cf 91       	pop	r28
    18b6:	0c 94 73 0c 	jmp	0x18e6	; 0x18e6 <strrev>

000018ba <utoa>:
    18ba:	fb 01       	movw	r30, r22
    18bc:	9f 01       	movw	r18, r30
    18be:	42 30       	cpi	r20, 0x02	; 2
    18c0:	74 f0       	brlt	.+28     	; 0x18de <utoa+0x24>
    18c2:	45 32       	cpi	r20, 0x25	; 37
    18c4:	64 f4       	brge	.+24     	; 0x18de <utoa+0x24>
    18c6:	64 2f       	mov	r22, r20
    18c8:	77 27       	eor	r23, r23
    18ca:	0e 94 83 0c 	call	0x1906	; 0x1906 <__udivmodhi4>
    18ce:	80 5d       	subi	r24, 0xD0	; 208
    18d0:	8a 33       	cpi	r24, 0x3A	; 58
    18d2:	0c f0       	brlt	.+2      	; 0x18d6 <utoa+0x1c>
    18d4:	89 5d       	subi	r24, 0xD9	; 217
    18d6:	81 93       	st	Z+, r24
    18d8:	cb 01       	movw	r24, r22
    18da:	00 97       	sbiw	r24, 0x00	; 0
    18dc:	a1 f7       	brne	.-24     	; 0x18c6 <utoa+0xc>
    18de:	10 82       	st	Z, r1
    18e0:	c9 01       	movw	r24, r18
    18e2:	0c 94 73 0c 	jmp	0x18e6	; 0x18e6 <strrev>

000018e6 <strrev>:
    18e6:	dc 01       	movw	r26, r24
    18e8:	fc 01       	movw	r30, r24
    18ea:	67 2f       	mov	r22, r23
    18ec:	71 91       	ld	r23, Z+
    18ee:	77 23       	and	r23, r23
    18f0:	e1 f7       	brne	.-8      	; 0x18ea <strrev+0x4>
    18f2:	32 97       	sbiw	r30, 0x02	; 2
    18f4:	04 c0       	rjmp	.+8      	; 0x18fe <strrev+0x18>
    18f6:	7c 91       	ld	r23, X
    18f8:	6d 93       	st	X+, r22
    18fa:	70 83       	st	Z, r23
    18fc:	62 91       	ld	r22, -Z
    18fe:	ae 17       	cp	r26, r30
    1900:	bf 07       	cpc	r27, r31
    1902:	c8 f3       	brcs	.-14     	; 0x18f6 <strrev+0x10>
    1904:	08 95       	ret

00001906 <__udivmodhi4>:
    1906:	aa 1b       	sub	r26, r26
    1908:	bb 1b       	sub	r27, r27
    190a:	51 e1       	ldi	r21, 0x11	; 17
    190c:	07 c0       	rjmp	.+14     	; 0x191c <__udivmodhi4_ep>

0000190e <__udivmodhi4_loop>:
    190e:	aa 1f       	adc	r26, r26
    1910:	bb 1f       	adc	r27, r27
    1912:	a6 17       	cp	r26, r22
    1914:	b7 07       	cpc	r27, r23
    1916:	10 f0       	brcs	.+4      	; 0x191c <__udivmodhi4_ep>
    1918:	a6 1b       	sub	r26, r22
    191a:	b7 0b       	sbc	r27, r23

0000191c <__udivmodhi4_ep>:
    191c:	88 1f       	adc	r24, r24
    191e:	99 1f       	adc	r25, r25
    1920:	5a 95       	dec	r21
    1922:	a9 f7       	brne	.-22     	; 0x190e <__udivmodhi4_loop>
    1924:	80 95       	com	r24
    1926:	90 95       	com	r25
    1928:	bc 01       	movw	r22, r24
    192a:	cd 01       	movw	r24, r26
    192c:	08 95       	ret

0000192e <__udivmodsi4>:
    192e:	a1 e2       	ldi	r26, 0x21	; 33
    1930:	1a 2e       	mov	r1, r26
    1932:	aa 1b       	sub	r26, r26
    1934:	bb 1b       	sub	r27, r27
    1936:	fd 01       	movw	r30, r26
    1938:	0d c0       	rjmp	.+26     	; 0x1954 <__udivmodsi4_ep>

0000193a <__udivmodsi4_loop>:
    193a:	aa 1f       	adc	r26, r26
    193c:	bb 1f       	adc	r27, r27
    193e:	ee 1f       	adc	r30, r30
    1940:	ff 1f       	adc	r31, r31
    1942:	a2 17       	cp	r26, r18
    1944:	b3 07       	cpc	r27, r19
    1946:	e4 07       	cpc	r30, r20
    1948:	f5 07       	cpc	r31, r21
    194a:	20 f0       	brcs	.+8      	; 0x1954 <__udivmodsi4_ep>
    194c:	a2 1b       	sub	r26, r18
    194e:	b3 0b       	sbc	r27, r19
    1950:	e4 0b       	sbc	r30, r20
    1952:	f5 0b       	sbc	r31, r21

00001954 <__udivmodsi4_ep>:
    1954:	66 1f       	adc	r22, r22
    1956:	77 1f       	adc	r23, r23
    1958:	88 1f       	adc	r24, r24
    195a:	99 1f       	adc	r25, r25
    195c:	1a 94       	dec	r1
    195e:	69 f7       	brne	.-38     	; 0x193a <__udivmodsi4_loop>
    1960:	60 95       	com	r22
    1962:	70 95       	com	r23
    1964:	80 95       	com	r24
    1966:	90 95       	com	r25
    1968:	9b 01       	movw	r18, r22
    196a:	ac 01       	movw	r20, r24
    196c:	bd 01       	movw	r22, r26
    196e:	cf 01       	movw	r24, r30
    1970:	08 95       	ret

00001972 <_exit>:
    1972:	f8 94       	cli

00001974 <__stop_program>:
    1974:	ff cf       	rjmp	.-2      	; 0x1974 <__stop_program>
