
ATmega32A_GCC_DigitalControlAudioSystem_pLibs.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000166a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000692  00800060  0000166a  000016fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002a  008006f2  008006f2  00001d90  2**0
                  ALLOC
  3 .debug_aranges 00000180  00000000  00000000  00001d90  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000009f8  00000000  00000000  00001f10  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002cc6  00000000  00000000  00002908  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d49  00000000  00000000  000055ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002876  00000000  00000000  00006317  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007b0  00000000  00000000  00008b90  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000b2e  00000000  00000000  00009340  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000cd5  00000000  00000000  00009e6e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000798  00000000  00000000  0000ab43  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 45 04 	jmp	0x88a	; 0x88a <__vector_1>
       8:	0c 94 91 00 	jmp	0x122	; 0x122 <__vector_2>
       c:	0c 94 9b 00 	jmp	0x136	; 0x136 <__vector_3>
      10:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__vector_4>
      14:	0c 94 af 00 	jmp	0x15e	; 0x15e <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	16 e0       	ldi	r17, 0x06	; 6
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e6       	ldi	r30, 0x6A	; 106
      68:	f6 e1       	ldi	r31, 0x16	; 22
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 3f       	cpi	r26, 0xF2	; 242
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a2 ef       	ldi	r26, 0xF2	; 242
      7a:	b6 e0       	ldi	r27, 0x06	; 6
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 31       	cpi	r26, 0x1C	; 28
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 00 04 	call	0x800	; 0x800 <main>
      8a:	0c 94 33 0b 	jmp	0x1666	; 0x1666 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <port_init>:
*****************************************/
void port_init(void)
{	

// PORT A connections
	DDRA  = 0b11111111;		//  PA7:U8/PGA2310,CS; PA6:U7/PGA2310,CS; PA5:CON2LCD,RS; PA4:CON2LCD,RW; PA3:CON2LCD,E; PA2:U2/74HC595,RCLK(LCD); PA1:U2/74HC595,SCLK(LCD); PA0:U2/74HC595,DATA(LCD);
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	8a bb       	out	0x1a, r24	; 26
	PORTA = 0b00000000;		//	Interfaces: NOT USED. PULLUP DISABLE in PORTA.
      96:	1b ba       	out	0x1b, r1	; 27

// PORT B connections
	DDRB  = 0b10111000;		//  PB7:U6,U7,U8/PGA2310,SCLK; PB6:U6,U7,U8/PGA2310,SDO(CON33,36,39); PB5:U6,U7,U8/PGA2310,SDI; PB4:U12/74HC595,DATA(REL_OUT); PB3:U6/PGA2310,CS; PB2:CON8/BUTTON,"ESCAPE",INT2; PB1:CON5/BUTTON,"ON/OFF"; PB0:CON14TempSensor/DS18S20,DQ,IN/OUT;
      98:	88 eb       	ldi	r24, 0xB8	; 184
      9a:	87 bb       	out	0x17, r24	; 23
	PORTB = 0b00000111;		//	Interfaces: EXTERNAL INTERRUPT 2; SPI. set pullup to IRTSOP2240 / BUTTON(on/off) / DS18s20.
      9c:	87 e0       	ldi	r24, 0x07	; 7
      9e:	88 bb       	out	0x18, r24	; 24

// PORT C connections
	DDRC  = 0b11001100;		//  PC7:U10/74HC595,DATA(REL_IN); PC6:U10/74HC595,SCLK(REL_IN); PC5:EncoderED1112S,A; PC4:EncoderED1112S,B; PC3:U10/74HC595,RCLK(REL_IN); PC2:Q2/BD237(RELAY_POWER_SUPPLY); PC1:DS1307/24C64,I2C/SDA; PC0:DS1307/24C64,I2C/SCL;
      a0:	8c ec       	ldi	r24, 0xCC	; 204
      a2:	84 bb       	out	0x14, r24	; 20
	PORTC = 0b00000000;		//	Interfaces: I2C. PULLUP DISABLE in PORTC.
      a4:	15 ba       	out	0x15, r1	; 21

// PORT D connections
	DDRD  = 0b11110000;		//  PD7:U12/74HC595,RCLK(REL_OUT); PD6:U12/74HC595,SCLK(REL_OUT); PD5:Q1/BD237(FAN_CONTROL_PWM); PD4:LED5/"ON/OFF AUDIO SYSTEM"; PD3:CON11/EncoderBUTTON,"MENU/ENTER"/INT1; PD2:CON12/IR/TSOP2240,/INT0; PD1:CON14/MAX232,UART/TXD; PD0:CON14/MAX232,UART/RXD;
      a6:	80 ef       	ldi	r24, 0xF0	; 240
      a8:	81 bb       	out	0x11, r24	; 17
	PORTD = 0b00001100;		//	Interfaces: TIMER1; UART/USART; EXTERNAL INTERRUPT 0, 1. PULLUP DISABLE in PORTD.
      aa:	8c e0       	ldi	r24, 0x0C	; 12
      ac:	82 bb       	out	0x12, r24	; 18
//	DDRD&=~_BV(0);// DDD0 = "0"  (DDD0=DDRD nulev bit) set PORTD pin0 to zero as input
//	PORTD|=_BV(0);// PD0  = "1"  Enable pull up
//	PORTD|=_BV(1);// PD1  = "1"  led
//	DDRD|=_BV(1); // DDD1 = "1"  (DDD1=DDRD parvi bit) set PORTD pin1 to one as output

}
      ae:	08 95       	ret

000000b0 <ext0_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 0 **
*******************************************/
void ext0_intrpt_init(void)
{
	MCUCR = 0b00000010;	// SETUP EXT INT 0, ISC01 = 1, ISC00 = 0: Falling edge on INT0 activates the interrupt; ISC01 = 1, ISC00 = 1: Rising edge on INT0 activates the interrupt;
      b0:	82 e0       	ldi	r24, 0x02	; 2
      b2:	85 bf       	out	0x35, r24	; 53

// IN FUNCTIONS:
//	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
//	GIFR   = 0b01000000;	// Clear INT0 flag.
}
      b4:	08 95       	ret

000000b6 <ext0_intrpt_on>:
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      b6:	80 e4       	ldi	r24, 0x40	; 64
      b8:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      ba:	8a bf       	out	0x3a, r24	; 58
}
      bc:	08 95       	ret

000000be <ext0_intrpt_off>:
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      be:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      c0:	80 e4       	ldi	r24, 0x40	; 64
      c2:	8a bf       	out	0x3a, r24	; 58
}
      c4:	08 95       	ret

000000c6 <ext1_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 1 **
*******************************************/
void ext1_intrpt_init(void)
{
}
      c6:	08 95       	ret

000000c8 <ext2_intrpt_init>:
//	MCUCSR = 0b00000000;	// SETUP EXT INT 2, ISC2 = 0: Falling edge on INT2 activates the interrupt; ISC2 = 1: Rising edge on INT2 activates the interrupt;

// IN FUNCTIONS:
//	GICR   = 0b00100000;	// INT2 = 0: Disable External Interrupt on INT2; INT2 = 1: Enable External Interrupt on INT2;
//	GIFR   = 0b00100000;	// Clear INT2 flag.
}
      c8:	08 95       	ret

000000ca <timer1_init>:
*****************************/
void timer1_init()
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  = 0b00000000;	// maskov registar za prekasvaniq
      ca:	19 be       	out	0x39, r1	; 57
	TCNT1H = 0b00000000;
      cc:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
      ce:	1c bc       	out	0x2c, r1	; 44

//	OCR1BH = 100; //20;			// 0   = 0b00000000 (DEC = BIN)	// LED
//	OCR1BL = 100; //20;			// 200 = 0b11001000 (DEC = BIN)	// LED

//	TIMSK = (1 << OCIE1A);
}
      d0:	08 95       	ret

000000d2 <timer2_init>:
/*****************************
** INITIZLIZATION OF TIMER2 **
*****************************/
void timer2_init(void)
{
	SFIOR = 0b00000010;		// Prescaler Reset Timer2 (bit1 –> PSR2)
      d2:	82 e0       	ldi	r24, 0x02	; 2
      d4:	80 bf       	out	0x30, r24	; 48
	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      d6:	81 e8       	ldi	r24, 0x81	; 129
      d8:	85 bd       	out	0x25, r24	; 37
	OCR2 = 0; // FAN PWM ON
      da:	13 bc       	out	0x23, r1	; 35
}
      dc:	08 95       	ret

000000de <timer1_on_speed1>:
/***************************************
******** DEFINITIONS OF TIMER 1 ********
***************************************/
void timer1_on_speed1()
{
	TCCR1A = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      de:	81 e8       	ldi	r24, 0x81	; 129
      e0:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00010001;
      e2:	81 e1       	ldi	r24, 0x11	; 17
      e4:	8e bd       	out	0x2e, r24	; 46

	OCR1AH = 0; // FAN PWM ON
      e6:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 1; // FAN PWM ON
      e8:	81 e0       	ldi	r24, 0x01	; 1
      ea:	8a bd       	out	0x2a, r24	; 42

//	OCR1BH = 0; // LED PWM ON
//	OCR1BL = 1; // LED PWM ON
}
      ec:	08 95       	ret

000000ee <timer1_off>:

void timer1_off()
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
      ee:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
      f0:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
      f2:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
      f4:	1a bc       	out	0x2a, r1	; 42

//	OCR1BH = 0; // LED PWM OFF
//	OCR1BL = 0; // LED PWM OFF
}
      f6:	08 95       	ret

000000f8 <FAN_PWM_SPEED1>:
/***************************************
******** DEFINITIONS OF TIMER 1 ********
***************************************/
void timer1_on_speed1()
{
	TCCR1A = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      f8:	81 e8       	ldi	r24, 0x81	; 129
      fa:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00010001;
      fc:	81 e1       	ldi	r24, 0x11	; 17
      fe:	8e bd       	out	0x2e, r24	; 46

	OCR1AH = 0; // FAN PWM ON
     100:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 1; // FAN PWM ON
     102:	81 e0       	ldi	r24, 0x01	; 1
     104:	8a bd       	out	0x2a, r24	; 42
******** DEFINITIONS OF FAN ********
***********************************/
void FAN_PWM_SPEED1()
{
	timer1_on_speed1();
}
     106:	08 95       	ret

00000108 <FAN_PWM_OFF>:
//	OCR1BL = 1; // LED PWM ON
}

void timer1_off()
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     108:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     10a:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     10c:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     10e:	1a bc       	out	0x2a, r1	; 42
	timer1_on_speed1();
}
void FAN_PWM_OFF()
{
	timer1_off();
}
     110:	08 95       	ret

00000112 <timer2_on>:
/***************************************
******** DEFINITIONS OF TIMER 2 ********
***************************************/
void timer2_on(void)	// Timer2 On
{
	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     112:	81 e8       	ldi	r24, 0x81	; 129
     114:	85 bd       	out	0x25, r24	; 37
	OCR2 = 1; // FAN PWM ON
     116:	81 e0       	ldi	r24, 0x01	; 1
     118:	83 bd       	out	0x23, r24	; 35
}
     11a:	08 95       	ret

0000011c <timer2_off>:

void timer2_off(void)	// Timer2 Off
{
	TCCR2 = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     11c:	15 bc       	out	0x25, r1	; 37
	OCR2 = 0; // FAN PWM OFF
     11e:	13 bc       	out	0x23, r1	; 35
}
     120:	08 95       	ret

00000122 <__vector_2>:

/*****************************************
**** EXTERNAL INTERRUPT 1 VECTOR 02 ******
*****************************************/
ISR(INT1_vect)
{
     122:	1f 92       	push	r1
     124:	0f 92       	push	r0
     126:	0f b6       	in	r0, 0x3f	; 63
     128:	0f 92       	push	r0
     12a:	11 24       	eor	r1, r1
}
     12c:	0f 90       	pop	r0
     12e:	0f be       	out	0x3f, r0	; 63
     130:	0f 90       	pop	r0
     132:	1f 90       	pop	r1
     134:	18 95       	reti

00000136 <__vector_3>:

/*****************************************
**** EXTERNAL INTERRUPT 2 VECTOR 03 ******
*****************************************/
ISR(INT2_vect)
{
     136:	1f 92       	push	r1
     138:	0f 92       	push	r0
     13a:	0f b6       	in	r0, 0x3f	; 63
     13c:	0f 92       	push	r0
     13e:	11 24       	eor	r1, r1
}
     140:	0f 90       	pop	r0
     142:	0f be       	out	0x3f, r0	; 63
     144:	0f 90       	pop	r0
     146:	1f 90       	pop	r1
     148:	18 95       	reti

0000014a <__vector_4>:

/*****************************************
**** TIMER 2 OUTPUT COMPARE VECTOR 04 ****
*****************************************/
ISR(TIMER2_COMP_vect)
{
     14a:	1f 92       	push	r1
     14c:	0f 92       	push	r0
     14e:	0f b6       	in	r0, 0x3f	; 63
     150:	0f 92       	push	r0
     152:	11 24       	eor	r1, r1
}
     154:	0f 90       	pop	r0
     156:	0f be       	out	0x3f, r0	; 63
     158:	0f 90       	pop	r0
     15a:	1f 90       	pop	r1
     15c:	18 95       	reti

0000015e <__vector_5>:

/*****************************************
**** TIMER 2 OVERFLOW VECTOR 05 **********
*****************************************/
ISR(TIMER2_OVF_vect)
{
     15e:	1f 92       	push	r1
     160:	0f 92       	push	r0
     162:	0f b6       	in	r0, 0x3f	; 63
     164:	0f 92       	push	r0
     166:	11 24       	eor	r1, r1
}
     168:	0f 90       	pop	r0
     16a:	0f be       	out	0x3f, r0	; 63
     16c:	0f 90       	pop	r0
     16e:	1f 90       	pop	r1
     170:	18 95       	reti

00000172 <about>:

	return temper;
}

void about(void)
{
     172:	0f 93       	push	r16
     174:	1f 93       	push	r17
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] =====================================================\r\n");
     176:	00 e6       	ldi	r16, 0x60	; 96
     178:	10 e0       	ldi	r17, 0x00	; 0
     17a:	c8 01       	movw	r24, r16
     17c:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartString("[UART INFO] \tAuthors and creators: P.Upinov and P.Stoyanov\r\n");
     180:	84 ea       	ldi	r24, 0xA4	; 164
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartString("[UART INFO] \tDevice name: Digital Control Audio System\r\n");
     188:	81 ee       	ldi	r24, 0xE1	; 225
     18a:	90 e0       	ldi	r25, 0x00	; 0
     18c:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartString("[UART INFO] \tFirmware version beta ");
     190:	8a e1       	ldi	r24, 0x1A	; 26
     192:	91 e0       	ldi	r25, 0x01	; 1
     194:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartInt(FIRMWARE_VERSION);
     198:	8b e1       	ldi	r24, 0x1B	; 27
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <transmitUartInt>
	transmitUartString("\r\n");
     1a0:	8e e3       	ldi	r24, 0x3E	; 62
     1a2:	91 e0       	ldi	r25, 0x01	; 1
     1a4:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartString("[UART INFO] =====================================================\r\n");
     1a8:	c8 01       	movw	r24, r16
     1aa:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartString("[UART INFO] Da dobavq upravlenie na:\
     1ae:	81 e4       	ldi	r24, 0x41	; 65
     1b0:	91 e0       	ldi	r25, 0x01	; 1
     1b2:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
					\r\n[UART INFO] - FAN smart controlling			\
					\r\n[UART INFO] - DS18S20						\
					\r\n[UART INFO] - RTC							\
					\r\n[UART INFO] - Memory\r\n");
#endif
}
     1b6:	1f 91       	pop	r17
     1b8:	0f 91       	pop	r16
     1ba:	08 95       	ret

000001bc <init_all>:
*********************************** START OF APPLICATION ************************************
********************************************************************************************/

void init_all()
{
	port_init();		// IO init and configure all port
     1bc:	0e 94 49 00 	call	0x92	; 0x92 <port_init>
//	timer2_init();
	LCD_INIT();			// LCD init and reset all lcd contain
     1c0:	0e 94 46 06 	call	0xc8c	; 0xc8c <LCD_INIT>
	uart_init();		// UART debug init
     1c4:	0e 94 0a 08 	call	0x1014	; 0x1014 <uart_init>
	about();			// Any debug important information
     1c8:	0e 94 b9 00 	call	0x172	; 0x172 <about>

	pga2310_init();		// SPI init and reset all (U6, U7, U8) PGA2310 volume values to null
     1cc:	0e 94 3b 07 	call	0xe76	; 0xe76 <pga2310_init>
//	relays_in_init();	// ?? nujno li e ?
//	relays_out_init();	// ?? nujno li e ?


}
     1d0:	08 95       	ret

000001d2 <temperMeasur>:
	}
	return 0;
}

char temperMeasur(unsigned char byte0, unsigned char byte1, unsigned char byte6, unsigned char byte7)
{
     1d2:	1f 93       	push	r17
	char tC = 0;
	char temper = 0;
	double k = 0;
	double j = 0;

	byte0 = storeTemp [0];
     1d4:	10 91 f3 06 	lds	r17, 0x06F3
	byte1 = storeTemp [1];
     1d8:	80 91 f4 06 	lds	r24, 0x06F4
	byte6 = storeTemp [6];
	byte7 = storeTemp [7];

	k = ((byte7 - byte6) / byte7) + 0.25;

	if((byte1 == 0x00) && (byte0 == 0x00))
     1dc:	88 23       	and	r24, r24
     1de:	61 f5       	brne	.+88     	; 0x238 <temperMeasur+0x66>
     1e0:	11 23       	and	r17, r17
     1e2:	79 f4       	brne	.+30     	; 0x202 <temperMeasur+0x30>
	{
		tC = (byte0/2);
		j = tC - k;
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     1e4:	81 ef       	ldi	r24, 0xF1	; 241
     1e6:	91 e0       	ldi	r25, 0x01	; 1
     1e8:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartInt(tC);		// uart debug information string 
     1ec:	80 e0       	ldi	r24, 0x00	; 0
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <transmitUartInt>
	transmitUartString(".0 C\r\n");			// uart debug information string
     1f4:	8b e0       	ldi	r24, 0x0B	; 11
     1f6:	92 e0       	ldi	r25, 0x02	; 2
     1f8:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     1fc:	80 e0       	ldi	r24, 0x00	; 0
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	13 c0       	rjmp	.+38     	; 0x228 <temperMeasur+0x56>
	LCD_DATA_STRING(".0 C");		//
	}
	else if((byte1 == 0x00) && (byte0 != 0x00))
	{
		transmitUartString("+");
     202:	87 e1       	ldi	r24, 0x17	; 23
     204:	92 e0       	ldi	r25, 0x02	; 2
     206:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
		tC = (byte0/2);
		j = tC - k;
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     20a:	81 ef       	ldi	r24, 0xF1	; 241
     20c:	91 e0       	ldi	r25, 0x01	; 1
     20e:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartInt(tC);		// uart debug information string 
     212:	16 95       	lsr	r17
     214:	81 2f       	mov	r24, r17
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <transmitUartInt>
	transmitUartString(".0 C\r\n");			// uart debug information string
     21c:	8b e0       	ldi	r24, 0x0B	; 11
     21e:	92 e0       	ldi	r25, 0x02	; 2
     220:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     224:	81 2f       	mov	r24, r17
     226:	90 e0       	ldi	r25, 0x00	; 0
     228:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <LCD_DATA_INT>
	LCD_DATA_STRING(".0 C");		//
     22c:	82 e1       	ldi	r24, 0x12	; 18
     22e:	92 e0       	ldi	r25, 0x02	; 2
     230:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
     234:	80 e0       	ldi	r24, 0x00	; 0
     236:	1b c0       	rjmp	.+54     	; 0x26e <temperMeasur+0x9c>
	}
	else if((byte1 == 0xFF) && (byte0 != 0x00))
     238:	8f 3f       	cpi	r24, 0xFF	; 255
     23a:	a1 f4       	brne	.+40     	; 0x264 <temperMeasur+0x92>
     23c:	11 23       	and	r17, r17
     23e:	91 f0       	breq	.+36     	; 0x264 <temperMeasur+0x92>
	{
		transmitUartString("-");
     240:	89 e1       	ldi	r24, 0x19	; 25
     242:	92 e0       	ldi	r25, 0x02	; 2
     244:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
//		tC = ((byte0 - 255.5) / 2);		// ne e dobre obraboteno za otricatelni chisla
		tC = ((byte0 - 255) / 2);
		j = tC - k;
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     248:	81 ef       	ldi	r24, 0xF1	; 241
     24a:	91 e0       	ldi	r25, 0x01	; 1
     24c:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartInt(tC);		// uart debug information string 
     250:	81 2f       	mov	r24, r17
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	8f 5f       	subi	r24, 0xFF	; 255
     256:	90 40       	sbci	r25, 0x00	; 0
     258:	62 e0       	ldi	r22, 0x02	; 2
     25a:	70 e0       	ldi	r23, 0x00	; 0
     25c:	0e 94 4a 0a 	call	0x1494	; 0x1494 <__divmodhi4>
     260:	16 2f       	mov	r17, r22
     262:	d8 cf       	rjmp	.-80     	; 0x214 <temperMeasur+0x42>
	}
	else
	{
		//lcdDataString("ERROR!");	// ERROR not return to display!!!!
#ifdef DEBUG_ERROR
	transmitUartString("[UART ERROR] ERROR TEMPERATURE\r\n");		// uart debug information string
     264:	8b e1       	ldi	r24, 0x1B	; 27
     266:	92 e0       	ldi	r25, 0x02	; 2
     268:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
     26c:	81 e0       	ldi	r24, 0x01	; 1
#endif
		return 1;
	}

	return temper;
}
     26e:	1f 91       	pop	r17
     270:	08 95       	ret

00000272 <oneWireRight>:
	}
	return 0;
}

unsigned char oneWireRight()
{
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
	unsigned char i;

#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
     276:	8c e3       	ldi	r24, 0x3C	; 60
     278:	92 e0       	ldi	r25, 0x02	; 2
     27a:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     27e:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <reset>
     282:	88 23       	and	r24, r24
     284:	09 f4       	brne	.+2      	; 0x288 <oneWireRight+0x16>
     286:	4d c0       	rjmp	.+154    	; 0x322 <oneWireRight+0xb0>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     288:	85 e5       	ldi	r24, 0x55	; 85
     28a:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		// 64-bit ROM CODE
		write_byte(0x10);	// Byte 0
     28e:	80 e1       	ldi	r24, 0x10	; 16
     290:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0x6D);	// Byte 1
     294:	8d e6       	ldi	r24, 0x6D	; 109
     296:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0xF4);	// Byte 2
     29a:	84 ef       	ldi	r24, 0xF4	; 244
     29c:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0x8F);	// Byte 3
     2a0:	8f e8       	ldi	r24, 0x8F	; 143
     2a2:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0x02);	// Byte 4
     2a6:	82 e0       	ldi	r24, 0x02	; 2
     2a8:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0x08);	// Byte 5
     2ac:	88 e0       	ldi	r24, 0x08	; 8
     2ae:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0x00);	// Byte 6
     2b2:	80 e0       	ldi	r24, 0x00	; 0
     2b4:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0xB1);	// Byte 7
     2b8:	81 eb       	ldi	r24, 0xB1	; 177
     2ba:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		// 64-bit ROM CODE

		write_byte(0x44);	// Master issues Convert T command.
     2be:	84 e4       	ldi	r24, 0x44	; 68
     2c0:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     2c4:	0e 94 54 05 	call	0xaa8	; 0xaa8 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     2c8:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <reset>
     2cc:	88 23       	and	r24, r24
     2ce:	49 f1       	breq	.+82     	; 0x322 <oneWireRight+0xb0>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     2d0:	85 e5       	ldi	r24, 0x55	; 85
     2d2:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			// 64-bit ROM CODE
			write_byte(0x10);	// Byte 0
     2d6:	80 e1       	ldi	r24, 0x10	; 16
     2d8:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0x6D);	// Byte 1
     2dc:	8d e6       	ldi	r24, 0x6D	; 109
     2de:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0xF4);	// Byte 2
     2e2:	84 ef       	ldi	r24, 0xF4	; 244
     2e4:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0x8F);	// Byte 3
     2e8:	8f e8       	ldi	r24, 0x8F	; 143
     2ea:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0x02);	// Byte 4
     2ee:	82 e0       	ldi	r24, 0x02	; 2
     2f0:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0x08);	// Byte 5
     2f4:	88 e0       	ldi	r24, 0x08	; 8
     2f6:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0x00);	// Byte 6
     2fa:	80 e0       	ldi	r24, 0x00	; 0
     2fc:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0xB1);	// Byte 7
     300:	81 eb       	ldi	r24, 0xB1	; 177
     302:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
     306:	8e eb       	ldi	r24, 0xBE	; 190
     308:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
     30c:	c3 ef       	ldi	r28, 0xF3	; 243
     30e:	d6 e0       	ldi	r29, 0x06	; 6
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     310:	0e 94 04 05 	call	0xa08	; 0xa08 <read_byte>
     314:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     316:	86 e0       	ldi	r24, 0x06	; 6
     318:	cc 3f       	cpi	r28, 0xFC	; 252
     31a:	d8 07       	cpc	r29, r24
     31c:	c9 f7       	brne	.-14     	; 0x310 <oneWireRight+0x9e>
     31e:	81 e0       	ldi	r24, 0x01	; 1
     320:	01 c0       	rjmp	.+2      	; 0x324 <oneWireRight+0xb2>
     322:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     324:	df 91       	pop	r29
     326:	cf 91       	pop	r28
     328:	08 95       	ret

0000032a <oneWireLeft>:

/*******************************************
**** 1-WIRE DS18x20 Temperature Sensors ****
*******************************************/
unsigned char oneWireLeft()
{
     32a:	cf 93       	push	r28
     32c:	df 93       	push	r29
	unsigned char i;

#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
     32e:	8d e7       	ldi	r24, 0x7D	; 125
     330:	92 e0       	ldi	r25, 0x02	; 2
     332:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     336:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <reset>
     33a:	88 23       	and	r24, r24
     33c:	09 f4       	brne	.+2      	; 0x340 <oneWireLeft+0x16>
     33e:	4d c0       	rjmp	.+154    	; 0x3da <oneWireLeft+0xb0>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     340:	85 e5       	ldi	r24, 0x55	; 85
     342:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		// 64-bit ROM CODE
		write_byte(0x10);	// Byte 0
     346:	80 e1       	ldi	r24, 0x10	; 16
     348:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0xDB);	// Byte 1
     34c:	8b ed       	ldi	r24, 0xDB	; 219
     34e:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0x09);	// Byte 2
     352:	89 e0       	ldi	r24, 0x09	; 9
     354:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0xA5);	// Byte 3
     358:	85 ea       	ldi	r24, 0xA5	; 165
     35a:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0x01);	// Byte 4
     35e:	81 e0       	ldi	r24, 0x01	; 1
     360:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0x08);	// Byte 5
     364:	88 e0       	ldi	r24, 0x08	; 8
     366:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0x00);	// Byte 6
     36a:	80 e0       	ldi	r24, 0x00	; 0
     36c:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0xC1);	// Byte 7
     370:	81 ec       	ldi	r24, 0xC1	; 193
     372:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		// 64-bit ROM CODE

		write_byte(0x44);	// Master issues Convert T command.
     376:	84 e4       	ldi	r24, 0x44	; 68
     378:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     37c:	0e 94 54 05 	call	0xaa8	; 0xaa8 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     380:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <reset>
     384:	88 23       	and	r24, r24
     386:	49 f1       	breq	.+82     	; 0x3da <oneWireLeft+0xb0>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     388:	85 e5       	ldi	r24, 0x55	; 85
     38a:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			// 64-bit ROM CODE
			write_byte(0x10);	// Byte 0
     38e:	80 e1       	ldi	r24, 0x10	; 16
     390:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0xDB);	// Byte 1
     394:	8b ed       	ldi	r24, 0xDB	; 219
     396:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0x09);	// Byte 2
     39a:	89 e0       	ldi	r24, 0x09	; 9
     39c:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0xA5);	// Byte 3
     3a0:	85 ea       	ldi	r24, 0xA5	; 165
     3a2:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0x01);	// Byte 4
     3a6:	81 e0       	ldi	r24, 0x01	; 1
     3a8:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0x08);	// Byte 5
     3ac:	88 e0       	ldi	r24, 0x08	; 8
     3ae:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0x00);	// Byte 6
     3b2:	80 e0       	ldi	r24, 0x00	; 0
     3b4:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0xC1);	// Byte 7
     3b8:	81 ec       	ldi	r24, 0xC1	; 193
     3ba:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
     3be:	8e eb       	ldi	r24, 0xBE	; 190
     3c0:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
     3c4:	c3 ef       	ldi	r28, 0xF3	; 243
     3c6:	d6 e0       	ldi	r29, 0x06	; 6
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     3c8:	0e 94 04 05 	call	0xa08	; 0xa08 <read_byte>
     3cc:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     3ce:	86 e0       	ldi	r24, 0x06	; 6
     3d0:	cc 3f       	cpi	r28, 0xFC	; 252
     3d2:	d8 07       	cpc	r29, r24
     3d4:	c9 f7       	brne	.-14     	; 0x3c8 <oneWireLeft+0x9e>
     3d6:	81 e0       	ldi	r24, 0x01	; 1
     3d8:	01 c0       	rjmp	.+2      	; 0x3dc <oneWireLeft+0xb2>
     3da:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     3dc:	df 91       	pop	r29
     3de:	cf 91       	pop	r28
     3e0:	08 95       	ret

000003e2 <temperature>:

/*****************************
**** TEMPERATURE FUNCTION ****
*****************************/
void temperature()
{
     3e2:	cf 93       	push	r28
     3e4:	df 93       	push	r29
	unsigned char i;
//	LED_low_DISPLAYLED_high();
//	LCD_INIT();								// LCD INITIZLIZATION
	LCD_COMMAND(LCD_SELECT_1ROW);	// select row 1
     3e6:	80 e0       	ldi	r24, 0x00	; 0
     3e8:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
	LCD_DATA_STRING("    TEPERATURE    ");		//
     3ec:	8d eb       	ldi	r24, 0xBD	; 189
     3ee:	92 e0       	ldi	r25, 0x02	; 2
     3f0:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
     3f4:	80 ec       	ldi	r24, 0xC0	; 192
     3f6:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
	LCD_DATA_STRING("LEFT  SENSOR: ");				//
     3fa:	80 ed       	ldi	r24, 0xD0	; 208
     3fc:	92 e0       	ldi	r25, 0x02	; 2
     3fe:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>

	oneWireLeft();
     402:	0e 94 95 01 	call	0x32a	; 0x32a <oneWireLeft>
     406:	c0 e0       	ldi	r28, 0x00	; 0
     408:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] byte ");
     40a:	8f ed       	ldi	r24, 0xDF	; 223
     40c:	92 e0       	ldi	r25, 0x02	; 2
     40e:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartInt(i);
     412:	ce 01       	movw	r24, r28
     414:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <transmitUartInt>
	transmitUartString(" : ");
     418:	81 ef       	ldi	r24, 0xF1	; 241
     41a:	92 e0       	ldi	r25, 0x02	; 2
     41c:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartInt(storeTemp[i]);
     420:	fe 01       	movw	r30, r28
     422:	ed 50       	subi	r30, 0x0D	; 13
     424:	f9 4f       	sbci	r31, 0xF9	; 249
     426:	80 81       	ld	r24, Z
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <transmitUartInt>
	transmitUartString("\r\n");
     42e:	8e e3       	ldi	r24, 0x3E	; 62
     430:	91 e0       	ldi	r25, 0x01	; 1
     432:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
     436:	21 96       	adiw	r28, 0x01	; 1
	LCD_DATA_STRING("    TEPERATURE    ");		//
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
	LCD_DATA_STRING("LEFT  SENSOR: ");				//

	oneWireLeft();
	for(i=0; i<9; i++)
     438:	c9 30       	cpi	r28, 0x09	; 9
     43a:	d1 05       	cpc	r29, r1
     43c:	31 f7       	brne	.-52     	; 0x40a <temperature+0x28>
	transmitUartString(" : ");
	transmitUartInt(storeTemp[i]);
	transmitUartString("\r\n");
#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     43e:	80 91 10 07 	lds	r24, 0x0710
     442:	60 91 0c 07 	lds	r22, 0x070C
     446:	40 91 0b 07 	lds	r20, 0x070B
     44a:	20 91 08 07 	lds	r18, 0x0708
     44e:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
     452:	84 e9       	ldi	r24, 0x94	; 148
     454:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
     458:	85 ef       	ldi	r24, 0xF5	; 245
     45a:	92 e0       	ldi	r25, 0x02	; 2
     45c:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
	oneWireRight();
     460:	0e 94 39 01 	call	0x272	; 0x272 <oneWireRight>
     464:	c0 e0       	ldi	r28, 0x00	; 0
     466:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] byte ");
     468:	8f ed       	ldi	r24, 0xDF	; 223
     46a:	92 e0       	ldi	r25, 0x02	; 2
     46c:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartInt(i);
     470:	ce 01       	movw	r24, r28
     472:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <transmitUartInt>
	transmitUartString(" : ");
     476:	81 ef       	ldi	r24, 0xF1	; 241
     478:	92 e0       	ldi	r25, 0x02	; 2
     47a:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartInt(storeTemp[i]);
     47e:	fe 01       	movw	r30, r28
     480:	ed 50       	subi	r30, 0x0D	; 13
     482:	f9 4f       	sbci	r31, 0xF9	; 249
     484:	80 81       	ld	r24, Z
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <transmitUartInt>
	transmitUartString("\r\n");
     48c:	8e e3       	ldi	r24, 0x3E	; 62
     48e:	91 e0       	ldi	r25, 0x01	; 1
     490:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
     494:	21 96       	adiw	r28, 0x01	; 1
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
	oneWireRight();
	for(i=0; i<9; i++)
     496:	c9 30       	cpi	r28, 0x09	; 9
     498:	d1 05       	cpc	r29, r1
     49a:	31 f7       	brne	.-52     	; 0x468 <temperature+0x86>
	transmitUartString(" : ");
	transmitUartInt(storeTemp[i]);
	transmitUartString("\r\n");
#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     49c:	80 91 10 07 	lds	r24, 0x0710
     4a0:	60 91 0c 07 	lds	r22, 0x070C
     4a4:	40 91 0b 07 	lds	r20, 0x070B
     4a8:	20 91 08 07 	lds	r18, 0x0708
     4ac:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
     4b0:	84 ed       	ldi	r24, 0xD4	; 212
     4b2:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
	LCD_DATA_STRING("             DS18x20");		//
     4b6:	84 e0       	ldi	r24, 0x04	; 4
     4b8:	93 e0       	ldi	r25, 0x03	; 3
     4ba:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
}
     4be:	df 91       	pop	r29
     4c0:	cf 91       	pop	r28
     4c2:	08 95       	ret

000004c4 <ampliferOff>:
/*********************
**** AMPLIFER OFF ****
*********************/
void ampliferOff(void)
{
	flagStatusBits->flagPower = 0;		// flag for amplifer off
     4c4:	e0 91 0e 07 	lds	r30, 0x070E
     4c8:	f0 91 0f 07 	lds	r31, 0x070F
     4cc:	80 81       	ld	r24, Z
     4ce:	8e 7f       	andi	r24, 0xFE	; 254
     4d0:	80 83       	st	Z, r24

	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     4d2:	80 e0       	ldi	r24, 0x00	; 0
     4d4:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer Off    ");	// 20 symbols
     4d8:	89 e1       	ldi	r24, 0x19	; 25
     4da:	93 e0       	ldi	r25, 0x03	; 3
     4dc:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>

	LCD_COMMAND(LCD_OFF);						// LCD ON without CURSOR
     4e0:	88 e0       	ldi	r24, 0x08	; 8
     4e2:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>

//			FAN_low();		// PORTD5 - FAN OFF (logic "0")  NON PWM, NON TIMER1

// RELAYS OFF
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch off relays out for all 6 channels\r\n");		// uart debug information string
     4e6:	8e e2       	ldi	r24, 0x2E	; 46
     4e8:	93 e0       	ldi	r25, 0x03	; 3
     4ea:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
//	relays_out_off();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
//	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch off relays in for all 6 channels\r\n");		// uart debug information string
     4ee:	8c e6       	ldi	r24, 0x6C	; 108
     4f0:	93 e0       	ldi	r25, 0x03	; 3
     4f2:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
//	relays_in_off();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
//	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch off relays for power 220V\r\n");		// uart debug information string
     4f6:	89 ea       	ldi	r24, 0xA9	; 169
     4f8:	93 e0       	ldi	r25, 0x03	; 3
     4fa:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
//	REL_POWER_low();// RELAY POWER OFF				// PESHO COMMENT 14.08.2015, 21:10

#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Fan is off\r\n");
     4fe:	8f ed       	ldi	r24, 0xDF	; 223
     500:	93 e0       	ldi	r25, 0x03	; 3
     502:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
//	OCR1BL = 1; // LED PWM ON
}

void timer1_off()
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     506:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     508:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     50a:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     50c:	1a bc       	out	0x2a, r1	; 42
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Fan is off\r\n");
#endif
	FAN_PWM_OFF();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1

	LCD_CLEAR_CONTAIN();
     50e:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_CLEAR_CONTAIN>
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Display off and status led on\r\n");
     512:	88 ef       	ldi	r24, 0xF8	; 248
     514:	93 e0       	ldi	r25, 0x03	; 3
     516:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     51a:	94 9a       	sbi	0x12, 4	; 18
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Amplifer is off\r\n");
     51c:	84 e2       	ldi	r24, 0x24	; 36
     51e:	94 e0       	ldi	r25, 0x04	; 4
     520:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
     524:	88 e8       	ldi	r24, 0x88	; 136
     526:	93 e1       	ldi	r25, 0x13	; 19
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     528:	20 e9       	ldi	r18, 0x90	; 144
     52a:	31 e0       	ldi	r19, 0x01	; 1
     52c:	f9 01       	movw	r30, r18
     52e:	31 97       	sbiw	r30, 0x01	; 1
     530:	f1 f7       	brne	.-4      	; 0x52e <ampliferOff+0x6a>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     532:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     534:	d9 f7       	brne	.-10     	; 0x52c <ampliferOff+0x68>
#endif

	_delay_ms(500);	// izchakvane pri natiskane za izkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton
}
     536:	08 95       	ret

00000538 <ampliferOn>:
/********************
**** AMPLIFER ON ****
********************/
void ampliferOn(void)
{
	flagStatusBits->flagPower = 1;		// flag for amplifer on
     538:	e0 91 0e 07 	lds	r30, 0x070E
     53c:	f0 91 0f 07 	lds	r31, 0x070F
     540:	80 81       	ld	r24, Z
     542:	81 60       	ori	r24, 0x01	; 1
     544:	80 83       	st	Z, r24

#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Amplifer is on\r\n");
     546:	82 e4       	ldi	r24, 0x42	; 66
     548:	94 e0       	ldi	r25, 0x04	; 4
     54a:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Display on and status led off\r\n");
     54e:	8f e5       	ldi	r24, 0x5F	; 95
     550:	94 e0       	ldi	r25, 0x04	; 4
     552:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     556:	94 98       	cbi	0x12, 4	; 18

	LCD_CLEAR_CONTAIN();						// clear all contain on display
     558:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_CLEAR_CONTAIN>
	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     55c:	80 e0       	ldi	r24, 0x00	; 0
     55e:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer On     ");	// 20 symbols
     562:	8b e8       	ldi	r24, 0x8B	; 139
     564:	94 e0       	ldi	r25, 0x04	; 4
     566:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);				// select row 2
     56a:	80 ec       	ldi	r24, 0xC0	; 192
     56c:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
	LCD_DATA_STRING("P.UPINOV  P.STOYANOV");	// 20 symbols //	LCD_EXECUTE_DATA("P.UPINOV  P.STOYANOV",20);	// char "DATA", int 13 of chars of "DATA"
     570:	80 ea       	ldi	r24, 0xA0	; 160
     572:	94 e0       	ldi	r25, 0x04	; 4
     574:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     578:	8c e0       	ldi	r24, 0x0C	; 12
     57a:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>

#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Fan is on\r\n");
     57e:	85 eb       	ldi	r24, 0xB5	; 181
     580:	94 e0       	ldi	r25, 0x04	; 4
     582:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartString("[UART INFO] Fan is always on, it isn't sensitive to temperature, because DS18S20 is disabling\r\n");
     586:	8d ec       	ldi	r24, 0xCD	; 205
     588:	94 e0       	ldi	r25, 0x04	; 4
     58a:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
/***************************************
******** DEFINITIONS OF TIMER 1 ********
***************************************/
void timer1_on_speed1()
{
	TCCR1A = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     58e:	81 e8       	ldi	r24, 0x81	; 129
     590:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00010001;
     592:	81 e1       	ldi	r24, 0x11	; 17
     594:	8e bd       	out	0x2e, r24	; 46

	OCR1AH = 0; // FAN PWM ON
     596:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 1; // FAN PWM ON
     598:	81 e0       	ldi	r24, 0x01	; 1
     59a:	8a bd       	out	0x2a, r24	; 42
	FAN_PWM_SPEED1();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1
//	FAN_high();			// PORTD5 - FAN ON (logic "1")	NON PWM, NON TIMER1

// RELAYS ON
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch on relays for power 220V\r\n");		// uart debug information string
     59c:	8d e2       	ldi	r24, 0x2D	; 45
     59e:	95 e0       	ldi	r25, 0x05	; 5
     5a0:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
//	REL_POWER_high();// RELAY POWER ON TRAFs		// PESHO COMMENT 14.08.2015, 21:10
//	_delay_ms(4000);								// PESHO COMMENT 14.08.2015, 21:10
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch on relays in for all 6 channels\r\n");		// uart debug information string
     5a4:	82 e6       	ldi	r24, 0x62	; 98
     5a6:	95 e0       	ldi	r25, 0x05	; 5
     5a8:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
//	relays_in1_6ch();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
//	_delay_ms(700);									// PESHO COMMENT 14.08.2015, 21:10
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Try to switch on relays out for all 6 channels\r\n");		// uart debug information string
     5ac:	8e e9       	ldi	r24, 0x9E	; 158
     5ae:	95 e0       	ldi	r25, 0x05	; 5
     5b0:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
     5b4:	80 e1       	ldi	r24, 0x10	; 16
     5b6:	97 e2       	ldi	r25, 0x27	; 39
     5b8:	20 e9       	ldi	r18, 0x90	; 144
     5ba:	31 e0       	ldi	r19, 0x01	; 1
     5bc:	f9 01       	movw	r30, r18
     5be:	31 97       	sbiw	r30, 0x01	; 1
     5c0:	f1 f7       	brne	.-4      	; 0x5be <ampliferOn+0x86>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     5c2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     5c4:	d9 f7       	brne	.-10     	; 0x5bc <ampliferOn+0x84>
#endif
//	relays_out_6ch();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
	_delay_ms(1000);	// izchakvane pri natiskane za vkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton
}
     5c6:	08 95       	ret

000005c8 <commonEncoder>:
**********************************************/
void commonEncoder(void)	// not finished
{
	static signed char saveValue = 0;	// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!! static ???
	signed char temp = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     5c8:	0e 94 b2 08 	call	0x1164	; 0x1164 <rotaryEncoderNikBarzakov>
	if(0==temp)
     5cc:	88 23       	and	r24, r24
     5ce:	09 f4       	brne	.+2      	; 0x5d2 <commonEncoder+0xa>
     5d0:	4f c0       	rjmp	.+158    	; 0x670 <commonEncoder+0xa8>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     5d2:	8f 3f       	cpi	r24, 0xFF	; 255
     5d4:	41 f5       	brne	.+80     	; 0x626 <commonEncoder+0x5e>
	{
		// encoder is decrement
		if(saveValue < -127)
     5d6:	80 91 fd 06 	lds	r24, 0x06FD
     5da:	80 38       	cpi	r24, 0x80	; 128
     5dc:	11 f4       	brne	.+4      	; 0x5e2 <commonEncoder+0x1a>
		{
			saveValue = 127;	// SIGNED CHAR MIN VALUE = -127
     5de:	8f e7       	ldi	r24, 0x7F	; 127
     5e0:	01 c0       	rjmp	.+2      	; 0x5e4 <commonEncoder+0x1c>
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     5e2:	81 50       	subi	r24, 0x01	; 1
     5e4:	80 93 fd 06 	sts	0x06FD, r24
		}
// LCD PRINT VALUE
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     5e8:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     5ea:	8c e0       	ldi	r24, 0x0C	; 12
     5ec:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     5f0:	84 ed       	ldi	r24, 0xD4	; 212
     5f2:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
		if (saveValue > 99)
     5f6:	80 91 fd 06 	lds	r24, 0x06FD
     5fa:	84 36       	cpi	r24, 0x64	; 100
     5fc:	1c f0       	brlt	.+6      	; 0x604 <commonEncoder+0x3c>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     5fe:	8b ed       	ldi	r24, 0xDB	; 219
     600:	95 e0       	ldi	r25, 0x05	; 5
     602:	07 c0       	rjmp	.+14     	; 0x612 <commonEncoder+0x4a>
		}
		else if (saveValue > 9)
     604:	8a 30       	cpi	r24, 0x0A	; 10
     606:	1c f0       	brlt	.+6      	; 0x60e <commonEncoder+0x46>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     608:	84 ee       	ldi	r24, 0xE4	; 228
     60a:	95 e0       	ldi	r25, 0x05	; 5
     60c:	02 c0       	rjmp	.+4      	; 0x612 <commonEncoder+0x4a>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     60e:	8e ee       	ldi	r24, 0xEE	; 238
     610:	95 e0       	ldi	r25, 0x05	; 5
     612:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     616:	80 91 fd 06 	lds	r24, 0x06FD
     61a:	99 27       	eor	r25, r25
     61c:	87 fd       	sbrc	r24, 7
     61e:	90 95       	com	r25
     620:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <LCD_DATA_INT>
     624:	08 95       	ret
	}
	else if(1==temp)
     626:	81 30       	cpi	r24, 0x01	; 1
     628:	19 f5       	brne	.+70     	; 0x670 <commonEncoder+0xa8>
		{
			saveValue = 128;	// SIGNED CHAR MAX VALUE = +128
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     62a:	80 91 fd 06 	lds	r24, 0x06FD
     62e:	8f 5f       	subi	r24, 0xFF	; 255
     630:	80 93 fd 06 	sts	0x06FD, r24
		}

	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     634:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     636:	8c e0       	ldi	r24, 0x0C	; 12
     638:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     63c:	84 ed       	ldi	r24, 0xD4	; 212
     63e:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
		if (saveValue > 99)
     642:	80 91 fd 06 	lds	r24, 0x06FD
     646:	84 36       	cpi	r24, 0x64	; 100
     648:	1c f0       	brlt	.+6      	; 0x650 <commonEncoder+0x88>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     64a:	8b ed       	ldi	r24, 0xDB	; 219
     64c:	95 e0       	ldi	r25, 0x05	; 5
     64e:	07 c0       	rjmp	.+14     	; 0x65e <commonEncoder+0x96>
		}
		else if (saveValue > 9)
     650:	8a 30       	cpi	r24, 0x0A	; 10
     652:	1c f0       	brlt	.+6      	; 0x65a <commonEncoder+0x92>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     654:	84 ee       	ldi	r24, 0xE4	; 228
     656:	95 e0       	ldi	r25, 0x05	; 5
     658:	02 c0       	rjmp	.+4      	; 0x65e <commonEncoder+0x96>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     65a:	8e ee       	ldi	r24, 0xEE	; 238
     65c:	95 e0       	ldi	r25, 0x05	; 5
     65e:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     662:	80 91 fd 06 	lds	r24, 0x06FD
     666:	99 27       	eor	r25, r25
     668:	87 fd       	sbrc	r24, 7
     66a:	90 95       	com	r25
     66c:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <LCD_DATA_INT>
     670:	08 95       	ret

00000672 <volumeUpdate>:
/*************************************
**** VOLUME UPDATE and LCD UPDATE ****
*************************************/
void volumeUpdate(void)
{
	PGA2310_Volume_Update(volumeValue[volumeIndex], volumeValue[volumeIndex]);	// update volume value on all channels
     672:	e0 91 f2 06 	lds	r30, 0x06F2
     676:	f0 e0       	ldi	r31, 0x00	; 0
     678:	e2 5f       	subi	r30, 0xF2	; 242
     67a:	f9 4f       	sbci	r31, 0xF9	; 249
     67c:	60 81       	ld	r22, Z
     67e:	86 2f       	mov	r24, r22
     680:	0e 94 24 07 	call	0xe48	; 0xe48 <PGA2310_Volume_Update>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     684:	84 ed       	ldi	r24, 0xD4	; 212
     686:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
//		LCD_DATA_STRING("Volume: ");	// 20 symbols
	if (volumeIndex > 9)
     68a:	80 91 f2 06 	lds	r24, 0x06F2
     68e:	8a 30       	cpi	r24, 0x0A	; 10
     690:	18 f0       	brcs	.+6      	; 0x698 <volumeUpdate+0x26>
	{
		LCD_DATA_STRING("Volume: ");	// 20 symbols
     692:	8b ed       	ldi	r24, 0xDB	; 219
     694:	95 e0       	ldi	r25, 0x05	; 5
     696:	02 c0       	rjmp	.+4      	; 0x69c <volumeUpdate+0x2a>
	}
	else
	{
		LCD_DATA_STRING("Volume: 0");	// 20 symbols
     698:	84 ee       	ldi	r24, 0xE4	; 228
     69a:	95 e0       	ldi	r25, 0x05	; 5
     69c:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
	}
	LCD_DATA_INT(volumeIndex);			// 20 symbols
     6a0:	80 91 f2 06 	lds	r24, 0x06F2
     6a4:	90 e0       	ldi	r25, 0x00	; 0
     6a6:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <LCD_DATA_INT>
#ifdef DEBUG_INFO
	transmitUartString("[UART INFO] Volume: ");		// uart debug information string
     6aa:	89 ef       	ldi	r24, 0xF9	; 249
     6ac:	95 e0       	ldi	r25, 0x05	; 5
     6ae:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
	transmitUartInt(volumeIndex);		// uart debug information string 
     6b2:	80 91 f2 06 	lds	r24, 0x06F2
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <transmitUartInt>
	transmitUartString("\r\n");			// uart debug information string
     6bc:	8e e3       	ldi	r24, 0x3E	; 62
     6be:	91 e0       	ldi	r25, 0x01	; 1
     6c0:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
}
     6c4:	08 95       	ret

000006c6 <volumeProcess>:
**** VOLUME PROCESS FUNCTION ****
********************************/
void volumeProcess(void)
{
	signed char temp = 0;//, tempEnc = 0, tempRem = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     6c6:	0e 94 b2 08 	call	0x1164	; 0x1164 <rotaryEncoderNikBarzakov>
//	tempRem = remoteVolume();
	if(0==temp)
     6ca:	88 23       	and	r24, r24
     6cc:	e1 f0       	breq	.+56     	; 0x706 <volumeProcess+0x40>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     6ce:	8f 3f       	cpi	r24, 0xFF	; 255
     6d0:	69 f4       	brne	.+26     	; 0x6ec <volumeProcess+0x26>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MIN + 1))
     6d2:	80 91 f2 06 	lds	r24, 0x06F2
     6d6:	88 23       	and	r24, r24
     6d8:	19 f4       	brne	.+6      	; 0x6e0 <volumeProcess+0x1a>
		{
			volumeIndex = VOLUME_MIN;
     6da:	10 92 f2 06 	sts	0x06F2, r1
     6de:	03 c0       	rjmp	.+6      	; 0x6e6 <volumeProcess+0x20>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     6e0:	81 50       	subi	r24, 0x01	; 1
     6e2:	80 93 f2 06 	sts	0x06F2, r24
		}
		volumeUpdate();
     6e6:	0e 94 39 03 	call	0x672	; 0x672 <volumeUpdate>
     6ea:	08 95       	ret
	}
	else if(1==temp)
     6ec:	81 30       	cpi	r24, 0x01	; 1
     6ee:	59 f4       	brne	.+22     	; 0x706 <volumeProcess+0x40>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_MAX - 2))
     6f0:	80 91 f2 06 	lds	r24, 0x06F2
     6f4:	83 31       	cpi	r24, 0x13	; 19
     6f6:	10 f0       	brcs	.+4      	; 0x6fc <volumeProcess+0x36>
		{
			volumeIndex = (VOLUME_MAX - 1);
     6f8:	83 e1       	ldi	r24, 0x13	; 19
     6fa:	01 c0       	rjmp	.+2      	; 0x6fe <volumeProcess+0x38>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     6fc:	8f 5f       	subi	r24, 0xFF	; 255
     6fe:	80 93 f2 06 	sts	0x06F2, r24
		}
		volumeUpdate();
     702:	0e 94 39 03 	call	0x672	; 0x672 <volumeUpdate>
     706:	08 95       	ret

00000708 <buttons_press>:


}

void buttons_press()
{
     708:	cf 93       	push	r28
     70a:	df 93       	push	r29
	flagStatusBits = &fSB;
     70c:	86 e1       	ldi	r24, 0x16	; 22
     70e:	97 e0       	ldi	r25, 0x07	; 7
     710:	90 93 0f 07 	sts	0x070F, r25
     714:	80 93 0e 07 	sts	0x070E, r24
	flagStatusBits->flagPower=0;	// inicializirane s nuli, no nai veroqtno poradi tova che e globalna stru
     718:	80 91 16 07 	lds	r24, 0x0716
	flagStatusBits->flagMute=0;		// inicializirane
     71c:	8c 7f       	andi	r24, 0xFC	; 252
     71e:	80 93 16 07 	sts	0x0716, r24
     722:	c0 e9       	ldi	r28, 0x90	; 144
     724:	d1 e0       	ldi	r29, 0x01	; 1
		LCD_DATA_INT(flagStatusBits->flagMute);		// 20 symbols
	_delay_ms(2000);
*/
	while(1)
	{
		if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)	// obj ptr flagStatusBtnRegister from struct flagStatusBtnOnOff
     726:	b1 99       	sbic	0x16, 1	; 22
     728:	0a c0       	rjmp	.+20     	; 0x73e <buttons_press+0x36>
     72a:	e0 91 0e 07 	lds	r30, 0x070E
     72e:	f0 91 0f 07 	lds	r31, 0x070F
     732:	80 81       	ld	r24, Z
     734:	80 fd       	sbrc	r24, 0
     736:	03 c0       	rjmp	.+6      	; 0x73e <buttons_press+0x36>
		{
//			flagStatusBits->flagPower = 1;			// filter za buton ON
			ampliferOn();
     738:	0e 94 9c 02 	call	0x538	; 0x538 <ampliferOn>
     73c:	f4 cf       	rjmp	.-24     	; 0x726 <buttons_press+0x1e>
//			_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
		}
		else if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     73e:	b1 99       	sbic	0x16, 1	; 22
     740:	0a c0       	rjmp	.+20     	; 0x756 <buttons_press+0x4e>
     742:	e0 91 0e 07 	lds	r30, 0x070E
     746:	f0 91 0f 07 	lds	r31, 0x070F
     74a:	80 81       	ld	r24, Z
     74c:	80 ff       	sbrs	r24, 0
     74e:	03 c0       	rjmp	.+6      	; 0x756 <buttons_press+0x4e>
		{
//			flagStatusBits->flagPower = 0;			// filter za buton OFF
			ampliferOff();
     750:	0e 94 62 02 	call	0x4c4	; 0x4c4 <ampliferOff>
     754:	e8 cf       	rjmp	.-48     	; 0x726 <buttons_press+0x1e>
		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     756:	b2 99       	sbic	0x16, 2	; 22
     758:	11 c0       	rjmp	.+34     	; 0x77c <buttons_press+0x74>
     75a:	e0 91 0e 07 	lds	r30, 0x070E
     75e:	f0 91 0f 07 	lds	r31, 0x070F
     762:	80 81       	ld	r24, Z
     764:	80 ff       	sbrs	r24, 0
     766:	0a c0       	rjmp	.+20     	; 0x77c <buttons_press+0x74>
		{
//			LCD_DATA_STRING("PRESSED BTN ESCAPE  ");	// 20 symbols
//			LCD_COMMAND(LCD_ON);
			LCD_CLEAR_CONTAIN();
     768:	0e 94 3e 06 	call	0xc7c	; 0xc7c <LCD_CLEAR_CONTAIN>
     76c:	88 e8       	ldi	r24, 0x88	; 136
     76e:	93 e1       	ldi	r25, 0x13	; 19
     770:	fe 01       	movw	r30, r28
     772:	31 97       	sbiw	r30, 0x01	; 1
     774:	f1 f7       	brne	.-4      	; 0x772 <buttons_press+0x6a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     776:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     778:	d9 f7       	brne	.-10     	; 0x770 <buttons_press+0x68>
     77a:	d5 cf       	rjmp	.-86     	; 0x726 <buttons_press+0x1e>
			_delay_ms(500);
//			volumeUp();
//			_delay_ms(200);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     77c:	83 99       	sbic	0x10, 3	; 16
     77e:	0f c0       	rjmp	.+30     	; 0x79e <buttons_press+0x96>
     780:	e0 91 0e 07 	lds	r30, 0x070E
     784:	f0 91 0f 07 	lds	r31, 0x070F
     788:	80 81       	ld	r24, Z
     78a:	80 ff       	sbrs	r24, 0
     78c:	08 c0       	rjmp	.+16     	; 0x79e <buttons_press+0x96>
     78e:	88 e8       	ldi	r24, 0x88	; 136
     790:	93 e1       	ldi	r25, 0x13	; 19
     792:	fe 01       	movw	r30, r28
     794:	31 97       	sbiw	r30, 0x01	; 1
     796:	f1 f7       	brne	.-4      	; 0x794 <buttons_press+0x8c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     798:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     79a:	d9 f7       	brne	.-10     	; 0x792 <buttons_press+0x8a>
     79c:	c4 cf       	rjmp	.-120    	; 0x726 <buttons_press+0x1e>
			_delay_ms(500);
//			volumeDown();
//			_delay_ms(200);

		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     79e:	b2 99       	sbic	0x16, 2	; 22
     7a0:	0f c0       	rjmp	.+30     	; 0x7c0 <buttons_press+0xb8>
     7a2:	e0 91 0e 07 	lds	r30, 0x070E
     7a6:	f0 91 0f 07 	lds	r31, 0x070F
     7aa:	80 81       	ld	r24, Z
     7ac:	80 fd       	sbrc	r24, 0
     7ae:	08 c0       	rjmp	.+16     	; 0x7c0 <buttons_press+0xb8>
     7b0:	88 e8       	ldi	r24, 0x88	; 136
     7b2:	93 e1       	ldi	r25, 0x13	; 19
     7b4:	fe 01       	movw	r30, r28
     7b6:	31 97       	sbiw	r30, 0x01	; 1
     7b8:	f1 f7       	brne	.-4      	; 0x7b6 <buttons_press+0xae>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7ba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7bc:	d9 f7       	brne	.-10     	; 0x7b4 <buttons_press+0xac>
     7be:	b3 cf       	rjmp	.-154    	; 0x726 <buttons_press+0x1e>
//			LCD_COMMAND(LCD_ON);
			_delay_ms(500);
//			setupMode();
//			_delay_ms(1000);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     7c0:	83 99       	sbic	0x10, 3	; 16
     7c2:	11 c0       	rjmp	.+34     	; 0x7e6 <buttons_press+0xde>
     7c4:	e0 91 0e 07 	lds	r30, 0x070E
     7c8:	f0 91 0f 07 	lds	r31, 0x070F
     7cc:	80 81       	ld	r24, Z
     7ce:	80 fd       	sbrc	r24, 0
     7d0:	0a c0       	rjmp	.+20     	; 0x7e6 <buttons_press+0xde>
		{
			temperature();
     7d2:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <temperature>
     7d6:	88 e8       	ldi	r24, 0x88	; 136
     7d8:	93 e1       	ldi	r25, 0x13	; 19
     7da:	fe 01       	movw	r30, r28
     7dc:	31 97       	sbiw	r30, 0x01	; 1
     7de:	f1 f7       	brne	.-4      	; 0x7dc <buttons_press+0xd4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7e0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7e2:	d9 f7       	brne	.-10     	; 0x7da <buttons_press+0xd2>
     7e4:	a0 cf       	rjmp	.-192    	; 0x726 <buttons_press+0x1e>
//			LCD_COMMAND(LCD_OFF);
			_delay_ms(500);
//			about();
//			_delay_ms(1000);
		}
		else if(flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     7e6:	e0 91 0e 07 	lds	r30, 0x070E
     7ea:	f0 91 0f 07 	lds	r31, 0x070F
     7ee:	80 81       	ld	r24, Z
     7f0:	80 ff       	sbrs	r24, 0
     7f2:	03 c0       	rjmp	.+6      	; 0x7fa <buttons_press+0xf2>
		{
			volumeProcess();
     7f4:	0e 94 63 03 	call	0x6c6	; 0x6c6 <volumeProcess>
     7f8:	96 cf       	rjmp	.-212    	; 0x726 <buttons_press+0x1e>
		}
		else if(flagStatusBits->flagPower == 0)
		{
			commonEncoder();
     7fa:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <commonEncoder>
     7fe:	93 cf       	rjmp	.-218    	; 0x726 <buttons_press+0x1e>

00000800 <main>:
******************************** START OF MAIN APPLICATION **********************************
********************************************************************************************/

int main(void)
{
	init_all();				// inicializacia na vsichko
     800:	0e 94 de 00 	call	0x1bc	; 0x1bc <init_all>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     804:	80 e4       	ldi	r24, 0x40	; 64
     806:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     808:	8a bf       	out	0x3a, r24	; 58
{
	init_all();				// inicializacia na vsichko
	ext0_intrpt_on();		// ENABLE interrupts to access IR DETECTION as call to function "IR_DECODER()" for -> SONY IR REMOTE
//	ext2_intrpt_on();

	sei();							// file "avr/interrupt.h"
     80a:	78 94       	sei
//	SREG = (1<<I);

	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     80c:	94 9a       	sbi	0x12, 4	; 18
	while(1)
	{		
		buttons_press();	// izchakvane za natiskane na buton
     80e:	0e 94 84 03 	call	0x708	; 0x708 <buttons_press>
     812:	fd cf       	rjmp	.-6      	; 0x80e <main+0xe>

00000814 <irDecode>:
************************************/
void irDecode(void)
{
//	byte byteSS0, byteSS1, byteMM0, byteMM1, byteHH0, byteHH1, byteDD0, byteDD1, byteMont0, byteMont1, byteYY0, byteYY1; // variables for convert DEC to BCD for LCD and UART for Time and Date

	GetSIRC12();
     814:	0e 94 5e 09 	call	0x12bc	; 0x12bc <GetSIRC12>
	if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 0)		// IR POWER -> ON
     818:	90 91 12 07 	lds	r25, 0x0712
     81c:	91 30       	cpi	r25, 0x01	; 1
     81e:	29 f4       	brne	.+10     	; 0x82a <irDecode+0x16>
     820:	80 91 0d 07 	lds	r24, 0x070D
     824:	85 31       	cpi	r24, 0x15	; 21
     826:	99 f4       	brne	.+38     	; 0x84e <irDecode+0x3a>
     828:	06 c0       	rjmp	.+12     	; 0x836 <irDecode+0x22>
     82a:	94 30       	cpi	r25, 0x04	; 4
     82c:	21 f5       	brne	.+72     	; 0x876 <__stack+0x17>
     82e:	80 91 0d 07 	lds	r24, 0x070D
     832:	8d 30       	cpi	r24, 0x0D	; 13
     834:	99 f4       	brne	.+38     	; 0x85c <irDecode+0x48>
     836:	e0 91 0e 07 	lds	r30, 0x070E
     83a:	f0 91 0f 07 	lds	r31, 0x070F
     83e:	80 81       	ld	r24, Z
     840:	80 fd       	sbrc	r24, 0
     842:	03 c0       	rjmp	.+6      	; 0x84a <irDecode+0x36>
	{		
		ampliferOn();
     844:	0e 94 9c 02 	call	0x538	; 0x538 <ampliferOn>
     848:	16 c0       	rjmp	.+44     	; 0x876 <__stack+0x17>
//		_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 1)	// IR POWER -> OFF
     84a:	91 30       	cpi	r25, 0x01	; 1
     84c:	29 f4       	brne	.+10     	; 0x858 <irDecode+0x44>
     84e:	80 91 0d 07 	lds	r24, 0x070D
     852:	85 31       	cpi	r24, 0x15	; 21
     854:	81 f4       	brne	.+32     	; 0x876 <__stack+0x17>
     856:	06 c0       	rjmp	.+12     	; 0x864 <__stack+0x5>
     858:	94 30       	cpi	r25, 0x04	; 4
     85a:	69 f4       	brne	.+26     	; 0x876 <__stack+0x17>
     85c:	80 91 0d 07 	lds	r24, 0x070D
     860:	8d 30       	cpi	r24, 0x0D	; 13
     862:	49 f4       	brne	.+18     	; 0x876 <__stack+0x17>
     864:	e0 91 0e 07 	lds	r30, 0x070E
     868:	f0 91 0f 07 	lds	r31, 0x070F
     86c:	80 81       	ld	r24, Z
     86e:	80 ff       	sbrs	r24, 0
     870:	02 c0       	rjmp	.+4      	; 0x876 <__stack+0x17>
	{
		ampliferOff();
     872:	0e 94 62 02 	call	0x4c4	; 0x4c4 <ampliferOff>
     876:	80 ed       	ldi	r24, 0xD0	; 208
     878:	97 e0       	ldi	r25, 0x07	; 7
     87a:	20 e9       	ldi	r18, 0x90	; 144
     87c:	31 e0       	ldi	r19, 0x01	; 1
     87e:	f9 01       	movw	r30, r18
     880:	31 97       	sbiw	r30, 0x01	; 1
     882:	f1 f7       	brne	.-4      	; 0x880 <__stack+0x21>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     884:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     886:	d9 f7       	brne	.-10     	; 0x87e <__stack+0x1f>
	else
	{
		// DO NOTING
	}
	_delay_ms(200);
}
     888:	08 95       	ret

0000088a <__vector_1>:

/*****************************************
**** EXTERNAL INTERRUPT 0 VECTOR 01 ******
*****************************************/
ISR(INT0_vect)
{
     88a:	1f 92       	push	r1
     88c:	0f 92       	push	r0
     88e:	0f b6       	in	r0, 0x3f	; 63
     890:	0f 92       	push	r0
     892:	11 24       	eor	r1, r1
     894:	2f 93       	push	r18
     896:	3f 93       	push	r19
     898:	4f 93       	push	r20
     89a:	5f 93       	push	r21
     89c:	6f 93       	push	r22
     89e:	7f 93       	push	r23
     8a0:	8f 93       	push	r24
     8a2:	9f 93       	push	r25
     8a4:	af 93       	push	r26
     8a6:	bf 93       	push	r27
     8a8:	ef 93       	push	r30
     8aa:	ff 93       	push	r31
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     8ac:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     8ae:	80 e4       	ldi	r24, 0x40	; 64
     8b0:	8a bf       	out	0x3a, r24	; 58
	ext0_intrpt_off();	// DISABLE new IR DETECTION

// LOGIC CHECK BEGIN
// VERIFY PRESSED IR BUTTON and switch to low line of IR pin PD2
	unsigned char low_level = 0;
    if(irPin == 0)
     8b2:	82 99       	sbic	0x10, 2	; 16
     8b4:	0b c0       	rjmp	.+22     	; 0x8cc <__vector_1+0x42>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     8b6:	8a e0       	ldi	r24, 0x0A	; 10
     8b8:	98 2f       	mov	r25, r24
     8ba:	9a 95       	dec	r25
     8bc:	f1 f7       	brne	.-4      	; 0x8ba <__vector_1+0x30>
     8be:	98 2f       	mov	r25, r24
     8c0:	9a 95       	dec	r25
     8c2:	f1 f7       	brne	.-4      	; 0x8c0 <__vector_1+0x36>
     8c4:	8a 95       	dec	r24
     8c6:	f1 f7       	brne	.-4      	; 0x8c4 <__vector_1+0x3a>
			_delay_us(2);	//2uS delay
		}

		if(low_level == 3)
		{
			irDecode();
     8c8:	0e 94 0a 04 	call	0x814	; 0x814 <irDecode>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     8cc:	80 e4       	ldi	r24, 0x40	; 64
     8ce:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     8d0:	8a bf       	out	0x3a, r24	; 58
		}
    }
// LOGIC CHECK END

	ext0_intrpt_on();	// ENABLE new IR DETECTION
}
     8d2:	ff 91       	pop	r31
     8d4:	ef 91       	pop	r30
     8d6:	bf 91       	pop	r27
     8d8:	af 91       	pop	r26
     8da:	9f 91       	pop	r25
     8dc:	8f 91       	pop	r24
     8de:	7f 91       	pop	r23
     8e0:	6f 91       	pop	r22
     8e2:	5f 91       	pop	r21
     8e4:	4f 91       	pop	r20
     8e6:	3f 91       	pop	r19
     8e8:	2f 91       	pop	r18
     8ea:	0f 90       	pop	r0
     8ec:	0f be       	out	0x3f, r0	; 63
     8ee:	0f 90       	pop	r0
     8f0:	1f 90       	pop	r1
     8f2:	18 95       	reti

000008f4 <eeprom_24c64_read>:
	// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
	// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !
	
	byte eepromReceiveByte0, eepromReceiveByte1, eepromReceiveByte2, eepromReceiveByte3, eepromReceiveByte4, eepromReceiveByte5;
// EEPROM READ
	i2c_start();
     8f4:	0e 94 88 05 	call	0xb10	; 0xb10 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);		// EEPROM 24C64 ADDRESS ACCESS WRITE
     8f8:	80 ea       	ldi	r24, 0xA0	; 160
     8fa:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     8fe:	80 e0       	ldi	r24, 0x00	; 0
     900:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     904:	80 e0       	ldi	r24, 0x00	; 0
     906:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>

	i2c_start();
     90a:	0e 94 88 05 	call	0xb10	; 0xb10 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_READ);		// EEPROM 24C64 ADDRESS ACCESS READ
     90e:	81 ea       	ldi	r24, 0xA1	; 161
     910:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
	eepromReceiveByte0	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     914:	80 e0       	ldi	r24, 0x00	; 0
     916:	0e 94 98 05 	call	0xb30	; 0xb30 <i2c_read>
	eepromReceiveByte1	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     91a:	80 e0       	ldi	r24, 0x00	; 0
     91c:	0e 94 98 05 	call	0xb30	; 0xb30 <i2c_read>
	eepromReceiveByte2	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     920:	80 e0       	ldi	r24, 0x00	; 0
     922:	0e 94 98 05 	call	0xb30	; 0xb30 <i2c_read>
	eepromReceiveByte3	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     926:	80 e0       	ldi	r24, 0x00	; 0
     928:	0e 94 98 05 	call	0xb30	; 0xb30 <i2c_read>
	eepromReceiveByte4	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     92c:	80 e0       	ldi	r24, 0x00	; 0
     92e:	0e 94 98 05 	call	0xb30	; 0xb30 <i2c_read>
	eepromReceiveByte5	= i2c_read(1);				// EEPROM DATA READ BYTE	// i2c_read(1) parametar razlichen ot 0 spira komunikaciqta NACK
     932:	81 e0       	ldi	r24, 0x01	; 1
     934:	0e 94 98 05 	call	0xb30	; 0xb30 <i2c_read>
	i2c_stop();
     938:	0e 94 8e 05 	call	0xb1c	; 0xb1c <i2c_stop>
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte2);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte3);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte4);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte5);
*/
}
     93c:	08 95       	ret

0000093e <eeprom_24c64_write>:
// Za da se vijda tova koeto se e zapisalo v pametta, a ne ot tozi bibliotechen fail !!!!!!!!!
// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !

// EEPROM WRITE
	i2c_start();
     93e:	0e 94 88 05 	call	0xb10	; 0xb10 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     942:	80 ea       	ldi	r24, 0xA0	; 160
     944:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     948:	80 e0       	ldi	r24, 0x00	; 0
     94a:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     94e:	80 e0       	ldi	r24, 0x00	; 0
     950:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
// Write data
	i2c_write(0x30);	// Data is stored: 0x30 - '0'
     954:	80 e3       	ldi	r24, 0x30	; 48
     956:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
	i2c_write(0x31);	// Data is stored: 0x31 - '1'
     95a:	81 e3       	ldi	r24, 0x31	; 49
     95c:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
	i2c_write(0x32);	// Data is stored: 0x32 - '2'
     960:	82 e3       	ldi	r24, 0x32	; 50
     962:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
	i2c_write(0x33);	// Data is stored: 0x33 - '3'
     966:	83 e3       	ldi	r24, 0x33	; 51
     968:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
	i2c_write(0x34);	// Data is stored: 0x34 - '4'
     96c:	84 e3       	ldi	r24, 0x34	; 52
     96e:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
	i2c_stop();
     972:	0e 94 8e 05 	call	0xb1c	; 0xb1c <i2c_stop>
}
     976:	08 95       	ret

00000978 <eeprom_24c64_reset>:

/*************************************
** RESET AND ZERO FILL EEPROM 24C64 **
*************************************/
void eeprom_24c64_reset()
{
     978:	cf 93       	push	r28
     97a:	df 93       	push	r29
	unsigned int i;	// 16 bits
// EEPROM WRITE
	i2c_start();
     97c:	0e 94 88 05 	call	0xb10	; 0xb10 <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     980:	80 ea       	ldi	r24, 0xA0	; 160
     982:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     986:	80 e0       	ldi	r24, 0x00	; 0
     988:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     98c:	80 e0       	ldi	r24, 0x00	; 0
     98e:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
     992:	c0 e0       	ldi	r28, 0x00	; 0
     994:	d0 e0       	ldi	r29, 0x00	; 0
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
     996:	80 e0       	ldi	r24, 0x00	; 0
     998:	0e 94 91 05 	call	0xb22	; 0xb22 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
     99c:	21 96       	adiw	r28, 0x01	; 1
     99e:	8f e1       	ldi	r24, 0x1F	; 31
     9a0:	cf 3f       	cpi	r28, 0xFF	; 255
     9a2:	d8 07       	cpc	r29, r24
     9a4:	c1 f7       	brne	.-16     	; 0x996 <eeprom_24c64_reset+0x1e>
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
	}
	i2c_stop();
     9a6:	0e 94 8e 05 	call	0xb1c	; 0xb1c <i2c_stop>
}
     9aa:	df 91       	pop	r29
     9ac:	cf 91       	pop	r28
     9ae:	08 95       	ret

000009b0 <reset>:
}
*/

unsigned char reset(void)
{
    DDRx |= (1<<Px);            //Ausgang
     9b0:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     9b2:	c0 98       	cbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     9b4:	80 e8       	ldi	r24, 0x80	; 128
     9b6:	97 e0       	ldi	r25, 0x07	; 7
     9b8:	01 97       	sbiw	r24, 0x01	; 1
     9ba:	f1 f7       	brne	.-4      	; 0x9b8 <reset+0x8>
    _delay_us(480);
	DDRx &= ~(1<<Px);
     9bc:	b8 98       	cbi	0x17, 0	; 23
     9be:	80 e4       	ldi	r24, 0x40	; 64
     9c0:	91 e0       	ldi	r25, 0x01	; 1
     9c2:	01 97       	sbiw	r24, 0x01	; 1
     9c4:	f1 f7       	brne	.-4      	; 0x9c2 <reset+0x12>
    _delay_us(80);
	if(!(PINx & (1<<Px)))     //Prüfe Slave-Antwort
     9c6:	b0 9b       	sbis	0x16, 0	; 22
     9c8:	02 c0       	rjmp	.+4      	; 0x9ce <reset+0x1e>
     9ca:	80 e0       	ldi	r24, 0x00	; 0
     9cc:	08 95       	ret
     9ce:	88 e0       	ldi	r24, 0x08	; 8
     9d0:	97 e0       	ldi	r25, 0x07	; 7
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	f1 f7       	brne	.-4      	; 0x9d2 <reset+0x22>
     9d6:	81 e0       	ldi	r24, 0x01	; 1
	}
    else
	{
        return 0;
	}
}
     9d8:	08 95       	ret

000009da <read_bit>:

unsigned char read_bit(void)
{
    DDRx |= (1<<Px);            //Ausgang
     9da:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     9dc:	c0 98       	cbi	0x18, 0	; 24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     9de:	85 e0       	ldi	r24, 0x05	; 5
     9e0:	8a 95       	dec	r24
     9e2:	f1 f7       	brne	.-4      	; 0x9e0 <read_bit+0x6>
    _delay_us(1);
	DDRx &= ~(1<<Px);
     9e4:	b8 98       	cbi	0x17, 0	; 23
     9e6:	80 e4       	ldi	r24, 0x40	; 64
     9e8:	8a 95       	dec	r24
     9ea:	f1 f7       	brne	.-4      	; 0x9e8 <read_bit+0xe>
    _delay_us(12);
    if(!(PINx & (1<<Px)))       //Abtastung innerhalb von 15µs
     9ec:	86 b3       	in	r24, 0x16	; 22
	}
	else
    {
		return 1;
	}
}
     9ee:	81 70       	andi	r24, 0x01	; 1
     9f0:	08 95       	ret

000009f2 <write_bit>:

void write_bit(unsigned char bitval)    //kann 0 oder 1 sein
{
    DDRx |= (1<<Px);            //Ausgang
     9f2:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     9f4:	c0 98       	cbi	0x18, 0	; 24
    if(bitval)
     9f6:	81 11       	cpse	r24, r1
	{
        PORTx |= (1<<Px);      //H-Pegel
     9f8:	c0 9a       	sbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     9fa:	88 eb       	ldi	r24, 0xB8	; 184
     9fc:	91 e0       	ldi	r25, 0x01	; 1
     9fe:	01 97       	sbiw	r24, 0x01	; 1
     a00:	f1 f7       	brne	.-4      	; 0x9fe <write_bit+0xc>
    }
	_delay_us(110);        
    DDRx &= ~(1<<Px);
     a02:	b8 98       	cbi	0x17, 0	; 23
    PORTx &= ~(1<<Px);
     a04:	c0 98       	cbi	0x18, 0	; 24
}
     a06:	08 95       	ret

00000a08 <read_byte>:

unsigned char read_byte(void)
{
     a08:	cf 92       	push	r12
     a0a:	df 92       	push	r13
     a0c:	ef 92       	push	r14
     a0e:	ff 92       	push	r15
     a10:	1f 93       	push	r17
     a12:	cf 93       	push	r28
     a14:	df 93       	push	r29
     a16:	10 e0       	ldi	r17, 0x00	; 0
     a18:	c0 e0       	ldi	r28, 0x00	; 0
     a1a:	d0 e0       	ldi	r29, 0x00	; 0
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
		{
            byte |= (1<<i);
     a1c:	91 e0       	ldi	r25, 0x01	; 1
     a1e:	c9 2e       	mov	r12, r25
     a20:	d1 2c       	mov	r13, r1
     a22:	80 ee       	ldi	r24, 0xE0	; 224
     a24:	e8 2e       	mov	r14, r24
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	f8 2e       	mov	r15, r24
unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
     a2a:	0e 94 ed 04 	call	0x9da	; 0x9da <read_bit>
     a2e:	88 23       	and	r24, r24
     a30:	41 f0       	breq	.+16     	; 0xa42 <read_byte+0x3a>
		{
            byte |= (1<<i);
     a32:	c6 01       	movw	r24, r12
     a34:	0c 2e       	mov	r0, r28
     a36:	02 c0       	rjmp	.+4      	; 0xa3c <read_byte+0x34>
     a38:	88 0f       	add	r24, r24
     a3a:	99 1f       	adc	r25, r25
     a3c:	0a 94       	dec	r0
     a3e:	e2 f7       	brpl	.-8      	; 0xa38 <read_byte+0x30>
     a40:	18 2b       	or	r17, r24
     a42:	c7 01       	movw	r24, r14
     a44:	01 97       	sbiw	r24, 0x01	; 1
     a46:	f1 f7       	brne	.-4      	; 0xa44 <read_byte+0x3c>
     a48:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
     a4a:	c8 30       	cpi	r28, 0x08	; 8
     a4c:	d1 05       	cpc	r29, r1
     a4e:	69 f7       	brne	.-38     	; 0xa2a <read_byte+0x22>
            byte |= (1<<i);
		}
        _delay_us(120);
    }
    return byte;
}
     a50:	81 2f       	mov	r24, r17
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	1f 91       	pop	r17
     a58:	ff 90       	pop	r15
     a5a:	ef 90       	pop	r14
     a5c:	df 90       	pop	r13
     a5e:	cf 90       	pop	r12
     a60:	08 95       	ret

00000a62 <write_byte>:

void write_byte(unsigned char byte)
{
     a62:	0f 93       	push	r16
     a64:	1f 93       	push	r17
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	c0 e0       	ldi	r28, 0x00	; 0
     a6c:	d0 e0       	ldi	r29, 0x00	; 0
    for(unsigned char i=0; i<8; i++)
	{
        if(byte & (1<<i))
     a6e:	08 2f       	mov	r16, r24
     a70:	10 e0       	ldi	r17, 0x00	; 0
     a72:	c8 01       	movw	r24, r16
     a74:	0c 2e       	mov	r0, r28
     a76:	02 c0       	rjmp	.+4      	; 0xa7c <write_byte+0x1a>
     a78:	95 95       	asr	r25
     a7a:	87 95       	ror	r24
     a7c:	0a 94       	dec	r0
     a7e:	e2 f7       	brpl	.-8      	; 0xa78 <write_byte+0x16>
     a80:	80 ff       	sbrs	r24, 0
     a82:	02 c0       	rjmp	.+4      	; 0xa88 <write_byte+0x26>
		{
			write_bit(1);
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	01 c0       	rjmp	.+2      	; 0xa8a <write_byte+0x28>
		}
        else
		{
            write_bit(0);
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <write_bit>
     a8e:	21 96       	adiw	r28, 0x01	; 1
    return byte;
}

void write_byte(unsigned char byte)
{
    for(unsigned char i=0; i<8; i++)
     a90:	c8 30       	cpi	r28, 0x08	; 8
     a92:	d1 05       	cpc	r29, r1
     a94:	71 f7       	brne	.-36     	; 0xa72 <write_byte+0x10>
     a96:	80 ee       	ldi	r24, 0xE0	; 224
     a98:	91 e0       	ldi	r25, 0x01	; 1
     a9a:	01 97       	sbiw	r24, 0x01	; 1
     a9c:	f1 f7       	brne	.-4      	; 0xa9a <write_byte+0x38>
		{
            write_bit(0);
		}
	}
    _delay_us(120);
}  
     a9e:	df 91       	pop	r29
     aa0:	cf 91       	pop	r28
     aa2:	1f 91       	pop	r17
     aa4:	0f 91       	pop	r16
     aa6:	08 95       	ret

00000aa8 <wait_ready>:
	return 0;
}

void wait_ready(void)
{
	while(!(read_bit()));
     aa8:	0e 94 ed 04 	call	0x9da	; 0x9da <read_bit>
     aac:	88 23       	and	r24, r24
     aae:	e1 f3       	breq	.-8      	; 0xaa8 <wait_ready>
}
     ab0:	08 95       	ret

00000ab2 <read_scratchpad>:
	}
    _delay_us(120);
}  

unsigned char read_scratchpad(void)
{
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29

	if(reset())
     ab6:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <reset>
     aba:	88 23       	and	r24, r24
     abc:	e9 f0       	breq	.+58     	; 0xaf8 <read_scratchpad+0x46>
	{
		write_byte(0xCC);
     abe:	8c ec       	ldi	r24, 0xCC	; 204
     ac0:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		write_byte(0x44);
     ac4:	84 e4       	ldi	r24, 0x44	; 68
     ac6:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
		wait_ready();
     aca:	0e 94 54 05 	call	0xaa8	; 0xaa8 <wait_ready>
		if(reset())
     ace:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <reset>
     ad2:	88 23       	and	r24, r24
     ad4:	89 f0       	breq	.+34     	; 0xaf8 <read_scratchpad+0x46>
		{
			write_byte(0xCC);
     ad6:	8c ec       	ldi	r24, 0xCC	; 204
     ad8:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
			write_byte(0xBE);
     adc:	8e eb       	ldi	r24, 0xBE	; 190
     ade:	0e 94 31 05 	call	0xa62	; 0xa62 <write_byte>
     ae2:	ce ef       	ldi	r28, 0xFE	; 254
     ae4:	d6 e0       	ldi	r29, 0x06	; 6
			for(unsigned char i=0; i<9; i++)
			{
				scratchpad [i] = read_byte();
     ae6:	0e 94 04 05 	call	0xa08	; 0xa08 <read_byte>
     aea:	89 93       	st	Y+, r24
		wait_ready();
		if(reset())
		{
			write_byte(0xCC);
			write_byte(0xBE);
			for(unsigned char i=0; i<9; i++)
     aec:	87 e0       	ldi	r24, 0x07	; 7
     aee:	c7 30       	cpi	r28, 0x07	; 7
     af0:	d8 07       	cpc	r29, r24
     af2:	c9 f7       	brne	.-14     	; 0xae6 <read_scratchpad+0x34>
     af4:	81 e0       	ldi	r24, 0x01	; 1
     af6:	01 c0       	rjmp	.+2      	; 0xafa <read_scratchpad+0x48>
     af8:	80 e0       	ldi	r24, 0x00	; 0
			}
			return 1;
		}
	}
	return 0;
}
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	08 95       	ret

00000b00 <i2c_init>:
|== TWPS = 1 => (4^TWPS)= 4  // TWSR = (0<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx01 => TWSR = 1 (DEC) => 4^1 =  4 =|
|== TWPS = 2 => (4^TWPS)=16  // TWSR = (1<<TWPS1)|(0<<TWPS0) => TWSR = 0bxxxxxx10 => TWSR = 2 (DEC) => 4^2 = 16 =|
|== TWPS = 3 => (4^TWPS)=64  // TWSR = (1<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx11 => TWSR = 3 (DEC) => 4^3 = 64 =|
|===============================================================================================================*/

	TWBR = 0b00010010;	// HEX=0x12	or DEC=18	// FCPU = 16 000 000 |-> SCL = 16000000 / (16+(2*TWBR*(4^TWPS)) = 16000000 / (16+(2*18*(4))) = 16000000 / 160 = 100 000 Hz = 100 kHz
     b00:	82 e1       	ldi	r24, 0x12	; 18
     b02:	80 b9       	out	0x00, r24	; 0
	TWSR = (0<<TWPS1)|(1<<TWPS0);	// SCL = 16 000 000 / 64  = 250 000 = 250kHz
     b04:	81 e0       	ldi	r24, 0x01	; 1
     b06:	81 b9       	out	0x01, r24	; 1
	TWCR = (1<<TWEN);	//	TWCR = 0x04; // TWCR = (x<<TWINT)|(x<<TWEA)|(x<<TWSTA)|(x<<TWSTO)|(x<<TWEN)|(x<<TWIE);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz
     b08:	84 e0       	ldi	r24, 0x04	; 4
     b0a:	86 bf       	out	0x36, r24	; 54
	TWDR = 0b00000000;
     b0c:	13 b8       	out	0x03, r1	; 3
}
     b0e:	08 95       	ret

00000b10 <i2c_start>:
/*****************************************
** START CONDITION OF I2C COMMUNICATION **
*****************************************/
void i2c_start(void)
{
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     b10:	84 ea       	ldi	r24, 0xA4	; 164
     b12:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     b14:	06 b6       	in	r0, 0x36	; 54
     b16:	07 fe       	sbrs	r0, 7
     b18:	fd cf       	rjmp	.-6      	; 0xb14 <i2c_start+0x4>
	{
	}
}
     b1a:	08 95       	ret

00000b1c <i2c_stop>:
/****************************************
** STOP CONDITION OF I2C COMMUNICATION **
****************************************/
void i2c_stop()
{
	TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     b1c:	84 e9       	ldi	r24, 0x94	; 148
     b1e:	86 bf       	out	0x36, r24	; 54
}
     b20:	08 95       	ret

00000b22 <i2c_write>:
/*******************************************
** WRITE/SEND 1 BYTE OF I2C COMMUNICATION **
*******************************************/
void i2c_write(unsigned char data)
{
	TWDR = data;
     b22:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT)|(1<<TWEN);
     b24:	84 e8       	ldi	r24, 0x84	; 132
     b26:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     b28:	06 b6       	in	r0, 0x36	; 54
     b2a:	07 fe       	sbrs	r0, 7
     b2c:	fd cf       	rjmp	.-6      	; 0xb28 <i2c_write+0x6>
	{
	}
}
     b2e:	08 95       	ret

00000b30 <i2c_read>:
/**********************************************
** READ/RECEIVE BYTE(S) OF I2C COMMUNICATION **
**********************************************/
unsigned char i2c_read(unsigned char isLast)
{
	if(isLast == 0 )
     b30:	88 23       	and	r24, r24
     b32:	11 f4       	brne	.+4      	; 0xb38 <i2c_read+0x8>
	{
		TWCR = (1<<TWINT)|(1<<TWEA)|(1<<TWEN);	// to next receive byte
     b34:	84 ec       	ldi	r24, 0xC4	; 196
     b36:	01 c0       	rjmp	.+2      	; 0xb3a <i2c_read+0xa>
	}
	else
	{
		TWCR = (1<<TWINT)|(1<<TWEN);			// to end of communication
     b38:	84 e8       	ldi	r24, 0x84	; 132
     b3a:	86 bf       	out	0x36, r24	; 54
	}
	
	while((TWCR & (1<<TWINT)) == 0)
     b3c:	06 b6       	in	r0, 0x36	; 54
     b3e:	07 fe       	sbrs	r0, 7
     b40:	fd cf       	rjmp	.-6      	; 0xb3c <i2c_read+0xc>
	{
	}
	return TWDR;
     b42:	83 b1       	in	r24, 0x03	; 3
}
     b44:	08 95       	ret

00000b46 <LCD_EXECUTE_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_EXECUTE_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     b46:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     b48:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     b4a:	87 ff       	sbrs	r24, 7
     b4c:	02 c0       	rjmp	.+4      	; 0xb52 <LCD_EXECUTE_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     b4e:	d8 9a       	sbi	0x1b, 0	; 27
     b50:	01 c0       	rjmp	.+2      	; 0xb54 <LCD_EXECUTE_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     b52:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     b54:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     b56:	9f 5f       	subi	r25, 0xFF	; 255
     b58:	98 30       	cpi	r25, 0x08	; 8
     b5a:	11 f0       	breq	.+4      	; 0xb60 <LCD_EXECUTE_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     b5c:	88 0f       	add	r24, r24
     b5e:	f4 cf       	rjmp	.-24     	; 0xb48 <LCD_EXECUTE_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     b60:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     b62:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     b64:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     b66:	da 98       	cbi	0x1b, 2	; 27
     b68:	88 ea       	ldi	r24, 0xA8	; 168
     b6a:	92 e0       	ldi	r25, 0x02	; 2
     b6c:	fc 01       	movw	r30, r24
     b6e:	31 97       	sbiw	r30, 0x01	; 1
     b70:	f1 f7       	brne	.-4      	; 0xb6e <LCD_EXECUTE_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     b72:	da 9a       	sbi	0x1b, 2	; 27
     b74:	01 97       	sbiw	r24, 0x01	; 1
     b76:	f1 f7       	brne	.-4      	; 0xb74 <LCD_EXECUTE_COMMAND+0x2e>
	LCD_REGSELECT_low();	// RS = 0
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);			//rcall 180 us
*/
	LCD_ENABLE_low();		// EN = 0
     b78:	db 98       	cbi	0x1b, 3	; 27
     b7a:	80 e9       	ldi	r24, 0x90	; 144
     b7c:	91 e0       	ldi	r25, 0x01	; 1
     b7e:	01 97       	sbiw	r24, 0x01	; 1
     b80:	f1 f7       	brne	.-4      	; 0xb7e <LCD_EXECUTE_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us

}
     b82:	08 95       	ret

00000b84 <LCD_EXECUTE_DATA>:

/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
     b88:	40 e0       	ldi	r20, 0x00	; 0
     b8a:	50 e0       	ldi	r21, 0x00	; 0
     b8c:	a8 ea       	ldi	r26, 0xA8	; 168
     b8e:	b2 e0       	ldi	r27, 0x02	; 2
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];
     b90:	c0 e9       	ldi	r28, 0x90	; 144
     b92:	d1 e0       	ldi	r29, 0x01	; 1
     b94:	22 c0       	rjmp	.+68     	; 0xbda <LCD_EXECUTE_DATA+0x56>
     b96:	fc 01       	movw	r30, r24
     b98:	e4 0f       	add	r30, r20
     b9a:	f5 1f       	adc	r31, r21
     b9c:	e0 81       	ld	r30, Z
     b9e:	20 e0       	ldi	r18, 0x00	; 0

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     ba0:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     ba2:	e7 ff       	sbrs	r30, 7
     ba4:	02 c0       	rjmp	.+4      	; 0xbaa <LCD_EXECUTE_DATA+0x26>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     ba6:	d8 9a       	sbi	0x1b, 0	; 27
     ba8:	01 c0       	rjmp	.+2      	; 0xbac <LCD_EXECUTE_DATA+0x28>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     baa:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     bac:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     bae:	2f 5f       	subi	r18, 0xFF	; 255
     bb0:	28 30       	cpi	r18, 0x08	; 8
     bb2:	11 f0       	breq	.+4      	; 0xbb8 <LCD_EXECUTE_DATA+0x34>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     bb4:	ee 0f       	add	r30, r30
     bb6:	f4 cf       	rjmp	.-24     	; 0xba0 <LCD_EXECUTE_DATA+0x1c>
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     bb8:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     bba:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     bbc:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     bbe:	da 98       	cbi	0x1b, 2	; 27
     bc0:	fd 01       	movw	r30, r26
     bc2:	31 97       	sbiw	r30, 0x01	; 1
     bc4:	f1 f7       	brne	.-4      	; 0xbc2 <LCD_EXECUTE_DATA+0x3e>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     bc6:	da 9a       	sbi	0x1b, 2	; 27
     bc8:	fd 01       	movw	r30, r26
     bca:	31 97       	sbiw	r30, 0x01	; 1
     bcc:	f1 f7       	brne	.-4      	; 0xbca <LCD_EXECUTE_DATA+0x46>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     bce:	db 98       	cbi	0x1b, 3	; 27
     bd0:	fe 01       	movw	r30, r28
     bd2:	31 97       	sbiw	r30, 0x01	; 1
     bd4:	f1 f7       	brne	.-4      	; 0xbd2 <LCD_EXECUTE_DATA+0x4e>
/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
     bd6:	4f 5f       	subi	r20, 0xFF	; 255
     bd8:	5f 4f       	sbci	r21, 0xFF	; 255
     bda:	46 17       	cp	r20, r22
     bdc:	57 07       	cpc	r21, r23
     bde:	dc f2       	brlt	.-74     	; 0xb96 <LCD_EXECUTE_DATA+0x12>
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}

//	LCD_EXECUTE_DATA_LAST();	// flush -> posleden simvol ili gore v cikala count_ns < numsymbols+1 ili count_ns <= numsymbols
}
     be0:	df 91       	pop	r29
     be2:	cf 91       	pop	r28
     be4:	08 95       	ret

00000be6 <LCD_EXECUTE_DATA_ONE>:

/************************************************
** WRITE/TRANSMIT ONE DATA BYTE TO LCD DISPLAY **
************************************************/
void LCD_EXECUTE_DATA_ONE(unsigned char data)	// HELP: LCD_EXECUTE_DATA(unsigned char data_byte_symbols) // LCD shift left out, msb is first
{
     be6:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     be8:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     bea:	87 ff       	sbrs	r24, 7
     bec:	02 c0       	rjmp	.+4      	; 0xbf2 <LCD_EXECUTE_DATA_ONE+0xc>
		{
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     bee:	d8 9a       	sbi	0x1b, 0	; 27
     bf0:	01 c0       	rjmp	.+2      	; 0xbf4 <LCD_EXECUTE_DATA_ONE+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     bf2:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     bf4:	d9 9a       	sbi	0x1b, 1	; 27
{
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     bf6:	9f 5f       	subi	r25, 0xFF	; 255
     bf8:	98 30       	cpi	r25, 0x08	; 8
     bfa:	11 f0       	breq	.+4      	; 0xc00 <LCD_EXECUTE_DATA_ONE+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     bfc:	88 0f       	add	r24, r24
     bfe:	f4 cf       	rjmp	.-24     	; 0xbe8 <LCD_EXECUTE_DATA_ONE+0x2>
	}
//update from down comment
	LCD_REGSELECT_high();	// RS = 1
     c00:	dd 9a       	sbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     c02:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     c04:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment

	LCD_RCK_low();
     c06:	da 98       	cbi	0x1b, 2	; 27
     c08:	88 ea       	ldi	r24, 0xA8	; 168
     c0a:	92 e0       	ldi	r25, 0x02	; 2
     c0c:	fc 01       	movw	r30, r24
     c0e:	31 97       	sbiw	r30, 0x01	; 1
     c10:	f1 f7       	brne	.-4      	; 0xc0e <LCD_EXECUTE_DATA_ONE+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     c12:	da 9a       	sbi	0x1b, 2	; 27
     c14:	01 97       	sbiw	r24, 0x01	; 1
     c16:	f1 f7       	brne	.-4      	; 0xc14 <LCD_EXECUTE_DATA_ONE+0x2e>
	LCD_REGSELECT_high();	// RS = 1
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);
*/
	LCD_ENABLE_low();		// EN = 0
     c18:	db 98       	cbi	0x1b, 3	; 27
     c1a:	80 e9       	ldi	r24, 0x90	; 144
     c1c:	91 e0       	ldi	r25, 0x01	; 1
     c1e:	01 97       	sbiw	r24, 0x01	; 1
     c20:	f1 f7       	brne	.-4      	; 0xc1e <LCD_EXECUTE_DATA_ONE+0x38>
	_delay_us(100);
}
     c22:	08 95       	ret

00000c24 <LCD_EXECUTE_DATA_LAST>:
/*****************************************************************************
** WRITE/TRANSMIT LAST DATA BYTE TO LCD DISPLAY AND FLUSH SN74HC595 BUFFER  **
*****************************************************************************/
void LCD_EXECUTE_DATA_LAST()	// flush -> izchistvane na bufer - prinuditelno izpisvane na posleden simvol
{
	LCD_ENABLE_low();
     c24:	db 98       	cbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     c26:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     c28:	dd 9a       	sbi	0x1b, 5	; 27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     c2a:	85 ed       	ldi	r24, 0xD5	; 213
     c2c:	98 2f       	mov	r25, r24
     c2e:	9a 95       	dec	r25
     c30:	f1 f7       	brne	.-4      	; 0xc2e <LCD_EXECUTE_DATA_LAST+0xa>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
	LCD_ENABLE_high();
     c32:	db 9a       	sbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     c34:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     c36:	dd 9a       	sbi	0x1b, 5	; 27
     c38:	8a 95       	dec	r24
     c3a:	f1 f7       	brne	.-4      	; 0xc38 <LCD_EXECUTE_DATA_LAST+0x14>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
}
     c3c:	08 95       	ret

00000c3e <LCD_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     c3e:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     c40:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     c42:	87 ff       	sbrs	r24, 7
     c44:	02 c0       	rjmp	.+4      	; 0xc4a <LCD_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     c46:	d8 9a       	sbi	0x1b, 0	; 27
     c48:	01 c0       	rjmp	.+2      	; 0xc4c <LCD_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     c4a:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     c4c:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     c4e:	9f 5f       	subi	r25, 0xFF	; 255
     c50:	98 30       	cpi	r25, 0x08	; 8
     c52:	11 f0       	breq	.+4      	; 0xc58 <LCD_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     c54:	88 0f       	add	r24, r24
     c56:	f4 cf       	rjmp	.-24     	; 0xc40 <LCD_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     c58:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     c5a:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     c5c:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     c5e:	da 98       	cbi	0x1b, 2	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c60:	88 ea       	ldi	r24, 0xA8	; 168
     c62:	92 e0       	ldi	r25, 0x02	; 2
     c64:	fc 01       	movw	r30, r24
     c66:	31 97       	sbiw	r30, 0x01	; 1
     c68:	f1 f7       	brne	.-4      	; 0xc66 <LCD_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     c6a:	da 9a       	sbi	0x1b, 2	; 27
     c6c:	01 97       	sbiw	r24, 0x01	; 1
     c6e:	f1 f7       	brne	.-4      	; 0xc6c <LCD_COMMAND+0x2e>
	_delay_us(170);			//rcall 180 us

	LCD_ENABLE_low();		// EN = 0
     c70:	db 98       	cbi	0x1b, 3	; 27
     c72:	80 e9       	ldi	r24, 0x90	; 144
     c74:	91 e0       	ldi	r25, 0x01	; 1
     c76:	01 97       	sbiw	r24, 0x01	; 1
     c78:	f1 f7       	brne	.-4      	; 0xc76 <LCD_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us
}
     c7a:	08 95       	ret

00000c7c <LCD_CLEAR_CONTAIN>:
/**************************************
** CLEAR ALL CONTAINS ON LCD DISPLAY **
**************************************/
void LCD_CLEAR_CONTAIN()
{
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 1. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     c7c:	81 e0       	ldi	r24, 0x01	; 1
     c7e:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
     c82:	80 ec       	ldi	r24, 0xC0	; 192
     c84:	92 e1       	ldi	r25, 0x12	; 18
     c86:	01 97       	sbiw	r24, 0x01	; 1
     c88:	f1 f7       	brne	.-4      	; 0xc86 <LCD_CLEAR_CONTAIN+0xa>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
}
     c8a:	08 95       	ret

00000c8c <LCD_INIT>:
/**********************************
** INITIZLIZATION OF LCD DISPLAY **
**********************************/
void LCD_INIT()
{
	LCD_COMMAND(LCD_8BIT_2ROWS_FONT5X7);		// 0b00111000	// 1. Function set: 8-bit interface data (DL = 1), 2-line display (N = 1), 5 x 7 dot character font (F = 0)
     c8c:	88 e3       	ldi	r24, 0x38	; 56
     c8e:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_ENTRY_MODE_INC_NOSHIFT);	// 0b00000110	// 2. Entry mode set: Increment by 1 (I/D = 1), No shift (S = 0)
     c92:	86 e0       	ldi	r24, 0x06	; 6
     c94:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_MOVE_FIRST);								// 3.
     c98:	82 e0       	ldi	r24, 0x02	; 2
     c9a:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 4. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     c9e:	81 e0       	ldi	r24, 0x01	; 1
     ca0:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
     ca4:	80 ec       	ldi	r24, 0xC0	; 192
     ca6:	92 e1       	ldi	r25, 0x12	; 18
     ca8:	01 97       	sbiw	r24, 0x01	; 1
     caa:	f1 f7       	brne	.-4      	; 0xca8 <LCD_INIT+0x1c>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
//	LCD_COMMAND(LCD_ON_BLINK_CURSOR);			// 0b00001111	// 5. Display on/off control: Display on (D = 1), Cursor on (C = 1), Blinking on (B = 1)
//	_delay_us(40);	// 37 uS	// comment for simulation
//	LCD_COMMAND(LCD_OFF);										// 5. Display off
}
     cac:	08 95       	ret

00000cae <LCD_DATA_STRING>:

/*********************************************************
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
     cae:	fc 01       	movw	r30, r24
     cb0:	28 ea       	ldi	r18, 0xA8	; 168
     cb2:	32 e0       	ldi	r19, 0x02	; 2
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     cb4:	40 e9       	ldi	r20, 0x90	; 144
     cb6:	51 e0       	ldi	r21, 0x01	; 1
     cb8:	1d c0       	rjmp	.+58     	; 0xcf4 <LCD_DATA_STRING+0x46>
     cba:	90 e0       	ldi	r25, 0x00	; 0
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     cbc:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     cbe:	87 ff       	sbrs	r24, 7
     cc0:	02 c0       	rjmp	.+4      	; 0xcc6 <LCD_DATA_STRING+0x18>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     cc2:	d8 9a       	sbi	0x1b, 0	; 27
     cc4:	01 c0       	rjmp	.+2      	; 0xcc8 <LCD_DATA_STRING+0x1a>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     cc6:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     cc8:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     cca:	9f 5f       	subi	r25, 0xFF	; 255
     ccc:	98 30       	cpi	r25, 0x08	; 8
     cce:	11 f0       	breq	.+4      	; 0xcd4 <LCD_DATA_STRING+0x26>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     cd0:	88 0f       	add	r24, r24
     cd2:	f4 cf       	rjmp	.-24     	; 0xcbc <LCD_DATA_STRING+0xe>
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;
     cd4:	31 96       	adiw	r30, 0x01	; 1
			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     cd6:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     cd8:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     cda:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     cdc:	da 98       	cbi	0x1b, 2	; 27
     cde:	c9 01       	movw	r24, r18
     ce0:	01 97       	sbiw	r24, 0x01	; 1
     ce2:	f1 f7       	brne	.-4      	; 0xce0 <LCD_DATA_STRING+0x32>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     ce4:	da 9a       	sbi	0x1b, 2	; 27
     ce6:	c9 01       	movw	r24, r18
     ce8:	01 97       	sbiw	r24, 0x01	; 1
     cea:	f1 f7       	brne	.-4      	; 0xce8 <LCD_DATA_STRING+0x3a>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     cec:	db 98       	cbi	0x1b, 3	; 27
     cee:	ca 01       	movw	r24, r20
     cf0:	01 97       	sbiw	r24, 0x01	; 1
     cf2:	f1 f7       	brne	.-4      	; 0xcf0 <LCD_DATA_STRING+0x42>
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     cf4:	80 81       	ld	r24, Z
     cf6:	88 23       	and	r24, r24
     cf8:	01 f7       	brne	.-64     	; 0xcba <LCD_DATA_STRING+0xc>
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}
}
     cfa:	08 95       	ret

00000cfc <LCD_CGRAM_CUSTOM_SYMBOLS>:
	 { 0x0E, 0x1B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F },	// Battery Charging  80%	// addr40-47
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
     cfc:	cf 93       	push	r28
     cfe:	df 93       	push	r29
	for(rows=0; rows<7; rows++)
     d00:	10 92 19 07 	sts	0x0719, r1
     d04:	10 92 18 07 	sts	0x0718, r1
     d08:	25 c0       	rjmp	.+74     	; 0xd54 <LCD_CGRAM_CUSTOM_SYMBOLS+0x58>
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
     d0a:	08 96       	adiw	r24, 0x08	; 8
     d0c:	88 0f       	add	r24, r24
     d0e:	88 0f       	add	r24, r24
     d10:	88 0f       	add	r24, r24
     d12:	0e 94 a3 05 	call	0xb46	; 0xb46 <LCD_EXECUTE_COMMAND>
     d16:	c0 e0       	ldi	r28, 0x00	; 0
     d18:	d0 e0       	ldi	r29, 0x00	; 0
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
     d1a:	e0 91 18 07 	lds	r30, 0x0718
     d1e:	f0 91 19 07 	lds	r31, 0x0719
     d22:	83 e0       	ldi	r24, 0x03	; 3
     d24:	ee 0f       	add	r30, r30
     d26:	ff 1f       	adc	r31, r31
     d28:	8a 95       	dec	r24
     d2a:	e1 f7       	brne	.-8      	; 0xd24 <LCD_CGRAM_CUSTOM_SYMBOLS+0x28>
     d2c:	ec 0f       	add	r30, r28
     d2e:	fd 1f       	adc	r31, r29
     d30:	ee 5d       	subi	r30, 0xDE	; 222
     d32:	f9 4f       	sbci	r31, 0xF9	; 249
     d34:	80 81       	ld	r24, Z
     d36:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <LCD_EXECUTE_DATA_ONE>
void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
     d3a:	21 96       	adiw	r28, 0x01	; 1
     d3c:	c8 30       	cpi	r28, 0x08	; 8
     d3e:	d1 05       	cpc	r29, r1
     d40:	61 f7       	brne	.-40     	; 0xd1a <LCD_CGRAM_CUSTOM_SYMBOLS+0x1e>
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
     d42:	80 91 18 07 	lds	r24, 0x0718
     d46:	90 91 19 07 	lds	r25, 0x0719
     d4a:	01 96       	adiw	r24, 0x01	; 1
     d4c:	90 93 19 07 	sts	0x0719, r25
     d50:	80 93 18 07 	sts	0x0718, r24
     d54:	80 91 18 07 	lds	r24, 0x0718
     d58:	90 91 19 07 	lds	r25, 0x0719
     d5c:	87 30       	cpi	r24, 0x07	; 7
     d5e:	91 05       	cpc	r25, r1
     d60:	a4 f2       	brlt	.-88     	; 0xd0a <LCD_CGRAM_CUSTOM_SYMBOLS+0xe>
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
		}
	}
}
     d62:	df 91       	pop	r29
     d64:	cf 91       	pop	r28
     d66:	08 95       	ret

00000d68 <LCD_DATA_ULONG>:
/****************************************************************
** WRITE/TRANSMIT MORE DATA UNSIGNED LONG BYTES TO LCD DISPLAY **
****************************************************************/
// USE THIS: lcdDataULong( (unsigned long)k + 1 );
void LCD_DATA_ULONG(unsigned long data)		// void lcdDataULong(const unsigned long data)
{
     d68:	df 93       	push	r29
     d6a:	cf 93       	push	r28
     d6c:	cd b7       	in	r28, 0x3d	; 61
     d6e:	de b7       	in	r29, 0x3e	; 62
     d70:	2a 97       	sbiw	r28, 0x0a	; 10
     d72:	0f b6       	in	r0, 0x3f	; 63
     d74:	f8 94       	cli
     d76:	de bf       	out	0x3e, r29	; 62
     d78:	0f be       	out	0x3f, r0	; 63
     d7a:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ultoa(data, buffer, 10));	// 10 -> DECIMAL
     d7c:	ae 01       	movw	r20, r28
     d7e:	4f 5f       	subi	r20, 0xFF	; 255
     d80:	5f 4f       	sbci	r21, 0xFF	; 255
     d82:	2a e0       	ldi	r18, 0x0A	; 10
     d84:	30 e0       	ldi	r19, 0x00	; 0
     d86:	0e 94 c6 0a 	call	0x158c	; 0x158c <ultoa>
     d8a:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
}
     d8e:	2a 96       	adiw	r28, 0x0a	; 10
     d90:	0f b6       	in	r0, 0x3f	; 63
     d92:	f8 94       	cli
     d94:	de bf       	out	0x3e, r29	; 62
     d96:	0f be       	out	0x3f, r0	; 63
     d98:	cd bf       	out	0x3d, r28	; 61
     d9a:	cf 91       	pop	r28
     d9c:	df 91       	pop	r29
     d9e:	08 95       	ret

00000da0 <LCD_DATA_LONG>:
/*******************************************************
** WRITE/TRANSMIT MORE DATA LONG BYTES TO LCD DISPLAY **
*******************************************************/
// USE THIS: lcdDataLong( (long)k + 1 );
void LCD_DATA_LONG(long data)		// void lcdDataLong(const long data)
{
     da0:	df 93       	push	r29
     da2:	cf 93       	push	r28
     da4:	cd b7       	in	r28, 0x3d	; 61
     da6:	de b7       	in	r29, 0x3e	; 62
     da8:	2a 97       	sbiw	r28, 0x0a	; 10
     daa:	0f b6       	in	r0, 0x3f	; 63
     dac:	f8 94       	cli
     dae:	de bf       	out	0x3e, r29	; 62
     db0:	0f be       	out	0x3f, r0	; 63
     db2:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ltoa(data, buffer, 10));	// 10 -> DECIMAL
     db4:	ae 01       	movw	r20, r28
     db6:	4f 5f       	subi	r20, 0xFF	; 255
     db8:	5f 4f       	sbci	r21, 0xFF	; 255
     dba:	2a e0       	ldi	r18, 0x0A	; 10
     dbc:	30 e0       	ldi	r19, 0x00	; 0
     dbe:	0e 94 92 0a 	call	0x1524	; 0x1524 <ltoa>
     dc2:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
}
     dc6:	2a 96       	adiw	r28, 0x0a	; 10
     dc8:	0f b6       	in	r0, 0x3f	; 63
     dca:	f8 94       	cli
     dcc:	de bf       	out	0x3e, r29	; 62
     dce:	0f be       	out	0x3f, r0	; 63
     dd0:	cd bf       	out	0x3d, r28	; 61
     dd2:	cf 91       	pop	r28
     dd4:	df 91       	pop	r29
     dd6:	08 95       	ret

00000dd8 <LCD_DATA_INT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataInt( (int)k + 1 );
void LCD_DATA_INT(int data)		// void lcdDataInt(const int data)
{
     dd8:	df 93       	push	r29
     dda:	cf 93       	push	r28
     ddc:	cd b7       	in	r28, 0x3d	; 61
     dde:	de b7       	in	r29, 0x3e	; 62
     de0:	2a 97       	sbiw	r28, 0x0a	; 10
     de2:	0f b6       	in	r0, 0x3f	; 63
     de4:	f8 94       	cli
     de6:	de bf       	out	0x3e, r29	; 62
     de8:	0f be       	out	0x3f, r0	; 63
     dea:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(itoa(data, buffer, 10));	// 10 -> DECIMAL
     dec:	be 01       	movw	r22, r28
     dee:	6f 5f       	subi	r22, 0xFF	; 255
     df0:	7f 4f       	sbci	r23, 0xFF	; 255
     df2:	4a e0       	ldi	r20, 0x0A	; 10
     df4:	50 e0       	ldi	r21, 0x00	; 0
     df6:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <itoa>
     dfa:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
}
     dfe:	2a 96       	adiw	r28, 0x0a	; 10
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	f8 94       	cli
     e04:	de bf       	out	0x3e, r29	; 62
     e06:	0f be       	out	0x3f, r0	; 63
     e08:	cd bf       	out	0x3d, r28	; 61
     e0a:	cf 91       	pop	r28
     e0c:	df 91       	pop	r29
     e0e:	08 95       	ret

00000e10 <LCD_DATA_UINT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataUInt( (unsigned int)k + 1 );
void LCD_DATA_UINT(unsigned int data)		// void lcdDataUInt(const unsigned int data)
{
     e10:	df 93       	push	r29
     e12:	cf 93       	push	r28
     e14:	cd b7       	in	r28, 0x3d	; 61
     e16:	de b7       	in	r29, 0x3e	; 62
     e18:	2a 97       	sbiw	r28, 0x0a	; 10
     e1a:	0f b6       	in	r0, 0x3f	; 63
     e1c:	f8 94       	cli
     e1e:	de bf       	out	0x3e, r29	; 62
     e20:	0f be       	out	0x3f, r0	; 63
     e22:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(utoa(data, buffer, 10));	// 10 -> DECIMAL
     e24:	be 01       	movw	r22, r28
     e26:	6f 5f       	subi	r22, 0xFF	; 255
     e28:	7f 4f       	sbci	r23, 0xFF	; 255
     e2a:	4a e0       	ldi	r20, 0x0A	; 10
     e2c:	50 e0       	ldi	r21, 0x00	; 0
     e2e:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <utoa>
     e32:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
}
     e36:	2a 96       	adiw	r28, 0x0a	; 10
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	f8 94       	cli
     e3c:	de bf       	out	0x3e, r29	; 62
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	cd bf       	out	0x3d, r28	; 61
     e42:	cf 91       	pop	r28
     e44:	df 91       	pop	r29
     e46:	08 95       	ret

00000e48 <PGA2310_Volume_Update>:

/*************************************
** DEFINITION PGA2310 VOLUME UPDATE **
*************************************/
void PGA2310_Volume_Update(unsigned char pgaVolumeLeft, unsigned char pgaVolumeRight)
{
     e48:	0f 93       	push	r16
     e4a:	1f 93       	push	r17
     e4c:	18 2f       	mov	r17, r24
     e4e:	06 2f       	mov	r16, r22
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
     e50:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
     e52:	0e 94 40 08 	call	0x1080	; 0x1080 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
     e56:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     e58:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
     e5a:	81 2f       	mov	r24, r17
     e5c:	60 2f       	mov	r22, r16
     e5e:	0e 94 40 08 	call	0x1080	; 0x1080 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
     e62:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA7 - /SS ENABLE
     e64:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
     e66:	81 2f       	mov	r24, r17
     e68:	60 2f       	mov	r22, r16
     e6a:	0e 94 40 08 	call	0x1080	; 0x1080 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
     e6e:	df 9a       	sbi	0x1b, 7	; 27

//	return SUCCESS;
}
     e70:	1f 91       	pop	r17
     e72:	0f 91       	pop	r16
     e74:	08 95       	ret

00000e76 <pga2310_init>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_init()
{
	spi_init();
     e76:	0e 94 2f 08 	call	0x105e	; 0x105e <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
     e7a:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     e7c:	80 e0       	ldi	r24, 0x00	; 0
     e7e:	60 e0       	ldi	r22, 0x00	; 0
     e80:	0e 94 40 08 	call	0x1080	; 0x1080 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
     e84:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     e86:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     e88:	80 e0       	ldi	r24, 0x00	; 0
     e8a:	60 e0       	ldi	r22, 0x00	; 0
     e8c:	0e 94 40 08 	call	0x1080	; 0x1080 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
     e90:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     e92:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     e94:	80 e0       	ldi	r24, 0x00	; 0
     e96:	60 e0       	ldi	r22, 0x00	; 0
     e98:	0e 94 40 08 	call	0x1080	; 0x1080 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
     e9c:	df 9a       	sbi	0x1b, 7	; 27
}
     e9e:	08 95       	ret

00000ea0 <pga2310_reset>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_reset()
{
	spi_init();
     ea0:	0e 94 2f 08 	call	0x105e	; 0x105e <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
     ea4:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     ea6:	80 e0       	ldi	r24, 0x00	; 0
     ea8:	60 e0       	ldi	r22, 0x00	; 0
     eaa:	0e 94 40 08 	call	0x1080	; 0x1080 <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
     eae:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     eb0:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     eb2:	80 e0       	ldi	r24, 0x00	; 0
     eb4:	60 e0       	ldi	r22, 0x00	; 0
     eb6:	0e 94 40 08 	call	0x1080	; 0x1080 <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
     eba:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
     ebc:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
     ebe:	80 e0       	ldi	r24, 0x00	; 0
     ec0:	60 e0       	ldi	r22, 0x00	; 0
     ec2:	0e 94 40 08 	call	0x1080	; 0x1080 <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
     ec6:	df 9a       	sbi	0x1b, 7	; 27
}
     ec8:	08 95       	ret

00000eca <uart_transmit>:

/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
     eca:	ac 01       	movw	r20, r24
     ecc:	20 e0       	ldi	r18, 0x00	; 0
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	09 c0       	rjmp	.+18     	; 0xee4 <uart_transmit+0x1a>
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		//UDR = uart_data[count_ns];
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
     ed2:	5d 9b       	sbis	0x0b, 5	; 11
     ed4:	fe cf       	rjmp	.-4      	; 0xed2 <uart_transmit+0x8>
		{
		}
		UDR = uart_data[count_ns];
     ed6:	fa 01       	movw	r30, r20
     ed8:	e2 0f       	add	r30, r18
     eda:	f3 1f       	adc	r31, r19
     edc:	80 81       	ld	r24, Z
     ede:	8c b9       	out	0x0c, r24	; 12
/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
     ee0:	2f 5f       	subi	r18, 0xFF	; 255
     ee2:	3f 4f       	sbci	r19, 0xFF	; 255
     ee4:	26 17       	cp	r18, r22
     ee6:	37 07       	cpc	r19, r23
     ee8:	a4 f3       	brlt	.-24     	; 0xed2 <uart_transmit+0x8>
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
		{
		}
		UDR = uart_data[count_ns];
	}
}
     eea:	08 95       	ret

00000eec <uart_transmit_one>:
/***************************************
** TRANSMIT/SEND 1 BYTE OF UART/USART **
***************************************/
void uart_transmit_one(unsigned char uart_data)
{
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
     eec:	5d 9b       	sbis	0x0b, 5	; 11
     eee:	fe cf       	rjmp	.-4      	; 0xeec <uart_transmit_one>
	{
	}
	UDR = uart_data;
     ef0:	8c b9       	out	0x0c, r24	; 12
}
     ef2:	08 95       	ret

00000ef4 <uart_transmit_DEC_to_BCD>:

/*****************************************************************		// NOT FINISHED
** TRANSMIT/SEND 1 BYTE CONVERTED FROM DEC TO BCD OF UART/USART **		// NOT FINISHED
*****************************************************************/		// NOT FINISHED
void uart_transmit_DEC_to_BCD(unsigned char dec_to_bcd_data)
{// pravi se preobrazuvane ot DEC to BCD i preobrazuvane za izvejdane na parviq simvol s filtar
     ef4:	98 2f       	mov	r25, r24
	
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
     ef6:	5d 9b       	sbis	0x0b, 5	; 11
     ef8:	fe cf       	rjmp	.-4      	; 0xef6 <uart_transmit_DEC_to_BCD+0x2>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data>>4));
     efa:	89 2f       	mov	r24, r25
     efc:	82 95       	swap	r24
     efe:	8f 70       	andi	r24, 0x0F	; 15
     f00:	80 5d       	subi	r24, 0xD0	; 208
     f02:	8c b9       	out	0x0c, r24	; 12

	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
     f04:	5d 9b       	sbis	0x0b, 5	; 11
     f06:	fe cf       	rjmp	.-4      	; 0xf04 <uart_transmit_DEC_to_BCD+0x10>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data & 0x0F));
     f08:	9f 70       	andi	r25, 0x0F	; 15
     f0a:	90 5d       	subi	r25, 0xD0	; 208
     f0c:	9c b9       	out	0x0c, r25	; 12
	byte bcdToDec(byte val)
	{
  		return ( (val/16*10) + (val%16) );
	}
*/
}
     f0e:	08 95       	ret

00000f10 <transmitUart>:
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
     f10:	5d 9b       	sbis	0x0b, 5	; 11
     f12:	fe cf       	rjmp	.-4      	; 0xf10 <transmitUart>
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
     f14:	8c b9       	out	0x0c, r24	; 12
}
     f16:	08 95       	ret

00000f18 <transmitUartString>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
     f18:	fc 01       	movw	r30, r24
     f1a:	04 c0       	rjmp	.+8      	; 0xf24 <transmitUartString+0xc>
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
     f1c:	5d 9b       	sbis	0x0b, 5	; 11
     f1e:	fe cf       	rjmp	.-4      	; 0xf1c <transmitUartString+0x4>
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
	{
		transmitUart(*data++);
     f20:	31 96       	adiw	r30, 0x01	; 1
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
     f22:	8c b9       	out	0x0c, r24	; 12
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
     f24:	80 81       	ld	r24, Z
     f26:	88 23       	and	r24, r24
     f28:	c9 f7       	brne	.-14     	; 0xf1c <transmitUartString+0x4>
	{
		transmitUart(*data++);
	}
}
     f2a:	08 95       	ret

00000f2c <receiveUart>:
/**************************************************		// NOT FINISHED
** RECEIVE/READ unsigned char BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
unsigned char receiveUart(void)
{
	while (!(UCSRA & (1<<RXC)))
     f2c:	5f 9b       	sbis	0x0b, 7	; 11
     f2e:	fe cf       	rjmp	.-4      	; 0xf2c <receiveUart>
	{};							/* Wait for data to be received */
	return UDR;					/* Get and return received data from buffer */
     f30:	8c b1       	in	r24, 0x0c	; 12
}
     f32:	08 95       	ret

00000f34 <transmitUartLong>:
/******************************************		// NOT FINISHED
** TRANSMIT/SEND long BYTE OF UART/USART **		// NOT FINISHED
******************************************/		// NOT FINISHED
// USE THIS: transmitUartLong( (long)k + 1 );
void transmitUartLong(long data)		// void transmitUartLong(const long data)
{
     f34:	df 93       	push	r29
     f36:	cf 93       	push	r28
     f38:	cd b7       	in	r28, 0x3d	; 61
     f3a:	de b7       	in	r29, 0x3e	; 62
     f3c:	2a 97       	sbiw	r28, 0x0a	; 10
     f3e:	0f b6       	in	r0, 0x3f	; 63
     f40:	f8 94       	cli
     f42:	de bf       	out	0x3e, r29	; 62
     f44:	0f be       	out	0x3f, r0	; 63
     f46:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ltoa(data, buffer, 10));		// 10 -> DECIMAL
     f48:	ae 01       	movw	r20, r28
     f4a:	4f 5f       	subi	r20, 0xFF	; 255
     f4c:	5f 4f       	sbci	r21, 0xFF	; 255
     f4e:	2a e0       	ldi	r18, 0x0A	; 10
     f50:	30 e0       	ldi	r19, 0x00	; 0
     f52:	0e 94 92 0a 	call	0x1524	; 0x1524 <ltoa>
     f56:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
}
     f5a:	2a 96       	adiw	r28, 0x0a	; 10
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	de bf       	out	0x3e, r29	; 62
     f62:	0f be       	out	0x3f, r0	; 63
     f64:	cd bf       	out	0x3d, r28	; 61
     f66:	cf 91       	pop	r28
     f68:	df 91       	pop	r29
     f6a:	08 95       	ret

00000f6c <transmitUartULong>:
/***************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned long BYTE OF UART/USART **		// NOT FINISHED
***************************************************/		// NOT FINISHED
// USE THIS: transmitUartULong( (unsigned long)k + 1 );
void transmitUartULong(unsigned long data)		// void transmitUartULong(const unsigned long data)
{
     f6c:	df 93       	push	r29
     f6e:	cf 93       	push	r28
     f70:	cd b7       	in	r28, 0x3d	; 61
     f72:	de b7       	in	r29, 0x3e	; 62
     f74:	2a 97       	sbiw	r28, 0x0a	; 10
     f76:	0f b6       	in	r0, 0x3f	; 63
     f78:	f8 94       	cli
     f7a:	de bf       	out	0x3e, r29	; 62
     f7c:	0f be       	out	0x3f, r0	; 63
     f7e:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ultoa(data, buffer, 10));		// 10 -> DECIMAL
     f80:	ae 01       	movw	r20, r28
     f82:	4f 5f       	subi	r20, 0xFF	; 255
     f84:	5f 4f       	sbci	r21, 0xFF	; 255
     f86:	2a e0       	ldi	r18, 0x0A	; 10
     f88:	30 e0       	ldi	r19, 0x00	; 0
     f8a:	0e 94 c6 0a 	call	0x158c	; 0x158c <ultoa>
     f8e:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
}
     f92:	2a 96       	adiw	r28, 0x0a	; 10
     f94:	0f b6       	in	r0, 0x3f	; 63
     f96:	f8 94       	cli
     f98:	de bf       	out	0x3e, r29	; 62
     f9a:	0f be       	out	0x3f, r0	; 63
     f9c:	cd bf       	out	0x3d, r28	; 61
     f9e:	cf 91       	pop	r28
     fa0:	df 91       	pop	r29
     fa2:	08 95       	ret

00000fa4 <transmitUartInt>:
/*****************************************		// NOT FINISHED
** TRANSMIT/SEND int BYTE OF UART/USART **		// NOT FINISHED
*****************************************/		// NOT FINISHED
// USE THIS: transmitUartInt( (int)k + 1 );
void transmitUartInt(int data)		// void transmitUartInt(const int data)
{
     fa4:	df 93       	push	r29
     fa6:	cf 93       	push	r28
     fa8:	cd b7       	in	r28, 0x3d	; 61
     faa:	de b7       	in	r29, 0x3e	; 62
     fac:	2a 97       	sbiw	r28, 0x0a	; 10
     fae:	0f b6       	in	r0, 0x3f	; 63
     fb0:	f8 94       	cli
     fb2:	de bf       	out	0x3e, r29	; 62
     fb4:	0f be       	out	0x3f, r0	; 63
     fb6:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(itoa(data, buffer, 10));		// 10 -> DECIMAL
     fb8:	be 01       	movw	r22, r28
     fba:	6f 5f       	subi	r22, 0xFF	; 255
     fbc:	7f 4f       	sbci	r23, 0xFF	; 255
     fbe:	4a e0       	ldi	r20, 0x0A	; 10
     fc0:	50 e0       	ldi	r21, 0x00	; 0
     fc2:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <itoa>
     fc6:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
}
     fca:	2a 96       	adiw	r28, 0x0a	; 10
     fcc:	0f b6       	in	r0, 0x3f	; 63
     fce:	f8 94       	cli
     fd0:	de bf       	out	0x3e, r29	; 62
     fd2:	0f be       	out	0x3f, r0	; 63
     fd4:	cd bf       	out	0x3d, r28	; 61
     fd6:	cf 91       	pop	r28
     fd8:	df 91       	pop	r29
     fda:	08 95       	ret

00000fdc <transmitUartUInt>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned int BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: transmitUartUInt( (unsigned int)k + 1 );
void transmitUartUInt(unsigned int data)		// void transmitUartUInt(const unsigned int data)
{
     fdc:	df 93       	push	r29
     fde:	cf 93       	push	r28
     fe0:	cd b7       	in	r28, 0x3d	; 61
     fe2:	de b7       	in	r29, 0x3e	; 62
     fe4:	2a 97       	sbiw	r28, 0x0a	; 10
     fe6:	0f b6       	in	r0, 0x3f	; 63
     fe8:	f8 94       	cli
     fea:	de bf       	out	0x3e, r29	; 62
     fec:	0f be       	out	0x3f, r0	; 63
     fee:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(utoa(data, buffer, 10));		// 10 -> DECIMAL
     ff0:	be 01       	movw	r22, r28
     ff2:	6f 5f       	subi	r22, 0xFF	; 255
     ff4:	7f 4f       	sbci	r23, 0xFF	; 255
     ff6:	4a e0       	ldi	r20, 0x0A	; 10
     ff8:	50 e0       	ldi	r21, 0x00	; 0
     ffa:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <utoa>
     ffe:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
}
    1002:	2a 96       	adiw	r28, 0x0a	; 10
    1004:	0f b6       	in	r0, 0x3f	; 63
    1006:	f8 94       	cli
    1008:	de bf       	out	0x3e, r29	; 62
    100a:	0f be       	out	0x3f, r0	; 63
    100c:	cd bf       	out	0x3d, r28	; 61
    100e:	cf 91       	pop	r28
    1010:	df 91       	pop	r29
    1012:	08 95       	ret

00001014 <uart_init>:
{
	switch(F_CPU)
	{
		case 16000000UL:
		{
			UBRRL = 103;	// Baudrate: 9600; (Error = 0.2%; 16MHz)
    1014:	87 e6       	ldi	r24, 0x67	; 103
    1016:	89 b9       	out	0x09, r24	; 9
			UBRRH = 0;
    1018:	10 bc       	out	0x20, r1	; 32
		{
			break;
		}
	}
#ifdef DEBUG_SETTING
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
    101a:	8c e0       	ldi	r24, 0x0C	; 12
    101c:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 2								// and next is update volume lcd information
    1020:	84 ed       	ldi	r24, 0xD4	; 212
    1022:	0e 94 1f 06 	call	0xc3e	; 0xc3e <LCD_COMMAND>
	LCD_DATA_STRING("Freq: ");		// 20 symbols			
    1026:	8a e5       	ldi	r24, 0x5A	; 90
    1028:	96 e0       	ldi	r25, 0x06	; 6
    102a:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
	LCD_DATA_ULONG(F_CPU);			// 20 symbols
    102e:	60 e0       	ldi	r22, 0x00	; 0
    1030:	74 e2       	ldi	r23, 0x24	; 36
    1032:	84 ef       	ldi	r24, 0xF4	; 244
    1034:	90 e0       	ldi	r25, 0x00	; 0
    1036:	0e 94 b4 06 	call	0xd68	; 0xd68 <LCD_DATA_ULONG>
	LCD_DATA_STRING(" MHz");		// 20 symbols
    103a:	81 e6       	ldi	r24, 0x61	; 97
    103c:	96 e0       	ldi	r25, 0x06	; 6
    103e:	0e 94 57 06 	call	0xcae	; 0xcae <LCD_DATA_STRING>
#endif
	// Razpoznavane na baudrate (skorost): 1. Izprashta se byte. 2. Poluchava se byte. 3. Sravnqva se polucheniq byte == izprateniq byte. // This is LOOP TX->RX
	// 4. Ako byte pri sravnqvaneto e edin i sasht to skorostta e izbranata v momenta, ako byte e razlichen - da se probva sas sledvashta baudrate.

	UCSRC = 0b10000110;		// URSEL = 1 (Accessing to UBRRH or UCSRC, is read as zero when reading UBRRH. The URSEL must be zero when writing the UBRRH.); UMSEL = 0 (Asynchronous Operation); UPM1 = 0, UPM0 = 0 (Parity Mode Disabled); USBS = 0 (1-Stop Bit); UCSZ2 = 0, UCSZ1 = 1, UCSZ0 = 1 (8-DataBits); UCPOL = 0 Polarity TX & RX (Rising XCK Edge -> Transmitted Data Changed (Output of TxDPin), Falling XCK Edge -> Received Data Sampled (Input on RxDPin))
    1042:	86 e8       	ldi	r24, 0x86	; 134
    1044:	80 bd       	out	0x20, r24	; 32
	UCSRB = 0b00001000;		// Enable only TXEN	- Transmitting Uart/Usart	// UCSRB = 0b10011000;		// Enable TXEN,RXEN,RXCIE	Transmitting and Receiving Uart/Usart
    1046:	88 e0       	ldi	r24, 0x08	; 8
    1048:	8a b9       	out	0x0a, r24	; 10
	UDR = 0b00000000;		// INITIALIZATION NULL OF UART DATA
    104a:	1c b8       	out	0x0c, r1	; 12

#ifdef DEBUG_INFO
	transmitUartString("\r\n");
    104c:	86 e6       	ldi	r24, 0x66	; 102
    104e:	96 e0       	ldi	r25, 0x06	; 6
    1050:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
#if DEBUG_SETTING
	transmitUartString("[UART INFO] Serial Port Settings - Baud rate: 9600, Data bits: 8 bits, Stop bits: 1 bit, Parity: None, Flow control: None or XON/XOFF\r\n");
    1054:	89 e6       	ldi	r24, 0x69	; 105
    1056:	96 e0       	ldi	r25, 0x06	; 6
    1058:	0e 94 8c 07 	call	0xf18	; 0xf18 <transmitUartString>
#endif
}
    105c:	08 95       	ret

0000105e <spi_init>:
/**************************
** INITIZLIZATION OF SPI **
***************************/
void spi_init()
{
	SPSR = (0<<SPIF)|(0<<WCOL)|(0<<SPI2X);
    105e:	1e b8       	out	0x0e, r1	; 14
//	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);			//0b01010010	// SPR1   = 1 - 16 000 000 / 64  = 250 000 = 250kHz  // KOMENTAR ZARADI SIMULACIQTA - PROTEUS BLOKIRANE ZARADI BIT V REGISTAR
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz	 // KAKVA KOMBINACIQ OT 4-te BITa VODI DO RAZBLOKIRANETO ???
    1060:	83 e5       	ldi	r24, 0x53	; 83
    1062:	8d b9       	out	0x0d, r24	; 13
	SPDR = 0b00000000;
    1064:	1f b8       	out	0x0f, r1	; 15

	PGA2310_U8_SPI_CS_high();	// /SS - DISABLE
	PGA2310_U8_SPI(0b00000000, 0b00000000);
	*/

	SPCR = (0<<SPE);
    1066:	1d b8       	out	0x0d, r1	; 13
}
    1068:	08 95       	ret

0000106a <spi_start>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    106a:	83 e5       	ldi	r24, 0x53	; 83
    106c:	8d b9       	out	0x0d, r24	; 13
}
    106e:	08 95       	ret

00001070 <spi_stop>:
/**************************************
** DEFINITION SPI FUNCTION STOP ONLY **
**************************************/
void spi_stop()
{
	SPCR = (0<<SPE);
    1070:	1d b8       	out	0x0d, r1	; 13
}
    1072:	08 95       	ret

00001074 <spi_write_one_byte>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1074:	93 e5       	ldi	r25, 0x53	; 83
    1076:	9d b9       	out	0x0d, r25	; 13
void spi_write_one_byte(unsigned char data)	// void PGA2310_U7_SPI(byte volume_left, byte volume_right)	//PGA2310_U7_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data;				//volume_right;
    1078:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    107a:	77 9b       	sbis	0x0e, 7	; 14
    107c:	fe cf       	rjmp	.-4      	; 0x107a <spi_write_one_byte+0x6>
	{
	}
}
    107e:	08 95       	ret

00001080 <spi_write_two_bytes>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1080:	93 e5       	ldi	r25, 0x53	; 83
    1082:	9d b9       	out	0x0d, r25	; 13
void spi_write_two_bytes(unsigned char data1, unsigned char data2)	// void PGA2310_U6_SPI(byte volume_left, byte volume_right)	//PGA2310_U6_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data1;				//volume_left;
    1084:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    1086:	77 9b       	sbis	0x0e, 7	; 14
    1088:	fe cf       	rjmp	.-4      	; 0x1086 <spi_write_two_bytes+0x6>
	{
	}

//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data2;				//volume_right;
    108a:	6f b9       	out	0x0f, r22	; 15
	while(!(SPSR & (1<<SPIF)))
    108c:	77 9b       	sbis	0x0e, 7	; 14
    108e:	fe cf       	rjmp	.-4      	; 0x108c <spi_write_two_bytes+0xc>
	{
	}
}
    1090:	08 95       	ret

00001092 <spi_write_more_bytes>:

/*********************************************
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
    1092:	fc 01       	movw	r30, r24
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1094:	93 e5       	ldi	r25, 0x53	; 83
    1096:	06 c0       	rjmp	.+12     	; 0x10a4 <spi_write_more_bytes+0x12>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    1098:	31 96       	adiw	r30, 0x01	; 1
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    109a:	9d b9       	out	0x0d, r25	; 13
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
	{
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
		spi_start();
		SPDR = *data;			//volume_left;
    109c:	80 81       	ld	r24, Z
    109e:	8f b9       	out	0x0f, r24	; 15
		while(!(SPSR & (1<<SPIF)))
    10a0:	77 9b       	sbis	0x0e, 7	; 14
    10a2:	fe cf       	rjmp	.-4      	; 0x10a0 <spi_write_more_bytes+0xe>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    10a4:	80 81       	ld	r24, Z
    10a6:	88 23       	and	r24, r24
    10a8:	b9 f7       	brne	.-18     	; 0x1098 <spi_write_more_bytes+0x6>
		SPDR = *data;			//volume_left;
		while(!(SPSR & (1<<SPIF)))
		{
		}
	}
}
    10aa:	08 95       	ret

000010ac <spi_read_more_bytes>:
unsigned char spi_read_more_bytes()	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
	unsigned char data = 0b00000000;
	//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data;			//volume_left;
    10ac:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF)))
    10ae:	77 9b       	sbis	0x0e, 7	; 14
    10b0:	fe cf       	rjmp	.-4      	; 0x10ae <spi_read_more_bytes+0x2>
	{
	}
	return data;
}
    10b2:	80 e0       	ldi	r24, 0x00	; 0
    10b4:	08 95       	ret

000010b6 <decToBcd>:

/**************************************************************
**** CONVERT NORMAL DECIMAL NUMBERS TO BINARY CODED DECIMAL ***
**************************************************************/
unsigned char decToBcd(unsigned char val)
{
    10b6:	48 2f       	mov	r20, r24
    10b8:	6a e0       	ldi	r22, 0x0A	; 10
    10ba:	0e 94 3e 0a 	call	0x147c	; 0x147c <__udivmodqi4>
    10be:	28 2f       	mov	r18, r24
    10c0:	30 e0       	ldi	r19, 0x00	; 0
    10c2:	84 e0       	ldi	r24, 0x04	; 4
    10c4:	22 0f       	add	r18, r18
    10c6:	33 1f       	adc	r19, r19
    10c8:	8a 95       	dec	r24
    10ca:	e1 f7       	brne	.-8      	; 0x10c4 <decToBcd+0xe>
    10cc:	84 2f       	mov	r24, r20
    10ce:	0e 94 3e 0a 	call	0x147c	; 0x147c <__udivmodqi4>
	return ( (val/10*16) + (val%10) );	// Get DEC format -> convert DEC to HEX
}
    10d2:	89 2f       	mov	r24, r25
    10d4:	82 0f       	add	r24, r18
    10d6:	08 95       	ret

000010d8 <bcdToDec>:

/**************************************************************
**** CONVERT BINARY CODED DECIMAL TO NORMAL DECIMAL NUMBERS ***
**************************************************************/
unsigned char bcdToDec(unsigned char val)
{
    10d8:	28 2f       	mov	r18, r24
    10da:	22 95       	swap	r18
    10dc:	2f 70       	andi	r18, 0x0F	; 15
    10de:	9a e0       	ldi	r25, 0x0A	; 10
    10e0:	29 9f       	mul	r18, r25
    10e2:	90 01       	movw	r18, r0
    10e4:	11 24       	eor	r1, r1
    10e6:	8f 70       	andi	r24, 0x0F	; 15
	return ( (val/16*10) + (val%16) );	// Get HEX format -> convert HEX to DEC
}
    10e8:	82 0f       	add	r24, r18
    10ea:	08 95       	ret

000010ec <shiftRightOutLsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    10ec:	a0 9a       	sbi	0x14, 0	; 20
    10ee:	94 e4       	ldi	r25, 0x44	; 68
    10f0:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regALSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    10f2:	90 ff       	sbrs	r25, 0
    10f4:	02 c0       	rjmp	.+4      	; 0x10fa <shiftRightOutLsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v LSB
    10f6:	a8 9a       	sbi	0x15, 0	; 21
    10f8:	01 c0       	rjmp	.+2      	; 0x10fc <shiftRightOutLsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
    10fa:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    10fc:	8f 5f       	subi	r24, 0xFF	; 255
    10fe:	88 30       	cpi	r24, 0x08	; 8
    1100:	11 f0       	breq	.+4      	; 0x1106 <shiftRightOutLsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
		}
		
		regALSB = regALSB >> 1;	// shiftvane na >> nadqsno
    1102:	96 95       	lsr	r25
    1104:	f6 cf       	rjmp	.-20     	; 0x10f2 <shiftRightOutLsbFirst+0x6>
    1106:	08 95       	ret

00001108 <shiftLeftOutMsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    1108:	a0 9a       	sbi	0x14, 0	; 20
    110a:	94 e4       	ldi	r25, 0x44	; 68
    110c:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regAMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
    110e:	97 ff       	sbrs	r25, 7
    1110:	02 c0       	rjmp	.+4      	; 0x1116 <shiftLeftOutMsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v MSB
    1112:	a8 9a       	sbi	0x15, 0	; 21
    1114:	01 c0       	rjmp	.+2      	; 0x1118 <shiftLeftOutMsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
    1116:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1118:	8f 5f       	subi	r24, 0xFF	; 255
    111a:	88 30       	cpi	r24, 0x08	; 8
    111c:	11 f0       	breq	.+4      	; 0x1122 <shiftLeftOutMsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
		}
		
		regAMSB = regAMSB << 1;	// shiftvane na << nalqvo
    111e:	99 0f       	add	r25, r25
    1120:	f6 cf       	rjmp	.-20     	; 0x110e <shiftLeftOutMsbFirst+0x6>
    1122:	08 95       	ret

00001124 <shiftRightInLsbFirst>:
void shiftRightInLsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    1124:	a0 98       	cbi	0x14, 0	; 20
    1126:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
    1128:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    112a:	8f 5f       	subi	r24, 0xFF	; 255
    112c:	88 30       	cpi	r24, 0x08	; 8
    112e:	e1 f7       	brne	.-8      	; 0x1128 <shiftRightInLsbFirst+0x4>
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
	}

}
    1130:	08 95       	ret

00001132 <shiftLeftInMsbFirst>:
void shiftLeftInMsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    1132:	a0 98       	cbi	0x14, 0	; 20
    1134:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
    1136:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1138:	8f 5f       	subi	r24, 0xFF	; 255
    113a:	88 30       	cpi	r24, 0x08	; 8
    113c:	e1 f7       	brne	.-8      	; 0x1136 <shiftLeftInMsbFirst+0x4>
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
	}

}
    113e:	08 95       	ret

00001140 <delay_ms>:

/*************************************************************
*********** FUNCTION SOFTWARE DELAY IN MILISECONDS ***********
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
    1140:	40 e0       	ldi	r20, 0x00	; 0
    1142:	50 e0       	ldi	r21, 0x00	; 0
    1144:	0b c0       	rjmp	.+22     	; 0x115c <delay_ms+0x1c>
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1146:	20 e0       	ldi	r18, 0x00	; 0
    1148:	30 e0       	ldi	r19, 0x00	; 0
	{
		for(j=0;j<100;j++)
		{
		  asm("nop");
    114a:	00 00       	nop
		  asm("nop");
    114c:	00 00       	nop
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
	{
		for(j=0;j<100;j++)
    114e:	2f 5f       	subi	r18, 0xFF	; 255
    1150:	3f 4f       	sbci	r19, 0xFF	; 255
    1152:	24 36       	cpi	r18, 0x64	; 100
    1154:	31 05       	cpc	r19, r1
    1156:	c9 f7       	brne	.-14     	; 0x114a <delay_ms+0xa>
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1158:	4f 5f       	subi	r20, 0xFF	; 255
    115a:	5f 4f       	sbci	r21, 0xFF	; 255
    115c:	48 17       	cp	r20, r24
    115e:	59 07       	cpc	r21, r25
    1160:	94 f3       	brlt	.-28     	; 0x1146 <delay_ms+0x6>
		{
		  asm("nop");
		  asm("nop");
		}
	}
}
    1162:	08 95       	ret

00001164 <rotaryEncoderNikBarzakov>:
** READ/SCAN ROTARY ENCODER OF NIK BARZAKOV **
*********************************************/
char rotaryEncoderNikBarzakov()
{
	char tempEncoder = 0;
	if((ENCODER_A_low()) && (ENCODER_B_low()))			// A0, B0
    1164:	9d 99       	sbic	0x13, 5	; 19
    1166:	0e c0       	rjmp	.+28     	; 0x1184 <rotaryEncoderNikBarzakov+0x20>
    1168:	9c 99       	sbic	0x13, 4	; 19
    116a:	0c c0       	rjmp	.+24     	; 0x1184 <rotaryEncoderNikBarzakov+0x20>
    116c:	88 ec       	ldi	r24, 0xC8	; 200
    116e:	90 e0       	ldi	r25, 0x00	; 0
    1170:	01 97       	sbiw	r24, 0x01	; 1
    1172:	f1 f7       	brne	.-4      	; 0x1170 <rotaryEncoderNikBarzakov+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_high()) && (ENCODER_B_low()))		// A1, B0
    1174:	9d 9b       	sbis	0x13, 5	; 19
    1176:	14 c0       	rjmp	.+40     	; 0x11a0 <rotaryEncoderNikBarzakov+0x3c>
    1178:	83 b3       	in	r24, 0x13	; 19
    117a:	82 95       	swap	r24
    117c:	8f 70       	andi	r24, 0x0F	; 15
    117e:	80 95       	com	r24
    1180:	81 70       	andi	r24, 0x01	; 1
    1182:	08 95       	ret
// VOLUME UP
			tempEncoder = 1;	//	tempEncoder++;
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}
	}
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    1184:	9d 9b       	sbis	0x13, 5	; 19
    1186:	0c c0       	rjmp	.+24     	; 0x11a0 <rotaryEncoderNikBarzakov+0x3c>
    1188:	9c 99       	sbic	0x13, 4	; 19
    118a:	0a c0       	rjmp	.+20     	; 0x11a0 <rotaryEncoderNikBarzakov+0x3c>
    118c:	88 ec       	ldi	r24, 0xC8	; 200
    118e:	90 e0       	ldi	r25, 0x00	; 0
    1190:	01 97       	sbiw	r24, 0x01	; 1
    1192:	f1 f7       	brne	.-4      	; 0x1190 <rotaryEncoderNikBarzakov+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    1194:	9d 99       	sbic	0x13, 5	; 19
    1196:	04 c0       	rjmp	.+8      	; 0x11a0 <rotaryEncoderNikBarzakov+0x3c>
    1198:	9c 99       	sbic	0x13, 4	; 19
    119a:	02 c0       	rjmp	.+4      	; 0x11a0 <rotaryEncoderNikBarzakov+0x3c>
    119c:	8f ef       	ldi	r24, 0xFF	; 255
    119e:	08 95       	ret
    11a0:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    11a2:	08 95       	ret

000011a4 <rotaryEncoderVer1>:
** READ/SCAN ROTARY ENCODER VERSION 1 / MODEL 1 **
*************************************************/
char rotaryEncoderVer1()	// Check imediate now bits in PIN register.
{
	char tempEncoder = 0;							// A1, B1
	if((ENCODER_A_low()) && (ENCODER_B_high()))			// A0, B1
    11a4:	9d 99       	sbic	0x13, 5	; 19
    11a6:	0e c0       	rjmp	.+28     	; 0x11c4 <rotaryEncoderVer1+0x20>
    11a8:	9c 9b       	sbis	0x13, 4	; 19
    11aa:	0c c0       	rjmp	.+24     	; 0x11c4 <rotaryEncoderVer1+0x20>
    11ac:	88 ec       	ldi	r24, 0xC8	; 200
    11ae:	90 e0       	ldi	r25, 0x00	; 0
    11b0:	01 97       	sbiw	r24, 0x01	; 1
    11b2:	f1 f7       	brne	.-4      	; 0x11b0 <rotaryEncoderVer1+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    11b4:	9d 99       	sbic	0x13, 5	; 19
    11b6:	14 c0       	rjmp	.+40     	; 0x11e0 <rotaryEncoderVer1+0x3c>
    11b8:	83 b3       	in	r24, 0x13	; 19
    11ba:	82 95       	swap	r24
    11bc:	8f 70       	andi	r24, 0x0F	; 15
    11be:	80 95       	com	r24
    11c0:	81 70       	andi	r24, 0x01	; 1
    11c2:	08 95       	ret
//			PORTD = volumeMassive[volumeIndex];
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}

	}													// A1. B1
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    11c4:	9d 9b       	sbis	0x13, 5	; 19
    11c6:	0c c0       	rjmp	.+24     	; 0x11e0 <rotaryEncoderVer1+0x3c>
    11c8:	9c 99       	sbic	0x13, 4	; 19
    11ca:	0a c0       	rjmp	.+20     	; 0x11e0 <rotaryEncoderVer1+0x3c>
    11cc:	88 ec       	ldi	r24, 0xC8	; 200
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	01 97       	sbiw	r24, 0x01	; 1
    11d2:	f1 f7       	brne	.-4      	; 0x11d0 <rotaryEncoderVer1+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    11d4:	9d 99       	sbic	0x13, 5	; 19
    11d6:	04 c0       	rjmp	.+8      	; 0x11e0 <rotaryEncoderVer1+0x3c>
    11d8:	9c 99       	sbic	0x13, 4	; 19
    11da:	02 c0       	rjmp	.+4      	; 0x11e0 <rotaryEncoderVer1+0x3c>
    11dc:	8f ef       	ldi	r24, 0xFF	; 255
    11de:	08 95       	ret
    11e0:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    11e2:	08 95       	ret

000011e4 <rotaryEncoderVer2>:
    11e4:	88 ec       	ldi	r24, 0xC8	; 200
    11e6:	90 e0       	ldi	r25, 0x00	; 0
    11e8:	fc 01       	movw	r30, r24
    11ea:	31 97       	sbiw	r30, 0x01	; 1
    11ec:	f1 f7       	brne	.-4      	; 0x11ea <rotaryEncoderVer2+0x6>
    11ee:	fc 01       	movw	r30, r24
    11f0:	31 97       	sbiw	r30, 0x01	; 1
    11f2:	f1 f7       	brne	.-4      	; 0x11f0 <rotaryEncoderVer2+0xc>
    11f4:	01 97       	sbiw	r24, 0x01	; 1
    11f6:	f1 f7       	brne	.-4      	; 0x11f4 <rotaryEncoderVer2+0x10>
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    11f8:	80 e0       	ldi	r24, 0x00	; 0
    11fa:	08 95       	ret

000011fc <RELAYS_IN_INIT>:
/*********************************************
** INITIZLIZATION OF SHIFT REGISTER 74HC595 **
*********************************************/
void RELAYS_IN_INIT()
{
}
    11fc:	08 95       	ret

000011fe <RELAYS_OUT_INIT>:

void RELAYS_OUT_INIT()
{
}
    11fe:	08 95       	ret

00001200 <RELAYS_IN_CHOOSE>:

/****************************************************************************************************************
** DEFINITION RELAYS IN FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS IN **
****************************************************************************************************************/
void RELAYS_IN_CHOOSE(unsigned char rel_in)	// HELP: RELAYS_IN_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    1200:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELIN_SCK_low();
    1202:	ae 98       	cbi	0x15, 6	; 21

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1204:	80 ff       	sbrs	r24, 0
    1206:	02 c0       	rjmp	.+4      	; 0x120c <RELAYS_IN_CHOOSE+0xc>
		{
			RELIN_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    1208:	af 9a       	sbi	0x15, 7	; 21
    120a:	01 c0       	rjmp	.+2      	; 0x120e <RELAYS_IN_CHOOSE+0xe>
		}
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    120c:	af 98       	cbi	0x15, 7	; 21
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELIN_SCK_high();
    120e:	ae 9a       	sbi	0x15, 6	; 21
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1210:	9f 5f       	subi	r25, 0xFF	; 255
    1212:	98 30       	cpi	r25, 0x08	; 8
    1214:	11 f0       	breq	.+4      	; 0x121a <RELAYS_IN_CHOOSE+0x1a>
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    1216:	86 95       	lsr	r24
    1218:	f4 cf       	rjmp	.-24     	; 0x1202 <RELAYS_IN_CHOOSE+0x2>

		RELIN_SCK_high();
	}

	RELIN_RCK_low();
    121a:	ab 98       	cbi	0x15, 3	; 21
    121c:	88 ea       	ldi	r24, 0xA8	; 168
    121e:	92 e0       	ldi	r25, 0x02	; 2
    1220:	fc 01       	movw	r30, r24
    1222:	31 97       	sbiw	r30, 0x01	; 1
    1224:	f1 f7       	brne	.-4      	; 0x1222 <RELAYS_IN_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELIN_RCK_high();
    1226:	ab 9a       	sbi	0x15, 3	; 21
    1228:	01 97       	sbiw	r24, 0x01	; 1
    122a:	f1 f7       	brne	.-4      	; 0x1228 <RELAYS_IN_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    122c:	08 95       	ret

0000122e <relays_in1_2ch>:

void relays_in1_2ch()
{
	RELAYS_IN_CHOOSE(0b00100000);	// RELE 1
    122e:	80 e2       	ldi	r24, 0x20	; 32
    1230:	0e 94 00 09 	call	0x1200	; 0x1200 <RELAYS_IN_CHOOSE>
}
    1234:	08 95       	ret

00001236 <relays_in1_6ch>:

void relays_in1_6ch()
{
	RELAYS_IN_CHOOSE(0b01100001);	// RELE 1,2,3
    1236:	81 e6       	ldi	r24, 0x61	; 97
    1238:	0e 94 00 09 	call	0x1200	; 0x1200 <RELAYS_IN_CHOOSE>
}
    123c:	08 95       	ret

0000123e <relays_in2_2ch>:

void relays_in2_2ch()
{
	RELAYS_IN_CHOOSE(0b00001010);	// RELE 4,5
    123e:	8a e0       	ldi	r24, 0x0A	; 10
    1240:	0e 94 00 09 	call	0x1200	; 0x1200 <RELAYS_IN_CHOOSE>
}
    1244:	08 95       	ret

00001246 <relays_in2_6ch>:

void relays_in2_6ch()
{
	RELAYS_IN_CHOOSE(0b10011010);	// RELE 4,5,6,7
    1246:	8a e9       	ldi	r24, 0x9A	; 154
    1248:	0e 94 00 09 	call	0x1200	; 0x1200 <RELAYS_IN_CHOOSE>
}
    124c:	08 95       	ret

0000124e <relays_in3_2ch>:

void relays_in3_2ch()
{
	RELAYS_IN_CHOOSE(0b00001100);	// RELE 8,5
    124e:	8c e0       	ldi	r24, 0x0C	; 12
    1250:	0e 94 00 09 	call	0x1200	; 0x1200 <RELAYS_IN_CHOOSE>
}
    1254:	08 95       	ret

00001256 <relays_in3_6ch>:

void relays_in3_6ch()
{
	RELAYS_IN_CHOOSE(0b10011100);	// RELE 8,5,6,7
    1256:	8c e9       	ldi	r24, 0x9C	; 156
    1258:	0e 94 00 09 	call	0x1200	; 0x1200 <RELAYS_IN_CHOOSE>
}
    125c:	08 95       	ret

0000125e <relays_in_off>:

void relays_in_off()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    125e:	80 e0       	ldi	r24, 0x00	; 0
    1260:	0e 94 00 09 	call	0x1200	; 0x1200 <RELAYS_IN_CHOOSE>
}
    1264:	08 95       	ret

00001266 <relays_in_init>:

void relays_in_init()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    1266:	80 e0       	ldi	r24, 0x00	; 0
    1268:	0e 94 00 09 	call	0x1200	; 0x1200 <RELAYS_IN_CHOOSE>
}
    126c:	08 95       	ret

0000126e <RELAYS_OUT_CHOOSE>:
/******************************************************************************************************************
** DEFINITION RELAYS OUT FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS OUT **
******************************************************************************************************************/
void RELAYS_OUT_CHOOSE(unsigned char rel_out)	// HELP: RELAYS_OUT_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    126e:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELOUT_SCK_low();
    1270:	96 98       	cbi	0x12, 6	; 18

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1272:	80 ff       	sbrs	r24, 0
    1274:	02 c0       	rjmp	.+4      	; 0x127a <RELAYS_OUT_CHOOSE+0xc>
		{
			RELOUT_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    1276:	c4 9a       	sbi	0x18, 4	; 24
    1278:	01 c0       	rjmp	.+2      	; 0x127c <RELAYS_OUT_CHOOSE+0xe>
		}
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    127a:	c4 98       	cbi	0x18, 4	; 24
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELOUT_SCK_high();
    127c:	96 9a       	sbi	0x12, 6	; 18
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    127e:	9f 5f       	subi	r25, 0xFF	; 255
    1280:	98 30       	cpi	r25, 0x08	; 8
    1282:	11 f0       	breq	.+4      	; 0x1288 <RELAYS_OUT_CHOOSE+0x1a>
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    1284:	86 95       	lsr	r24
    1286:	f4 cf       	rjmp	.-24     	; 0x1270 <RELAYS_OUT_CHOOSE+0x2>

		RELOUT_SCK_high();
	}

	RELOUT_RCK_low();
    1288:	97 98       	cbi	0x12, 7	; 18
    128a:	88 ea       	ldi	r24, 0xA8	; 168
    128c:	92 e0       	ldi	r25, 0x02	; 2
    128e:	fc 01       	movw	r30, r24
    1290:	31 97       	sbiw	r30, 0x01	; 1
    1292:	f1 f7       	brne	.-4      	; 0x1290 <RELAYS_OUT_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELOUT_RCK_high();
    1294:	97 9a       	sbi	0x12, 7	; 18
    1296:	01 97       	sbiw	r24, 0x01	; 1
    1298:	f1 f7       	brne	.-4      	; 0x1296 <RELAYS_OUT_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    129a:	08 95       	ret

0000129c <relays_out_1ch>:

void relays_out_1ch()
{
	RELAYS_OUT_CHOOSE(0b10000000);	// RELE 1
    129c:	80 e8       	ldi	r24, 0x80	; 128
    129e:	0e 94 37 09 	call	0x126e	; 0x126e <RELAYS_OUT_CHOOSE>
}
    12a2:	08 95       	ret

000012a4 <relays_out_6ch>:

void relays_out_6ch()
{
	RELAYS_OUT_CHOOSE(0b11111100);	// RELE 1,2,3,4,5,6
    12a4:	8c ef       	ldi	r24, 0xFC	; 252
    12a6:	0e 94 37 09 	call	0x126e	; 0x126e <RELAYS_OUT_CHOOSE>
}
    12aa:	08 95       	ret

000012ac <relays_out_off>:
void relays_out_off()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    12ac:	80 e0       	ldi	r24, 0x00	; 0
    12ae:	0e 94 37 09 	call	0x126e	; 0x126e <RELAYS_OUT_CHOOSE>
}
    12b2:	08 95       	ret

000012b4 <relays_out_init>:
void relays_out_init()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    12b4:	80 e0       	ldi	r24, 0x00	; 0
    12b6:	0e 94 37 09 	call	0x126e	; 0x126e <RELAYS_OUT_CHOOSE>
}
    12ba:	08 95       	ret

000012bc <GetSIRC12>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    12bc:	10 92 0d 07 	sts	0x070D, r1
    12c0:	10 92 12 07 	sts	0x0712, r1

	while(irPin);				//wait for it to be low
    12c4:	82 99       	sbic	0x10, 2	; 16
    12c6:	fe cf       	rjmp	.-4      	; 0x12c4 <GetSIRC12+0x8>
    12c8:	20 e0       	ldi	r18, 0x00	; 0
    12ca:	40 e2       	ldi	r20, 0x20	; 32
    12cc:	53 e0       	ldi	r21, 0x03	; 3
    12ce:	04 c0       	rjmp	.+8      	; 0x12d8 <GetSIRC12+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    12d0:	2f 5f       	subi	r18, 0xFF	; 255
    12d2:	ca 01       	movw	r24, r20
    12d4:	01 97       	sbiw	r24, 0x01	; 1
    12d6:	f1 f7       	brne	.-4      	; 0x12d4 <GetSIRC12+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    12d8:	82 9b       	sbis	0x10, 2	; 16
    12da:	fa cf       	rjmp	.-12     	; 0x12d0 <GetSIRC12+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    12dc:	2b 50       	subi	r18, 0x0B	; 11
    12de:	23 30       	cpi	r18, 0x03	; 3
    12e0:	70 f5       	brcc	.+92     	; 0x133e <GetSIRC12+0x82>
	{
		return;		//goto StartLook;
    12e2:	40 e0       	ldi	r20, 0x00	; 0
    12e4:	30 e0       	ldi	r19, 0x00	; 0
    12e6:	60 e2       	ldi	r22, 0x20	; 32
    12e8:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    12ea:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    12ec:	82 99       	sbic	0x10, 2	; 16
    12ee:	fe cf       	rjmp	.-4      	; 0x12ec <GetSIRC12+0x30>
    12f0:	20 e0       	ldi	r18, 0x00	; 0
    12f2:	04 c0       	rjmp	.+8      	; 0x12fc <GetSIRC12+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    12f4:	2f 5f       	subi	r18, 0xFF	; 255
    12f6:	cb 01       	movw	r24, r22
    12f8:	01 97       	sbiw	r24, 0x01	; 1
    12fa:	f1 f7       	brne	.-4      	; 0x12f8 <GetSIRC12+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    12fc:	82 9b       	sbis	0x10, 2	; 16
    12fe:	fa cf       	rjmp	.-12     	; 0x12f4 <GetSIRC12+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1300:	26 30       	cpi	r18, 0x06	; 6
    1302:	08 f0       	brcs	.+2      	; 0x1306 <GetSIRC12+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    1304:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    1306:	4f 5f       	subi	r20, 0xFF	; 255
    1308:	47 30       	cpi	r20, 0x07	; 7
    130a:	79 f7       	brne	.-34     	; 0x12ea <GetSIRC12+0x2e>
    130c:	30 93 0d 07 	sts	0x070D, r19
    1310:	40 e0       	ldi	r20, 0x00	; 0
    1312:	30 e0       	ldi	r19, 0x00	; 0
    1314:	60 e2       	ldi	r22, 0x20	; 32
    1316:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1318:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    131a:	82 99       	sbic	0x10, 2	; 16
    131c:	fe cf       	rjmp	.-4      	; 0x131a <GetSIRC12+0x5e>
    131e:	20 e0       	ldi	r18, 0x00	; 0
    1320:	04 c0       	rjmp	.+8      	; 0x132a <GetSIRC12+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1322:	2f 5f       	subi	r18, 0xFF	; 255
    1324:	cb 01       	movw	r24, r22
    1326:	01 97       	sbiw	r24, 0x01	; 1
    1328:	f1 f7       	brne	.-4      	; 0x1326 <GetSIRC12+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    132a:	82 9b       	sbis	0x10, 2	; 16
    132c:	fa cf       	rjmp	.-12     	; 0x1322 <GetSIRC12+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    132e:	26 30       	cpi	r18, 0x06	; 6
    1330:	08 f0       	brcs	.+2      	; 0x1334 <GetSIRC12+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1332:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
    1334:	4f 5f       	subi	r20, 0xFF	; 255
    1336:	45 30       	cpi	r20, 0x05	; 5
    1338:	79 f7       	brne	.-34     	; 0x1318 <GetSIRC12+0x5c>
    133a:	30 93 12 07 	sts	0x0712, r19
    133e:	08 95       	ret

00001340 <GetSIRC15>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    1340:	10 92 0d 07 	sts	0x070D, r1
    1344:	10 92 12 07 	sts	0x0712, r1

	while(irPin);				//wait for it to be low
    1348:	82 99       	sbic	0x10, 2	; 16
    134a:	fe cf       	rjmp	.-4      	; 0x1348 <GetSIRC15+0x8>
    134c:	20 e0       	ldi	r18, 0x00	; 0
    134e:	40 e2       	ldi	r20, 0x20	; 32
    1350:	53 e0       	ldi	r21, 0x03	; 3
    1352:	04 c0       	rjmp	.+8      	; 0x135c <GetSIRC15+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    1354:	2f 5f       	subi	r18, 0xFF	; 255
    1356:	ca 01       	movw	r24, r20
    1358:	01 97       	sbiw	r24, 0x01	; 1
    135a:	f1 f7       	brne	.-4      	; 0x1358 <GetSIRC15+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    135c:	82 9b       	sbis	0x10, 2	; 16
    135e:	fa cf       	rjmp	.-12     	; 0x1354 <GetSIRC15+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    1360:	2b 50       	subi	r18, 0x0B	; 11
    1362:	23 30       	cpi	r18, 0x03	; 3
    1364:	70 f5       	brcc	.+92     	; 0x13c2 <GetSIRC15+0x82>
	{
		return;		//goto StartLook;
    1366:	40 e0       	ldi	r20, 0x00	; 0
    1368:	30 e0       	ldi	r19, 0x00	; 0
    136a:	60 e2       	ldi	r22, 0x20	; 32
    136c:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    136e:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1370:	82 99       	sbic	0x10, 2	; 16
    1372:	fe cf       	rjmp	.-4      	; 0x1370 <GetSIRC15+0x30>
    1374:	20 e0       	ldi	r18, 0x00	; 0
    1376:	04 c0       	rjmp	.+8      	; 0x1380 <GetSIRC15+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    1378:	2f 5f       	subi	r18, 0xFF	; 255
    137a:	cb 01       	movw	r24, r22
    137c:	01 97       	sbiw	r24, 0x01	; 1
    137e:	f1 f7       	brne	.-4      	; 0x137c <GetSIRC15+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1380:	82 9b       	sbis	0x10, 2	; 16
    1382:	fa cf       	rjmp	.-12     	; 0x1378 <GetSIRC15+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1384:	26 30       	cpi	r18, 0x06	; 6
    1386:	08 f0       	brcs	.+2      	; 0x138a <GetSIRC15+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    1388:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    138a:	4f 5f       	subi	r20, 0xFF	; 255
    138c:	47 30       	cpi	r20, 0x07	; 7
    138e:	79 f7       	brne	.-34     	; 0x136e <GetSIRC15+0x2e>
    1390:	30 93 0d 07 	sts	0x070D, r19
    1394:	40 e0       	ldi	r20, 0x00	; 0
    1396:	30 e0       	ldi	r19, 0x00	; 0
    1398:	60 e2       	ldi	r22, 0x20	; 32
    139a:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    139c:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    139e:	82 99       	sbic	0x10, 2	; 16
    13a0:	fe cf       	rjmp	.-4      	; 0x139e <GetSIRC15+0x5e>
    13a2:	20 e0       	ldi	r18, 0x00	; 0
    13a4:	04 c0       	rjmp	.+8      	; 0x13ae <GetSIRC15+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    13a6:	2f 5f       	subi	r18, 0xFF	; 255
    13a8:	cb 01       	movw	r24, r22
    13aa:	01 97       	sbiw	r24, 0x01	; 1
    13ac:	f1 f7       	brne	.-4      	; 0x13aa <GetSIRC15+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    13ae:	82 9b       	sbis	0x10, 2	; 16
    13b0:	fa cf       	rjmp	.-12     	; 0x13a6 <GetSIRC15+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    13b2:	26 30       	cpi	r18, 0x06	; 6
    13b4:	08 f0       	brcs	.+2      	; 0x13b8 <GetSIRC15+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    13b6:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
    13b8:	4f 5f       	subi	r20, 0xFF	; 255
    13ba:	48 30       	cpi	r20, 0x08	; 8
    13bc:	79 f7       	brne	.-34     	; 0x139c <GetSIRC15+0x5c>
    13be:	30 93 12 07 	sts	0x0712, r19
    13c2:	08 95       	ret

000013c4 <GetSIRC20>:
{
	char x;
	char lTime;

//StartLook:
	irExtended = irAddress = irCommand = 0;
    13c4:	10 92 0d 07 	sts	0x070D, r1
    13c8:	10 92 12 07 	sts	0x0712, r1
    13cc:	10 92 14 07 	sts	0x0714, r1

	while(irPin);				//wait for it to be low
    13d0:	82 99       	sbic	0x10, 2	; 16
    13d2:	fe cf       	rjmp	.-4      	; 0x13d0 <GetSIRC20+0xc>
    13d4:	20 e0       	ldi	r18, 0x00	; 0
    13d6:	40 e2       	ldi	r20, 0x20	; 32
    13d8:	53 e0       	ldi	r21, 0x03	; 3
    13da:	04 c0       	rjmp	.+8      	; 0x13e4 <GetSIRC20+0x20>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    13dc:	2f 5f       	subi	r18, 0xFF	; 255
    13de:	ca 01       	movw	r24, r20
    13e0:	01 97       	sbiw	r24, 0x01	; 1
    13e2:	f1 f7       	brne	.-4      	; 0x13e0 <GetSIRC20+0x1c>
	irExtended = irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    13e4:	82 9b       	sbis	0x10, 2	; 16
    13e6:	fa cf       	rjmp	.-12     	; 0x13dc <GetSIRC20+0x18>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    13e8:	2b 50       	subi	r18, 0x0B	; 11
    13ea:	23 30       	cpi	r18, 0x03	; 3
    13ec:	08 f0       	brcs	.+2      	; 0x13f0 <GetSIRC20+0x2c>
    13ee:	45 c0       	rjmp	.+138    	; 0x147a <GetSIRC20+0xb6>
	{
		return;		//goto StartLook;
    13f0:	40 e0       	ldi	r20, 0x00	; 0
    13f2:	30 e0       	ldi	r19, 0x00	; 0
    13f4:	60 e2       	ldi	r22, 0x20	; 32
    13f6:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    13f8:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    13fa:	82 99       	sbic	0x10, 2	; 16
    13fc:	fe cf       	rjmp	.-4      	; 0x13fa <GetSIRC20+0x36>
    13fe:	20 e0       	ldi	r18, 0x00	; 0
    1400:	04 c0       	rjmp	.+8      	; 0x140a <GetSIRC20+0x46>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    1402:	2f 5f       	subi	r18, 0xFF	; 255
    1404:	cb 01       	movw	r24, r22
    1406:	01 97       	sbiw	r24, 0x01	; 1
    1408:	f1 f7       	brne	.-4      	; 0x1406 <GetSIRC20+0x42>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    140a:	82 9b       	sbis	0x10, 2	; 16
    140c:	fa cf       	rjmp	.-12     	; 0x1402 <GetSIRC20+0x3e>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    140e:	26 30       	cpi	r18, 0x06	; 6
    1410:	08 f0       	brcs	.+2      	; 0x1414 <GetSIRC20+0x50>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    1412:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    1414:	4f 5f       	subi	r20, 0xFF	; 255
    1416:	47 30       	cpi	r20, 0x07	; 7
    1418:	79 f7       	brne	.-34     	; 0x13f8 <GetSIRC20+0x34>
    141a:	30 93 0d 07 	sts	0x070D, r19
    141e:	40 e0       	ldi	r20, 0x00	; 0
    1420:	30 e0       	ldi	r19, 0x00	; 0
    1422:	60 e2       	ldi	r22, 0x20	; 32
    1424:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1426:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1428:	82 99       	sbic	0x10, 2	; 16
    142a:	fe cf       	rjmp	.-4      	; 0x1428 <GetSIRC20+0x64>
    142c:	20 e0       	ldi	r18, 0x00	; 0
    142e:	04 c0       	rjmp	.+8      	; 0x1438 <GetSIRC20+0x74>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1430:	2f 5f       	subi	r18, 0xFF	; 255
    1432:	cb 01       	movw	r24, r22
    1434:	01 97       	sbiw	r24, 0x01	; 1
    1436:	f1 f7       	brne	.-4      	; 0x1434 <GetSIRC20+0x70>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1438:	82 9b       	sbis	0x10, 2	; 16
    143a:	fa cf       	rjmp	.-12     	; 0x1430 <GetSIRC20+0x6c>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    143c:	26 30       	cpi	r18, 0x06	; 6
    143e:	08 f0       	brcs	.+2      	; 0x1442 <GetSIRC20+0x7e>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1440:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
    1442:	4f 5f       	subi	r20, 0xFF	; 255
    1444:	45 30       	cpi	r20, 0x05	; 5
    1446:	79 f7       	brne	.-34     	; 0x1426 <GetSIRC20+0x62>
    1448:	30 93 12 07 	sts	0x0712, r19
    144c:	40 e0       	ldi	r20, 0x00	; 0
    144e:	30 e0       	ldi	r19, 0x00	; 0
    1450:	60 e2       	ldi	r22, 0x20	; 32
    1452:	73 e0       	ldi	r23, 0x03	; 3
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
		{
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1454:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1456:	82 99       	sbic	0x10, 2	; 16
    1458:	fe cf       	rjmp	.-4      	; 0x1456 <GetSIRC20+0x92>
    145a:	20 e0       	ldi	r18, 0x00	; 0
    145c:	04 c0       	rjmp	.+8      	; 0x1466 <GetSIRC20+0xa2>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    145e:	2f 5f       	subi	r18, 0xFF	; 255
    1460:	cb 01       	movw	r24, r22
    1462:	01 97       	sbiw	r24, 0x01	; 1
    1464:	f1 f7       	brne	.-4      	; 0x1462 <GetSIRC20+0x9e>
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1466:	82 9b       	sbis	0x10, 2	; 16
    1468:	fa cf       	rjmp	.-12     	; 0x145e <GetSIRC20+0x9a>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    146a:	26 30       	cpi	r18, 0x06	; 6
    146c:	08 f0       	brcs	.+2      	; 0x1470 <GetSIRC20+0xac>
				irExtended |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    146e:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
    1470:	4f 5f       	subi	r20, 0xFF	; 255
    1472:	48 30       	cpi	r20, 0x08	; 8
    1474:	79 f7       	brne	.-34     	; 0x1454 <GetSIRC20+0x90>
    1476:	30 93 14 07 	sts	0x0714, r19
    147a:	08 95       	ret

0000147c <__udivmodqi4>:
    147c:	99 1b       	sub	r25, r25
    147e:	79 e0       	ldi	r23, 0x09	; 9
    1480:	04 c0       	rjmp	.+8      	; 0x148a <__udivmodqi4_ep>

00001482 <__udivmodqi4_loop>:
    1482:	99 1f       	adc	r25, r25
    1484:	96 17       	cp	r25, r22
    1486:	08 f0       	brcs	.+2      	; 0x148a <__udivmodqi4_ep>
    1488:	96 1b       	sub	r25, r22

0000148a <__udivmodqi4_ep>:
    148a:	88 1f       	adc	r24, r24
    148c:	7a 95       	dec	r23
    148e:	c9 f7       	brne	.-14     	; 0x1482 <__udivmodqi4_loop>
    1490:	80 95       	com	r24
    1492:	08 95       	ret

00001494 <__divmodhi4>:
    1494:	97 fb       	bst	r25, 7
    1496:	09 2e       	mov	r0, r25
    1498:	07 26       	eor	r0, r23
    149a:	0a d0       	rcall	.+20     	; 0x14b0 <__divmodhi4_neg1>
    149c:	77 fd       	sbrc	r23, 7
    149e:	04 d0       	rcall	.+8      	; 0x14a8 <__divmodhi4_neg2>
    14a0:	0c d0       	rcall	.+24     	; 0x14ba <__udivmodhi4>
    14a2:	06 d0       	rcall	.+12     	; 0x14b0 <__divmodhi4_neg1>
    14a4:	00 20       	and	r0, r0
    14a6:	1a f4       	brpl	.+6      	; 0x14ae <__divmodhi4_exit>

000014a8 <__divmodhi4_neg2>:
    14a8:	70 95       	com	r23
    14aa:	61 95       	neg	r22
    14ac:	7f 4f       	sbci	r23, 0xFF	; 255

000014ae <__divmodhi4_exit>:
    14ae:	08 95       	ret

000014b0 <__divmodhi4_neg1>:
    14b0:	f6 f7       	brtc	.-4      	; 0x14ae <__divmodhi4_exit>
    14b2:	90 95       	com	r25
    14b4:	81 95       	neg	r24
    14b6:	9f 4f       	sbci	r25, 0xFF	; 255
    14b8:	08 95       	ret

000014ba <__udivmodhi4>:
    14ba:	aa 1b       	sub	r26, r26
    14bc:	bb 1b       	sub	r27, r27
    14be:	51 e1       	ldi	r21, 0x11	; 17
    14c0:	07 c0       	rjmp	.+14     	; 0x14d0 <__udivmodhi4_ep>

000014c2 <__udivmodhi4_loop>:
    14c2:	aa 1f       	adc	r26, r26
    14c4:	bb 1f       	adc	r27, r27
    14c6:	a6 17       	cp	r26, r22
    14c8:	b7 07       	cpc	r27, r23
    14ca:	10 f0       	brcs	.+4      	; 0x14d0 <__udivmodhi4_ep>
    14cc:	a6 1b       	sub	r26, r22
    14ce:	b7 0b       	sbc	r27, r23

000014d0 <__udivmodhi4_ep>:
    14d0:	88 1f       	adc	r24, r24
    14d2:	99 1f       	adc	r25, r25
    14d4:	5a 95       	dec	r21
    14d6:	a9 f7       	brne	.-22     	; 0x14c2 <__udivmodhi4_loop>
    14d8:	80 95       	com	r24
    14da:	90 95       	com	r25
    14dc:	bc 01       	movw	r22, r24
    14de:	cd 01       	movw	r24, r26
    14e0:	08 95       	ret

000014e2 <itoa>:
    14e2:	fb 01       	movw	r30, r22
    14e4:	9f 01       	movw	r18, r30
    14e6:	e8 94       	clt
    14e8:	42 30       	cpi	r20, 0x02	; 2
    14ea:	c4 f0       	brlt	.+48     	; 0x151c <itoa+0x3a>
    14ec:	45 32       	cpi	r20, 0x25	; 37
    14ee:	b4 f4       	brge	.+44     	; 0x151c <itoa+0x3a>
    14f0:	4a 30       	cpi	r20, 0x0A	; 10
    14f2:	29 f4       	brne	.+10     	; 0x14fe <itoa+0x1c>
    14f4:	97 fb       	bst	r25, 7
    14f6:	1e f4       	brtc	.+6      	; 0x14fe <itoa+0x1c>
    14f8:	90 95       	com	r25
    14fa:	81 95       	neg	r24
    14fc:	9f 4f       	sbci	r25, 0xFF	; 255
    14fe:	64 2f       	mov	r22, r20
    1500:	77 27       	eor	r23, r23
    1502:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <__udivmodhi4>
    1506:	80 5d       	subi	r24, 0xD0	; 208
    1508:	8a 33       	cpi	r24, 0x3A	; 58
    150a:	0c f0       	brlt	.+2      	; 0x150e <itoa+0x2c>
    150c:	89 5d       	subi	r24, 0xD9	; 217
    150e:	81 93       	st	Z+, r24
    1510:	cb 01       	movw	r24, r22
    1512:	00 97       	sbiw	r24, 0x00	; 0
    1514:	a1 f7       	brne	.-24     	; 0x14fe <itoa+0x1c>
    1516:	16 f4       	brtc	.+4      	; 0x151c <itoa+0x3a>
    1518:	5d e2       	ldi	r21, 0x2D	; 45
    151a:	51 93       	st	Z+, r21
    151c:	10 82       	st	Z, r1
    151e:	c9 01       	movw	r24, r18
    1520:	0c 94 01 0b 	jmp	0x1602	; 0x1602 <strrev>

00001524 <ltoa>:
    1524:	fa 01       	movw	r30, r20
    1526:	cf 93       	push	r28
    1528:	ff 93       	push	r31
    152a:	ef 93       	push	r30
    152c:	22 30       	cpi	r18, 0x02	; 2
    152e:	44 f1       	brlt	.+80     	; 0x1580 <ltoa+0x5c>
    1530:	25 32       	cpi	r18, 0x25	; 37
    1532:	34 f5       	brge	.+76     	; 0x1580 <ltoa+0x5c>
    1534:	c2 2f       	mov	r28, r18
    1536:	e8 94       	clt
    1538:	ca 30       	cpi	r28, 0x0A	; 10
    153a:	49 f4       	brne	.+18     	; 0x154e <ltoa+0x2a>
    153c:	97 fb       	bst	r25, 7
    153e:	3e f4       	brtc	.+14     	; 0x154e <ltoa+0x2a>
    1540:	90 95       	com	r25
    1542:	80 95       	com	r24
    1544:	70 95       	com	r23
    1546:	61 95       	neg	r22
    1548:	7f 4f       	sbci	r23, 0xFF	; 255
    154a:	8f 4f       	sbci	r24, 0xFF	; 255
    154c:	9f 4f       	sbci	r25, 0xFF	; 255
    154e:	2c 2f       	mov	r18, r28
    1550:	33 27       	eor	r19, r19
    1552:	44 27       	eor	r20, r20
    1554:	55 27       	eor	r21, r21
    1556:	ff 93       	push	r31
    1558:	ef 93       	push	r30
    155a:	0e 94 11 0b 	call	0x1622	; 0x1622 <__udivmodsi4>
    155e:	ef 91       	pop	r30
    1560:	ff 91       	pop	r31
    1562:	60 5d       	subi	r22, 0xD0	; 208
    1564:	6a 33       	cpi	r22, 0x3A	; 58
    1566:	0c f0       	brlt	.+2      	; 0x156a <ltoa+0x46>
    1568:	69 5d       	subi	r22, 0xD9	; 217
    156a:	61 93       	st	Z+, r22
    156c:	b9 01       	movw	r22, r18
    156e:	ca 01       	movw	r24, r20
    1570:	60 50       	subi	r22, 0x00	; 0
    1572:	70 40       	sbci	r23, 0x00	; 0
    1574:	80 40       	sbci	r24, 0x00	; 0
    1576:	90 40       	sbci	r25, 0x00	; 0
    1578:	51 f7       	brne	.-44     	; 0x154e <ltoa+0x2a>
    157a:	16 f4       	brtc	.+4      	; 0x1580 <ltoa+0x5c>
    157c:	cd e2       	ldi	r28, 0x2D	; 45
    157e:	c1 93       	st	Z+, r28
    1580:	10 82       	st	Z, r1
    1582:	8f 91       	pop	r24
    1584:	9f 91       	pop	r25
    1586:	cf 91       	pop	r28
    1588:	0c 94 01 0b 	jmp	0x1602	; 0x1602 <strrev>

0000158c <ultoa>:
    158c:	fa 01       	movw	r30, r20
    158e:	cf 93       	push	r28
    1590:	ff 93       	push	r31
    1592:	ef 93       	push	r30
    1594:	22 30       	cpi	r18, 0x02	; 2
    1596:	cc f0       	brlt	.+50     	; 0x15ca <ultoa+0x3e>
    1598:	25 32       	cpi	r18, 0x25	; 37
    159a:	bc f4       	brge	.+46     	; 0x15ca <ultoa+0x3e>
    159c:	c2 2f       	mov	r28, r18
    159e:	2c 2f       	mov	r18, r28
    15a0:	33 27       	eor	r19, r19
    15a2:	44 27       	eor	r20, r20
    15a4:	55 27       	eor	r21, r21
    15a6:	ff 93       	push	r31
    15a8:	ef 93       	push	r30
    15aa:	0e 94 11 0b 	call	0x1622	; 0x1622 <__udivmodsi4>
    15ae:	ef 91       	pop	r30
    15b0:	ff 91       	pop	r31
    15b2:	60 5d       	subi	r22, 0xD0	; 208
    15b4:	6a 33       	cpi	r22, 0x3A	; 58
    15b6:	0c f0       	brlt	.+2      	; 0x15ba <ultoa+0x2e>
    15b8:	69 5d       	subi	r22, 0xD9	; 217
    15ba:	61 93       	st	Z+, r22
    15bc:	b9 01       	movw	r22, r18
    15be:	ca 01       	movw	r24, r20
    15c0:	60 50       	subi	r22, 0x00	; 0
    15c2:	70 40       	sbci	r23, 0x00	; 0
    15c4:	80 40       	sbci	r24, 0x00	; 0
    15c6:	90 40       	sbci	r25, 0x00	; 0
    15c8:	51 f7       	brne	.-44     	; 0x159e <ultoa+0x12>
    15ca:	10 82       	st	Z, r1
    15cc:	8f 91       	pop	r24
    15ce:	9f 91       	pop	r25
    15d0:	cf 91       	pop	r28
    15d2:	0c 94 01 0b 	jmp	0x1602	; 0x1602 <strrev>

000015d6 <utoa>:
    15d6:	fb 01       	movw	r30, r22
    15d8:	9f 01       	movw	r18, r30
    15da:	42 30       	cpi	r20, 0x02	; 2
    15dc:	74 f0       	brlt	.+28     	; 0x15fa <utoa+0x24>
    15de:	45 32       	cpi	r20, 0x25	; 37
    15e0:	64 f4       	brge	.+24     	; 0x15fa <utoa+0x24>
    15e2:	64 2f       	mov	r22, r20
    15e4:	77 27       	eor	r23, r23
    15e6:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <__udivmodhi4>
    15ea:	80 5d       	subi	r24, 0xD0	; 208
    15ec:	8a 33       	cpi	r24, 0x3A	; 58
    15ee:	0c f0       	brlt	.+2      	; 0x15f2 <utoa+0x1c>
    15f0:	89 5d       	subi	r24, 0xD9	; 217
    15f2:	81 93       	st	Z+, r24
    15f4:	cb 01       	movw	r24, r22
    15f6:	00 97       	sbiw	r24, 0x00	; 0
    15f8:	a1 f7       	brne	.-24     	; 0x15e2 <utoa+0xc>
    15fa:	10 82       	st	Z, r1
    15fc:	c9 01       	movw	r24, r18
    15fe:	0c 94 01 0b 	jmp	0x1602	; 0x1602 <strrev>

00001602 <strrev>:
    1602:	dc 01       	movw	r26, r24
    1604:	fc 01       	movw	r30, r24
    1606:	67 2f       	mov	r22, r23
    1608:	71 91       	ld	r23, Z+
    160a:	77 23       	and	r23, r23
    160c:	e1 f7       	brne	.-8      	; 0x1606 <strrev+0x4>
    160e:	32 97       	sbiw	r30, 0x02	; 2
    1610:	04 c0       	rjmp	.+8      	; 0x161a <strrev+0x18>
    1612:	7c 91       	ld	r23, X
    1614:	6d 93       	st	X+, r22
    1616:	70 83       	st	Z, r23
    1618:	62 91       	ld	r22, -Z
    161a:	ae 17       	cp	r26, r30
    161c:	bf 07       	cpc	r27, r31
    161e:	c8 f3       	brcs	.-14     	; 0x1612 <strrev+0x10>
    1620:	08 95       	ret

00001622 <__udivmodsi4>:
    1622:	a1 e2       	ldi	r26, 0x21	; 33
    1624:	1a 2e       	mov	r1, r26
    1626:	aa 1b       	sub	r26, r26
    1628:	bb 1b       	sub	r27, r27
    162a:	fd 01       	movw	r30, r26
    162c:	0d c0       	rjmp	.+26     	; 0x1648 <__udivmodsi4_ep>

0000162e <__udivmodsi4_loop>:
    162e:	aa 1f       	adc	r26, r26
    1630:	bb 1f       	adc	r27, r27
    1632:	ee 1f       	adc	r30, r30
    1634:	ff 1f       	adc	r31, r31
    1636:	a2 17       	cp	r26, r18
    1638:	b3 07       	cpc	r27, r19
    163a:	e4 07       	cpc	r30, r20
    163c:	f5 07       	cpc	r31, r21
    163e:	20 f0       	brcs	.+8      	; 0x1648 <__udivmodsi4_ep>
    1640:	a2 1b       	sub	r26, r18
    1642:	b3 0b       	sbc	r27, r19
    1644:	e4 0b       	sbc	r30, r20
    1646:	f5 0b       	sbc	r31, r21

00001648 <__udivmodsi4_ep>:
    1648:	66 1f       	adc	r22, r22
    164a:	77 1f       	adc	r23, r23
    164c:	88 1f       	adc	r24, r24
    164e:	99 1f       	adc	r25, r25
    1650:	1a 94       	dec	r1
    1652:	69 f7       	brne	.-38     	; 0x162e <__udivmodsi4_loop>
    1654:	60 95       	com	r22
    1656:	70 95       	com	r23
    1658:	80 95       	com	r24
    165a:	90 95       	com	r25
    165c:	9b 01       	movw	r18, r22
    165e:	ac 01       	movw	r20, r24
    1660:	bd 01       	movw	r22, r26
    1662:	cf 01       	movw	r24, r30
    1664:	08 95       	ret

00001666 <_exit>:
    1666:	f8 94       	cli

00001668 <__stop_program>:
    1668:	ff cf       	rjmp	.-2      	; 0x1668 <__stop_program>
