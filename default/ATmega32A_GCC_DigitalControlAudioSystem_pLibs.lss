
ATmega32A_GCC_DigitalControlAudioSystem_pLibs.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001838  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000065c  00800060  00001838  000018cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002b  008006bc  008006bc  00001f28  2**0
                  ALLOC
  3 .debug_aranges 00000180  00000000  00000000  00001f28  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000a4d  00000000  00000000  000020a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002e9e  00000000  00000000  00002af5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d5e  00000000  00000000  00005993  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002a89  00000000  00000000  000066f1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007d0  00000000  00000000  0000917c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000b6f  00000000  00000000  0000994c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000dbe  00000000  00000000  0000a4bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000798  00000000  00000000  0000b279  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 44 05 	jmp	0xa88	; 0xa88 <__vector_1>
       8:	0c 94 97 00 	jmp	0x12e	; 0x12e <__vector_2>
       c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__vector_3>
      10:	0c 94 ab 00 	jmp	0x156	; 0x156 <__vector_4>
      14:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	16 e0       	ldi	r17, 0x06	; 6
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e3       	ldi	r30, 0x38	; 56
      68:	f8 e1       	ldi	r31, 0x18	; 24
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 3b       	cpi	r26, 0xBC	; 188
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ac eb       	ldi	r26, 0xBC	; 188
      7a:	b6 e0       	ldi	r27, 0x06	; 6
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 3e       	cpi	r26, 0xE7	; 231
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 7d 04 	call	0x8fa	; 0x8fa <main>
      8a:	0c 94 1a 0c 	jmp	0x1834	; 0x1834 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <port_init>:
*****************************************/
void port_init(void)
{	

// PORT A connections
	DDRA  = 0b11111111;		//  PA7:U8/PGA2310,CS; PA6:U7/PGA2310,CS; PA5:CON2LCD,RS; PA4:CON2LCD,RW; PA3:CON2LCD,E; PA2:U2/74HC595,RCLK(LCD); PA1:U2/74HC595,SCLK(LCD); PA0:U2/74HC595,DATA(LCD);
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	8a bb       	out	0x1a, r24	; 26
	PORTA = 0b00000000;		//	Interfaces: NOT USED. PULLUP DISABLE in PORTA.
      96:	1b ba       	out	0x1b, r1	; 27

// PORT B connections
	DDRB  = 0b10111000;		//  PB7:U6,U7,U8/PGA2310,SCLK; PB6:U6,U7,U8/PGA2310,SDO(CON33,36,39); PB5:U6,U7,U8/PGA2310,SDI; PB4:U12/74HC595,DATA(REL_OUT); PB3:U6/PGA2310,CS; PB2:CON8/BUTTON,"ESCAPE",INT2; PB1:CON5/BUTTON,"ON/OFF"; PB0:CON14TempSensor/DS18S20,DQ,IN/OUT;
      98:	88 eb       	ldi	r24, 0xB8	; 184
      9a:	87 bb       	out	0x17, r24	; 23
	PORTB = 0b00000111;		//	Interfaces: EXTERNAL INTERRUPT 2; SPI. set pullup to IRTSOP2240 / BUTTON(on/off) / DS18s20.
      9c:	87 e0       	ldi	r24, 0x07	; 7
      9e:	88 bb       	out	0x18, r24	; 24

// PORT C connections
	DDRC  = 0b11001100;		//  PC7:U10/74HC595,DATA(REL_IN); PC6:U10/74HC595,SCLK(REL_IN); PC5:EncoderED1112S,A; PC4:EncoderED1112S,B; PC3:U10/74HC595,RCLK(REL_IN); PC2:Q2/BD237(RELAY_POWER_SUPPLY); PC1:DS1307/24C64,I2C/SDA; PC0:DS1307/24C64,I2C/SCL;
      a0:	8c ec       	ldi	r24, 0xCC	; 204
      a2:	84 bb       	out	0x14, r24	; 20
	PORTC = 0b00000000;		//	Interfaces: I2C. PULLUP DISABLE in PORTC.
      a4:	15 ba       	out	0x15, r1	; 21

// PORT D connections
	DDRD  = 0b11110000;		//  PD7:U12/74HC595,RCLK(REL_OUT); PD6:U12/74HC595,SCLK(REL_OUT); PD5:Q1/BD237(FAN_CONTROL_PWM); PD4:LED5/"ON/OFF AUDIO SYSTEM"; PD3:CON11/EncoderBUTTON,"MENU/ENTER"/INT1; PD2:CON12/IR/TSOP2240,/INT0; PD1:CON14/MAX232,UART/TXD; PD0:CON14/MAX232,UART/RXD;
      a6:	80 ef       	ldi	r24, 0xF0	; 240
      a8:	81 bb       	out	0x11, r24	; 17
	PORTD = 0b00001100;		//	Interfaces: TIMER1; UART/USART; EXTERNAL INTERRUPT 0, 1. PULLUP DISABLE in PORTD.
      aa:	8c e0       	ldi	r24, 0x0C	; 12
      ac:	82 bb       	out	0x12, r24	; 18
//	DDRD&=~_BV(0);// DDD0 = "0"  (DDD0=DDRD nulev bit) set PORTD pin0 to zero as input
//	PORTD|=_BV(0);// PD0  = "1"  Enable pull up
//	PORTD|=_BV(1);// PD1  = "1"  led
//	DDRD|=_BV(1); // DDD1 = "1"  (DDD1=DDRD parvi bit) set PORTD pin1 to one as output

}
      ae:	08 95       	ret

000000b0 <ext0_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 0 **
*******************************************/
void ext0_intrpt_init(void)
{
	MCUCR = 0b00000010;	// SETUP EXT INT 0, ISC01 = 1, ISC00 = 0: Falling edge on INT0 activates the interrupt; ISC01 = 1, ISC00 = 1: Rising edge on INT0 activates the interrupt;
      b0:	82 e0       	ldi	r24, 0x02	; 2
      b2:	85 bf       	out	0x35, r24	; 53

// IN FUNCTIONS:
//	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
//	GIFR   = 0b01000000;	// Clear INT0 flag.
}
      b4:	08 95       	ret

000000b6 <ext0_intrpt_on>:
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      b6:	80 e4       	ldi	r24, 0x40	; 64
      b8:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      ba:	8a bf       	out	0x3a, r24	; 58
}
      bc:	08 95       	ret

000000be <ext0_intrpt_off>:
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
      be:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
      c0:	80 e4       	ldi	r24, 0x40	; 64
      c2:	8a bf       	out	0x3a, r24	; 58
}
      c4:	08 95       	ret

000000c6 <ext1_intrpt_init>:
/*******************************************
** INITIZLIZATION OF EXTERNAL INTERRUPT 1 **
*******************************************/
void ext1_intrpt_init(void)
{
}
      c6:	08 95       	ret

000000c8 <ext2_intrpt_init>:
//	MCUCSR = 0b00000000;	// SETUP EXT INT 2, ISC2 = 0: Falling edge on INT2 activates the interrupt; ISC2 = 1: Rising edge on INT2 activates the interrupt;

// IN FUNCTIONS:
//	GICR   = 0b00100000;	// INT2 = 0: Disable External Interrupt on INT2; INT2 = 1: Enable External Interrupt on INT2;
//	GIFR   = 0b00100000;	// Clear INT2 flag.
}
      c8:	08 95       	ret

000000ca <timer1_init>:
*****************************/
void timer1_init(void)
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  = 0b00000000;	// maskov registar za prekasvaniq
      ca:	19 be       	out	0x39, r1	; 57
	TCNT1H = 0b00000000;
      cc:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
      ce:	1c bc       	out	0x2c, r1	; 44

//	OCR1BH = 100; //20;			// 0   = 0b00000000 (DEC = BIN)	// LED
//	OCR1BL = 100; //20;			// 200 = 0b11001000 (DEC = BIN)	// LED

//	TIMSK = (1 << OCIE1A);
}
      d0:	08 95       	ret

000000d2 <timer2_init>:
/*****************************
** INITIZLIZATION OF TIMER2 **
*****************************/
void timer2_init(void)
{
	SFIOR = 0b00000010;		// Prescaler Reset Timer2 (bit1 –> PSR2)
      d2:	82 e0       	ldi	r24, 0x02	; 2
      d4:	80 bf       	out	0x30, r24	; 48
	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      d6:	81 e8       	ldi	r24, 0x81	; 129
      d8:	85 bd       	out	0x25, r24	; 37
	OCR2 = 0; // FAN PWM ON
      da:	13 bc       	out	0x23, r1	; 35
}
      dc:	08 95       	ret

000000de <timer1_on_speed>:
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
      de:	81 ea       	ldi	r24, 0xA1	; 161
      e0:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
      e2:	81 e0       	ldi	r24, 0x01	; 1
      e4:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
      e6:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
      e8:	80 91 77 06 	lds	r24, 0x0677
      ec:	e8 e7       	ldi	r30, 0x78	; 120
      ee:	f6 e0       	ldi	r31, 0x06	; 6
      f0:	e8 0f       	add	r30, r24
      f2:	f1 1d       	adc	r31, r1
      f4:	80 81       	ld	r24, Z
      f6:	8a bd       	out	0x2a, r24	; 42

// CHANNEL B
//	OCR1BH = 0; // LED PWM ON				// out	OCR1BH, r16		; 0   = 0b00000000 (DEC = BIN)
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}
      f8:	08 95       	ret

000000fa <timer1_off>:

void timer1_off(void)
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
      fa:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
      fc:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
      fe:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     100:	1a bc       	out	0x2a, r1	; 42

//	OCR1BH = 0; // LED PWM OFF
//	OCR1BL = 0; // LED PWM OFF
}
     102:	08 95       	ret

00000104 <FAN_PWM_SPEED1>:
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     104:	81 ea       	ldi	r24, 0xA1	; 161
     106:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     108:	81 e0       	ldi	r24, 0x01	; 1
     10a:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     10c:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     10e:	80 91 77 06 	lds	r24, 0x0677
     112:	e8 e7       	ldi	r30, 0x78	; 120
     114:	f6 e0       	ldi	r31, 0x06	; 6
     116:	e8 0f       	add	r30, r24
     118:	f1 1d       	adc	r31, r1
     11a:	80 81       	ld	r24, Z
     11c:	8a bd       	out	0x2a, r24	; 42
******** DEFINITIONS OF FAN ********
***********************************/
void FAN_PWM_SPEED1(void)
{
	timer1_on_speed();
}
     11e:	08 95       	ret

00000120 <FAN_PWM_OFF>:
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}

void timer1_off(void)
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     120:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     122:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     124:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     126:	1a bc       	out	0x2a, r1	; 42
	timer1_on_speed();
}
void FAN_PWM_OFF(void)
{
	timer1_off();
}
     128:	08 95       	ret

0000012a <timer2_on>:
***************************************/
void timer2_on(void)	// Timer2 On
{
//	TCCR2 = 0b10000001;		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
//	OCR2 = 1; // FAN PWM ON
}
     12a:	08 95       	ret

0000012c <timer2_off>:

void timer2_off(void)	// Timer2 Off
{
//	TCCR2 = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
//	OCR2 = 0; // FAN PWM OFF
}
     12c:	08 95       	ret

0000012e <__vector_2>:

/*****************************************
**** EXTERNAL INTERRUPT 1 VECTOR 02 ******
*****************************************/
ISR(INT1_vect)
{
     12e:	1f 92       	push	r1
     130:	0f 92       	push	r0
     132:	0f b6       	in	r0, 0x3f	; 63
     134:	0f 92       	push	r0
     136:	11 24       	eor	r1, r1
}
     138:	0f 90       	pop	r0
     13a:	0f be       	out	0x3f, r0	; 63
     13c:	0f 90       	pop	r0
     13e:	1f 90       	pop	r1
     140:	18 95       	reti

00000142 <__vector_3>:

/*****************************************
**** EXTERNAL INTERRUPT 2 VECTOR 03 ******
*****************************************/
ISR(INT2_vect)
{
     142:	1f 92       	push	r1
     144:	0f 92       	push	r0
     146:	0f b6       	in	r0, 0x3f	; 63
     148:	0f 92       	push	r0
     14a:	11 24       	eor	r1, r1
}
     14c:	0f 90       	pop	r0
     14e:	0f be       	out	0x3f, r0	; 63
     150:	0f 90       	pop	r0
     152:	1f 90       	pop	r1
     154:	18 95       	reti

00000156 <__vector_4>:

/*****************************************
**** TIMER 2 OUTPUT COMPARE VECTOR 04 ****
*****************************************/
ISR(TIMER2_COMP_vect)
{
     156:	1f 92       	push	r1
     158:	0f 92       	push	r0
     15a:	0f b6       	in	r0, 0x3f	; 63
     15c:	0f 92       	push	r0
     15e:	11 24       	eor	r1, r1
}
     160:	0f 90       	pop	r0
     162:	0f be       	out	0x3f, r0	; 63
     164:	0f 90       	pop	r0
     166:	1f 90       	pop	r1
     168:	18 95       	reti

0000016a <__vector_5>:

/*****************************************
**** TIMER 2 OVERFLOW VECTOR 05 **********
*****************************************/
ISR(TIMER2_OVF_vect)
{
     16a:	1f 92       	push	r1
     16c:	0f 92       	push	r0
     16e:	0f b6       	in	r0, 0x3f	; 63
     170:	0f 92       	push	r0
     172:	11 24       	eor	r1, r1
}
     174:	0f 90       	pop	r0
     176:	0f be       	out	0x3f, r0	; 63
     178:	0f 90       	pop	r0
     17a:	1f 90       	pop	r1
     17c:	18 95       	reti

0000017e <about>:

	return temper;
}

void about(void)
{
     17e:	0f 93       	push	r16
     180:	1f 93       	push	r17
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] =====================================================\r\n");
     182:	00 e6       	ldi	r16, 0x60	; 96
     184:	10 e0       	ldi	r17, 0x00	; 0
     186:	c8 01       	movw	r24, r16
     188:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartString("[UART INFO] \tAuthors and creators: P.Upinov and P.Stoyanov\r\n");
     18c:	84 ea       	ldi	r24, 0xA4	; 164
     18e:	90 e0       	ldi	r25, 0x00	; 0
     190:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartString("[UART INFO] \tDevice name: Digital Control Audio System\r\n");
     194:	81 ee       	ldi	r24, 0xE1	; 225
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartString("[UART INFO] \tFirmware version beta ");
     19c:	8a e1       	ldi	r24, 0x1A	; 26
     19e:	91 e0       	ldi	r25, 0x01	; 1
     1a0:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartInt(FIRMWARE_VERSION);
     1a4:	8c e1       	ldi	r24, 0x1C	; 28
     1a6:	90 e0       	ldi	r25, 0x00	; 0
     1a8:	0e 94 de 08 	call	0x11bc	; 0x11bc <transmitUartInt>
		transmitUartString("\r\n");
     1ac:	8e e3       	ldi	r24, 0x3E	; 62
     1ae:	91 e0       	ldi	r25, 0x01	; 1
     1b0:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartString("[UART INFO] =====================================================\r\n");
     1b4:	c8 01       	movw	r24, r16
     1b6:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartString("[UART INFO] Da dobavq upravlenie na:\
     1ba:	81 e4       	ldi	r24, 0x41	; 65
     1bc:	91 e0       	ldi	r25, 0x01	; 1
     1be:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
						\r\n[UART INFO] - FAN smart controlling			\
						\r\n[UART INFO] - DS18S20						\
						\r\n[UART INFO] - RTC							\
						\r\n[UART INFO] - Memory\r\n");
	#endif
}
     1c2:	1f 91       	pop	r17
     1c4:	0f 91       	pop	r16
     1c6:	08 95       	ret

000001c8 <init_all>:
*********************************** START OF APPLICATION ************************************
********************************************************************************************/

void init_all()
{
	port_init();		// IO init and configure all port
     1c8:	0e 94 49 00 	call	0x92	; 0x92 <port_init>
*****************************/
void timer1_init(void)
{
// http://www.mikroe.com/forum/viewtopic.php?f=72&t=51076

	TIMSK  = 0b00000000;	// maskov registar za prekasvaniq
     1cc:	19 be       	out	0x39, r1	; 57
	TCNT1H = 0b00000000;
     1ce:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0b00000000;
     1d0:	1c bc       	out	0x2c, r1	; 44
void init_all()
{
	port_init();		// IO init and configure all port
	timer1_init();		// FAN INIT
//	timer2_init();
	LCD_INIT();			// LCD init and reset all lcd contain
     1d2:	0e 94 45 07 	call	0xe8a	; 0xe8a <LCD_INIT>
	uart_init();		// UART debug init
     1d6:	0e 94 95 08 	call	0x112a	; 0x112a <uart_init>
	about();			// Any debug important information
     1da:	0e 94 bf 00 	call	0x17e	; 0x17e <about>

	pga2310_init();		// SPI init and reset all (U6, U7, U8) PGA2310 volume values to null
     1de:	0e 94 3a 08 	call	0x1074	; 0x1074 <pga2310_init>
	relays_in_init();	// nujno e daden reset be da bade izkliuche usilvatelq, togava reletata za vhod i izhod (bez power relay) sa ostanali vkliucheni
     1e2:	0e 94 1a 0a 	call	0x1434	; 0x1434 <relays_in_init>
	relays_out_init();	// nujno e daden reset be da bade izkliuche usilvatelq, togava reletata za vhod i izhod (bez power relay)sa ostanali vkliucheni
     1e6:	0e 94 41 0a 	call	0x1482	; 0x1482 <relays_out_init>


}
     1ea:	08 95       	ret

000001ec <temperMeasur>:
	}
	return 0;
}

char temperMeasur(unsigned char byte0, unsigned char byte1, unsigned char byte6, unsigned char byte7)
{
     1ec:	1f 93       	push	r17
	char tC = 0;
	char temper = 0;
	double k = 0;
	double j = 0;

	byte0 = storeTemp [0];
     1ee:	10 91 be 06 	lds	r17, 0x06BE
	byte1 = storeTemp [1];
     1f2:	80 91 bf 06 	lds	r24, 0x06BF
	byte6 = storeTemp [6];
	byte7 = storeTemp [7];

	k = ((byte7 - byte6) / byte7) + 0.25;

	if((byte1 == 0x00) && (byte0 == 0x00))
     1f6:	88 23       	and	r24, r24
     1f8:	61 f5       	brne	.+88     	; 0x252 <temperMeasur+0x66>
     1fa:	11 23       	and	r17, r17
     1fc:	79 f4       	brne	.+30     	; 0x21c <temperMeasur+0x30>
	{
		tC = (byte0/2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     1fe:	85 ef       	ldi	r24, 0xF5	; 245
     200:	91 e0       	ldi	r25, 0x01	; 1
     202:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     206:	80 e0       	ldi	r24, 0x00	; 0
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	0e 94 de 08 	call	0x11bc	; 0x11bc <transmitUartInt>
		transmitUartString(".0 C\r\n");			// uart debug information string
     20e:	8f e0       	ldi	r24, 0x0F	; 15
     210:	92 e0       	ldi	r25, 0x02	; 2
     212:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     216:	80 e0       	ldi	r24, 0x00	; 0
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	13 c0       	rjmp	.+38     	; 0x242 <temperMeasur+0x56>
	LCD_DATA_STRING(".0 C");		//
	}
	else if((byte1 == 0x00) && (byte0 != 0x00))
	{
		transmitUartString("+");
     21c:	8b e1       	ldi	r24, 0x1B	; 27
     21e:	92 e0       	ldi	r25, 0x02	; 2
     220:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		tC = (byte0/2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     224:	85 ef       	ldi	r24, 0xF5	; 245
     226:	91 e0       	ldi	r25, 0x01	; 1
     228:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     22c:	16 95       	lsr	r17
     22e:	81 2f       	mov	r24, r17
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	0e 94 de 08 	call	0x11bc	; 0x11bc <transmitUartInt>
		transmitUartString(".0 C\r\n");			// uart debug information string
     236:	8f e0       	ldi	r24, 0x0F	; 15
     238:	92 e0       	ldi	r25, 0x02	; 2
     23a:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif
//	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
	LCD_DATA_INT(tC);		//
     23e:	81 2f       	mov	r24, r17
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_DATA_INT>
	LCD_DATA_STRING(".0 C");		//
     246:	86 e1       	ldi	r24, 0x16	; 22
     248:	92 e0       	ldi	r25, 0x02	; 2
     24a:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
     24e:	80 e0       	ldi	r24, 0x00	; 0
     250:	1b c0       	rjmp	.+54     	; 0x288 <temperMeasur+0x9c>
	}
	else if((byte1 == 0xFF) && (byte0 != 0x00))
     252:	8f 3f       	cpi	r24, 0xFF	; 255
     254:	a1 f4       	brne	.+40     	; 0x27e <temperMeasur+0x92>
     256:	11 23       	and	r17, r17
     258:	91 f0       	breq	.+36     	; 0x27e <temperMeasur+0x92>
	{
		transmitUartString("-");
     25a:	8d e1       	ldi	r24, 0x1D	; 29
     25c:	92 e0       	ldi	r25, 0x02	; 2
     25e:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
//		tC = ((byte0 - 255.5) / 2);		// ne e dobre obraboteno za otricatelni chisla
		tC = ((byte0 - 255) / 2);
		j = tC - k;
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Temperature: ");		// uart debug information string
     262:	85 ef       	ldi	r24, 0xF5	; 245
     264:	91 e0       	ldi	r25, 0x01	; 1
     266:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartInt(tC);		// uart debug information string 
     26a:	81 2f       	mov	r24, r17
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	8f 5f       	subi	r24, 0xFF	; 255
     270:	90 40       	sbci	r25, 0x00	; 0
     272:	62 e0       	ldi	r22, 0x02	; 2
     274:	70 e0       	ldi	r23, 0x00	; 0
     276:	0e 94 31 0b 	call	0x1662	; 0x1662 <__divmodhi4>
     27a:	16 2f       	mov	r17, r22
     27c:	d8 cf       	rjmp	.-80     	; 0x22e <temperMeasur+0x42>
	}
	else
	{
		//lcdDataString("ERROR!");	// ERROR not return to display!!!!
	#ifdef DEBUG_ERROR
		transmitUartString("[UART ERROR] ERROR TEMPERATURE\r\n");		// uart debug information string
     27e:	8f e1       	ldi	r24, 0x1F	; 31
     280:	92 e0       	ldi	r25, 0x02	; 2
     282:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
     286:	81 e0       	ldi	r24, 0x01	; 1
	#endif
		return 1;
	}

	return temper;
}
     288:	1f 91       	pop	r17
     28a:	08 95       	ret

0000028c <oneWireRight>:
	}
	return 0;
}

unsigned char oneWireRight()
{
     28c:	cf 93       	push	r28
     28e:	df 93       	push	r29
	unsigned char i;

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR RIGHT: 10 6D F4 8F 02 08 00 B1 \r\n");		// uart debug information string
     290:	80 e4       	ldi	r24, 0x40	; 64
     292:	92 e0       	ldi	r25, 0x02	; 2
     294:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     298:	0e 94 d7 05 	call	0xbae	; 0xbae <reset>
     29c:	88 23       	and	r24, r24
     29e:	09 f4       	brne	.+2      	; 0x2a2 <oneWireRight+0x16>
     2a0:	4d c0       	rjmp	.+154    	; 0x33c <oneWireRight+0xb0>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     2a2:	85 e5       	ldi	r24, 0x55	; 85
     2a4:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		// 64-bit ROM CODE
		write_byte(0x10);	// Byte 0
     2a8:	80 e1       	ldi	r24, 0x10	; 16
     2aa:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0x6D);	// Byte 1
     2ae:	8d e6       	ldi	r24, 0x6D	; 109
     2b0:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0xF4);	// Byte 2
     2b4:	84 ef       	ldi	r24, 0xF4	; 244
     2b6:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0x8F);	// Byte 3
     2ba:	8f e8       	ldi	r24, 0x8F	; 143
     2bc:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0x02);	// Byte 4
     2c0:	82 e0       	ldi	r24, 0x02	; 2
     2c2:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0x08);	// Byte 5
     2c6:	88 e0       	ldi	r24, 0x08	; 8
     2c8:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0x00);	// Byte 6
     2cc:	80 e0       	ldi	r24, 0x00	; 0
     2ce:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0xB1);	// Byte 7
     2d2:	81 eb       	ldi	r24, 0xB1	; 177
     2d4:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		// 64-bit ROM CODE

		write_byte(0x44);	// Master issues Convert T command.
     2d8:	84 e4       	ldi	r24, 0x44	; 68
     2da:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     2de:	0e 94 53 06 	call	0xca6	; 0xca6 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     2e2:	0e 94 d7 05 	call	0xbae	; 0xbae <reset>
     2e6:	88 23       	and	r24, r24
     2e8:	49 f1       	breq	.+82     	; 0x33c <oneWireRight+0xb0>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     2ea:	85 e5       	ldi	r24, 0x55	; 85
     2ec:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			// 64-bit ROM CODE
			write_byte(0x10);	// Byte 0
     2f0:	80 e1       	ldi	r24, 0x10	; 16
     2f2:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0x6D);	// Byte 1
     2f6:	8d e6       	ldi	r24, 0x6D	; 109
     2f8:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0xF4);	// Byte 2
     2fc:	84 ef       	ldi	r24, 0xF4	; 244
     2fe:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0x8F);	// Byte 3
     302:	8f e8       	ldi	r24, 0x8F	; 143
     304:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0x02);	// Byte 4
     308:	82 e0       	ldi	r24, 0x02	; 2
     30a:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0x08);	// Byte 5
     30e:	88 e0       	ldi	r24, 0x08	; 8
     310:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0x00);	// Byte 6
     314:	80 e0       	ldi	r24, 0x00	; 0
     316:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0xB1);	// Byte 7
     31a:	81 eb       	ldi	r24, 0xB1	; 177
     31c:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
     320:	8e eb       	ldi	r24, 0xBE	; 190
     322:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
     326:	ce eb       	ldi	r28, 0xBE	; 190
     328:	d6 e0       	ldi	r29, 0x06	; 6
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     32a:	0e 94 03 06 	call	0xc06	; 0xc06 <read_byte>
     32e:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xB1);	// Byte 7
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     330:	86 e0       	ldi	r24, 0x06	; 6
     332:	c7 3c       	cpi	r28, 0xC7	; 199
     334:	d8 07       	cpc	r29, r24
     336:	c9 f7       	brne	.-14     	; 0x32a <oneWireRight+0x9e>
     338:	81 e0       	ldi	r24, 0x01	; 1
     33a:	01 c0       	rjmp	.+2      	; 0x33e <oneWireRight+0xb2>
     33c:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     33e:	df 91       	pop	r29
     340:	cf 91       	pop	r28
     342:	08 95       	ret

00000344 <oneWireLeft>:

/*******************************************
**** 1-WIRE DS18x20 Temperature Sensors ****
*******************************************/
unsigned char oneWireLeft()
{
     344:	cf 93       	push	r28
     346:	df 93       	push	r29
	unsigned char i;

	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] TEMPERATURE SENSOR LEFT: 10 DB 09 A5 01 08 00 C1 \r\n");		// uart debug information string
     348:	81 e8       	ldi	r24, 0x81	; 129
     34a:	92 e0       	ldi	r25, 0x02	; 2
     34c:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif	
	if(reset())				// Master issues reset pulse. DS18S20s respond with presence pulse.
     350:	0e 94 d7 05 	call	0xbae	; 0xbae <reset>
     354:	88 23       	and	r24, r24
     356:	09 f4       	brne	.+2      	; 0x35a <oneWireLeft+0x16>
     358:	4d c0       	rjmp	.+154    	; 0x3f4 <oneWireLeft+0xb0>
	{
		write_byte(0x55);	// Master issues Match ROM command.
     35a:	85 e5       	ldi	r24, 0x55	; 85
     35c:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		// 64-bit ROM CODE
		write_byte(0x10);	// Byte 0
     360:	80 e1       	ldi	r24, 0x10	; 16
     362:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0xDB);	// Byte 1
     366:	8b ed       	ldi	r24, 0xDB	; 219
     368:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0x09);	// Byte 2
     36c:	89 e0       	ldi	r24, 0x09	; 9
     36e:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0xA5);	// Byte 3
     372:	85 ea       	ldi	r24, 0xA5	; 165
     374:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0x01);	// Byte 4
     378:	81 e0       	ldi	r24, 0x01	; 1
     37a:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0x08);	// Byte 5
     37e:	88 e0       	ldi	r24, 0x08	; 8
     380:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0x00);	// Byte 6
     384:	80 e0       	ldi	r24, 0x00	; 0
     386:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0xC1);	// Byte 7
     38a:	81 ec       	ldi	r24, 0xC1	; 193
     38c:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		// 64-bit ROM CODE

		write_byte(0x44);	// Master issues Convert T command.
     390:	84 e4       	ldi	r24, 0x44	; 68
     392:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		wait_ready();		// Master applies strong pullup to DQ for the duration of the conversion (tCONV).
     396:	0e 94 53 06 	call	0xca6	; 0xca6 <wait_ready>
		if(reset())			// Master issues reset pulse. DS18S20s respond with presence pulse.
     39a:	0e 94 d7 05 	call	0xbae	; 0xbae <reset>
     39e:	88 23       	and	r24, r24
     3a0:	49 f1       	breq	.+82     	; 0x3f4 <oneWireLeft+0xb0>
		{
			write_byte(0x55);	// Master issues Match ROM command.
     3a2:	85 e5       	ldi	r24, 0x55	; 85
     3a4:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			// 64-bit ROM CODE
			write_byte(0x10);	// Byte 0
     3a8:	80 e1       	ldi	r24, 0x10	; 16
     3aa:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0xDB);	// Byte 1
     3ae:	8b ed       	ldi	r24, 0xDB	; 219
     3b0:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0x09);	// Byte 2
     3b4:	89 e0       	ldi	r24, 0x09	; 9
     3b6:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0xA5);	// Byte 3
     3ba:	85 ea       	ldi	r24, 0xA5	; 165
     3bc:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0x01);	// Byte 4
     3c0:	81 e0       	ldi	r24, 0x01	; 1
     3c2:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0x08);	// Byte 5
     3c6:	88 e0       	ldi	r24, 0x08	; 8
     3c8:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0x00);	// Byte 6
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0xC1);	// Byte 7
     3d2:	81 ec       	ldi	r24, 0xC1	; 193
     3d4:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
     3d8:	8e eb       	ldi	r24, 0xBE	; 190
     3da:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
     3de:	ce eb       	ldi	r28, 0xBE	; 190
     3e0:	d6 e0       	ldi	r29, 0x06	; 6
			for(i=0; i<9; i++)
			{
				storeTemp [i] = read_byte();	//	Master reads entire scratchpad including CRC. The master then recalculates the CRC of the first eight data bytes from the scratchpad and compares the calculated CRC with the read CRC (byte 9). If they match, the master continues; if not, the read operation is repeated.
     3e2:	0e 94 03 06 	call	0xc06	; 0xc06 <read_byte>
     3e6:	89 93       	st	Y+, r24
			write_byte(0x00);	// Byte 6
			write_byte(0xC1);	// Byte 7
			// 64-bit ROM CODE

			write_byte(0xBE);	// Master issues Read Scratchpad command.
			for(i=0; i<9; i++)
     3e8:	86 e0       	ldi	r24, 0x06	; 6
     3ea:	c7 3c       	cpi	r28, 0xC7	; 199
     3ec:	d8 07       	cpc	r29, r24
     3ee:	c9 f7       	brne	.-14     	; 0x3e2 <oneWireLeft+0x9e>
     3f0:	81 e0       	ldi	r24, 0x01	; 1
     3f2:	01 c0       	rjmp	.+2      	; 0x3f6 <oneWireLeft+0xb2>
     3f4:	80 e0       	ldi	r24, 0x00	; 0
		}
//transmitUartString("RETURN 0\r\n");
//transmitUartString("END WORKING\r\n");
	}
	return 0;
}
     3f6:	df 91       	pop	r29
     3f8:	cf 91       	pop	r28
     3fa:	08 95       	ret

000003fc <temperature>:

/*****************************
**** TEMPERATURE FUNCTION ****
*****************************/
void temperature()
{
     3fc:	cf 93       	push	r28
     3fe:	df 93       	push	r29
	unsigned char i;
//	LED_low_DISPLAYLED_high();
//	LCD_INIT();								// LCD INITIZLIZATION
	LCD_COMMAND(LCD_SELECT_1ROW);	// select row 1
     400:	80 e0       	ldi	r24, 0x00	; 0
     402:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
	LCD_DATA_STRING("    TEPERATURE    ");		//
     406:	81 ec       	ldi	r24, 0xC1	; 193
     408:	92 e0       	ldi	r25, 0x02	; 2
     40a:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
     40e:	80 ec       	ldi	r24, 0xC0	; 192
     410:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
	LCD_DATA_STRING("LEFT  SENSOR: ");				//
     414:	84 ed       	ldi	r24, 0xD4	; 212
     416:	92 e0       	ldi	r25, 0x02	; 2
     418:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>

	oneWireLeft();
     41c:	0e 94 a2 01 	call	0x344	; 0x344 <oneWireLeft>
     420:	c0 e0       	ldi	r28, 0x00	; 0
     422:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] byte ");
     424:	83 ee       	ldi	r24, 0xE3	; 227
     426:	92 e0       	ldi	r25, 0x02	; 2
     428:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartInt(i);
     42c:	ce 01       	movw	r24, r28
     42e:	0e 94 de 08 	call	0x11bc	; 0x11bc <transmitUartInt>
		transmitUartString(" : ");
     432:	85 ef       	ldi	r24, 0xF5	; 245
     434:	92 e0       	ldi	r25, 0x02	; 2
     436:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartInt(storeTemp[i]);
     43a:	fe 01       	movw	r30, r28
     43c:	e2 54       	subi	r30, 0x42	; 66
     43e:	f9 4f       	sbci	r31, 0xF9	; 249
     440:	80 81       	ld	r24, Z
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	0e 94 de 08 	call	0x11bc	; 0x11bc <transmitUartInt>
		transmitUartString("\r\n");
     448:	8e e3       	ldi	r24, 0x3E	; 62
     44a:	91 e0       	ldi	r25, 0x01	; 1
     44c:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
     450:	21 96       	adiw	r28, 0x01	; 1
	LCD_DATA_STRING("    TEPERATURE    ");		//
	LCD_COMMAND(LCD_SELECT_2ROW);	// select row 2
	LCD_DATA_STRING("LEFT  SENSOR: ");				//

	oneWireLeft();
	for(i=0; i<9; i++)
     452:	c9 30       	cpi	r28, 0x09	; 9
     454:	d1 05       	cpc	r29, r1
     456:	31 f7       	brne	.-52     	; 0x424 <temperature+0x28>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     458:	80 91 db 06 	lds	r24, 0x06DB
     45c:	60 91 d7 06 	lds	r22, 0x06D7
     460:	40 91 d6 06 	lds	r20, 0x06D6
     464:	20 91 d3 06 	lds	r18, 0x06D3
     468:	0e 94 f6 00 	call	0x1ec	; 0x1ec <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
     46c:	84 e9       	ldi	r24, 0x94	; 148
     46e:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
     472:	89 ef       	ldi	r24, 0xF9	; 249
     474:	92 e0       	ldi	r25, 0x02	; 2
     476:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
	oneWireRight();
     47a:	0e 94 46 01 	call	0x28c	; 0x28c <oneWireRight>
     47e:	c0 e0       	ldi	r28, 0x00	; 0
     480:	d0 e0       	ldi	r29, 0x00	; 0
	for(i=0; i<9; i++)
	{
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] byte ");
     482:	83 ee       	ldi	r24, 0xE3	; 227
     484:	92 e0       	ldi	r25, 0x02	; 2
     486:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartInt(i);
     48a:	ce 01       	movw	r24, r28
     48c:	0e 94 de 08 	call	0x11bc	; 0x11bc <transmitUartInt>
		transmitUartString(" : ");
     490:	85 ef       	ldi	r24, 0xF5	; 245
     492:	92 e0       	ldi	r25, 0x02	; 2
     494:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartInt(storeTemp[i]);
     498:	fe 01       	movw	r30, r28
     49a:	e2 54       	subi	r30, 0x42	; 66
     49c:	f9 4f       	sbci	r31, 0xF9	; 249
     49e:	80 81       	ld	r24, Z
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	0e 94 de 08 	call	0x11bc	; 0x11bc <transmitUartInt>
		transmitUartString("\r\n");
     4a6:	8e e3       	ldi	r24, 0x3E	; 62
     4a8:	91 e0       	ldi	r25, 0x01	; 1
     4aa:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
     4ae:	21 96       	adiw	r28, 0x01	; 1
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_3ROW);	// select row 3
	LCD_DATA_STRING("RIGHT SENSOR: ");			//
	oneWireRight();
	for(i=0; i<9; i++)
     4b0:	c9 30       	cpi	r28, 0x09	; 9
     4b2:	d1 05       	cpc	r29, r1
     4b4:	31 f7       	brne	.-52     	; 0x482 <temperature+0x86>
		transmitUartString(" : ");
		transmitUartInt(storeTemp[i]);
		transmitUartString("\r\n");
	#endif
	}
	temperMeasur(byte0, byte1, byte6, byte7);
     4b6:	80 91 db 06 	lds	r24, 0x06DB
     4ba:	60 91 d7 06 	lds	r22, 0x06D7
     4be:	40 91 d6 06 	lds	r20, 0x06D6
     4c2:	20 91 d3 06 	lds	r18, 0x06D3
     4c6:	0e 94 f6 00 	call	0x1ec	; 0x1ec <temperMeasur>
//lcdDataString("?? C"); // ot gornata funkciq

	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 4
     4ca:	84 ed       	ldi	r24, 0xD4	; 212
     4cc:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
	LCD_DATA_STRING("             DS18x20");		//
     4d0:	88 e0       	ldi	r24, 0x08	; 8
     4d2:	93 e0       	ldi	r25, 0x03	; 3
     4d4:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
}
     4d8:	df 91       	pop	r29
     4da:	cf 91       	pop	r28
     4dc:	08 95       	ret

000004de <commonEncoder>:
**********************************************/
void commonEncoder(void)	// not finished
{
	static signed char saveValue = 0;	// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!! static ???
	signed char temp = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     4de:	0e 94 99 09 	call	0x1332	; 0x1332 <rotaryEncoderNikBarzakov>
	if(0==temp)
     4e2:	88 23       	and	r24, r24
     4e4:	09 f4       	brne	.+2      	; 0x4e8 <commonEncoder+0xa>
     4e6:	4f c0       	rjmp	.+158    	; 0x586 <commonEncoder+0xa8>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     4e8:	8f 3f       	cpi	r24, 0xFF	; 255
     4ea:	41 f5       	brne	.+80     	; 0x53c <commonEncoder+0x5e>
	{
		// encoder is decrement
		if(saveValue < -127)
     4ec:	80 91 c8 06 	lds	r24, 0x06C8
     4f0:	80 38       	cpi	r24, 0x80	; 128
     4f2:	11 f4       	brne	.+4      	; 0x4f8 <commonEncoder+0x1a>
		{
			saveValue = 127;	// SIGNED CHAR MIN VALUE = -127
     4f4:	8f e7       	ldi	r24, 0x7F	; 127
     4f6:	01 c0       	rjmp	.+2      	; 0x4fa <commonEncoder+0x1c>
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     4f8:	81 50       	subi	r24, 0x01	; 1
     4fa:	80 93 c8 06 	sts	0x06C8, r24
//			fanSpeedStep [FAN_LIMIT_POSITIONS]
		}
// LCD PRINT VALUE
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     4fe:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     500:	8c e0       	ldi	r24, 0x0C	; 12
     502:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     506:	84 ed       	ldi	r24, 0xD4	; 212
     508:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
		if (saveValue > 99)
     50c:	80 91 c8 06 	lds	r24, 0x06C8
     510:	84 36       	cpi	r24, 0x64	; 100
     512:	1c f0       	brlt	.+6      	; 0x51a <commonEncoder+0x3c>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     514:	8d e1       	ldi	r24, 0x1D	; 29
     516:	93 e0       	ldi	r25, 0x03	; 3
     518:	07 c0       	rjmp	.+14     	; 0x528 <commonEncoder+0x4a>
		}
		else if (saveValue > 9)
     51a:	8a 30       	cpi	r24, 0x0A	; 10
     51c:	1c f0       	brlt	.+6      	; 0x524 <commonEncoder+0x46>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     51e:	86 e2       	ldi	r24, 0x26	; 38
     520:	93 e0       	ldi	r25, 0x03	; 3
     522:	02 c0       	rjmp	.+4      	; 0x528 <commonEncoder+0x4a>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     524:	80 e3       	ldi	r24, 0x30	; 48
     526:	93 e0       	ldi	r25, 0x03	; 3
     528:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     52c:	80 91 c8 06 	lds	r24, 0x06C8
     530:	99 27       	eor	r25, r25
     532:	87 fd       	sbrc	r24, 7
     534:	90 95       	com	r25
     536:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_DATA_INT>
     53a:	08 95       	ret
	}
	else if(1==temp)
     53c:	81 30       	cpi	r24, 0x01	; 1
     53e:	19 f5       	brne	.+70     	; 0x586 <commonEncoder+0xa8>
		{
			saveValue = 128;	// SIGNED CHAR MAX VALUE = +128
		}
		else
		{
			saveValue += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     540:	80 91 c8 06 	lds	r24, 0x06C8
     544:	8f 5f       	subi	r24, 0xFF	; 255
     546:	80 93 c8 06 	sts	0x06C8, r24
		}

	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     54a:	94 98       	cbi	0x12, 4	; 18
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     54c:	8c e0       	ldi	r24, 0x0C	; 12
     54e:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     552:	84 ed       	ldi	r24, 0xD4	; 212
     554:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
		if (saveValue > 99)
     558:	80 91 c8 06 	lds	r24, 0x06C8
     55c:	84 36       	cpi	r24, 0x64	; 100
     55e:	1c f0       	brlt	.+6      	; 0x566 <commonEncoder+0x88>
		{
			LCD_DATA_STRING("Volume: ");	// 20 symbols
     560:	8d e1       	ldi	r24, 0x1D	; 29
     562:	93 e0       	ldi	r25, 0x03	; 3
     564:	07 c0       	rjmp	.+14     	; 0x574 <commonEncoder+0x96>
		}
		else if (saveValue > 9)
     566:	8a 30       	cpi	r24, 0x0A	; 10
     568:	1c f0       	brlt	.+6      	; 0x570 <commonEncoder+0x92>
		{
			LCD_DATA_STRING("Volume: 0");	// 20 symbols
     56a:	86 e2       	ldi	r24, 0x26	; 38
     56c:	93 e0       	ldi	r25, 0x03	; 3
     56e:	02 c0       	rjmp	.+4      	; 0x574 <commonEncoder+0x96>
		}
		else
		{
			LCD_DATA_STRING("Volume: 00");	// 20 symbols			
     570:	80 e3       	ldi	r24, 0x30	; 48
     572:	93 e0       	ldi	r25, 0x03	; 3
     574:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
		}
		LCD_DATA_INT(saveValue);		// 20 symbols
     578:	80 91 c8 06 	lds	r24, 0x06C8
     57c:	99 27       	eor	r25, r25
     57e:	87 fd       	sbrc	r24, 7
     580:	90 95       	com	r25
     582:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_DATA_INT>
     586:	08 95       	ret

00000588 <volumeUpdate>:
/*************************************
**** VOLUME UPDATE and LCD UPDATE ****
*************************************/
void volumeUpdate(void)
{
	PGA2310_Volume_Update(volumeValue[volumeIndex], volumeValue[volumeIndex]);	// update volume value on all channels
     588:	e0 91 bd 06 	lds	r30, 0x06BD
     58c:	f0 e0       	ldi	r31, 0x00	; 0
     58e:	ed 59       	subi	r30, 0x9D	; 157
     590:	f9 4f       	sbci	r31, 0xF9	; 249
     592:	60 81       	ld	r22, Z
     594:	86 2f       	mov	r24, r22
     596:	0e 94 23 08 	call	0x1046	; 0x1046 <PGA2310_Volume_Update>
	LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     59a:	84 ed       	ldi	r24, 0xD4	; 212
     59c:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
//		LCD_DATA_STRING("Volume: ");	// 20 symbols
	if (volumeIndex > 9)
     5a0:	80 91 bd 06 	lds	r24, 0x06BD
     5a4:	8a 30       	cpi	r24, 0x0A	; 10
     5a6:	18 f0       	brcs	.+6      	; 0x5ae <volumeUpdate+0x26>
	{
		LCD_DATA_STRING("Volume: ");	// 20 symbols
     5a8:	8d e1       	ldi	r24, 0x1D	; 29
     5aa:	93 e0       	ldi	r25, 0x03	; 3
     5ac:	02 c0       	rjmp	.+4      	; 0x5b2 <volumeUpdate+0x2a>
	}
	else
	{
		LCD_DATA_STRING("Volume: 0");	// 20 symbols
     5ae:	86 e2       	ldi	r24, 0x26	; 38
     5b0:	93 e0       	ldi	r25, 0x03	; 3
     5b2:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
	}
	LCD_DATA_INT(volumeIndex);			// 20 symbols
     5b6:	80 91 bd 06 	lds	r24, 0x06BD
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_DATA_INT>
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Volume: ");		// uart debug information string
     5c0:	8b e3       	ldi	r24, 0x3B	; 59
     5c2:	93 e0       	ldi	r25, 0x03	; 3
     5c4:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartInt(volumeIndex);		// uart debug information string 
     5c8:	80 91 bd 06 	lds	r24, 0x06BD
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	0e 94 de 08 	call	0x11bc	; 0x11bc <transmitUartInt>
		transmitUartString("\r\n");			// uart debug information string
     5d2:	8e e3       	ldi	r24, 0x3E	; 62
     5d4:	91 e0       	ldi	r25, 0x01	; 1
     5d6:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif
}
     5da:	08 95       	ret

000005dc <volumeMute>:
/************************************
**** VOLUME MUTE/UNMUTE FUNCTION ****
************************************/
void volumeMute(void)
{
	if(flagStatusBits->flagMute == 0)
     5dc:	e0 91 d9 06 	lds	r30, 0x06D9
     5e0:	f0 91 da 06 	lds	r31, 0x06DA
     5e4:	80 81       	ld	r24, Z
     5e6:	81 fd       	sbrc	r24, 1
     5e8:	0c c0       	rjmp	.+24     	; 0x602 <volumeMute+0x26>
	{
		volumeBuffer = volumeIndex;		// strore volume volue
     5ea:	80 91 bd 06 	lds	r24, 0x06BD
     5ee:	80 93 bc 06 	sts	0x06BC, r24
		volumeIndex = VOLUME_MUTE;		// MUTE ON
     5f2:	10 92 bd 06 	sts	0x06BD, r1
		flagStatusBits->flagMute = 1;	// MUTE ON
     5f6:	80 81       	ld	r24, Z
     5f8:	82 60       	ori	r24, 0x02	; 2
     5fa:	80 83       	st	Z, r24
		#ifdef DEBUG_INFO
			transmitUartString("[UART INFO] Volume mute is on\r\n");
     5fc:	80 e5       	ldi	r24, 0x50	; 80
     5fe:	93 e0       	ldi	r25, 0x03	; 3
     600:	0b c0       	rjmp	.+22     	; 0x618 <volumeMute+0x3c>
		#endif
	}
	else
	{
		volumeIndex = volumeBuffer;		// MUTE OFF
     602:	80 91 bc 06 	lds	r24, 0x06BC
     606:	80 93 bd 06 	sts	0x06BD, r24
		volumeBuffer = VOLUME_MUTE;		// clear volume volue
     60a:	10 92 bc 06 	sts	0x06BC, r1
		flagStatusBits->flagMute = 0;	// MUTE OFF
     60e:	80 81       	ld	r24, Z
     610:	8d 7f       	andi	r24, 0xFD	; 253
     612:	80 83       	st	Z, r24
		#ifdef DEBUG_INFO
			transmitUartString("[UART INFO] Volume mute is off\r\n");
     614:	80 e7       	ldi	r24, 0x70	; 112
     616:	93 e0       	ldi	r25, 0x03	; 3
     618:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		#endif
	}
	volumeUpdate();
     61c:	0e 94 c4 02 	call	0x588	; 0x588 <volumeUpdate>
}
     620:	08 95       	ret

00000622 <volumeProcessRemote>:
/********************************************
**** VOLUME PROCESS FUNCTION FROM REMOTE ****
********************************************/
void volumeProcessRemote(signed char temp)
{
	if(-1==temp)
     622:	8f 3f       	cpi	r24, 0xFF	; 255
     624:	69 f4       	brne	.+26     	; 0x640 <volumeProcessRemote+0x1e>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     626:	80 91 bd 06 	lds	r24, 0x06BD
     62a:	88 23       	and	r24, r24
     62c:	19 f4       	brne	.+6      	; 0x634 <volumeProcessRemote+0x12>
		{
			volumeIndex = VOLUME_MUTE;
     62e:	10 92 bd 06 	sts	0x06BD, r1
     632:	03 c0       	rjmp	.+6      	; 0x63a <volumeProcessRemote+0x18>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     634:	81 50       	subi	r24, 0x01	; 1
     636:	80 93 bd 06 	sts	0x06BD, r24
		}
		volumeUpdate();
     63a:	0e 94 c4 02 	call	0x588	; 0x588 <volumeUpdate>
     63e:	08 95       	ret
	}
	else if(1==temp)
     640:	81 30       	cpi	r24, 0x01	; 1
     642:	59 f4       	brne	.+22     	; 0x65a <volumeProcessRemote+0x38>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     644:	80 91 bd 06 	lds	r24, 0x06BD
     648:	83 31       	cpi	r24, 0x13	; 19
     64a:	10 f0       	brcs	.+4      	; 0x650 <volumeProcessRemote+0x2e>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     64c:	83 e1       	ldi	r24, 0x13	; 19
     64e:	01 c0       	rjmp	.+2      	; 0x652 <volumeProcessRemote+0x30>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     650:	8f 5f       	subi	r24, 0xFF	; 255
     652:	80 93 bd 06 	sts	0x06BD, r24
		}
		volumeUpdate();
     656:	0e 94 c4 02 	call	0x588	; 0x588 <volumeUpdate>
     65a:	08 95       	ret

0000065c <volumeProcess>:
**** VOLUME PROCESS FUNCTION FROM ENCODER ****
*********************************************/
void volumeProcess(void)
{
	signed char temp = 0;//, tempEnc = 0, tempRem = 0;				// zadaljitelno signed char!!! ima osobenost pri vrashtaneto na rezultat ot funkciq!!!
	temp = rotaryEncoderNikBarzakov();
     65c:	0e 94 99 09 	call	0x1332	; 0x1332 <rotaryEncoderNikBarzakov>
	if(0==temp)
     660:	88 23       	and	r24, r24
     662:	e1 f0       	breq	.+56     	; 0x69c <volumeProcess+0x40>
	{
		// do nothing, encoder havn't been rotated  // ne e bil zavartan
	}
	else if(-1==temp)
     664:	8f 3f       	cpi	r24, 0xFF	; 255
     666:	69 f4       	brne	.+26     	; 0x682 <volumeProcess+0x26>
	{
		// encoder is decrement
		if(volumeIndex < (VOLUME_MUTE + 1))
     668:	80 91 bd 06 	lds	r24, 0x06BD
     66c:	88 23       	and	r24, r24
     66e:	19 f4       	brne	.+6      	; 0x676 <volumeProcess+0x1a>
		{
			volumeIndex = VOLUME_MUTE;
     670:	10 92 bd 06 	sts	0x06BD, r1
     674:	03 c0       	rjmp	.+6      	; 0x67c <volumeProcess+0x20>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     676:	81 50       	subi	r24, 0x01	; 1
     678:	80 93 bd 06 	sts	0x06BD, r24
		}
		volumeUpdate();
     67c:	0e 94 c4 02 	call	0x588	; 0x588 <volumeUpdate>
     680:	08 95       	ret
	}
	else if(1==temp)
     682:	81 30       	cpi	r24, 0x01	; 1
     684:	59 f4       	brne	.+22     	; 0x69c <volumeProcess+0x40>
	{
		// encoder is increment
		if (volumeIndex > (VOLUME_LIMIT_POSITIONS - 2))
     686:	80 91 bd 06 	lds	r24, 0x06BD
     68a:	83 31       	cpi	r24, 0x13	; 19
     68c:	10 f0       	brcs	.+4      	; 0x692 <volumeProcess+0x36>
		{
			volumeIndex = (VOLUME_LIMIT_POSITIONS - 1);
     68e:	83 e1       	ldi	r24, 0x13	; 19
     690:	01 c0       	rjmp	.+2      	; 0x694 <volumeProcess+0x38>
		}
		else
		{
			volumeIndex += temp;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     692:	8f 5f       	subi	r24, 0xFF	; 255
     694:	80 93 bd 06 	sts	0x06BD, r24
		}
		volumeUpdate();
     698:	0e 94 c4 02 	call	0x588	; 0x588 <volumeUpdate>
     69c:	08 95       	ret

0000069e <ampliferOff>:
/*********************
**** AMPLIFER OFF ****
*********************/
void ampliferOff(void)
{
	flagStatusBits->flagPower = 0;		// flag for amplifer off
     69e:	e0 91 d9 06 	lds	r30, 0x06D9
     6a2:	f0 91 da 06 	lds	r31, 0x06DA
     6a6:	80 81       	ld	r24, Z
     6a8:	8e 7f       	andi	r24, 0xFE	; 254
     6aa:	80 83       	st	Z, r24

	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     6ac:	80 e0       	ldi	r24, 0x00	; 0
     6ae:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer Off    ");	// 20 symbols
     6b2:	81 e9       	ldi	r24, 0x91	; 145
     6b4:	93 e0       	ldi	r25, 0x03	; 3
     6b6:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>

	LCD_COMMAND(LCD_OFF);						// LCD ON without CURSOR
     6ba:	88 e0       	ldi	r24, 0x08	; 8
     6bc:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>

//			FAN_low();		// PORTD5 - FAN OFF (logic "0")  NON PWM, NON TIMER1

// RELAYS OFF FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays out for all 6 channels\r\n");		// uart debug information string
     6c0:	86 ea       	ldi	r24, 0xA6	; 166
     6c2:	93 e0       	ldi	r25, 0x03	; 3
     6c4:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif
	relays_out_off();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     6c8:	0e 94 3d 0a 	call	0x147a	; 0x147a <relays_out_off>
     6cc:	88 e5       	ldi	r24, 0x58	; 88
     6ce:	9b e1       	ldi	r25, 0x1B	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     6d0:	20 e9       	ldi	r18, 0x90	; 144
     6d2:	31 e0       	ldi	r19, 0x01	; 1
     6d4:	f9 01       	movw	r30, r18
     6d6:	31 97       	sbiw	r30, 0x01	; 1
     6d8:	f1 f7       	brne	.-4      	; 0x6d6 <ampliferOff+0x38>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6da:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     6dc:	d9 f7       	brne	.-10     	; 0x6d4 <ampliferOff+0x36>
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays in for all 6 channels\r\n");		// uart debug information string
     6de:	84 ee       	ldi	r24, 0xE4	; 228
     6e0:	93 e0       	ldi	r25, 0x03	; 3
     6e2:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif
	relays_in_off();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     6e6:	0e 94 16 0a 	call	0x142c	; 0x142c <relays_in_off>
     6ea:	88 e5       	ldi	r24, 0x58	; 88
     6ec:	9b e1       	ldi	r25, 0x1B	; 27
     6ee:	20 e9       	ldi	r18, 0x90	; 144
     6f0:	31 e0       	ldi	r19, 0x01	; 1
     6f2:	f9 01       	movw	r30, r18
     6f4:	31 97       	sbiw	r30, 0x01	; 1
     6f6:	f1 f7       	brne	.-4      	; 0x6f4 <ampliferOff+0x56>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6f8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     6fa:	d9 f7       	brne	.-10     	; 0x6f2 <ampliferOff+0x54>
	_delay_ms(700);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch off relays for power 220V\r\n");		// uart debug information string
     6fc:	81 e2       	ldi	r24, 0x21	; 33
     6fe:	94 e0       	ldi	r25, 0x04	; 4
     700:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif
	REL_POWER_low();// RELAY POWER OFF				// PESHO COMMENT 14.08.2015, 21:10
     704:	aa 98       	cbi	0x15, 2	; 21

// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan is off\r\n");
     706:	87 e5       	ldi	r24, 0x57	; 87
     708:	94 e0       	ldi	r25, 0x04	; 4
     70a:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
//	OCR1BL = 1; // LED PWM ON				// out	OCR1BL, r17		; 200 = 0b11001000 (DEC = BIN)
}

void timer1_off(void)
{
	TCCR1A = 0b00000000;		// DISABLED OCOC1A - PWM, OC1B - Disabled, normal port.
     70e:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000000;		// 
     710:	1e bc       	out	0x2e, r1	; 46

	OCR1AH = 0; // FAN PWM OFF
     712:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0; // FAN PWM OFF
     714:	1a bc       	out	0x2a, r1	; 42
		transmitUartString("[UART INFO] Fan is off\r\n");
	#endif
	FAN_PWM_OFF();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1

// FANS FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();
     716:	0e 94 3d 07 	call	0xe7a	; 0xe7a <LCD_CLEAR_CONTAIN>
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display off and status led on\r\n");
     71a:	80 e7       	ldi	r24, 0x70	; 112
     71c:	94 e0       	ldi	r25, 0x04	; 4
     71e:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif

// LED ON FUNC
	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     722:	94 9a       	sbi	0x12, 4	; 18

// UART MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Amplifer is off\r\n");
     724:	8c e9       	ldi	r24, 0x9C	; 156
     726:	94 e0       	ldi	r25, 0x04	; 4
     728:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
     72c:	88 e8       	ldi	r24, 0x88	; 136
     72e:	93 e1       	ldi	r25, 0x13	; 19
     730:	20 e9       	ldi	r18, 0x90	; 144
     732:	31 e0       	ldi	r19, 0x01	; 1
     734:	f9 01       	movw	r30, r18
     736:	31 97       	sbiw	r30, 0x01	; 1
     738:	f1 f7       	brne	.-4      	; 0x736 <ampliferOff+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     73a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     73c:	d9 f7       	brne	.-10     	; 0x734 <ampliferOff+0x96>
	#endif

	_delay_ms(500);	// izchakvane pri natiskane za izkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton
}
     73e:	08 95       	ret

00000740 <ampliferOn>:
/********************
**** AMPLIFER ON ****
********************/
void ampliferOn(void)
{
	flagStatusBits->flagPower = 1;		// flag for amplifer on
     740:	e0 91 d9 06 	lds	r30, 0x06D9
     744:	f0 91 da 06 	lds	r31, 0x06DA
     748:	80 81       	ld	r24, Z
     74a:	81 60       	ori	r24, 0x01	; 1
     74c:	80 83       	st	Z, r24

// UART MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Amplifer is on\r\n");
     74e:	8a eb       	ldi	r24, 0xBA	; 186
     750:	94 e0       	ldi	r25, 0x04	; 4
     752:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Display on and status led off\r\n");
     756:	87 ed       	ldi	r24, 0xD7	; 215
     758:	94 e0       	ldi	r25, 0x04	; 4
     75a:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif

// LED OFF FUNC
	LED_low_DISPLAYLED_high();		// PORTD4 - LED OFF (logic "0"), DISPLAY BACKLIGHT ON (logic "0"),  NON PWM, NON TIMER1
     75e:	94 98       	cbi	0x12, 4	; 18

// LCD FUNC & MESSAGE
	LCD_CLEAR_CONTAIN();						// clear all contain on display
     760:	0e 94 3d 07 	call	0xe7a	; 0xe7a <LCD_CLEAR_CONTAIN>
	LCD_COMMAND(LCD_SELECT_1ROW);				// select row 1
     764:	80 e0       	ldi	r24, 0x00	; 0
     766:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
	LCD_DATA_STRING("    Amplifer On     ");	// 20 symbols
     76a:	83 e0       	ldi	r24, 0x03	; 3
     76c:	95 e0       	ldi	r25, 0x05	; 5
     76e:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
	LCD_COMMAND(LCD_SELECT_2ROW);				// select row 2
     772:	80 ec       	ldi	r24, 0xC0	; 192
     774:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
	LCD_DATA_STRING("P.UPINOV  P.STOYANOV");	// 20 symbols //	LCD_EXECUTE_DATA("P.UPINOV  P.STOYANOV",20);	// char "DATA", int 13 of chars of "DATA"
     778:	88 e1       	ldi	r24, 0x18	; 24
     77a:	95 e0       	ldi	r25, 0x05	; 5
     77c:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
	LCD_COMMAND(LCD_ON);						// LCD ON without CURSOR
     780:	8c e0       	ldi	r24, 0x0C	; 12
     782:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
// FANS FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Fan is on\r\n");
     786:	8d e2       	ldi	r24, 0x2D	; 45
     788:	95 e0       	ldi	r25, 0x05	; 5
     78a:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
		transmitUartString("[UART INFO] Fan is always on, it isn't sensitive to temperature, because DS18S20 is disabling\r\n");
     78e:	85 e4       	ldi	r24, 0x45	; 69
     790:	95 e0       	ldi	r25, 0x05	; 5
     792:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     796:	81 ea       	ldi	r24, 0xA1	; 161
     798:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     79a:	81 e0       	ldi	r24, 0x01	; 1
     79c:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     79e:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     7a0:	e0 91 77 06 	lds	r30, 0x0677
     7a4:	f0 e0       	ldi	r31, 0x00	; 0
     7a6:	e8 58       	subi	r30, 0x88	; 136
     7a8:	f9 4f       	sbci	r31, 0xF9	; 249
     7aa:	80 81       	ld	r24, Z
     7ac:	8a bd       	out	0x2a, r24	; 42
	FAN_PWM_SPEED1();	// KOMENTAR ZARADI SIMULACIQTA - MNOGO BAVI PRI SIMULACIQ S TIMER1
//	FAN_high();			// PORTD5 - FAN ON (logic "1")	NON PWM, NON TIMER1

// RELAYS ON FUNC & MESSAGE
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays for power 220V\r\n");		// uart debug information string
     7ae:	85 ea       	ldi	r24, 0xA5	; 165
     7b0:	95 e0       	ldi	r25, 0x05	; 5
     7b2:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif
	REL_POWER_high();// RELAY POWER ON TRAFs		// PESHO COMMENT 14.08.2015, 21:10
     7b6:	aa 9a       	sbi	0x15, 2	; 21
     7b8:	80 e4       	ldi	r24, 0x40	; 64
     7ba:	9c e9       	ldi	r25, 0x9C	; 156
     7bc:	20 e9       	ldi	r18, 0x90	; 144
     7be:	31 e0       	ldi	r19, 0x01	; 1
     7c0:	f9 01       	movw	r30, r18
     7c2:	31 97       	sbiw	r30, 0x01	; 1
     7c4:	f1 f7       	brne	.-4      	; 0x7c2 <ampliferOn+0x82>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7c6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7c8:	d9 f7       	brne	.-10     	; 0x7c0 <ampliferOn+0x80>
	_delay_ms(4000);								// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays in for all 6 channels\r\n");		// uart debug information string
     7ca:	8a ed       	ldi	r24, 0xDA	; 218
     7cc:	95 e0       	ldi	r25, 0x05	; 5
     7ce:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif
	relays_in1_6ch();	// RELAYS IN1 CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     7d2:	0e 94 02 0a 	call	0x1404	; 0x1404 <relays_in1_6ch>
     7d6:	88 e5       	ldi	r24, 0x58	; 88
     7d8:	9b e1       	ldi	r25, 0x1B	; 27
     7da:	20 e9       	ldi	r18, 0x90	; 144
     7dc:	31 e0       	ldi	r19, 0x01	; 1
     7de:	f9 01       	movw	r30, r18
     7e0:	31 97       	sbiw	r30, 0x01	; 1
     7e2:	f1 f7       	brne	.-4      	; 0x7e0 <ampliferOn+0xa0>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7e4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7e6:	d9 f7       	brne	.-10     	; 0x7de <ampliferOn+0x9e>
	_delay_ms(700);									// PESHO COMMENT 14.08.2015, 21:10
	#ifdef DEBUG_INFO
		transmitUartString("[UART INFO] Try to switch on relays out for all 6 channels\r\n");		// uart debug information string
     7e8:	86 e1       	ldi	r24, 0x16	; 22
     7ea:	96 e0       	ldi	r25, 0x06	; 6
     7ec:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
	#endif
	relays_out_6ch();	// RELAYS OUT CHANNELS 6	// PESHO COMMENT 14.08.2015, 21:10
     7f0:	0e 94 39 0a 	call	0x1472	; 0x1472 <relays_out_6ch>
     7f4:	80 e1       	ldi	r24, 0x10	; 16
     7f6:	97 e2       	ldi	r25, 0x27	; 39
     7f8:	20 e9       	ldi	r18, 0x90	; 144
     7fa:	31 e0       	ldi	r19, 0x01	; 1
     7fc:	f9 01       	movw	r30, r18
     7fe:	31 97       	sbiw	r30, 0x01	; 1
     800:	f1 f7       	brne	.-4      	; 0x7fe <ampliferOn+0xbe>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     802:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     804:	d9 f7       	brne	.-10     	; 0x7fc <ampliferOn+0xbc>
	_delay_ms(1000);	// izchakvane pri natiskane za vkliuchvane i otpuskane na buton - filtar treptqsht kontakt buton
}
     806:	08 95       	ret

00000808 <buttons_press>:


}

void buttons_press()
{
     808:	cf 93       	push	r28
     80a:	df 93       	push	r29
	flagStatusBits = &fSB;
     80c:	81 ee       	ldi	r24, 0xE1	; 225
     80e:	96 e0       	ldi	r25, 0x06	; 6
     810:	90 93 da 06 	sts	0x06DA, r25
     814:	80 93 d9 06 	sts	0x06D9, r24
	flagStatusBits->flagPower=0;	// inicializirane s nuli, no nai veroqtno poradi tova che e globalna stru
     818:	80 91 e1 06 	lds	r24, 0x06E1
	flagStatusBits->flagMute=0;		// inicializirane
     81c:	8c 7f       	andi	r24, 0xFC	; 252
     81e:	80 93 e1 06 	sts	0x06E1, r24
     822:	c0 e9       	ldi	r28, 0x90	; 144
     824:	d1 e0       	ldi	r29, 0x01	; 1
		LCD_DATA_INT(flagStatusBits->flagMute);		// 20 symbols
	_delay_ms(2000);
*/
	while(1)
	{
		if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)	// obj ptr flagStatusBtnRegister from struct flagStatusBtnOnOff
     826:	b1 99       	sbic	0x16, 1	; 22
     828:	0a c0       	rjmp	.+20     	; 0x83e <buttons_press+0x36>
     82a:	e0 91 d9 06 	lds	r30, 0x06D9
     82e:	f0 91 da 06 	lds	r31, 0x06DA
     832:	80 81       	ld	r24, Z
     834:	80 fd       	sbrc	r24, 0
     836:	03 c0       	rjmp	.+6      	; 0x83e <buttons_press+0x36>
		{
//			flagStatusBits->flagPower = 1;			// filter za buton ON
			ampliferOn();
     838:	0e 94 a0 03 	call	0x740	; 0x740 <ampliferOn>
     83c:	f4 cf       	rjmp	.-24     	; 0x826 <buttons_press+0x1e>
//			_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
		}
		else if(BUTTON_ON_OFF_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     83e:	b1 99       	sbic	0x16, 1	; 22
     840:	0a c0       	rjmp	.+20     	; 0x856 <buttons_press+0x4e>
     842:	e0 91 d9 06 	lds	r30, 0x06D9
     846:	f0 91 da 06 	lds	r31, 0x06DA
     84a:	80 81       	ld	r24, Z
     84c:	80 ff       	sbrs	r24, 0
     84e:	03 c0       	rjmp	.+6      	; 0x856 <buttons_press+0x4e>
		{
//			flagStatusBits->flagPower = 0;			// filter za buton OFF
			ampliferOff();
     850:	0e 94 4f 03 	call	0x69e	; 0x69e <ampliferOff>
     854:	e8 cf       	rjmp	.-48     	; 0x826 <buttons_press+0x1e>
		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     856:	b2 99       	sbic	0x16, 2	; 22
     858:	11 c0       	rjmp	.+34     	; 0x87c <__stack+0x1d>
     85a:	e0 91 d9 06 	lds	r30, 0x06D9
     85e:	f0 91 da 06 	lds	r31, 0x06DA
     862:	80 81       	ld	r24, Z
     864:	80 ff       	sbrs	r24, 0
     866:	0a c0       	rjmp	.+20     	; 0x87c <__stack+0x1d>
		{
//			LCD_DATA_STRING("PRESSED BTN ESCAPE  ");	// 20 symbols
//			LCD_COMMAND(LCD_ON);
			LCD_CLEAR_CONTAIN();
     868:	0e 94 3d 07 	call	0xe7a	; 0xe7a <LCD_CLEAR_CONTAIN>
     86c:	88 e8       	ldi	r24, 0x88	; 136
     86e:	93 e1       	ldi	r25, 0x13	; 19
     870:	fe 01       	movw	r30, r28
     872:	31 97       	sbiw	r30, 0x01	; 1
     874:	f1 f7       	brne	.-4      	; 0x872 <__stack+0x13>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     876:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     878:	d9 f7       	brne	.-10     	; 0x870 <__stack+0x11>
     87a:	d5 cf       	rjmp	.-86     	; 0x826 <buttons_press+0x1e>
			_delay_ms(500);
//			volumeUp();
//			_delay_ms(200);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     87c:	83 99       	sbic	0x10, 3	; 16
     87e:	0f c0       	rjmp	.+30     	; 0x89e <__stack+0x3f>
     880:	e0 91 d9 06 	lds	r30, 0x06D9
     884:	f0 91 da 06 	lds	r31, 0x06DA
     888:	80 81       	ld	r24, Z
     88a:	80 ff       	sbrs	r24, 0
     88c:	08 c0       	rjmp	.+16     	; 0x89e <__stack+0x3f>
     88e:	88 e8       	ldi	r24, 0x88	; 136
     890:	93 e1       	ldi	r25, 0x13	; 19
     892:	fe 01       	movw	r30, r28
     894:	31 97       	sbiw	r30, 0x01	; 1
     896:	f1 f7       	brne	.-4      	; 0x894 <__stack+0x35>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     898:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     89a:	d9 f7       	brne	.-10     	; 0x892 <__stack+0x33>
     89c:	c4 cf       	rjmp	.-120    	; 0x826 <buttons_press+0x1e>
			_delay_ms(500);
//			volumeDown();
//			_delay_ms(200);

		}
		else if(BUTTON_ESC_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     89e:	b2 99       	sbic	0x16, 2	; 22
     8a0:	0f c0       	rjmp	.+30     	; 0x8c0 <__stack+0x61>
     8a2:	e0 91 d9 06 	lds	r30, 0x06D9
     8a6:	f0 91 da 06 	lds	r31, 0x06DA
     8aa:	80 81       	ld	r24, Z
     8ac:	80 fd       	sbrc	r24, 0
     8ae:	08 c0       	rjmp	.+16     	; 0x8c0 <__stack+0x61>
     8b0:	88 e8       	ldi	r24, 0x88	; 136
     8b2:	93 e1       	ldi	r25, 0x13	; 19
     8b4:	fe 01       	movw	r30, r28
     8b6:	31 97       	sbiw	r30, 0x01	; 1
     8b8:	f1 f7       	brne	.-4      	; 0x8b6 <__stack+0x57>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8ba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8bc:	d9 f7       	brne	.-10     	; 0x8b4 <__stack+0x55>
     8be:	b3 cf       	rjmp	.-154    	; 0x826 <buttons_press+0x1e>
//			LCD_COMMAND(LCD_ON);
			_delay_ms(500);
//			setupMode();
//			_delay_ms(1000);
		}
		else if(BUTTON_ENCODER_low() && flagStatusBits->flagPower == 0)//fSB.flagPower == 0)//flagStatusBits->flagPower == 0)
     8c0:	83 99       	sbic	0x10, 3	; 16
     8c2:	11 c0       	rjmp	.+34     	; 0x8e6 <__stack+0x87>
     8c4:	e0 91 d9 06 	lds	r30, 0x06D9
     8c8:	f0 91 da 06 	lds	r31, 0x06DA
     8cc:	80 81       	ld	r24, Z
     8ce:	80 fd       	sbrc	r24, 0
     8d0:	0a c0       	rjmp	.+20     	; 0x8e6 <__stack+0x87>
		{
			temperature();
     8d2:	0e 94 fe 01 	call	0x3fc	; 0x3fc <temperature>
     8d6:	88 e8       	ldi	r24, 0x88	; 136
     8d8:	93 e1       	ldi	r25, 0x13	; 19
     8da:	fe 01       	movw	r30, r28
     8dc:	31 97       	sbiw	r30, 0x01	; 1
     8de:	f1 f7       	brne	.-4      	; 0x8dc <__stack+0x7d>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8e0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8e2:	d9 f7       	brne	.-10     	; 0x8da <__stack+0x7b>
     8e4:	a0 cf       	rjmp	.-192    	; 0x826 <buttons_press+0x1e>
//			LCD_COMMAND(LCD_OFF);
			_delay_ms(500);
//			about();
//			_delay_ms(1000);
		}
		else if(flagStatusBits->flagPower == 1)//fSB.flagPower == 1)//flagStatusBits->flagPower == 1)
     8e6:	e0 91 d9 06 	lds	r30, 0x06D9
     8ea:	f0 91 da 06 	lds	r31, 0x06DA
     8ee:	80 81       	ld	r24, Z
     8f0:	80 ff       	sbrs	r24, 0
     8f2:	99 cf       	rjmp	.-206    	; 0x826 <buttons_press+0x1e>
		{
			volumeProcess();
     8f4:	0e 94 2e 03 	call	0x65c	; 0x65c <volumeProcess>
     8f8:	96 cf       	rjmp	.-212    	; 0x826 <buttons_press+0x1e>

000008fa <main>:
******************************** START OF MAIN APPLICATION **********************************
********************************************************************************************/

int main(void)
{
	init_all();				// inicializacia na vsichko
     8fa:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <init_all>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     8fe:	80 e4       	ldi	r24, 0x40	; 64
     900:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     902:	8a bf       	out	0x3a, r24	; 58
{
	init_all();				// inicializacia na vsichko
	ext0_intrpt_on();		// ENABLE interrupts to access IR DETECTION as call to function "IR_DECODER()" for -> SONY IR REMOTE
//	ext2_intrpt_on();

	sei();							// file "avr/interrupt.h"
     904:	78 94       	sei
//	SREG = (1<<I);

	LED_high_DISPLAYLED_low();		// PORTD4 - LED ON (logic "1"), DISPLAY BACKLIGHT OFF (logic "1"),  NON PWM, NON TIMER1
     906:	94 9a       	sbi	0x12, 4	; 18
	while(1)
	{		
		buttons_press();	// izchakvane za natiskane na buton
     908:	0e 94 04 04 	call	0x808	; 0x808 <buttons_press>
     90c:	fd cf       	rjmp	.-6      	; 0x908 <main+0xe>

0000090e <irDecode>:
************************************/
void irDecode(void)
{
//	byte byteSS0, byteSS1, byteMM0, byteMM1, byteHH0, byteHH1, byteDD0, byteDD1, byteMont0, byteMont1, byteYY0, byteYY1; // variables for convert DEC to BCD for LCD and UART for Time and Date

	GetSIRC12();
     90e:	0e 94 45 0a 	call	0x148a	; 0x148a <GetSIRC12>
	if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 0)		// IR POWER -> ON
     912:	90 91 dd 06 	lds	r25, 0x06DD
     916:	91 30       	cpi	r25, 0x01	; 1
     918:	29 f4       	brne	.+10     	; 0x924 <irDecode+0x16>
     91a:	80 91 d8 06 	lds	r24, 0x06D8
     91e:	85 31       	cpi	r24, 0x15	; 21
     920:	99 f4       	brne	.+38     	; 0x948 <irDecode+0x3a>
     922:	06 c0       	rjmp	.+12     	; 0x930 <irDecode+0x22>
     924:	94 30       	cpi	r25, 0x04	; 4
     926:	29 f5       	brne	.+74     	; 0x972 <irDecode+0x64>
     928:	80 91 d8 06 	lds	r24, 0x06D8
     92c:	8d 30       	cpi	r24, 0x0D	; 13
     92e:	99 f4       	brne	.+38     	; 0x956 <irDecode+0x48>
     930:	e0 91 d9 06 	lds	r30, 0x06D9
     934:	f0 91 da 06 	lds	r31, 0x06DA
     938:	80 81       	ld	r24, Z
     93a:	80 fd       	sbrc	r24, 0
     93c:	03 c0       	rjmp	.+6      	; 0x944 <irDecode+0x36>
	{		
		ampliferOn();
     93e:	0e 94 a0 03 	call	0x740	; 0x740 <ampliferOn>
     942:	98 c0       	rjmp	.+304    	; 0xa74 <irDecode+0x166>
//		_delay_ms(1000);	// izchakvane za natiskane i otpuskane na buton - filtar treptqsht kontakt buton
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A && irCommand == IR_REMOTE_COMMAND_RM_677A_STANDBY) || (irAddress == IR_REMOTE_CAR_DEVICE_RM_X157 && irCommand == IR_REMOTE_COMMAND_RM_X157_OFF)) && flagStatusBits->flagPower == 1)	// IR POWER -> OFF
     944:	91 30       	cpi	r25, 0x01	; 1
     946:	29 f4       	brne	.+10     	; 0x952 <irDecode+0x44>
     948:	80 91 d8 06 	lds	r24, 0x06D8
     94c:	85 31       	cpi	r24, 0x15	; 21
     94e:	b1 f4       	brne	.+44     	; 0x97c <irDecode+0x6e>
     950:	06 c0       	rjmp	.+12     	; 0x95e <irDecode+0x50>
     952:	94 30       	cpi	r25, 0x04	; 4
     954:	71 f4       	brne	.+28     	; 0x972 <irDecode+0x64>
     956:	80 91 d8 06 	lds	r24, 0x06D8
     95a:	8d 30       	cpi	r24, 0x0D	; 13
     95c:	79 f4       	brne	.+30     	; 0x97c <irDecode+0x6e>
     95e:	e0 91 d9 06 	lds	r30, 0x06D9
     962:	f0 91 da 06 	lds	r31, 0x06DA
     966:	80 81       	ld	r24, Z
     968:	80 ff       	sbrs	r24, 0
     96a:	03 c0       	rjmp	.+6      	; 0x972 <irDecode+0x64>
	{
		ampliferOff();
     96c:	0e 94 4f 03 	call	0x69e	; 0x69e <ampliferOff>
     970:	81 c0       	rjmp	.+258    	; 0xa74 <irDecode+0x166>
//		flagPower = 0;			// filter za buton OFF
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLUP)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME UP"
     972:	91 30       	cpi	r25, 0x01	; 1
     974:	19 f0       	breq	.+6      	; 0x97c <irDecode+0x6e>
     976:	94 30       	cpi	r25, 0x04	; 4
     978:	09 f0       	breq	.+2      	; 0x97c <irDecode+0x6e>
     97a:	7c c0       	rjmp	.+248    	; 0xa74 <irDecode+0x166>
     97c:	20 91 d8 06 	lds	r18, 0x06D8
     980:	22 31       	cpi	r18, 0x12	; 18
     982:	49 f4       	brne	.+18     	; 0x996 <irDecode+0x88>
     984:	e0 91 d9 06 	lds	r30, 0x06D9
     988:	f0 91 da 06 	lds	r31, 0x06DA
     98c:	80 81       	ld	r24, Z
     98e:	80 ff       	sbrs	r24, 0
     990:	02 c0       	rjmp	.+4      	; 0x996 <irDecode+0x88>
	{	// VOLUME UP
		volumeProcessRemote(REMOTE_VOLUME_UP);
     992:	81 e0       	ldi	r24, 0x01	; 1
     994:	0f c0       	rjmp	.+30     	; 0x9b4 <irDecode+0xa6>
//		break;
	}
	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_VOLDN)) && flagStatusBits->flagPower == 1)	// Sony TV & CarAudio IR Remote Device - "VOLUME DOWN"
     996:	91 30       	cpi	r25, 0x01	; 1
     998:	19 f0       	breq	.+6      	; 0x9a0 <irDecode+0x92>
     99a:	94 30       	cpi	r25, 0x04	; 4
     99c:	09 f0       	breq	.+2      	; 0x9a0 <irDecode+0x92>
     99e:	6a c0       	rjmp	.+212    	; 0xa74 <irDecode+0x166>
     9a0:	23 31       	cpi	r18, 0x13	; 19
     9a2:	59 f4       	brne	.+22     	; 0x9ba <irDecode+0xac>
     9a4:	e0 91 d9 06 	lds	r30, 0x06D9
     9a8:	f0 91 da 06 	lds	r31, 0x06DA
     9ac:	80 81       	ld	r24, Z
     9ae:	80 ff       	sbrs	r24, 0
     9b0:	04 c0       	rjmp	.+8      	; 0x9ba <irDecode+0xac>
	{	// VOLUME DOWN
		volumeProcessRemote(REMOTE_VOLUME_DOWN);
     9b2:	8f ef       	ldi	r24, 0xFF	; 255
     9b4:	0e 94 11 03 	call	0x622	; 0x622 <volumeProcessRemote>
     9b8:	5d c0       	rjmp	.+186    	; 0xa74 <irDecode+0x166>
//		break;
	}

	else if(((irAddress == IR_REMOTE_TV_DEVICE_RM_677A || irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_ATT)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     9ba:	91 30       	cpi	r25, 0x01	; 1
     9bc:	19 f0       	breq	.+6      	; 0x9c4 <irDecode+0xb6>
     9be:	94 30       	cpi	r25, 0x04	; 4
     9c0:	09 f0       	breq	.+2      	; 0x9c4 <irDecode+0xb6>
     9c2:	58 c0       	rjmp	.+176    	; 0xa74 <irDecode+0x166>
     9c4:	24 31       	cpi	r18, 0x14	; 20
     9c6:	51 f4       	brne	.+20     	; 0x9dc <irDecode+0xce>
     9c8:	e0 91 d9 06 	lds	r30, 0x06D9
     9cc:	f0 91 da 06 	lds	r31, 0x06DA
     9d0:	80 81       	ld	r24, Z
     9d2:	80 ff       	sbrs	r24, 0
     9d4:	03 c0       	rjmp	.+6      	; 0x9dc <irDecode+0xce>
	{	// MUTE
		volumeMute();
     9d6:	0e 94 ee 02 	call	0x5dc	; 0x5dc <volumeMute>
     9da:	4c c0       	rjmp	.+152    	; 0xa74 <irDecode+0x166>
//		break;
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_DOWN)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     9dc:	94 30       	cpi	r25, 0x04	; 4
     9de:	09 f0       	breq	.+2      	; 0x9e2 <irDecode+0xd4>
     9e0:	49 c0       	rjmp	.+146    	; 0xa74 <irDecode+0x166>
     9e2:	22 33       	cpi	r18, 0x32	; 50
     9e4:	81 f4       	brne	.+32     	; 0xa06 <irDecode+0xf8>
     9e6:	e0 91 d9 06 	lds	r30, 0x06D9
     9ea:	f0 91 da 06 	lds	r31, 0x06DA
     9ee:	80 81       	ld	r24, Z
     9f0:	80 ff       	sbrs	r24, 0
     9f2:	40 c0       	rjmp	.+128    	; 0xa74 <irDecode+0x166>
	{	// FAN STEP UP
		if(fanSpeed < FAN_SPEED_ABSOLUTE_MIN + 1)//0)
     9f4:	80 91 77 06 	lds	r24, 0x0677
     9f8:	88 23       	and	r24, r24
     9fa:	19 f4       	brne	.+6      	; 0xa02 <irDecode+0xf4>
		{
			fanSpeed = FAN_SPEED_ABSOLUTE_MIN;	//0;	// 0-7
     9fc:	10 92 77 06 	sts	0x0677, r1
     a00:	14 c0       	rjmp	.+40     	; 0xa2a <irDecode+0x11c>
		}
		else
		{
			fanSpeed--;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     a02:	81 50       	subi	r24, 0x01	; 1
     a04:	10 c0       	rjmp	.+32     	; 0xa26 <irDecode+0x118>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
		LCD_DATA_STRING(" or ");
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
		timer1_on_speed();
	}
	else if(((irAddress == IR_REMOTE_CAR_DEVICE_RM_X157) && (irCommand == IR_REMOTE_COMMAND_RM_X157_UP)) && flagStatusBits->flagPower == 1)		// Sony TV & CarAudio IR Remote Device - "MUTE" -> ON
     a06:	23 33       	cpi	r18, 0x33	; 51
     a08:	a9 f5       	brne	.+106    	; 0xa74 <irDecode+0x166>
     a0a:	e0 91 d9 06 	lds	r30, 0x06D9
     a0e:	f0 91 da 06 	lds	r31, 0x06DA
     a12:	80 81       	ld	r24, Z
     a14:	80 ff       	sbrs	r24, 0
     a16:	2e c0       	rjmp	.+92     	; 0xa74 <irDecode+0x166>
	{	// FAN STEP DOWN
		if(fanSpeed > FAN_LIMIT_POSITIONS - 2)//7)
     a18:	80 91 77 06 	lds	r24, 0x0677
     a1c:	87 30       	cpi	r24, 0x07	; 7
     a1e:	10 f0       	brcs	.+4      	; 0xa24 <irDecode+0x116>
		{
			fanSpeed = FAN_LIMIT_POSITIONS - 1;	//7;	// 0-7
     a20:	87 e0       	ldi	r24, 0x07	; 7
     a22:	01 c0       	rjmp	.+2      	; 0xa26 <irDecode+0x118>
		}
		else
		{
			fanSpeed++;	// sabirane s polojitelno chislo, kratak zapis na: volumeIndex = volumeIndex + temp;
     a24:	8f 5f       	subi	r24, 0xFF	; 255
     a26:	80 93 77 06 	sts	0x0677, r24
		}
//		fanSpeedStep [fanSpeed];// = { 0x00, 100, 125, 150, 175, 200, 225, 250 };
		LCD_COMMAND(LCD_SELECT_4ROW);	// select row 3								// and next is update volume lcd information
     a2a:	84 ed       	ldi	r24, 0xD4	; 212
     a2c:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
		LCD_DATA_STRING("Fan Step: ");	// 20 symbols			
     a30:	83 e5       	ldi	r24, 0x53	; 83
     a32:	96 e0       	ldi	r25, 0x06	; 6
     a34:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
		LCD_DATA_INT(fanSpeed);		// 20 symbols
     a38:	80 91 77 06 	lds	r24, 0x0677
     a3c:	90 e0       	ldi	r25, 0x00	; 0
     a3e:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_DATA_INT>
		LCD_DATA_STRING(" or ");
     a42:	8e e5       	ldi	r24, 0x5E	; 94
     a44:	96 e0       	ldi	r25, 0x06	; 6
     a46:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
		LCD_DATA_INT(fanSpeedStep[fanSpeed]);
     a4a:	e0 91 77 06 	lds	r30, 0x0677
     a4e:	f0 e0       	ldi	r31, 0x00	; 0
     a50:	e8 58       	subi	r30, 0x88	; 136
     a52:	f9 4f       	sbci	r31, 0xF9	; 249
     a54:	80 81       	ld	r24, Z
     a56:	90 e0       	ldi	r25, 0x00	; 0
     a58:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <LCD_DATA_INT>
***************************************/
void timer1_on_speed(void)
{
//		ldi	r16, 0			; maskov registar za prekasvaniq
//		out	TIMSK, r16		; 
	TCCR1A = 0b10100001;	// 0b10000001;	// nastroika na 2 kanala rejim na rabota na SHIM		// 0b10100001 - OC1A,OC1B - PWM;  0b10000001 - OC1A PWM, OC1B - Disabled, normal port.
     a5c:	81 ea       	ldi	r24, 0xA1	; 161
     a5e:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0b00000001;	// 0b00010001;	// nastroika na 2 kanala rejim na rabota na SHIM i preddelitel 8
     a60:	81 e0       	ldi	r24, 0x01	; 1
     a62:	8e bd       	out	0x2e, r24	; 46

// CHANNEL A
	OCR1AH = 0;		// 0; // FAN PWM ON		// out	OCR1AH, r16		; 0   = 0b00000000 (DEC = BIN)
     a64:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = fanSpeedStep [fanSpeed];//100;	// 1; // FAN PWM ON		// out	OCR1AL, r17		; 200 = 0b11001000 (DEC = BIN)
     a66:	e0 91 77 06 	lds	r30, 0x0677
     a6a:	f0 e0       	ldi	r31, 0x00	; 0
     a6c:	e8 58       	subi	r30, 0x88	; 136
     a6e:	f9 4f       	sbci	r31, 0xF9	; 249
     a70:	80 81       	ld	r24, Z
     a72:	8a bd       	out	0x2a, r24	; 42
     a74:	80 ed       	ldi	r24, 0xD0	; 208
     a76:	97 e0       	ldi	r25, 0x07	; 7
     a78:	20 e9       	ldi	r18, 0x90	; 144
     a7a:	31 e0       	ldi	r19, 0x01	; 1
     a7c:	f9 01       	movw	r30, r18
     a7e:	31 97       	sbiw	r30, 0x01	; 1
     a80:	f1 f7       	brne	.-4      	; 0xa7e <irDecode+0x170>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     a82:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     a84:	d9 f7       	brne	.-10     	; 0xa7c <irDecode+0x16e>
	else
	{
		// DO NOTING
	}
	_delay_ms(200);
}
     a86:	08 95       	ret

00000a88 <__vector_1>:

/*****************************************
**** EXTERNAL INTERRUPT 0 VECTOR 01 ******
*****************************************/
ISR(INT0_vect)
{
     a88:	1f 92       	push	r1
     a8a:	0f 92       	push	r0
     a8c:	0f b6       	in	r0, 0x3f	; 63
     a8e:	0f 92       	push	r0
     a90:	11 24       	eor	r1, r1
     a92:	2f 93       	push	r18
     a94:	3f 93       	push	r19
     a96:	4f 93       	push	r20
     a98:	5f 93       	push	r21
     a9a:	6f 93       	push	r22
     a9c:	7f 93       	push	r23
     a9e:	8f 93       	push	r24
     aa0:	9f 93       	push	r25
     aa2:	af 93       	push	r26
     aa4:	bf 93       	push	r27
     aa6:	ef 93       	push	r30
     aa8:	ff 93       	push	r31
/*********************************
** EXTERNAL INTERRUPT 0 DISABLE **
*********************************/
void ext0_intrpt_off(void)		// Disable external interrupt 0 (PD0 - DISABLE new IR DETECTION)
{
	GICR   = 0b00000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     aaa:	1b be       	out	0x3b, r1	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     aac:	80 e4       	ldi	r24, 0x40	; 64
     aae:	8a bf       	out	0x3a, r24	; 58
	ext0_intrpt_off();	// DISABLE new IR DETECTION

// LOGIC CHECK BEGIN
// VERIFY PRESSED IR BUTTON and switch to low line of IR pin PD2
	unsigned char low_level = 0;
    if(irPin == 0)
     ab0:	82 99       	sbic	0x10, 2	; 16
     ab2:	0b c0       	rjmp	.+22     	; 0xaca <__vector_1+0x42>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     ab4:	8a e0       	ldi	r24, 0x0A	; 10
     ab6:	98 2f       	mov	r25, r24
     ab8:	9a 95       	dec	r25
     aba:	f1 f7       	brne	.-4      	; 0xab8 <__vector_1+0x30>
     abc:	98 2f       	mov	r25, r24
     abe:	9a 95       	dec	r25
     ac0:	f1 f7       	brne	.-4      	; 0xabe <__vector_1+0x36>
     ac2:	8a 95       	dec	r24
     ac4:	f1 f7       	brne	.-4      	; 0xac2 <__vector_1+0x3a>
			_delay_us(2);	//2uS delay
		}

		if(low_level == 3)
		{
			irDecode();
     ac6:	0e 94 87 04 	call	0x90e	; 0x90e <irDecode>
/********************************
** EXTERNAL INTERRUPT 0 ENABLE **
********************************/
void ext0_intrpt_on(void)		// Enable external interrupt 0 (PD0 - ENABLE new IR DETECTION)
{
	GICR   = 0b01000000;	// INT0 = 0: Disable External Interrupt on INT0; INT0 = 1: Enable External Interrupt on INT0;
     aca:	80 e4       	ldi	r24, 0x40	; 64
     acc:	8b bf       	out	0x3b, r24	; 59
	GIFR   = 0b01000000;	// Clear INT0 flag.
     ace:	8a bf       	out	0x3a, r24	; 58
		}
    }
// LOGIC CHECK END

	ext0_intrpt_on();	// ENABLE new IR DETECTION
}
     ad0:	ff 91       	pop	r31
     ad2:	ef 91       	pop	r30
     ad4:	bf 91       	pop	r27
     ad6:	af 91       	pop	r26
     ad8:	9f 91       	pop	r25
     ada:	8f 91       	pop	r24
     adc:	7f 91       	pop	r23
     ade:	6f 91       	pop	r22
     ae0:	5f 91       	pop	r21
     ae2:	4f 91       	pop	r20
     ae4:	3f 91       	pop	r19
     ae6:	2f 91       	pop	r18
     ae8:	0f 90       	pop	r0
     aea:	0f be       	out	0x3f, r0	; 63
     aec:	0f 90       	pop	r0
     aee:	1f 90       	pop	r1
     af0:	18 95       	reti

00000af2 <eeprom_24c64_read>:
	// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
	// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !
	
	byte eepromReceiveByte0, eepromReceiveByte1, eepromReceiveByte2, eepromReceiveByte3, eepromReceiveByte4, eepromReceiveByte5;
// EEPROM READ
	i2c_start();
     af2:	0e 94 87 06 	call	0xd0e	; 0xd0e <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);		// EEPROM 24C64 ADDRESS ACCESS WRITE
     af6:	80 ea       	ldi	r24, 0xA0	; 160
     af8:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     afc:	80 e0       	ldi	r24, 0x00	; 0
     afe:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b02:	80 e0       	ldi	r24, 0x00	; 0
     b04:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>

	i2c_start();
     b08:	0e 94 87 06 	call	0xd0e	; 0xd0e <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_READ);		// EEPROM 24C64 ADDRESS ACCESS READ
     b0c:	81 ea       	ldi	r24, 0xA1	; 161
     b0e:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
	eepromReceiveByte0	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b12:	80 e0       	ldi	r24, 0x00	; 0
     b14:	0e 94 97 06 	call	0xd2e	; 0xd2e <i2c_read>
	eepromReceiveByte1	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b18:	80 e0       	ldi	r24, 0x00	; 0
     b1a:	0e 94 97 06 	call	0xd2e	; 0xd2e <i2c_read>
	eepromReceiveByte2	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b1e:	80 e0       	ldi	r24, 0x00	; 0
     b20:	0e 94 97 06 	call	0xd2e	; 0xd2e <i2c_read>
	eepromReceiveByte3	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b24:	80 e0       	ldi	r24, 0x00	; 0
     b26:	0e 94 97 06 	call	0xd2e	; 0xd2e <i2c_read>
	eepromReceiveByte4	= i2c_read(0);				// EEPROM DATA READ BYTE	// i2c_read(0) parametar raven na 0 prodaljava komunikaciqta kato potvarjdava ACK
     b2a:	80 e0       	ldi	r24, 0x00	; 0
     b2c:	0e 94 97 06 	call	0xd2e	; 0xd2e <i2c_read>
	eepromReceiveByte5	= i2c_read(1);				// EEPROM DATA READ BYTE	// i2c_read(1) parametar razlichen ot 0 spira komunikaciqta NACK
     b30:	81 e0       	ldi	r24, 0x01	; 1
     b32:	0e 94 97 06 	call	0xd2e	; 0xd2e <i2c_read>
	i2c_stop();
     b36:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_stop>
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte2);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte3);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte4);
	LCD_EXECUTE_DATA_ONE(eepromReceiveByte5);
*/
}
     b3a:	08 95       	ret

00000b3c <eeprom_24c64_write>:
// Za da se vijda tova koeto se e zapisalo v pametta, a ne ot tozi bibliotechen fail !!!!!!!!!
// ZA TAZI CEL TRQBVA DA IMA UKAZATEL/MASIV KOITO DA VARNE REZULTATA OT CHETENETO NA PAMETTA
// SAMO AKO E NUJNO DA SE VIJDA KAKVO E BILO ZAPISANO !

// EEPROM WRITE
	i2c_start();
     b3c:	0e 94 87 06 	call	0xd0e	; 0xd0e <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     b40:	80 ea       	ldi	r24, 0xA0	; 160
     b42:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     b46:	80 e0       	ldi	r24, 0x00	; 0
     b48:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b4c:	80 e0       	ldi	r24, 0x00	; 0
     b4e:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
// Write data
	i2c_write(0x30);	// Data is stored: 0x30 - '0'
     b52:	80 e3       	ldi	r24, 0x30	; 48
     b54:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
	i2c_write(0x31);	// Data is stored: 0x31 - '1'
     b58:	81 e3       	ldi	r24, 0x31	; 49
     b5a:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
	i2c_write(0x32);	// Data is stored: 0x32 - '2'
     b5e:	82 e3       	ldi	r24, 0x32	; 50
     b60:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
	i2c_write(0x33);	// Data is stored: 0x33 - '3'
     b64:	83 e3       	ldi	r24, 0x33	; 51
     b66:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
	i2c_write(0x34);	// Data is stored: 0x34 - '4'
     b6a:	84 e3       	ldi	r24, 0x34	; 52
     b6c:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
	i2c_stop();
     b70:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_stop>
}
     b74:	08 95       	ret

00000b76 <eeprom_24c64_reset>:

/*************************************
** RESET AND ZERO FILL EEPROM 24C64 **
*************************************/
void eeprom_24c64_reset()
{
     b76:	cf 93       	push	r28
     b78:	df 93       	push	r29
	unsigned int i;	// 16 bits
// EEPROM WRITE
	i2c_start();
     b7a:	0e 94 87 06 	call	0xd0e	; 0xd0e <i2c_start>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
     b7e:	80 ea       	ldi	r24, 0xA0	; 160
     b80:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
     b84:	80 e0       	ldi	r24, 0x00	; 0
     b86:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
     b8a:	80 e0       	ldi	r24, 0x00	; 0
     b8c:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
     b90:	c0 e0       	ldi	r28, 0x00	; 0
     b92:	d0 e0       	ldi	r29, 0x00	; 0
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
     b94:	80 e0       	ldi	r24, 0x00	; 0
     b96:	0e 94 90 06 	call	0xd20	; 0xd20 <i2c_write>
	i2c_write(EEPROM_24C64_I2C_ADDRESS_WRITE);	// EEPROM AT24C64 ADDRESS ACCESS WRITE
// HIGH and LOW BYTE ADDRESS
	i2c_write(EEPROM_24C64_I2C_HIGH_BYTE_ADDRESS_MIN);	// HIGH STORE ADDRESS
	i2c_write(EEPROM_24C64_I2C_LOW_BYTE_ADDRESS_MIN);	// LOW  STORE ADDRESS	
// Write data
	for(i=0; i<8191; i++)	// from 0x0000 to 0x1FFF
     b9a:	21 96       	adiw	r28, 0x01	; 1
     b9c:	8f e1       	ldi	r24, 0x1F	; 31
     b9e:	cf 3f       	cpi	r28, 0xFF	; 255
     ba0:	d8 07       	cpc	r29, r24
     ba2:	c1 f7       	brne	.-16     	; 0xb94 <eeprom_24c64_reset+0x1e>
	{
		i2c_write(0b00000000);	// Data is stored: 0x00 from Address 0x00 to 0xFF
	}
	i2c_stop();
     ba4:	0e 94 8d 06 	call	0xd1a	; 0xd1a <i2c_stop>
}
     ba8:	df 91       	pop	r29
     baa:	cf 91       	pop	r28
     bac:	08 95       	ret

00000bae <reset>:
}
*/

unsigned char reset(void)
{
    DDRx |= (1<<Px);            //Ausgang
     bae:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     bb0:	c0 98       	cbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     bb2:	80 e8       	ldi	r24, 0x80	; 128
     bb4:	97 e0       	ldi	r25, 0x07	; 7
     bb6:	01 97       	sbiw	r24, 0x01	; 1
     bb8:	f1 f7       	brne	.-4      	; 0xbb6 <reset+0x8>
    _delay_us(480);
	DDRx &= ~(1<<Px);
     bba:	b8 98       	cbi	0x17, 0	; 23
     bbc:	80 e4       	ldi	r24, 0x40	; 64
     bbe:	91 e0       	ldi	r25, 0x01	; 1
     bc0:	01 97       	sbiw	r24, 0x01	; 1
     bc2:	f1 f7       	brne	.-4      	; 0xbc0 <reset+0x12>
    _delay_us(80);
	if(!(PINx & (1<<Px)))     //Prüfe Slave-Antwort
     bc4:	b0 9b       	sbis	0x16, 0	; 22
     bc6:	02 c0       	rjmp	.+4      	; 0xbcc <reset+0x1e>
     bc8:	80 e0       	ldi	r24, 0x00	; 0
     bca:	08 95       	ret
     bcc:	88 e0       	ldi	r24, 0x08	; 8
     bce:	97 e0       	ldi	r25, 0x07	; 7
     bd0:	01 97       	sbiw	r24, 0x01	; 1
     bd2:	f1 f7       	brne	.-4      	; 0xbd0 <reset+0x22>
     bd4:	81 e0       	ldi	r24, 0x01	; 1
	}
    else
	{
        return 0;
	}
}
     bd6:	08 95       	ret

00000bd8 <read_bit>:

unsigned char read_bit(void)
{
    DDRx |= (1<<Px);            //Ausgang
     bd8:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     bda:	c0 98       	cbi	0x18, 0	; 24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     bdc:	85 e0       	ldi	r24, 0x05	; 5
     bde:	8a 95       	dec	r24
     be0:	f1 f7       	brne	.-4      	; 0xbde <read_bit+0x6>
    _delay_us(1);
	DDRx &= ~(1<<Px);
     be2:	b8 98       	cbi	0x17, 0	; 23
     be4:	80 e4       	ldi	r24, 0x40	; 64
     be6:	8a 95       	dec	r24
     be8:	f1 f7       	brne	.-4      	; 0xbe6 <read_bit+0xe>
    _delay_us(12);
    if(!(PINx & (1<<Px)))       //Abtastung innerhalb von 15µs
     bea:	86 b3       	in	r24, 0x16	; 22
	}
	else
    {
		return 1;
	}
}
     bec:	81 70       	andi	r24, 0x01	; 1
     bee:	08 95       	ret

00000bf0 <write_bit>:

void write_bit(unsigned char bitval)    //kann 0 oder 1 sein
{
    DDRx |= (1<<Px);            //Ausgang
     bf0:	b8 9a       	sbi	0x17, 0	; 23
	PORTx &= ~(1<<Px);
     bf2:	c0 98       	cbi	0x18, 0	; 24
    if(bitval)
     bf4:	81 11       	cpse	r24, r1
	{
        PORTx |= (1<<Px);      //H-Pegel
     bf6:	c0 9a       	sbi	0x18, 0	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     bf8:	88 eb       	ldi	r24, 0xB8	; 184
     bfa:	91 e0       	ldi	r25, 0x01	; 1
     bfc:	01 97       	sbiw	r24, 0x01	; 1
     bfe:	f1 f7       	brne	.-4      	; 0xbfc <write_bit+0xc>
    }
	_delay_us(110);        
    DDRx &= ~(1<<Px);
     c00:	b8 98       	cbi	0x17, 0	; 23
    PORTx &= ~(1<<Px);
     c02:	c0 98       	cbi	0x18, 0	; 24
}
     c04:	08 95       	ret

00000c06 <read_byte>:

unsigned char read_byte(void)
{
     c06:	cf 92       	push	r12
     c08:	df 92       	push	r13
     c0a:	ef 92       	push	r14
     c0c:	ff 92       	push	r15
     c0e:	1f 93       	push	r17
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	10 e0       	ldi	r17, 0x00	; 0
     c16:	c0 e0       	ldi	r28, 0x00	; 0
     c18:	d0 e0       	ldi	r29, 0x00	; 0
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
		{
            byte |= (1<<i);
     c1a:	91 e0       	ldi	r25, 0x01	; 1
     c1c:	c9 2e       	mov	r12, r25
     c1e:	d1 2c       	mov	r13, r1
     c20:	80 ee       	ldi	r24, 0xE0	; 224
     c22:	e8 2e       	mov	r14, r24
     c24:	81 e0       	ldi	r24, 0x01	; 1
     c26:	f8 2e       	mov	r15, r24
unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
	{
        if(read_bit ())
     c28:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <read_bit>
     c2c:	88 23       	and	r24, r24
     c2e:	41 f0       	breq	.+16     	; 0xc40 <read_byte+0x3a>
		{
            byte |= (1<<i);
     c30:	c6 01       	movw	r24, r12
     c32:	0c 2e       	mov	r0, r28
     c34:	02 c0       	rjmp	.+4      	; 0xc3a <read_byte+0x34>
     c36:	88 0f       	add	r24, r24
     c38:	99 1f       	adc	r25, r25
     c3a:	0a 94       	dec	r0
     c3c:	e2 f7       	brpl	.-8      	; 0xc36 <read_byte+0x30>
     c3e:	18 2b       	or	r17, r24
     c40:	c7 01       	movw	r24, r14
     c42:	01 97       	sbiw	r24, 0x01	; 1
     c44:	f1 f7       	brne	.-4      	; 0xc42 <read_byte+0x3c>
     c46:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char read_byte(void)
{
    unsigned char byte = 0;
    for(unsigned char i=0; i<8; i++)
     c48:	c8 30       	cpi	r28, 0x08	; 8
     c4a:	d1 05       	cpc	r29, r1
     c4c:	69 f7       	brne	.-38     	; 0xc28 <read_byte+0x22>
            byte |= (1<<i);
		}
        _delay_us(120);
    }
    return byte;
}
     c4e:	81 2f       	mov	r24, r17
     c50:	df 91       	pop	r29
     c52:	cf 91       	pop	r28
     c54:	1f 91       	pop	r17
     c56:	ff 90       	pop	r15
     c58:	ef 90       	pop	r14
     c5a:	df 90       	pop	r13
     c5c:	cf 90       	pop	r12
     c5e:	08 95       	ret

00000c60 <write_byte>:

void write_byte(unsigned char byte)
{
     c60:	0f 93       	push	r16
     c62:	1f 93       	push	r17
     c64:	cf 93       	push	r28
     c66:	df 93       	push	r29
     c68:	c0 e0       	ldi	r28, 0x00	; 0
     c6a:	d0 e0       	ldi	r29, 0x00	; 0
    for(unsigned char i=0; i<8; i++)
	{
        if(byte & (1<<i))
     c6c:	08 2f       	mov	r16, r24
     c6e:	10 e0       	ldi	r17, 0x00	; 0
     c70:	c8 01       	movw	r24, r16
     c72:	0c 2e       	mov	r0, r28
     c74:	02 c0       	rjmp	.+4      	; 0xc7a <write_byte+0x1a>
     c76:	95 95       	asr	r25
     c78:	87 95       	ror	r24
     c7a:	0a 94       	dec	r0
     c7c:	e2 f7       	brpl	.-8      	; 0xc76 <write_byte+0x16>
     c7e:	80 ff       	sbrs	r24, 0
     c80:	02 c0       	rjmp	.+4      	; 0xc86 <write_byte+0x26>
		{
			write_bit(1);
     c82:	81 e0       	ldi	r24, 0x01	; 1
     c84:	01 c0       	rjmp	.+2      	; 0xc88 <write_byte+0x28>
		}
        else
		{
            write_bit(0);
     c86:	80 e0       	ldi	r24, 0x00	; 0
     c88:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <write_bit>
     c8c:	21 96       	adiw	r28, 0x01	; 1
    return byte;
}

void write_byte(unsigned char byte)
{
    for(unsigned char i=0; i<8; i++)
     c8e:	c8 30       	cpi	r28, 0x08	; 8
     c90:	d1 05       	cpc	r29, r1
     c92:	71 f7       	brne	.-36     	; 0xc70 <write_byte+0x10>
     c94:	80 ee       	ldi	r24, 0xE0	; 224
     c96:	91 e0       	ldi	r25, 0x01	; 1
     c98:	01 97       	sbiw	r24, 0x01	; 1
     c9a:	f1 f7       	brne	.-4      	; 0xc98 <write_byte+0x38>
		{
            write_bit(0);
		}
	}
    _delay_us(120);
}  
     c9c:	df 91       	pop	r29
     c9e:	cf 91       	pop	r28
     ca0:	1f 91       	pop	r17
     ca2:	0f 91       	pop	r16
     ca4:	08 95       	ret

00000ca6 <wait_ready>:
	return 0;
}

void wait_ready(void)
{
	while(!(read_bit()));
     ca6:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <read_bit>
     caa:	88 23       	and	r24, r24
     cac:	e1 f3       	breq	.-8      	; 0xca6 <wait_ready>
}
     cae:	08 95       	ret

00000cb0 <read_scratchpad>:
	}
    _delay_us(120);
}  

unsigned char read_scratchpad(void)
{
     cb0:	cf 93       	push	r28
     cb2:	df 93       	push	r29

	if(reset())
     cb4:	0e 94 d7 05 	call	0xbae	; 0xbae <reset>
     cb8:	88 23       	and	r24, r24
     cba:	e9 f0       	breq	.+58     	; 0xcf6 <read_scratchpad+0x46>
	{
		write_byte(0xCC);
     cbc:	8c ec       	ldi	r24, 0xCC	; 204
     cbe:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		write_byte(0x44);
     cc2:	84 e4       	ldi	r24, 0x44	; 68
     cc4:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
		wait_ready();
     cc8:	0e 94 53 06 	call	0xca6	; 0xca6 <wait_ready>
		if(reset())
     ccc:	0e 94 d7 05 	call	0xbae	; 0xbae <reset>
     cd0:	88 23       	and	r24, r24
     cd2:	89 f0       	breq	.+34     	; 0xcf6 <read_scratchpad+0x46>
		{
			write_byte(0xCC);
     cd4:	8c ec       	ldi	r24, 0xCC	; 204
     cd6:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
			write_byte(0xBE);
     cda:	8e eb       	ldi	r24, 0xBE	; 190
     cdc:	0e 94 30 06 	call	0xc60	; 0xc60 <write_byte>
     ce0:	c9 ec       	ldi	r28, 0xC9	; 201
     ce2:	d6 e0       	ldi	r29, 0x06	; 6
			for(unsigned char i=0; i<9; i++)
			{
				scratchpad [i] = read_byte();
     ce4:	0e 94 03 06 	call	0xc06	; 0xc06 <read_byte>
     ce8:	89 93       	st	Y+, r24
		wait_ready();
		if(reset())
		{
			write_byte(0xCC);
			write_byte(0xBE);
			for(unsigned char i=0; i<9; i++)
     cea:	86 e0       	ldi	r24, 0x06	; 6
     cec:	c2 3d       	cpi	r28, 0xD2	; 210
     cee:	d8 07       	cpc	r29, r24
     cf0:	c9 f7       	brne	.-14     	; 0xce4 <read_scratchpad+0x34>
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	01 c0       	rjmp	.+2      	; 0xcf8 <read_scratchpad+0x48>
     cf6:	80 e0       	ldi	r24, 0x00	; 0
			}
			return 1;
		}
	}
	return 0;
}
     cf8:	df 91       	pop	r29
     cfa:	cf 91       	pop	r28
     cfc:	08 95       	ret

00000cfe <i2c_init>:
|== TWPS = 1 => (4^TWPS)= 4  // TWSR = (0<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx01 => TWSR = 1 (DEC) => 4^1 =  4 =|
|== TWPS = 2 => (4^TWPS)=16  // TWSR = (1<<TWPS1)|(0<<TWPS0) => TWSR = 0bxxxxxx10 => TWSR = 2 (DEC) => 4^2 = 16 =|
|== TWPS = 3 => (4^TWPS)=64  // TWSR = (1<<TWPS1)|(1<<TWPS0) => TWSR = 0bxxxxxx11 => TWSR = 3 (DEC) => 4^3 = 64 =|
|===============================================================================================================*/

	TWBR = 0b00010010;	// HEX=0x12	or DEC=18	// FCPU = 16 000 000 |-> SCL = 16000000 / (16+(2*TWBR*(4^TWPS)) = 16000000 / (16+(2*18*(4))) = 16000000 / 160 = 100 000 Hz = 100 kHz
     cfe:	82 e1       	ldi	r24, 0x12	; 18
     d00:	80 b9       	out	0x00, r24	; 0
	TWSR = (0<<TWPS1)|(1<<TWPS0);	// SCL = 16 000 000 / 64  = 250 000 = 250kHz
     d02:	81 e0       	ldi	r24, 0x01	; 1
     d04:	81 b9       	out	0x01, r24	; 1
	TWCR = (1<<TWEN);	//	TWCR = 0x04; // TWCR = (x<<TWINT)|(x<<TWEA)|(x<<TWSTA)|(x<<TWSTO)|(x<<TWEN)|(x<<TWIE);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz
     d06:	84 e0       	ldi	r24, 0x04	; 4
     d08:	86 bf       	out	0x36, r24	; 54
	TWDR = 0b00000000;
     d0a:	13 b8       	out	0x03, r1	; 3
}
     d0c:	08 95       	ret

00000d0e <i2c_start>:
/*****************************************
** START CONDITION OF I2C COMMUNICATION **
*****************************************/
void i2c_start(void)
{
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     d0e:	84 ea       	ldi	r24, 0xA4	; 164
     d10:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     d12:	06 b6       	in	r0, 0x36	; 54
     d14:	07 fe       	sbrs	r0, 7
     d16:	fd cf       	rjmp	.-6      	; 0xd12 <i2c_start+0x4>
	{
	}
}
     d18:	08 95       	ret

00000d1a <i2c_stop>:
/****************************************
** STOP CONDITION OF I2C COMMUNICATION **
****************************************/
void i2c_stop()
{
	TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     d1a:	84 e9       	ldi	r24, 0x94	; 148
     d1c:	86 bf       	out	0x36, r24	; 54
}
     d1e:	08 95       	ret

00000d20 <i2c_write>:
/*******************************************
** WRITE/SEND 1 BYTE OF I2C COMMUNICATION **
*******************************************/
void i2c_write(unsigned char data)
{
	TWDR = data;
     d20:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT)|(1<<TWEN);
     d22:	84 e8       	ldi	r24, 0x84	; 132
     d24:	86 bf       	out	0x36, r24	; 54
	while((TWCR & (1<<TWINT)) == 0)
     d26:	06 b6       	in	r0, 0x36	; 54
     d28:	07 fe       	sbrs	r0, 7
     d2a:	fd cf       	rjmp	.-6      	; 0xd26 <i2c_write+0x6>
	{
	}
}
     d2c:	08 95       	ret

00000d2e <i2c_read>:
/**********************************************
** READ/RECEIVE BYTE(S) OF I2C COMMUNICATION **
**********************************************/
unsigned char i2c_read(unsigned char isLast)
{
	if(isLast == 0 )
     d2e:	88 23       	and	r24, r24
     d30:	11 f4       	brne	.+4      	; 0xd36 <i2c_read+0x8>
	{
		TWCR = (1<<TWINT)|(1<<TWEA)|(1<<TWEN);	// to next receive byte
     d32:	84 ec       	ldi	r24, 0xC4	; 196
     d34:	01 c0       	rjmp	.+2      	; 0xd38 <i2c_read+0xa>
	}
	else
	{
		TWCR = (1<<TWINT)|(1<<TWEN);			// to end of communication
     d36:	84 e8       	ldi	r24, 0x84	; 132
     d38:	86 bf       	out	0x36, r24	; 54
	}
	
	while((TWCR & (1<<TWINT)) == 0)
     d3a:	06 b6       	in	r0, 0x36	; 54
     d3c:	07 fe       	sbrs	r0, 7
     d3e:	fd cf       	rjmp	.-6      	; 0xd3a <i2c_read+0xc>
	{
	}
	return TWDR;
     d40:	83 b1       	in	r24, 0x03	; 3
}
     d42:	08 95       	ret

00000d44 <LCD_EXECUTE_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_EXECUTE_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     d44:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     d46:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     d48:	87 ff       	sbrs	r24, 7
     d4a:	02 c0       	rjmp	.+4      	; 0xd50 <LCD_EXECUTE_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     d4c:	d8 9a       	sbi	0x1b, 0	; 27
     d4e:	01 c0       	rjmp	.+2      	; 0xd52 <LCD_EXECUTE_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     d50:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     d52:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     d54:	9f 5f       	subi	r25, 0xFF	; 255
     d56:	98 30       	cpi	r25, 0x08	; 8
     d58:	11 f0       	breq	.+4      	; 0xd5e <LCD_EXECUTE_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     d5a:	88 0f       	add	r24, r24
     d5c:	f4 cf       	rjmp	.-24     	; 0xd46 <LCD_EXECUTE_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     d5e:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     d60:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     d62:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     d64:	da 98       	cbi	0x1b, 2	; 27
     d66:	88 ea       	ldi	r24, 0xA8	; 168
     d68:	92 e0       	ldi	r25, 0x02	; 2
     d6a:	fc 01       	movw	r30, r24
     d6c:	31 97       	sbiw	r30, 0x01	; 1
     d6e:	f1 f7       	brne	.-4      	; 0xd6c <LCD_EXECUTE_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     d70:	da 9a       	sbi	0x1b, 2	; 27
     d72:	01 97       	sbiw	r24, 0x01	; 1
     d74:	f1 f7       	brne	.-4      	; 0xd72 <LCD_EXECUTE_COMMAND+0x2e>
	LCD_REGSELECT_low();	// RS = 0
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);			//rcall 180 us
*/
	LCD_ENABLE_low();		// EN = 0
     d76:	db 98       	cbi	0x1b, 3	; 27
     d78:	80 e9       	ldi	r24, 0x90	; 144
     d7a:	91 e0       	ldi	r25, 0x01	; 1
     d7c:	01 97       	sbiw	r24, 0x01	; 1
     d7e:	f1 f7       	brne	.-4      	; 0xd7c <LCD_EXECUTE_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us

}
     d80:	08 95       	ret

00000d82 <LCD_EXECUTE_DATA>:

/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
     d82:	cf 93       	push	r28
     d84:	df 93       	push	r29
     d86:	40 e0       	ldi	r20, 0x00	; 0
     d88:	50 e0       	ldi	r21, 0x00	; 0
     d8a:	a8 ea       	ldi	r26, 0xA8	; 168
     d8c:	b2 e0       	ldi	r27, 0x02	; 2
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];
     d8e:	c0 e9       	ldi	r28, 0x90	; 144
     d90:	d1 e0       	ldi	r29, 0x01	; 1
     d92:	22 c0       	rjmp	.+68     	; 0xdd8 <LCD_EXECUTE_DATA+0x56>
     d94:	fc 01       	movw	r30, r24
     d96:	e4 0f       	add	r30, r20
     d98:	f5 1f       	adc	r31, r21
     d9a:	e0 81       	ld	r30, Z
     d9c:	20 e0       	ldi	r18, 0x00	; 0

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     d9e:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     da0:	e7 ff       	sbrs	r30, 7
     da2:	02 c0       	rjmp	.+4      	; 0xda8 <LCD_EXECUTE_DATA+0x26>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     da4:	d8 9a       	sbi	0x1b, 0	; 27
     da6:	01 c0       	rjmp	.+2      	; 0xdaa <LCD_EXECUTE_DATA+0x28>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     da8:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     daa:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = data[count_ns];

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     dac:	2f 5f       	subi	r18, 0xFF	; 255
     dae:	28 30       	cpi	r18, 0x08	; 8
     db0:	11 f0       	breq	.+4      	; 0xdb6 <LCD_EXECUTE_DATA+0x34>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     db2:	ee 0f       	add	r30, r30
     db4:	f4 cf       	rjmp	.-24     	; 0xd9e <LCD_EXECUTE_DATA+0x1c>
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     db6:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     db8:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     dba:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     dbc:	da 98       	cbi	0x1b, 2	; 27
     dbe:	fd 01       	movw	r30, r26
     dc0:	31 97       	sbiw	r30, 0x01	; 1
     dc2:	f1 f7       	brne	.-4      	; 0xdc0 <LCD_EXECUTE_DATA+0x3e>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     dc4:	da 9a       	sbi	0x1b, 2	; 27
     dc6:	fd 01       	movw	r30, r26
     dc8:	31 97       	sbiw	r30, 0x01	; 1
     dca:	f1 f7       	brne	.-4      	; 0xdc8 <LCD_EXECUTE_DATA+0x46>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     dcc:	db 98       	cbi	0x1b, 3	; 27
     dce:	fe 01       	movw	r30, r28
     dd0:	31 97       	sbiw	r30, 0x01	; 1
     dd2:	f1 f7       	brne	.-4      	; 0xdd0 <LCD_EXECUTE_DATA+0x4e>
/**************************************************
** WRITE/TRANSMIT MORE DATA BYTES TO LCD DISPLAY **
**************************************************/
void LCD_EXECUTE_DATA(char data [], int numsymbols)	// HELP: LCD_EXECUTE_DATA(char masive_of_byte_symbols, int number_of_masive_byte_symbols) // LCD shift left out, msb is first
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols+1 -> za string ima nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
     dd4:	4f 5f       	subi	r20, 0xFF	; 255
     dd6:	5f 4f       	sbci	r21, 0xFF	; 255
     dd8:	46 17       	cp	r20, r22
     dda:	57 07       	cpc	r21, r23
     ddc:	dc f2       	brlt	.-74     	; 0xd94 <LCD_EXECUTE_DATA+0x12>
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}

//	LCD_EXECUTE_DATA_LAST();	// flush -> posleden simvol ili gore v cikala count_ns < numsymbols+1 ili count_ns <= numsymbols
}
     dde:	df 91       	pop	r29
     de0:	cf 91       	pop	r28
     de2:	08 95       	ret

00000de4 <LCD_EXECUTE_DATA_ONE>:

/************************************************
** WRITE/TRANSMIT ONE DATA BYTE TO LCD DISPLAY **
************************************************/
void LCD_EXECUTE_DATA_ONE(unsigned char data)	// HELP: LCD_EXECUTE_DATA(unsigned char data_byte_symbols) // LCD shift left out, msb is first
{
     de4:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     de6:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     de8:	87 ff       	sbrs	r24, 7
     dea:	02 c0       	rjmp	.+4      	; 0xdf0 <LCD_EXECUTE_DATA_ONE+0xc>
		{
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     dec:	d8 9a       	sbi	0x1b, 0	; 27
     dee:	01 c0       	rjmp	.+2      	; 0xdf2 <LCD_EXECUTE_DATA_ONE+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     df0:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     df2:	d9 9a       	sbi	0x1b, 1	; 27
{
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = data;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     df4:	9f 5f       	subi	r25, 0xFF	; 255
     df6:	98 30       	cpi	r25, 0x08	; 8
     df8:	11 f0       	breq	.+4      	; 0xdfe <LCD_EXECUTE_DATA_ONE+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     dfa:	88 0f       	add	r24, r24
     dfc:	f4 cf       	rjmp	.-24     	; 0xde6 <LCD_EXECUTE_DATA_ONE+0x2>
	}
//update from down comment
	LCD_REGSELECT_high();	// RS = 1
     dfe:	dd 9a       	sbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     e00:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     e02:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment

	LCD_RCK_low();
     e04:	da 98       	cbi	0x1b, 2	; 27
     e06:	88 ea       	ldi	r24, 0xA8	; 168
     e08:	92 e0       	ldi	r25, 0x02	; 2
     e0a:	fc 01       	movw	r30, r24
     e0c:	31 97       	sbiw	r30, 0x01	; 1
     e0e:	f1 f7       	brne	.-4      	; 0xe0c <LCD_EXECUTE_DATA_ONE+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     e10:	da 9a       	sbi	0x1b, 2	; 27
     e12:	01 97       	sbiw	r24, 0x01	; 1
     e14:	f1 f7       	brne	.-4      	; 0xe12 <LCD_EXECUTE_DATA_ONE+0x2e>
	LCD_REGSELECT_high();	// RS = 1
	LCD_READWRITE_low();	// RW = 0
	LCD_ENABLE_high();		// EN = 1
	_delay_us(100);
*/
	LCD_ENABLE_low();		// EN = 0
     e16:	db 98       	cbi	0x1b, 3	; 27
     e18:	80 e9       	ldi	r24, 0x90	; 144
     e1a:	91 e0       	ldi	r25, 0x01	; 1
     e1c:	01 97       	sbiw	r24, 0x01	; 1
     e1e:	f1 f7       	brne	.-4      	; 0xe1c <LCD_EXECUTE_DATA_ONE+0x38>
	_delay_us(100);
}
     e20:	08 95       	ret

00000e22 <LCD_EXECUTE_DATA_LAST>:
/*****************************************************************************
** WRITE/TRANSMIT LAST DATA BYTE TO LCD DISPLAY AND FLUSH SN74HC595 BUFFER  **
*****************************************************************************/
void LCD_EXECUTE_DATA_LAST()	// flush -> izchistvane na bufer - prinuditelno izpisvane na posleden simvol
{
	LCD_ENABLE_low();
     e22:	db 98       	cbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     e24:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     e26:	dd 9a       	sbi	0x1b, 5	; 27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     e28:	85 ed       	ldi	r24, 0xD5	; 213
     e2a:	98 2f       	mov	r25, r24
     e2c:	9a 95       	dec	r25
     e2e:	f1 f7       	brne	.-4      	; 0xe2c <LCD_EXECUTE_DATA_LAST+0xa>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
	LCD_ENABLE_high();
     e30:	db 9a       	sbi	0x1b, 3	; 27
	LCD_READWRITE_low();
     e32:	dc 98       	cbi	0x1b, 4	; 27
	LCD_REGSELECT_high();
     e34:	dd 9a       	sbi	0x1b, 5	; 27
     e36:	8a 95       	dec	r24
     e38:	f1 f7       	brne	.-4      	; 0xe36 <LCD_EXECUTE_DATA_LAST+0x14>
	_delay_us(40);				// from 100 or 180 //rcall 180 us
}
     e3a:	08 95       	ret

00000e3c <LCD_COMMAND>:

/******************************************
** WRITE/TRANSMIT COMMAND TO LCD DISPLAY **
******************************************/
void LCD_COMMAND(unsigned char command)	// HELP: LCD_EXECUTE_COMMAND(unsigned char byte_choose_a_command) // LCD shift left out, msb is first
{
     e3c:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		LCD_SCK_low();
     e3e:	d9 98       	cbi	0x1b, 1	; 27

		if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     e40:	87 ff       	sbrs	r24, 7
     e42:	02 c0       	rjmp	.+4      	; 0xe48 <LCD_COMMAND+0xc>
		{	
			LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     e44:	d8 9a       	sbi	0x1b, 0	; 27
     e46:	01 c0       	rjmp	.+2      	; 0xe4a <LCD_COMMAND+0xe>
		}
		else
		{
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
     e48:	d8 98       	cbi	0x1b, 0	; 27
		}

		LCD_SCK_high();		
     e4a:	d9 9a       	sbi	0x1b, 1	; 27
	unsigned char conbyte = command;
	unsigned char storeMSB;
	unsigned char x;
	storeMSB = conbyte;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     e4c:	9f 5f       	subi	r25, 0xFF	; 255
     e4e:	98 30       	cpi	r25, 0x08	; 8
     e50:	11 f0       	breq	.+4      	; 0xe56 <LCD_COMMAND+0x1a>
			LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);	
		}

		LCD_SCK_high();		

		storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     e52:	88 0f       	add	r24, r24
     e54:	f4 cf       	rjmp	.-24     	; 0xe3e <LCD_COMMAND+0x2>
	}
//update from down comment
	LCD_REGSELECT_low();	// RS = 0
     e56:	dd 98       	cbi	0x1b, 5	; 27
	LCD_READWRITE_low();	// RW = 0
     e58:	dc 98       	cbi	0x1b, 4	; 27
	LCD_ENABLE_high();		// EN = 1
     e5a:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
	LCD_RCK_low();
     e5c:	da 98       	cbi	0x1b, 2	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     e5e:	88 ea       	ldi	r24, 0xA8	; 168
     e60:	92 e0       	ldi	r25, 0x02	; 2
     e62:	fc 01       	movw	r30, r24
     e64:	31 97       	sbiw	r30, 0x01	; 1
     e66:	f1 f7       	brne	.-4      	; 0xe64 <LCD_COMMAND+0x28>
	_delay_us(170);			//rcall 180 us
	LCD_RCK_high();
     e68:	da 9a       	sbi	0x1b, 2	; 27
     e6a:	01 97       	sbiw	r24, 0x01	; 1
     e6c:	f1 f7       	brne	.-4      	; 0xe6a <LCD_COMMAND+0x2e>
	_delay_us(170);			//rcall 180 us

	LCD_ENABLE_low();		// EN = 0
     e6e:	db 98       	cbi	0x1b, 3	; 27
     e70:	80 e9       	ldi	r24, 0x90	; 144
     e72:	91 e0       	ldi	r25, 0x01	; 1
     e74:	01 97       	sbiw	r24, 0x01	; 1
     e76:	f1 f7       	brne	.-4      	; 0xe74 <LCD_COMMAND+0x38>
	_delay_us(100);			//rcall 180 us
}
     e78:	08 95       	ret

00000e7a <LCD_CLEAR_CONTAIN>:
/**************************************
** CLEAR ALL CONTAINS ON LCD DISPLAY **
**************************************/
void LCD_CLEAR_CONTAIN()
{
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 1. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     e7a:	81 e0       	ldi	r24, 0x01	; 1
     e7c:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
     e80:	80 ec       	ldi	r24, 0xC0	; 192
     e82:	92 e1       	ldi	r25, 0x12	; 18
     e84:	01 97       	sbiw	r24, 0x01	; 1
     e86:	f1 f7       	brne	.-4      	; 0xe84 <LCD_CLEAR_CONTAIN+0xa>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
}
     e88:	08 95       	ret

00000e8a <LCD_INIT>:
/**********************************
** INITIZLIZATION OF LCD DISPLAY **
**********************************/
void LCD_INIT()
{
	LCD_COMMAND(LCD_8BIT_2ROWS_FONT5X7);		// 0b00111000	// 1. Function set: 8-bit interface data (DL = 1), 2-line display (N = 1), 5 x 7 dot character font (F = 0)
     e8a:	88 e3       	ldi	r24, 0x38	; 56
     e8c:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_ENTRY_MODE_INC_NOSHIFT);	// 0b00000110	// 2. Entry mode set: Increment by 1 (I/D = 1), No shift (S = 0)
     e90:	86 e0       	ldi	r24, 0x06	; 6
     e92:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_MOVE_FIRST);								// 3.
     e96:	82 e0       	ldi	r24, 0x02	; 2
     e98:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
//	_delay_us(40);	// 37 uS	// comment for simulation
	LCD_COMMAND(LCD_CLEAR);						// 0b00000001	// 4. Display clear; // !!! ... from old code LCD_CLEAR can't be first command !!!
     e9c:	81 e0       	ldi	r24, 0x01	; 1
     e9e:	0e 94 1e 07 	call	0xe3c	; 0xe3c <LCD_COMMAND>
     ea2:	80 ec       	ldi	r24, 0xC0	; 192
     ea4:	92 e1       	ldi	r25, 0x12	; 18
     ea6:	01 97       	sbiw	r24, 0x01	; 1
     ea8:	f1 f7       	brne	.-4      	; 0xea6 <LCD_INIT+0x1c>
	_delay_us(1200);	// 1.53 mS	or use this _delay_ms(2); LCD_EXECUTE_COMMAND() = 440us, 440+1200 = 1640 uS
//	LCD_COMMAND(LCD_ON_BLINK_CURSOR);			// 0b00001111	// 5. Display on/off control: Display on (D = 1), Cursor on (C = 1), Blinking on (B = 1)
//	_delay_us(40);	// 37 uS	// comment for simulation
//	LCD_COMMAND(LCD_OFF);										// 5. Display off
}
     eaa:	08 95       	ret

00000eac <LCD_DATA_STRING>:

/*********************************************************
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
     eac:	fc 01       	movw	r30, r24
     eae:	28 ea       	ldi	r18, 0xA8	; 168
     eb0:	32 e0       	ldi	r19, 0x02	; 2
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     eb2:	40 e9       	ldi	r20, 0x90	; 144
     eb4:	51 e0       	ldi	r21, 0x01	; 1
     eb6:	1d c0       	rjmp	.+58     	; 0xef2 <LCD_DATA_STRING+0x46>
     eb8:	90 e0       	ldi	r25, 0x00	; 0
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
		{
			LCD_SCK_low();
     eba:	d9 98       	cbi	0x1b, 1	; 27

			if(storeMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
     ebc:	87 ff       	sbrs	r24, 7
     ebe:	02 c0       	rjmp	.+4      	; 0xec4 <LCD_DATA_STRING+0x18>
			{
				LCD_SDI_high();	// izvejdane na log "1" v MSB	// PORTA |= (1<<LCD_SDI_PIN);
     ec0:	d8 9a       	sbi	0x1b, 0	; 27
     ec2:	01 c0       	rjmp	.+2      	; 0xec6 <LCD_DATA_STRING+0x1a>
			}
			else
			{
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
     ec4:	d8 98       	cbi	0x1b, 0	; 27
			}

			LCD_SCK_high();		
     ec6:	d9 9a       	sbi	0x1b, 1	; 27
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;

		for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
     ec8:	9f 5f       	subi	r25, 0xFF	; 255
     eca:	98 30       	cpi	r25, 0x08	; 8
     ecc:	11 f0       	breq	.+4      	; 0xed2 <LCD_DATA_STRING+0x26>
				LCD_SDI_low();	// izvejdane na log "0" v MSB	// PORTA &= ~(1<<LCD_SDI_PIN);
			}

			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
     ece:	88 0f       	add	r24, r24
     ed0:	f4 cf       	rjmp	.-24     	; 0xeba <LCD_DATA_STRING+0xe>
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
	{
		unsigned char storeMSB;
		unsigned char x;
		storeMSB = *data++;
     ed2:	31 96       	adiw	r30, 0x01	; 1
			LCD_SCK_high();		

			storeMSB = storeMSB << 1;	// shiftvane na << nalqvo
		}
//update from down comment
		LCD_REGSELECT_high();	// RS = 1
     ed4:	dd 9a       	sbi	0x1b, 5	; 27
		LCD_READWRITE_low();	// RW = 0
     ed6:	dc 98       	cbi	0x1b, 4	; 27
		LCD_ENABLE_high();		// EN = 1
     ed8:	db 9a       	sbi	0x1b, 3	; 27
//update from down comment
		LCD_RCK_low();
     eda:	da 98       	cbi	0x1b, 2	; 27
     edc:	c9 01       	movw	r24, r18
     ede:	01 97       	sbiw	r24, 0x01	; 1
     ee0:	f1 f7       	brne	.-4      	; 0xede <LCD_DATA_STRING+0x32>
		_delay_us(170);			//rcall 180 us
		LCD_RCK_high();
     ee2:	da 9a       	sbi	0x1b, 2	; 27
     ee4:	c9 01       	movw	r24, r18
     ee6:	01 97       	sbiw	r24, 0x01	; 1
     ee8:	f1 f7       	brne	.-4      	; 0xee6 <LCD_DATA_STRING+0x3a>
		LCD_REGSELECT_high();	// RS = 1
		LCD_READWRITE_low();	// RW = 0
		LCD_ENABLE_high();		// EN = 1
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
     eea:	db 98       	cbi	0x1b, 3	; 27
     eec:	ca 01       	movw	r24, r20
     eee:	01 97       	sbiw	r24, 0x01	; 1
     ef0:	f1 f7       	brne	.-4      	; 0xeee <LCD_DATA_STRING+0x42>
** WRITE/TRANSMIT MORE DATA STRING BYTES TO LCD DISPLAY **
*********************************************************/
void LCD_DATA_STRING(char *data)
{
// USE THIS: char symbols [] = "PESHO"; lcdExecuteDataString(symbols);
	while(*data)// != '\0')	// is there or isn't there ?? String Terminator last charachter '\0'
     ef2:	80 81       	ld	r24, Z
     ef4:	88 23       	and	r24, r24
     ef6:	01 f7       	brne	.-64     	; 0xeb8 <LCD_DATA_STRING+0xc>
		_delay_us(100);
*/
		LCD_ENABLE_low();		// EN = 0
		_delay_us(100);
	}
}
     ef8:	08 95       	ret

00000efa <LCD_CGRAM_CUSTOM_SYMBOLS>:
	 { 0x0E, 0x1B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F },	// Battery Charging  80%	// addr40-47
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
     efa:	cf 93       	push	r28
     efc:	df 93       	push	r29
	for(rows=0; rows<7; rows++)
     efe:	10 92 e4 06 	sts	0x06E4, r1
     f02:	10 92 e3 06 	sts	0x06E3, r1
     f06:	25 c0       	rjmp	.+74     	; 0xf52 <LCD_CGRAM_CUSTOM_SYMBOLS+0x58>
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
     f08:	08 96       	adiw	r24, 0x08	; 8
     f0a:	88 0f       	add	r24, r24
     f0c:	88 0f       	add	r24, r24
     f0e:	88 0f       	add	r24, r24
     f10:	0e 94 a2 06 	call	0xd44	; 0xd44 <LCD_EXECUTE_COMMAND>
     f14:	c0 e0       	ldi	r28, 0x00	; 0
     f16:	d0 e0       	ldi	r29, 0x00	; 0
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
     f18:	e0 91 e3 06 	lds	r30, 0x06E3
     f1c:	f0 91 e4 06 	lds	r31, 0x06E4
     f20:	83 e0       	ldi	r24, 0x03	; 3
     f22:	ee 0f       	add	r30, r30
     f24:	ff 1f       	adc	r31, r31
     f26:	8a 95       	dec	r24
     f28:	e1 f7       	brne	.-8      	; 0xf22 <LCD_CGRAM_CUSTOM_SYMBOLS+0x28>
     f2a:	ec 0f       	add	r30, r28
     f2c:	fd 1f       	adc	r31, r29
     f2e:	e0 58       	subi	r30, 0x80	; 128
     f30:	f9 4f       	sbci	r31, 0xF9	; 249
     f32:	80 81       	ld	r24, Z
     f34:	0e 94 f2 06 	call	0xde4	; 0xde4 <LCD_EXECUTE_DATA_ONE>
void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
	{
		LCD_EXECUTE_COMMAND(LCD_CGRAM_STORE_ADDR_CHAR0+(rows*LCD_CGRAM_SYMBOL_CONTAIN_8BYTES));	// 0x40 = 0b0100000 SET CGRAM BASE 0 ADDRESS and OFFSET ADDRESS TO NEXT CHARACTER (LCD_CGRAM_STORE_ADDR_CHAR0+(row*8))
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
     f38:	21 96       	adiw	r28, 0x01	; 1
     f3a:	c8 30       	cpi	r28, 0x08	; 8
     f3c:	d1 05       	cpc	r29, r1
     f3e:	61 f7       	brne	.-40     	; 0xf18 <LCD_CGRAM_CUSTOM_SYMBOLS+0x1e>
	 { 0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }		// Battery Charging 100%	// addr48-55
};

void LCD_CGRAM_CUSTOM_SYMBOLS()
{
	for(rows=0; rows<7; rows++)
     f40:	80 91 e3 06 	lds	r24, 0x06E3
     f44:	90 91 e4 06 	lds	r25, 0x06E4
     f48:	01 96       	adiw	r24, 0x01	; 1
     f4a:	90 93 e4 06 	sts	0x06E4, r25
     f4e:	80 93 e3 06 	sts	0x06E3, r24
     f52:	80 91 e3 06 	lds	r24, 0x06E3
     f56:	90 91 e4 06 	lds	r25, 0x06E4
     f5a:	87 30       	cpi	r24, 0x07	; 7
     f5c:	91 05       	cpc	r25, r1
     f5e:	a4 f2       	brlt	.-88     	; 0xf08 <LCD_CGRAM_CUSTOM_SYMBOLS+0xe>
		for(int cols=0; cols<LCD_CGRAM_SYMBOL_CONTAIN_8BYTES; cols++)
		{
			LCD_EXECUTE_DATA_ONE(symbolGenerator[rows][cols]);
		}
	}
}
     f60:	df 91       	pop	r29
     f62:	cf 91       	pop	r28
     f64:	08 95       	ret

00000f66 <LCD_DATA_ULONG>:
/****************************************************************
** WRITE/TRANSMIT MORE DATA UNSIGNED LONG BYTES TO LCD DISPLAY **
****************************************************************/
// USE THIS: lcdDataULong( (unsigned long)k + 1 );
void LCD_DATA_ULONG(unsigned long data)		// void lcdDataULong(const unsigned long data)
{
     f66:	df 93       	push	r29
     f68:	cf 93       	push	r28
     f6a:	cd b7       	in	r28, 0x3d	; 61
     f6c:	de b7       	in	r29, 0x3e	; 62
     f6e:	2a 97       	sbiw	r28, 0x0a	; 10
     f70:	0f b6       	in	r0, 0x3f	; 63
     f72:	f8 94       	cli
     f74:	de bf       	out	0x3e, r29	; 62
     f76:	0f be       	out	0x3f, r0	; 63
     f78:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ultoa(data, buffer, 10));	// 10 -> DECIMAL
     f7a:	ae 01       	movw	r20, r28
     f7c:	4f 5f       	subi	r20, 0xFF	; 255
     f7e:	5f 4f       	sbci	r21, 0xFF	; 255
     f80:	2a e0       	ldi	r18, 0x0A	; 10
     f82:	30 e0       	ldi	r19, 0x00	; 0
     f84:	0e 94 ad 0b 	call	0x175a	; 0x175a <ultoa>
     f88:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
}
     f8c:	2a 96       	adiw	r28, 0x0a	; 10
     f8e:	0f b6       	in	r0, 0x3f	; 63
     f90:	f8 94       	cli
     f92:	de bf       	out	0x3e, r29	; 62
     f94:	0f be       	out	0x3f, r0	; 63
     f96:	cd bf       	out	0x3d, r28	; 61
     f98:	cf 91       	pop	r28
     f9a:	df 91       	pop	r29
     f9c:	08 95       	ret

00000f9e <LCD_DATA_LONG>:
/*******************************************************
** WRITE/TRANSMIT MORE DATA LONG BYTES TO LCD DISPLAY **
*******************************************************/
// USE THIS: lcdDataLong( (long)k + 1 );
void LCD_DATA_LONG(long data)		// void lcdDataLong(const long data)
{
     f9e:	df 93       	push	r29
     fa0:	cf 93       	push	r28
     fa2:	cd b7       	in	r28, 0x3d	; 61
     fa4:	de b7       	in	r29, 0x3e	; 62
     fa6:	2a 97       	sbiw	r28, 0x0a	; 10
     fa8:	0f b6       	in	r0, 0x3f	; 63
     faa:	f8 94       	cli
     fac:	de bf       	out	0x3e, r29	; 62
     fae:	0f be       	out	0x3f, r0	; 63
     fb0:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(ltoa(data, buffer, 10));	// 10 -> DECIMAL
     fb2:	ae 01       	movw	r20, r28
     fb4:	4f 5f       	subi	r20, 0xFF	; 255
     fb6:	5f 4f       	sbci	r21, 0xFF	; 255
     fb8:	2a e0       	ldi	r18, 0x0A	; 10
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <ltoa>
     fc0:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
}
     fc4:	2a 96       	adiw	r28, 0x0a	; 10
     fc6:	0f b6       	in	r0, 0x3f	; 63
     fc8:	f8 94       	cli
     fca:	de bf       	out	0x3e, r29	; 62
     fcc:	0f be       	out	0x3f, r0	; 63
     fce:	cd bf       	out	0x3d, r28	; 61
     fd0:	cf 91       	pop	r28
     fd2:	df 91       	pop	r29
     fd4:	08 95       	ret

00000fd6 <LCD_DATA_INT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataInt( (int)k + 1 );
void LCD_DATA_INT(int data)		// void lcdDataInt(const int data)
{
     fd6:	df 93       	push	r29
     fd8:	cf 93       	push	r28
     fda:	cd b7       	in	r28, 0x3d	; 61
     fdc:	de b7       	in	r29, 0x3e	; 62
     fde:	2a 97       	sbiw	r28, 0x0a	; 10
     fe0:	0f b6       	in	r0, 0x3f	; 63
     fe2:	f8 94       	cli
     fe4:	de bf       	out	0x3e, r29	; 62
     fe6:	0f be       	out	0x3f, r0	; 63
     fe8:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(itoa(data, buffer, 10));	// 10 -> DECIMAL
     fea:	be 01       	movw	r22, r28
     fec:	6f 5f       	subi	r22, 0xFF	; 255
     fee:	7f 4f       	sbci	r23, 0xFF	; 255
     ff0:	4a e0       	ldi	r20, 0x0A	; 10
     ff2:	50 e0       	ldi	r21, 0x00	; 0
     ff4:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <itoa>
     ff8:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
}
     ffc:	2a 96       	adiw	r28, 0x0a	; 10
     ffe:	0f b6       	in	r0, 0x3f	; 63
    1000:	f8 94       	cli
    1002:	de bf       	out	0x3e, r29	; 62
    1004:	0f be       	out	0x3f, r0	; 63
    1006:	cd bf       	out	0x3d, r28	; 61
    1008:	cf 91       	pop	r28
    100a:	df 91       	pop	r29
    100c:	08 95       	ret

0000100e <LCD_DATA_UINT>:
/******************************************************
** WRITE/TRANSMIT MORE DATA INT BYTES TO LCD DISPLAY **
******************************************************/
// USE THIS: lcdDataUInt( (unsigned int)k + 1 );
void LCD_DATA_UINT(unsigned int data)		// void lcdDataUInt(const unsigned int data)
{
    100e:	df 93       	push	r29
    1010:	cf 93       	push	r28
    1012:	cd b7       	in	r28, 0x3d	; 61
    1014:	de b7       	in	r29, 0x3e	; 62
    1016:	2a 97       	sbiw	r28, 0x0a	; 10
    1018:	0f b6       	in	r0, 0x3f	; 63
    101a:	f8 94       	cli
    101c:	de bf       	out	0x3e, r29	; 62
    101e:	0f be       	out	0x3f, r0	; 63
    1020:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	LCD_DATA_STRING(utoa(data, buffer, 10));	// 10 -> DECIMAL
    1022:	be 01       	movw	r22, r28
    1024:	6f 5f       	subi	r22, 0xFF	; 255
    1026:	7f 4f       	sbci	r23, 0xFF	; 255
    1028:	4a e0       	ldi	r20, 0x0A	; 10
    102a:	50 e0       	ldi	r21, 0x00	; 0
    102c:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <utoa>
    1030:	0e 94 56 07 	call	0xeac	; 0xeac <LCD_DATA_STRING>
}
    1034:	2a 96       	adiw	r28, 0x0a	; 10
    1036:	0f b6       	in	r0, 0x3f	; 63
    1038:	f8 94       	cli
    103a:	de bf       	out	0x3e, r29	; 62
    103c:	0f be       	out	0x3f, r0	; 63
    103e:	cd bf       	out	0x3d, r28	; 61
    1040:	cf 91       	pop	r28
    1042:	df 91       	pop	r29
    1044:	08 95       	ret

00001046 <PGA2310_Volume_Update>:

/*************************************
** DEFINITION PGA2310 VOLUME UPDATE **
*************************************/
void PGA2310_Volume_Update(unsigned char pgaVolumeLeft, unsigned char pgaVolumeRight)
{
    1046:	0f 93       	push	r16
    1048:	1f 93       	push	r17
    104a:	18 2f       	mov	r17, r24
    104c:	06 2f       	mov	r16, r22
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    104e:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    1050:	0e 94 27 09 	call	0x124e	; 0x124e <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    1054:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1056:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    1058:	81 2f       	mov	r24, r17
    105a:	60 2f       	mov	r22, r16
    105c:	0e 94 27 09 	call	0x124e	; 0x124e <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    1060:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA7 - /SS ENABLE
    1062:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(pgaVolumeLeft, pgaVolumeRight);
    1064:	81 2f       	mov	r24, r17
    1066:	60 2f       	mov	r22, r16
    1068:	0e 94 27 09 	call	0x124e	; 0x124e <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    106c:	df 9a       	sbi	0x1b, 7	; 27

//	return SUCCESS;
}
    106e:	1f 91       	pop	r17
    1070:	0f 91       	pop	r16
    1072:	08 95       	ret

00001074 <pga2310_init>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_init()
{
	spi_init();
    1074:	0e 94 16 09 	call	0x122c	; 0x122c <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    1078:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    107a:	80 e0       	ldi	r24, 0x00	; 0
    107c:	60 e0       	ldi	r22, 0x00	; 0
    107e:	0e 94 27 09 	call	0x124e	; 0x124e <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    1082:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1084:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1086:	80 e0       	ldi	r24, 0x00	; 0
    1088:	60 e0       	ldi	r22, 0x00	; 0
    108a:	0e 94 27 09 	call	0x124e	; 0x124e <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    108e:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    1090:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    1092:	80 e0       	ldi	r24, 0x00	; 0
    1094:	60 e0       	ldi	r22, 0x00	; 0
    1096:	0e 94 27 09 	call	0x124e	; 0x124e <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    109a:	df 9a       	sbi	0x1b, 7	; 27
}
    109c:	08 95       	ret

0000109e <pga2310_reset>:
/**************************************
** DEFINITION PGA2310 INITIALIZATION **
**************************************/
void pga2310_reset()
{
	spi_init();
    109e:	0e 94 16 09 	call	0x122c	; 0x122c <spi_init>
	
	PGA2310_U6_SPI_CS_low();	// CHIP SELECT BIT // PB3 - /SS ENABLE
    10a2:	c3 98       	cbi	0x18, 3	; 24
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    10a4:	80 e0       	ldi	r24, 0x00	; 0
    10a6:	60 e0       	ldi	r22, 0x00	; 0
    10a8:	0e 94 27 09 	call	0x124e	; 0x124e <spi_write_two_bytes>
	PGA2310_U6_SPI_CS_high();	// CHIP SELECT BIT // PB3 - /SS DISABLE
    10ac:	c3 9a       	sbi	0x18, 3	; 24

	PGA2310_U7_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    10ae:	de 98       	cbi	0x1b, 6	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    10b0:	80 e0       	ldi	r24, 0x00	; 0
    10b2:	60 e0       	ldi	r22, 0x00	; 0
    10b4:	0e 94 27 09 	call	0x124e	; 0x124e <spi_write_two_bytes>
	PGA2310_U7_SPI_CS_high();	// CHIP SELECT BIT // PA6 - /SS DISABLE
    10b8:	de 9a       	sbi	0x1b, 6	; 27

	PGA2310_U8_SPI_CS_low();	// CHIP SELECT BIT // PA6 - /SS ENABLE
    10ba:	df 98       	cbi	0x1b, 7	; 27
	spi_write_two_bytes(ZERO_FILL, ZERO_FILL);	// left and right channel
    10bc:	80 e0       	ldi	r24, 0x00	; 0
    10be:	60 e0       	ldi	r22, 0x00	; 0
    10c0:	0e 94 27 09 	call	0x124e	; 0x124e <spi_write_two_bytes>
	PGA2310_U8_SPI_CS_high();	// CHIP SELECT BIT // PA7 - /SS DISABLE
    10c4:	df 9a       	sbi	0x1b, 7	; 27
}
    10c6:	08 95       	ret

000010c8 <uart_transmit>:

/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
    10c8:	ac 01       	movw	r20, r24
    10ca:	20 e0       	ldi	r18, 0x00	; 0
    10cc:	30 e0       	ldi	r19, 0x00	; 0
    10ce:	09 c0       	rjmp	.+18     	; 0x10e2 <uart_transmit+0x1a>
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
	{
		//UDR = uart_data[count_ns];
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10d0:	5d 9b       	sbis	0x0b, 5	; 11
    10d2:	fe cf       	rjmp	.-4      	; 0x10d0 <uart_transmit+0x8>
		{
		}
		UDR = uart_data[count_ns];
    10d4:	fa 01       	movw	r30, r20
    10d6:	e2 0f       	add	r30, r18
    10d8:	f3 1f       	adc	r31, r19
    10da:	80 81       	ld	r24, Z
    10dc:	8c b9       	out	0x0c, r24	; 12
/*******************************************
** TRANSMIT/SEND MORE BYTES OF UART/USART **
*******************************************/
void uart_transmit(char uart_data [], int numsymbols)
{
	for(int count_ns = 0; count_ns < numsymbols; count_ns++)	// count_ns < numsymbols -> za string nqma nijda ot dobavqne na +1 za posledniq simvol ili ot smqna na znaka <=
    10de:	2f 5f       	subi	r18, 0xFF	; 255
    10e0:	3f 4f       	sbci	r19, 0xFF	; 255
    10e2:	26 17       	cp	r18, r22
    10e4:	37 07       	cpc	r19, r23
    10e6:	a4 f3       	brlt	.-24     	; 0x10d0 <uart_transmit+0x8>
		while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
		{
		}
		UDR = uart_data[count_ns];
	}
}
    10e8:	08 95       	ret

000010ea <uart_transmit_one>:
/***************************************
** TRANSMIT/SEND 1 BYTE OF UART/USART **
***************************************/
void uart_transmit_one(unsigned char uart_data)
{
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10ea:	5d 9b       	sbis	0x0b, 5	; 11
    10ec:	fe cf       	rjmp	.-4      	; 0x10ea <uart_transmit_one>
	{
	}
	UDR = uart_data;
    10ee:	8c b9       	out	0x0c, r24	; 12
}
    10f0:	08 95       	ret

000010f2 <uart_transmit_DEC_to_BCD>:

/*****************************************************************		// NOT FINISHED
** TRANSMIT/SEND 1 BYTE CONVERTED FROM DEC TO BCD OF UART/USART **		// NOT FINISHED
*****************************************************************/		// NOT FINISHED
void uart_transmit_DEC_to_BCD(unsigned char dec_to_bcd_data)
{// pravi se preobrazuvane ot DEC to BCD i preobrazuvane za izvejdane na parviq simvol s filtar
    10f2:	98 2f       	mov	r25, r24
	
	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    10f4:	5d 9b       	sbis	0x0b, 5	; 11
    10f6:	fe cf       	rjmp	.-4      	; 0x10f4 <uart_transmit_DEC_to_BCD+0x2>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data>>4));
    10f8:	89 2f       	mov	r24, r25
    10fa:	82 95       	swap	r24
    10fc:	8f 70       	andi	r24, 0x0F	; 15
    10fe:	80 5d       	subi	r24, 0xD0	; 208
    1100:	8c b9       	out	0x0c, r24	; 12

	while(!(UCSRA & (1<<UDRE)))	// cikal za proverka na gotovnost - dali e izpraten simbola i v gotovnost li e za nov simvol
    1102:	5d 9b       	sbis	0x0b, 5	; 11
    1104:	fe cf       	rjmp	.-4      	; 0x1102 <uart_transmit_DEC_to_BCD+0x10>
	{
	}
	UDR = ('0'+ (dec_to_bcd_data & 0x0F));
    1106:	9f 70       	andi	r25, 0x0F	; 15
    1108:	90 5d       	subi	r25, 0xD0	; 208
    110a:	9c b9       	out	0x0c, r25	; 12
	byte bcdToDec(byte val)
	{
  		return ( (val/16*10) + (val%16) );
	}
*/
}
    110c:	08 95       	ret

0000110e <transmitUart>:
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
    110e:	5d 9b       	sbis	0x0b, 5	; 11
    1110:	fe cf       	rjmp	.-4      	; 0x110e <transmitUart>
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
    1112:	8c b9       	out	0x0c, r24	; 12
}
    1114:	08 95       	ret

00001116 <transmitUartString>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
    1116:	fc 01       	movw	r30, r24
    1118:	04 c0       	rjmp	.+8      	; 0x1122 <transmitUartString+0xc>
** TRANSMIT/SEND 1 BYTE OF UART/USART **		// NOT FINISHED
***************************************/		// NOT FINISHED
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
    111a:	5d 9b       	sbis	0x0b, 5	; 11
    111c:	fe cf       	rjmp	.-4      	; 0x111a <transmitUartString+0x4>
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
	{
		transmitUart(*data++);
    111e:	31 96       	adiw	r30, 0x01	; 1
// USE THIS: uart_puts(" = "); OR transmitUart(data); data++; transmitUart(data);
void transmitUart(unsigned char data)
{
	while (!(UCSRA & (1<<UDRE)))
	{};							/* Wait for empty transmit buffer */
	UDR = data;					/* Put data into buffer, sends the data */
    1120:	8c b9       	out	0x0c, r24	; 12
** TRANSMIT/SEND MORE STRING BYTES OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: char symbols [] = "PESHO"; transmitUartString(symbols);
void transmitUartString(char *data)		// void transmitUartString(const char *data)
{
	while(*data)
    1122:	80 81       	ld	r24, Z
    1124:	88 23       	and	r24, r24
    1126:	c9 f7       	brne	.-14     	; 0x111a <transmitUartString+0x4>
	{
		transmitUart(*data++);
	}
}
    1128:	08 95       	ret

0000112a <uart_init>:
{
	switch(F_CPU)
	{
		case 16000000UL:
		{
			UBRRL = 103;	// Baudrate: 9600; (Error = 0.2%; 16MHz)
    112a:	87 e6       	ldi	r24, 0x67	; 103
    112c:	89 b9       	out	0x09, r24	; 9
			UBRRH = 0;
    112e:	10 bc       	out	0x20, r1	; 32
	LCD_DATA_STRING(" MHz");		// 20 symbols
#endif
	// Razpoznavane na baudrate (skorost): 1. Izprashta se byte. 2. Poluchava se byte. 3. Sravnqva se polucheniq byte == izprateniq byte. // This is LOOP TX->RX
	// 4. Ako byte pri sravnqvaneto e edin i sasht to skorostta e izbranata v momenta, ako byte e razlichen - da se probva sas sledvashta baudrate.

	UCSRC = 0b10000110;		// URSEL = 1 (Accessing to UBRRH or UCSRC, is read as zero when reading UBRRH. The URSEL must be zero when writing the UBRRH.); UMSEL = 0 (Asynchronous Operation); UPM1 = 0, UPM0 = 0 (Parity Mode Disabled); USBS = 0 (1-Stop Bit); UCSZ2 = 0, UCSZ1 = 1, UCSZ0 = 1 (8-DataBits); UCPOL = 0 Polarity TX & RX (Rising XCK Edge -> Transmitted Data Changed (Output of TxDPin), Falling XCK Edge -> Received Data Sampled (Input on RxDPin))
    1130:	86 e8       	ldi	r24, 0x86	; 134
    1132:	80 bd       	out	0x20, r24	; 32
	UCSRB = 0b00001000;		// Enable only TXEN	- Transmitting Uart/Usart	// UCSRB = 0b10011000;		// Enable TXEN,RXEN,RXCIE	Transmitting and Receiving Uart/Usart
    1134:	88 e0       	ldi	r24, 0x08	; 8
    1136:	8a b9       	out	0x0a, r24	; 10
	UDR = 0b00000000;		// INITIALIZATION NULL OF UART DATA
    1138:	1c b8       	out	0x0c, r1	; 12

#ifdef DEBUG_INFO
	transmitUartString("\r\n");
    113a:	88 eb       	ldi	r24, 0xB8	; 184
    113c:	96 e0       	ldi	r25, 0x06	; 6
    113e:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
#endif
#if DEBUG_SETTING
	transmitUartString("[UART INFO] Serial Port Settings - Baud rate: 9600, Data bits: 8 bits, Stop bits: 1 bit, Parity: None, Flow control: None or XON/XOFF\r\n");
#endif
}
    1142:	08 95       	ret

00001144 <receiveUart>:
/**************************************************		// NOT FINISHED
** RECEIVE/READ unsigned char BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
unsigned char receiveUart(void)
{
	while (!(UCSRA & (1<<RXC)))
    1144:	5f 9b       	sbis	0x0b, 7	; 11
    1146:	fe cf       	rjmp	.-4      	; 0x1144 <receiveUart>
	{};							/* Wait for data to be received */
	return UDR;					/* Get and return received data from buffer */
    1148:	8c b1       	in	r24, 0x0c	; 12
}
    114a:	08 95       	ret

0000114c <transmitUartLong>:
/******************************************		// NOT FINISHED
** TRANSMIT/SEND long BYTE OF UART/USART **		// NOT FINISHED
******************************************/		// NOT FINISHED
// USE THIS: transmitUartLong( (long)k + 1 );
void transmitUartLong(long data)		// void transmitUartLong(const long data)
{
    114c:	df 93       	push	r29
    114e:	cf 93       	push	r28
    1150:	cd b7       	in	r28, 0x3d	; 61
    1152:	de b7       	in	r29, 0x3e	; 62
    1154:	2a 97       	sbiw	r28, 0x0a	; 10
    1156:	0f b6       	in	r0, 0x3f	; 63
    1158:	f8 94       	cli
    115a:	de bf       	out	0x3e, r29	; 62
    115c:	0f be       	out	0x3f, r0	; 63
    115e:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ltoa(data, buffer, 10));		// 10 -> DECIMAL
    1160:	ae 01       	movw	r20, r28
    1162:	4f 5f       	subi	r20, 0xFF	; 255
    1164:	5f 4f       	sbci	r21, 0xFF	; 255
    1166:	2a e0       	ldi	r18, 0x0A	; 10
    1168:	30 e0       	ldi	r19, 0x00	; 0
    116a:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <ltoa>
    116e:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
}
    1172:	2a 96       	adiw	r28, 0x0a	; 10
    1174:	0f b6       	in	r0, 0x3f	; 63
    1176:	f8 94       	cli
    1178:	de bf       	out	0x3e, r29	; 62
    117a:	0f be       	out	0x3f, r0	; 63
    117c:	cd bf       	out	0x3d, r28	; 61
    117e:	cf 91       	pop	r28
    1180:	df 91       	pop	r29
    1182:	08 95       	ret

00001184 <transmitUartULong>:
/***************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned long BYTE OF UART/USART **		// NOT FINISHED
***************************************************/		// NOT FINISHED
// USE THIS: transmitUartULong( (unsigned long)k + 1 );
void transmitUartULong(unsigned long data)		// void transmitUartULong(const unsigned long data)
{
    1184:	df 93       	push	r29
    1186:	cf 93       	push	r28
    1188:	cd b7       	in	r28, 0x3d	; 61
    118a:	de b7       	in	r29, 0x3e	; 62
    118c:	2a 97       	sbiw	r28, 0x0a	; 10
    118e:	0f b6       	in	r0, 0x3f	; 63
    1190:	f8 94       	cli
    1192:	de bf       	out	0x3e, r29	; 62
    1194:	0f be       	out	0x3f, r0	; 63
    1196:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(ultoa(data, buffer, 10));		// 10 -> DECIMAL
    1198:	ae 01       	movw	r20, r28
    119a:	4f 5f       	subi	r20, 0xFF	; 255
    119c:	5f 4f       	sbci	r21, 0xFF	; 255
    119e:	2a e0       	ldi	r18, 0x0A	; 10
    11a0:	30 e0       	ldi	r19, 0x00	; 0
    11a2:	0e 94 ad 0b 	call	0x175a	; 0x175a <ultoa>
    11a6:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
}
    11aa:	2a 96       	adiw	r28, 0x0a	; 10
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	f8 94       	cli
    11b0:	de bf       	out	0x3e, r29	; 62
    11b2:	0f be       	out	0x3f, r0	; 63
    11b4:	cd bf       	out	0x3d, r28	; 61
    11b6:	cf 91       	pop	r28
    11b8:	df 91       	pop	r29
    11ba:	08 95       	ret

000011bc <transmitUartInt>:
/*****************************************		// NOT FINISHED
** TRANSMIT/SEND int BYTE OF UART/USART **		// NOT FINISHED
*****************************************/		// NOT FINISHED
// USE THIS: transmitUartInt( (int)k + 1 );
void transmitUartInt(int data)		// void transmitUartInt(const int data)
{
    11bc:	df 93       	push	r29
    11be:	cf 93       	push	r28
    11c0:	cd b7       	in	r28, 0x3d	; 61
    11c2:	de b7       	in	r29, 0x3e	; 62
    11c4:	2a 97       	sbiw	r28, 0x0a	; 10
    11c6:	0f b6       	in	r0, 0x3f	; 63
    11c8:	f8 94       	cli
    11ca:	de bf       	out	0x3e, r29	; 62
    11cc:	0f be       	out	0x3f, r0	; 63
    11ce:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(itoa(data, buffer, 10));		// 10 -> DECIMAL
    11d0:	be 01       	movw	r22, r28
    11d2:	6f 5f       	subi	r22, 0xFF	; 255
    11d4:	7f 4f       	sbci	r23, 0xFF	; 255
    11d6:	4a e0       	ldi	r20, 0x0A	; 10
    11d8:	50 e0       	ldi	r21, 0x00	; 0
    11da:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <itoa>
    11de:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
}
    11e2:	2a 96       	adiw	r28, 0x0a	; 10
    11e4:	0f b6       	in	r0, 0x3f	; 63
    11e6:	f8 94       	cli
    11e8:	de bf       	out	0x3e, r29	; 62
    11ea:	0f be       	out	0x3f, r0	; 63
    11ec:	cd bf       	out	0x3d, r28	; 61
    11ee:	cf 91       	pop	r28
    11f0:	df 91       	pop	r29
    11f2:	08 95       	ret

000011f4 <transmitUartUInt>:
/**************************************************		// NOT FINISHED
** TRANSMIT/SEND unsigned int BYTE OF UART/USART **		// NOT FINISHED
**************************************************/		// NOT FINISHED
// USE THIS: transmitUartUInt( (unsigned int)k + 1 );
void transmitUartUInt(unsigned int data)		// void transmitUartUInt(const unsigned int data)
{
    11f4:	df 93       	push	r29
    11f6:	cf 93       	push	r28
    11f8:	cd b7       	in	r28, 0x3d	; 61
    11fa:	de b7       	in	r29, 0x3e	; 62
    11fc:	2a 97       	sbiw	r28, 0x0a	; 10
    11fe:	0f b6       	in	r0, 0x3f	; 63
    1200:	f8 94       	cli
    1202:	de bf       	out	0x3e, r29	; 62
    1204:	0f be       	out	0x3f, r0	; 63
    1206:	cd bf       	out	0x3d, r28	; 61
	char buffer[10];
	transmitUartString(utoa(data, buffer, 10));		// 10 -> DECIMAL
    1208:	be 01       	movw	r22, r28
    120a:	6f 5f       	subi	r22, 0xFF	; 255
    120c:	7f 4f       	sbci	r23, 0xFF	; 255
    120e:	4a e0       	ldi	r20, 0x0A	; 10
    1210:	50 e0       	ldi	r21, 0x00	; 0
    1212:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <utoa>
    1216:	0e 94 8b 08 	call	0x1116	; 0x1116 <transmitUartString>
}
    121a:	2a 96       	adiw	r28, 0x0a	; 10
    121c:	0f b6       	in	r0, 0x3f	; 63
    121e:	f8 94       	cli
    1220:	de bf       	out	0x3e, r29	; 62
    1222:	0f be       	out	0x3f, r0	; 63
    1224:	cd bf       	out	0x3d, r28	; 61
    1226:	cf 91       	pop	r28
    1228:	df 91       	pop	r29
    122a:	08 95       	ret

0000122c <spi_init>:
/**************************
** INITIZLIZATION OF SPI **
***************************/
void spi_init()
{
	SPSR = (0<<SPIF)|(0<<WCOL)|(0<<SPI2X);
    122c:	1e b8       	out	0x0e, r1	; 14
//	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);			//0b01010010	// SPR1   = 1 - 16 000 000 / 64  = 250 000 = 250kHz  // KOMENTAR ZARADI SIMULACIQTA - PROTEUS BLOKIRANE ZARADI BIT V REGISTAR
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0);	//0b01010010	// SPR0,1 = 1 - 16 000 000 / 128 = 125 000 = 125kHz	 // KAKVA KOMBINACIQ OT 4-te BITa VODI DO RAZBLOKIRANETO ???
    122e:	83 e5       	ldi	r24, 0x53	; 83
    1230:	8d b9       	out	0x0d, r24	; 13
	SPDR = 0b00000000;
    1232:	1f b8       	out	0x0f, r1	; 15

	PGA2310_U8_SPI_CS_high();	// /SS - DISABLE
	PGA2310_U8_SPI(0b00000000, 0b00000000);
	*/

	SPCR = (0<<SPE);
    1234:	1d b8       	out	0x0d, r1	; 13
}
    1236:	08 95       	ret

00001238 <spi_start>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1238:	83 e5       	ldi	r24, 0x53	; 83
    123a:	8d b9       	out	0x0d, r24	; 13
}
    123c:	08 95       	ret

0000123e <spi_stop>:
/**************************************
** DEFINITION SPI FUNCTION STOP ONLY **
**************************************/
void spi_stop()
{
	SPCR = (0<<SPE);
    123e:	1d b8       	out	0x0d, r1	; 13
}
    1240:	08 95       	ret

00001242 <spi_write_one_byte>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1242:	93 e5       	ldi	r25, 0x53	; 83
    1244:	9d b9       	out	0x0d, r25	; 13
void spi_write_one_byte(unsigned char data)	// void PGA2310_U7_SPI(byte volume_left, byte volume_right)	//PGA2310_U7_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data;				//volume_right;
    1246:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    1248:	77 9b       	sbis	0x0e, 7	; 14
    124a:	fe cf       	rjmp	.-4      	; 0x1248 <spi_write_one_byte+0x6>
	{
	}
}
    124c:	08 95       	ret

0000124e <spi_write_two_bytes>:
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    124e:	93 e5       	ldi	r25, 0x53	; 83
    1250:	9d b9       	out	0x0d, r25	; 13
void spi_write_two_bytes(unsigned char data1, unsigned char data2)	// void PGA2310_U6_SPI(byte volume_left, byte volume_right)	//PGA2310_U6_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	spi_start();
	SPDR = data1;				//volume_left;
    1252:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)))
    1254:	77 9b       	sbis	0x0e, 7	; 14
    1256:	fe cf       	rjmp	.-4      	; 0x1254 <spi_write_two_bytes+0x6>
	{
	}

//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data2;				//volume_right;
    1258:	6f b9       	out	0x0f, r22	; 15
	while(!(SPSR & (1<<SPIF)))
    125a:	77 9b       	sbis	0x0e, 7	; 14
    125c:	fe cf       	rjmp	.-4      	; 0x125a <spi_write_two_bytes+0xc>
	{
	}
}
    125e:	08 95       	ret

00001260 <spi_write_more_bytes>:

/*********************************************
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
    1260:	fc 01       	movw	r30, r24
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1262:	93 e5       	ldi	r25, 0x53	; 83
    1264:	06 c0       	rjmp	.+12     	; 0x1272 <spi_write_more_bytes+0x12>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    1266:	31 96       	adiw	r30, 0x01	; 1
/***************************************
** DEFINITION SPI FUNCTION START ONLY **
***************************************/
void spi_start()
{
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1)|(1<<SPR0); //	SPCR = (1<<SPE);
    1268:	9d b9       	out	0x0d, r25	; 13
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
	{
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
		spi_start();
		SPDR = *data;			//volume_left;
    126a:	80 81       	ld	r24, Z
    126c:	8f b9       	out	0x0f, r24	; 15
		while(!(SPSR & (1<<SPIF)))
    126e:	77 9b       	sbis	0x0e, 7	; 14
    1270:	fe cf       	rjmp	.-4      	; 0x126e <spi_write_more_bytes+0xe>
** DEFINITION SPI FUNCTION WRITE MORE BYTES **
*********************************************/
void spi_write_more_bytes(unsigned char *data)	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - /SS ENABLE
	while(*data++)
    1272:	80 81       	ld	r24, Z
    1274:	88 23       	and	r24, r24
    1276:	b9 f7       	brne	.-18     	; 0x1266 <spi_write_more_bytes+0x6>
		SPDR = *data;			//volume_left;
		while(!(SPSR & (1<<SPIF)))
		{
		}
	}
}
    1278:	08 95       	ret

0000127a <spi_read_more_bytes>:
unsigned char spi_read_more_bytes()	// void PGA2310_U8_SPI(byte volume_left, byte volume_right)	//PGA2310_U8_SPI(0b00001111);
{
	unsigned char data = 0b00000000;
	//	PORTB = (0<<PB4);			// DON'T FORGET	CHIP SELECT BIT // PB4 - NOT USED HERE
	//	SPSR = 0b00000000;			// http://www.embeddedrelated.com/groups/lpc2000/show/16257.php
	SPDR = data;			//volume_left;
    127a:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF)))
    127c:	77 9b       	sbis	0x0e, 7	; 14
    127e:	fe cf       	rjmp	.-4      	; 0x127c <spi_read_more_bytes+0x2>
	{
	}
	return data;
}
    1280:	80 e0       	ldi	r24, 0x00	; 0
    1282:	08 95       	ret

00001284 <decToBcd>:

/**************************************************************
**** CONVERT NORMAL DECIMAL NUMBERS TO BINARY CODED DECIMAL ***
**************************************************************/
unsigned char decToBcd(unsigned char val)
{
    1284:	48 2f       	mov	r20, r24
    1286:	6a e0       	ldi	r22, 0x0A	; 10
    1288:	0e 94 25 0b 	call	0x164a	; 0x164a <__udivmodqi4>
    128c:	28 2f       	mov	r18, r24
    128e:	30 e0       	ldi	r19, 0x00	; 0
    1290:	84 e0       	ldi	r24, 0x04	; 4
    1292:	22 0f       	add	r18, r18
    1294:	33 1f       	adc	r19, r19
    1296:	8a 95       	dec	r24
    1298:	e1 f7       	brne	.-8      	; 0x1292 <decToBcd+0xe>
    129a:	84 2f       	mov	r24, r20
    129c:	0e 94 25 0b 	call	0x164a	; 0x164a <__udivmodqi4>
	return ( (val/10*16) + (val%10) );	// Get DEC format -> convert DEC to HEX
}
    12a0:	89 2f       	mov	r24, r25
    12a2:	82 0f       	add	r24, r18
    12a4:	08 95       	ret

000012a6 <bcdToDec>:

/**************************************************************
**** CONVERT BINARY CODED DECIMAL TO NORMAL DECIMAL NUMBERS ***
**************************************************************/
unsigned char bcdToDec(unsigned char val)
{
    12a6:	28 2f       	mov	r18, r24
    12a8:	22 95       	swap	r18
    12aa:	2f 70       	andi	r18, 0x0F	; 15
    12ac:	9a e0       	ldi	r25, 0x0A	; 10
    12ae:	29 9f       	mul	r18, r25
    12b0:	90 01       	movw	r18, r0
    12b2:	11 24       	eor	r1, r1
    12b4:	8f 70       	andi	r24, 0x0F	; 15
	return ( (val/16*10) + (val%16) );	// Get HEX format -> convert HEX to DEC
}
    12b6:	82 0f       	add	r24, r18
    12b8:	08 95       	ret

000012ba <shiftRightOutLsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    12ba:	a0 9a       	sbi	0x14, 0	; 20
    12bc:	94 e4       	ldi	r25, 0x44	; 68
    12be:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regALSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    12c0:	90 ff       	sbrs	r25, 0
    12c2:	02 c0       	rjmp	.+4      	; 0x12c8 <shiftRightOutLsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v LSB
    12c4:	a8 9a       	sbi	0x15, 0	; 21
    12c6:	01 c0       	rjmp	.+2      	; 0x12ca <shiftRightOutLsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
    12c8:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regALSB;
	unsigned char x;
	regALSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12ca:	8f 5f       	subi	r24, 0xFF	; 255
    12cc:	88 30       	cpi	r24, 0x08	; 8
    12ce:	11 f0       	breq	.+4      	; 0x12d4 <shiftRightOutLsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v LSB
		}
		
		regALSB = regALSB >> 1;	// shiftvane na >> nadqsno
    12d0:	96 95       	lsr	r25
    12d2:	f6 cf       	rjmp	.-20     	; 0x12c0 <shiftRightOutLsbFirst+0x6>
    12d4:	08 95       	ret

000012d6 <shiftLeftOutMsbFirst>:
{
	unsigned char conbyte = 0x44;
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output
    12d6:	a0 9a       	sbi	0x14, 0	; 20
    12d8:	94 e4       	ldi	r25, 0x44	; 68
    12da:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		if(regAMSB & 0x80)	// maska & za log "1" na MSB 0b10000000
    12dc:	97 ff       	sbrs	r25, 7
    12de:	02 c0       	rjmp	.+4      	; 0x12e4 <shiftLeftOutMsbFirst+0xe>
		{
			PORTC |= (1<<serPin);	// izvejdane na log "1" v MSB
    12e0:	a8 9a       	sbi	0x15, 0	; 21
    12e2:	01 c0       	rjmp	.+2      	; 0x12e6 <shiftLeftOutMsbFirst+0x10>
		}
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
    12e4:	a8 98       	cbi	0x15, 0	; 21
	unsigned char regAMSB;
	unsigned char x;
	regAMSB = conbyte;
	DDRC |= (1<<serPin);	// serial pin output

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12e6:	8f 5f       	subi	r24, 0xFF	; 255
    12e8:	88 30       	cpi	r24, 0x08	; 8
    12ea:	11 f0       	breq	.+4      	; 0x12f0 <shiftLeftOutMsbFirst+0x1a>
		else
		{
			PORTC &= ~(1<<serPin);	// izvejdane na log "0" v MSB
		}
		
		regAMSB = regAMSB << 1;	// shiftvane na << nalqvo
    12ec:	99 0f       	add	r25, r25
    12ee:	f6 cf       	rjmp	.-20     	; 0x12dc <shiftLeftOutMsbFirst+0x6>
    12f0:	08 95       	ret

000012f2 <shiftRightInLsbFirst>:
void shiftRightInLsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    12f2:	a0 98       	cbi	0x14, 0	; 20
    12f4:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
    12f6:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    12f8:	8f 5f       	subi	r24, 0xFF	; 255
    12fa:	88 30       	cpi	r24, 0x08	; 8
    12fc:	e1 f7       	brne	.-8      	; 0x12f6 <shiftRightInLsbFirst+0x4>
	{
		REGA = REGA >> 1;	// shift REGA to right one bit
		REGA |= (PINC & (1<<serPin)) << (7-serPin);	// copy bit serPin of PORTC to MSB of REGA
	}

}
    12fe:	08 95       	ret

00001300 <shiftLeftInMsbFirst>:
void shiftLeftInMsbFirst()
{
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input
    1300:	a0 98       	cbi	0x14, 0	; 20
    1302:	80 e0       	ldi	r24, 0x00	; 0

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
    1304:	93 b3       	in	r25, 0x13	; 19
	unsigned char x;
	unsigned char REGA = 0;
	
	DDRC &= ~(1<<serPin);	// serial pin input

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    1306:	8f 5f       	subi	r24, 0xFF	; 255
    1308:	88 30       	cpi	r24, 0x08	; 8
    130a:	e1 f7       	brne	.-8      	; 0x1304 <shiftLeftInMsbFirst+0x4>
	{
		REGA = REGA << 1;	// shift REGA to left one bit
		REGA |= (PINC & (1<<serPin)) >> serPin;	// copy bit serPin of PORTC to LSB of REGA
	}

}
    130c:	08 95       	ret

0000130e <delay_ms>:

/*************************************************************
*********** FUNCTION SOFTWARE DELAY IN MILISECONDS ***********
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
    130e:	40 e0       	ldi	r20, 0x00	; 0
    1310:	50 e0       	ldi	r21, 0x00	; 0
    1312:	0b c0       	rjmp	.+22     	; 0x132a <delay_ms+0x1c>
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1314:	20 e0       	ldi	r18, 0x00	; 0
    1316:	30 e0       	ldi	r19, 0x00	; 0
	{
		for(j=0;j<100;j++)
		{
		  asm("nop");
    1318:	00 00       	nop
		  asm("nop");
    131a:	00 00       	nop
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
	{
		for(j=0;j<100;j++)
    131c:	2f 5f       	subi	r18, 0xFF	; 255
    131e:	3f 4f       	sbci	r19, 0xFF	; 255
    1320:	24 36       	cpi	r18, 0x64	; 100
    1322:	31 05       	cpc	r19, r1
    1324:	c9 f7       	brne	.-14     	; 0x1318 <delay_ms+0xa>
*************************************************************/
void delay_ms(int miliSec)  //for 1 Mhz crystal
{
	//  miliSec = miliSec * 16;	// for 16MHz
	int i,j;
	for(i=0;i<miliSec;i++)
    1326:	4f 5f       	subi	r20, 0xFF	; 255
    1328:	5f 4f       	sbci	r21, 0xFF	; 255
    132a:	48 17       	cp	r20, r24
    132c:	59 07       	cpc	r21, r25
    132e:	94 f3       	brlt	.-28     	; 0x1314 <delay_ms+0x6>
		{
		  asm("nop");
		  asm("nop");
		}
	}
}
    1330:	08 95       	ret

00001332 <rotaryEncoderNikBarzakov>:
** READ/SCAN ROTARY ENCODER OF NIK BARZAKOV **
*********************************************/
char rotaryEncoderNikBarzakov()
{
	char tempEncoder = 0;
	if((ENCODER_A_low()) && (ENCODER_B_low()))			// A0, B0
    1332:	9d 99       	sbic	0x13, 5	; 19
    1334:	0e c0       	rjmp	.+28     	; 0x1352 <rotaryEncoderNikBarzakov+0x20>
    1336:	9c 99       	sbic	0x13, 4	; 19
    1338:	0c c0       	rjmp	.+24     	; 0x1352 <rotaryEncoderNikBarzakov+0x20>
    133a:	88 ec       	ldi	r24, 0xC8	; 200
    133c:	90 e0       	ldi	r25, 0x00	; 0
    133e:	01 97       	sbiw	r24, 0x01	; 1
    1340:	f1 f7       	brne	.-4      	; 0x133e <rotaryEncoderNikBarzakov+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_high()) && (ENCODER_B_low()))		// A1, B0
    1342:	9d 9b       	sbis	0x13, 5	; 19
    1344:	14 c0       	rjmp	.+40     	; 0x136e <rotaryEncoderNikBarzakov+0x3c>
    1346:	83 b3       	in	r24, 0x13	; 19
    1348:	82 95       	swap	r24
    134a:	8f 70       	andi	r24, 0x0F	; 15
    134c:	80 95       	com	r24
    134e:	81 70       	andi	r24, 0x01	; 1
    1350:	08 95       	ret
// VOLUME UP
			tempEncoder = 1;	//	tempEncoder++;
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}
	}
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    1352:	9d 9b       	sbis	0x13, 5	; 19
    1354:	0c c0       	rjmp	.+24     	; 0x136e <rotaryEncoderNikBarzakov+0x3c>
    1356:	9c 99       	sbic	0x13, 4	; 19
    1358:	0a c0       	rjmp	.+20     	; 0x136e <rotaryEncoderNikBarzakov+0x3c>
    135a:	88 ec       	ldi	r24, 0xC8	; 200
    135c:	90 e0       	ldi	r25, 0x00	; 0
    135e:	01 97       	sbiw	r24, 0x01	; 1
    1360:	f1 f7       	brne	.-4      	; 0x135e <rotaryEncoderNikBarzakov+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    1362:	9d 99       	sbic	0x13, 5	; 19
    1364:	04 c0       	rjmp	.+8      	; 0x136e <rotaryEncoderNikBarzakov+0x3c>
    1366:	9c 99       	sbic	0x13, 4	; 19
    1368:	02 c0       	rjmp	.+4      	; 0x136e <rotaryEncoderNikBarzakov+0x3c>
    136a:	8f ef       	ldi	r24, 0xFF	; 255
    136c:	08 95       	ret
    136e:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    1370:	08 95       	ret

00001372 <rotaryEncoderVer1>:
** READ/SCAN ROTARY ENCODER VERSION 1 / MODEL 1 **
*************************************************/
char rotaryEncoderVer1()	// Check imediate now bits in PIN register.
{
	char tempEncoder = 0;							// A1, B1
	if((ENCODER_A_low()) && (ENCODER_B_high()))			// A0, B1
    1372:	9d 99       	sbic	0x13, 5	; 19
    1374:	0e c0       	rjmp	.+28     	; 0x1392 <rotaryEncoderVer1+0x20>
    1376:	9c 9b       	sbis	0x13, 4	; 19
    1378:	0c c0       	rjmp	.+24     	; 0x1392 <rotaryEncoderVer1+0x20>
    137a:	88 ec       	ldi	r24, 0xC8	; 200
    137c:	90 e0       	ldi	r25, 0x00	; 0
    137e:	01 97       	sbiw	r24, 0x01	; 1
    1380:	f1 f7       	brne	.-4      	; 0x137e <rotaryEncoderVer1+0xc>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    1382:	9d 99       	sbic	0x13, 5	; 19
    1384:	14 c0       	rjmp	.+40     	; 0x13ae <rotaryEncoderVer1+0x3c>
    1386:	83 b3       	in	r24, 0x13	; 19
    1388:	82 95       	swap	r24
    138a:	8f 70       	andi	r24, 0x0F	; 15
    138c:	80 95       	com	r24
    138e:	81 70       	andi	r24, 0x01	; 1
    1390:	08 95       	ret
//			PORTD = volumeMassive[volumeIndex];
			// ---> Clockwise; Zavartane po posoka na chasovnikovata strelka.
		}

	}													// A1. B1
	else if((ENCODER_A_high()) && (ENCODER_B_low()))	// A1, B0
    1392:	9d 9b       	sbis	0x13, 5	; 19
    1394:	0c c0       	rjmp	.+24     	; 0x13ae <rotaryEncoderVer1+0x3c>
    1396:	9c 99       	sbic	0x13, 4	; 19
    1398:	0a c0       	rjmp	.+20     	; 0x13ae <rotaryEncoderVer1+0x3c>
    139a:	88 ec       	ldi	r24, 0xC8	; 200
    139c:	90 e0       	ldi	r25, 0x00	; 0
    139e:	01 97       	sbiw	r24, 0x01	; 1
    13a0:	f1 f7       	brne	.-4      	; 0x139e <rotaryEncoderVer1+0x2c>
	{
		_delay_us(50);	// delay before next check bits
		if((ENCODER_A_low()) && (ENCODER_B_low()))		// A0, B0
    13a2:	9d 99       	sbic	0x13, 5	; 19
    13a4:	04 c0       	rjmp	.+8      	; 0x13ae <rotaryEncoderVer1+0x3c>
    13a6:	9c 99       	sbic	0x13, 4	; 19
    13a8:	02 c0       	rjmp	.+4      	; 0x13ae <rotaryEncoderVer1+0x3c>
    13aa:	8f ef       	ldi	r24, 0xFF	; 255
    13ac:	08 95       	ret
    13ae:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    13b0:	08 95       	ret

000013b2 <rotaryEncoderVer2>:
    13b2:	88 ec       	ldi	r24, 0xC8	; 200
    13b4:	90 e0       	ldi	r25, 0x00	; 0
    13b6:	fc 01       	movw	r30, r24
    13b8:	31 97       	sbiw	r30, 0x01	; 1
    13ba:	f1 f7       	brne	.-4      	; 0x13b8 <rotaryEncoderVer2+0x6>
    13bc:	fc 01       	movw	r30, r24
    13be:	31 97       	sbiw	r30, 0x01	; 1
    13c0:	f1 f7       	brne	.-4      	; 0x13be <rotaryEncoderVer2+0xc>
    13c2:	01 97       	sbiw	r24, 0x01	; 1
    13c4:	f1 f7       	brne	.-4      	; 0x13c2 <rotaryEncoderVer2+0x10>
	else
	{
		// do nothing
	}
	return tempEncoder;
}
    13c6:	80 e0       	ldi	r24, 0x00	; 0
    13c8:	08 95       	ret

000013ca <RELAYS_IN_INIT>:
/*********************************************
** INITIZLIZATION OF SHIFT REGISTER 74HC595 **
*********************************************/
void RELAYS_IN_INIT()
{
}
    13ca:	08 95       	ret

000013cc <RELAYS_OUT_INIT>:

void RELAYS_OUT_INIT()
{
}
    13cc:	08 95       	ret

000013ce <RELAYS_IN_CHOOSE>:

/****************************************************************************************************************
** DEFINITION RELAYS IN FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS IN **
****************************************************************************************************************/
void RELAYS_IN_CHOOSE(unsigned char rel_in)	// HELP: RELAYS_IN_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    13ce:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELIN_SCK_low();
    13d0:	ae 98       	cbi	0x15, 6	; 21

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    13d2:	80 ff       	sbrs	r24, 0
    13d4:	02 c0       	rjmp	.+4      	; 0x13da <RELAYS_IN_CHOOSE+0xc>
		{
			RELIN_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    13d6:	af 9a       	sbi	0x15, 7	; 21
    13d8:	01 c0       	rjmp	.+2      	; 0x13dc <RELAYS_IN_CHOOSE+0xe>
		}
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    13da:	af 98       	cbi	0x15, 7	; 21
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELIN_SCK_high();
    13dc:	ae 9a       	sbi	0x15, 6	; 21
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_in;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    13de:	9f 5f       	subi	r25, 0xFF	; 255
    13e0:	98 30       	cpi	r25, 0x08	; 8
    13e2:	11 f0       	breq	.+4      	; 0x13e8 <RELAYS_IN_CHOOSE+0x1a>
		else
		{
			RELIN_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    13e4:	86 95       	lsr	r24
    13e6:	f4 cf       	rjmp	.-24     	; 0x13d0 <RELAYS_IN_CHOOSE+0x2>

		RELIN_SCK_high();
	}

	RELIN_RCK_low();
    13e8:	ab 98       	cbi	0x15, 3	; 21
    13ea:	88 ea       	ldi	r24, 0xA8	; 168
    13ec:	92 e0       	ldi	r25, 0x02	; 2
    13ee:	fc 01       	movw	r30, r24
    13f0:	31 97       	sbiw	r30, 0x01	; 1
    13f2:	f1 f7       	brne	.-4      	; 0x13f0 <RELAYS_IN_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELIN_RCK_high();
    13f4:	ab 9a       	sbi	0x15, 3	; 21
    13f6:	01 97       	sbiw	r24, 0x01	; 1
    13f8:	f1 f7       	brne	.-4      	; 0x13f6 <RELAYS_IN_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    13fa:	08 95       	ret

000013fc <relays_in1_2ch>:

void relays_in1_2ch()
{
	RELAYS_IN_CHOOSE(0b00100000);	// RELE 1
    13fc:	80 e2       	ldi	r24, 0x20	; 32
    13fe:	0e 94 e7 09 	call	0x13ce	; 0x13ce <RELAYS_IN_CHOOSE>
}
    1402:	08 95       	ret

00001404 <relays_in1_6ch>:

void relays_in1_6ch()
{
	RELAYS_IN_CHOOSE(0b01100001);	// RELE 1,2,3
    1404:	81 e6       	ldi	r24, 0x61	; 97
    1406:	0e 94 e7 09 	call	0x13ce	; 0x13ce <RELAYS_IN_CHOOSE>
}
    140a:	08 95       	ret

0000140c <relays_in2_2ch>:

void relays_in2_2ch()
{
	RELAYS_IN_CHOOSE(0b00001010);	// RELE 4,5
    140c:	8a e0       	ldi	r24, 0x0A	; 10
    140e:	0e 94 e7 09 	call	0x13ce	; 0x13ce <RELAYS_IN_CHOOSE>
}
    1412:	08 95       	ret

00001414 <relays_in2_6ch>:

void relays_in2_6ch()
{
	RELAYS_IN_CHOOSE(0b10011010);	// RELE 4,5,6,7
    1414:	8a e9       	ldi	r24, 0x9A	; 154
    1416:	0e 94 e7 09 	call	0x13ce	; 0x13ce <RELAYS_IN_CHOOSE>
}
    141a:	08 95       	ret

0000141c <relays_in3_2ch>:

void relays_in3_2ch()
{
	RELAYS_IN_CHOOSE(0b00001100);	// RELE 8,5
    141c:	8c e0       	ldi	r24, 0x0C	; 12
    141e:	0e 94 e7 09 	call	0x13ce	; 0x13ce <RELAYS_IN_CHOOSE>
}
    1422:	08 95       	ret

00001424 <relays_in3_6ch>:

void relays_in3_6ch()
{
	RELAYS_IN_CHOOSE(0b10011100);	// RELE 8,5,6,7
    1424:	8c e9       	ldi	r24, 0x9C	; 156
    1426:	0e 94 e7 09 	call	0x13ce	; 0x13ce <RELAYS_IN_CHOOSE>
}
    142a:	08 95       	ret

0000142c <relays_in_off>:

void relays_in_off()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    142c:	80 e0       	ldi	r24, 0x00	; 0
    142e:	0e 94 e7 09 	call	0x13ce	; 0x13ce <RELAYS_IN_CHOOSE>
}
    1432:	08 95       	ret

00001434 <relays_in_init>:

void relays_in_init()
{
	RELAYS_IN_CHOOSE(0b00000000);	// 0b00000000 // [8][7][6][5][4][3][2][1] // RELETA IZKLIUCHENI 
    1434:	80 e0       	ldi	r24, 0x00	; 0
    1436:	0e 94 e7 09 	call	0x13ce	; 0x13ce <RELAYS_IN_CHOOSE>
}
    143a:	08 95       	ret

0000143c <RELAYS_OUT_CHOOSE>:
/******************************************************************************************************************
** DEFINITION RELAYS OUT FUNCTIONS, WRITE/TRANSMIT 8bits (1Byte) TO SHIFT REGISTER 74HC595 AND CHOOSE RELAYS OUT **
******************************************************************************************************************/
void RELAYS_OUT_CHOOSE(unsigned char rel_out)	// HELP: RELAYS_OUT_CHOOSE(unsigned char byte_of_choosing_combination_of_relay_in) // 74HC595 shift right out, lsb is first
{
    143c:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
	{
		RELOUT_SCK_low();
    143e:	96 98       	cbi	0x12, 6	; 18

		if(storeLSB & 0x01)	// maska & za log "1" na LSB 0b00000001
    1440:	80 ff       	sbrs	r24, 0
    1442:	02 c0       	rjmp	.+4      	; 0x1448 <RELAYS_OUT_CHOOSE+0xc>
		{
			RELOUT_SDI_high();	// izvejdane na log "1" v MSB	// PORTC |= (1<<RELIN_SDI_PIN);
    1444:	c4 9a       	sbi	0x18, 4	; 24
    1446:	01 c0       	rjmp	.+2      	; 0x144a <RELAYS_OUT_CHOOSE+0xe>
		}
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
    1448:	c4 98       	cbi	0x18, 4	; 24
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno

		RELOUT_SCK_high();
    144a:	96 9a       	sbi	0x12, 6	; 18
{
	unsigned char storeLSB;
	unsigned char x;
	storeLSB = rel_out;

	for(x=0; x<8; x++)		// cikal za predavane seriino na 1 byte
    144c:	9f 5f       	subi	r25, 0xFF	; 255
    144e:	98 30       	cpi	r25, 0x08	; 8
    1450:	11 f0       	breq	.+4      	; 0x1456 <RELAYS_OUT_CHOOSE+0x1a>
		else
		{
			RELOUT_SDI_low();	// izvejdane na log "0" v MSB	// PORTC &= ~(1<<RELIN_SDI_PIN);	
		}
		
		storeLSB = storeLSB >> 1;	// shiftvane na >> nadqsno
    1452:	86 95       	lsr	r24
    1454:	f4 cf       	rjmp	.-24     	; 0x143e <RELAYS_OUT_CHOOSE+0x2>

		RELOUT_SCK_high();
	}

	RELOUT_RCK_low();
    1456:	97 98       	cbi	0x12, 7	; 18
    1458:	88 ea       	ldi	r24, 0xA8	; 168
    145a:	92 e0       	ldi	r25, 0x02	; 2
    145c:	fc 01       	movw	r30, r24
    145e:	31 97       	sbiw	r30, 0x01	; 1
    1460:	f1 f7       	brne	.-4      	; 0x145e <RELAYS_OUT_CHOOSE+0x22>
	_delay_us(170);			//rcall 180 us
	RELOUT_RCK_high();
    1462:	97 9a       	sbi	0x12, 7	; 18
    1464:	01 97       	sbiw	r24, 0x01	; 1
    1466:	f1 f7       	brne	.-4      	; 0x1464 <RELAYS_OUT_CHOOSE+0x28>
	_delay_us(170);			//rcall 180 us

}
    1468:	08 95       	ret

0000146a <relays_out_1ch>:

void relays_out_1ch()
{
	RELAYS_OUT_CHOOSE(0b10000000);	// RELE 1
    146a:	80 e8       	ldi	r24, 0x80	; 128
    146c:	0e 94 1e 0a 	call	0x143c	; 0x143c <RELAYS_OUT_CHOOSE>
}
    1470:	08 95       	ret

00001472 <relays_out_6ch>:

void relays_out_6ch()
{
	RELAYS_OUT_CHOOSE(0b11111100);	// RELE 1,2,3,4,5,6
    1472:	8c ef       	ldi	r24, 0xFC	; 252
    1474:	0e 94 1e 0a 	call	0x143c	; 0x143c <RELAYS_OUT_CHOOSE>
}
    1478:	08 95       	ret

0000147a <relays_out_off>:
void relays_out_off()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    147a:	80 e0       	ldi	r24, 0x00	; 0
    147c:	0e 94 1e 0a 	call	0x143c	; 0x143c <RELAYS_OUT_CHOOSE>
}
    1480:	08 95       	ret

00001482 <relays_out_init>:
void relays_out_init()
{
	RELAYS_OUT_CHOOSE(0b00000000);	// RELE 1,2,3,4,5,6
    1482:	80 e0       	ldi	r24, 0x00	; 0
    1484:	0e 94 1e 0a 	call	0x143c	; 0x143c <RELAYS_OUT_CHOOSE>
}
    1488:	08 95       	ret

0000148a <GetSIRC12>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    148a:	10 92 d8 06 	sts	0x06D8, r1
    148e:	10 92 dd 06 	sts	0x06DD, r1

	while(irPin);				//wait for it to be low
    1492:	82 99       	sbic	0x10, 2	; 16
    1494:	fe cf       	rjmp	.-4      	; 0x1492 <GetSIRC12+0x8>
    1496:	20 e0       	ldi	r18, 0x00	; 0
    1498:	40 e2       	ldi	r20, 0x20	; 32
    149a:	53 e0       	ldi	r21, 0x03	; 3
    149c:	04 c0       	rjmp	.+8      	; 0x14a6 <GetSIRC12+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    149e:	2f 5f       	subi	r18, 0xFF	; 255
    14a0:	ca 01       	movw	r24, r20
    14a2:	01 97       	sbiw	r24, 0x01	; 1
    14a4:	f1 f7       	brne	.-4      	; 0x14a2 <GetSIRC12+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    14a6:	82 9b       	sbis	0x10, 2	; 16
    14a8:	fa cf       	rjmp	.-12     	; 0x149e <GetSIRC12+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    14aa:	2b 50       	subi	r18, 0x0B	; 11
    14ac:	23 30       	cpi	r18, 0x03	; 3
    14ae:	70 f5       	brcc	.+92     	; 0x150c <GetSIRC12+0x82>
	{
		return;		//goto StartLook;
    14b0:	40 e0       	ldi	r20, 0x00	; 0
    14b2:	30 e0       	ldi	r19, 0x00	; 0
    14b4:	60 e2       	ldi	r22, 0x20	; 32
    14b6:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    14b8:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    14ba:	82 99       	sbic	0x10, 2	; 16
    14bc:	fe cf       	rjmp	.-4      	; 0x14ba <GetSIRC12+0x30>
    14be:	20 e0       	ldi	r18, 0x00	; 0
    14c0:	04 c0       	rjmp	.+8      	; 0x14ca <GetSIRC12+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    14c2:	2f 5f       	subi	r18, 0xFF	; 255
    14c4:	cb 01       	movw	r24, r22
    14c6:	01 97       	sbiw	r24, 0x01	; 1
    14c8:	f1 f7       	brne	.-4      	; 0x14c6 <GetSIRC12+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    14ca:	82 9b       	sbis	0x10, 2	; 16
    14cc:	fa cf       	rjmp	.-12     	; 0x14c2 <GetSIRC12+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    14ce:	26 30       	cpi	r18, 0x06	; 6
    14d0:	08 f0       	brcs	.+2      	; 0x14d4 <GetSIRC12+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    14d2:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    14d4:	4f 5f       	subi	r20, 0xFF	; 255
    14d6:	47 30       	cpi	r20, 0x07	; 7
    14d8:	79 f7       	brne	.-34     	; 0x14b8 <GetSIRC12+0x2e>
    14da:	30 93 d8 06 	sts	0x06D8, r19
    14de:	40 e0       	ldi	r20, 0x00	; 0
    14e0:	30 e0       	ldi	r19, 0x00	; 0
    14e2:	60 e2       	ldi	r22, 0x20	; 32
    14e4:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    14e6:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    14e8:	82 99       	sbic	0x10, 2	; 16
    14ea:	fe cf       	rjmp	.-4      	; 0x14e8 <GetSIRC12+0x5e>
    14ec:	20 e0       	ldi	r18, 0x00	; 0
    14ee:	04 c0       	rjmp	.+8      	; 0x14f8 <GetSIRC12+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    14f0:	2f 5f       	subi	r18, 0xFF	; 255
    14f2:	cb 01       	movw	r24, r22
    14f4:	01 97       	sbiw	r24, 0x01	; 1
    14f6:	f1 f7       	brne	.-4      	; 0x14f4 <GetSIRC12+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    14f8:	82 9b       	sbis	0x10, 2	; 16
    14fa:	fa cf       	rjmp	.-12     	; 0x14f0 <GetSIRC12+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    14fc:	26 30       	cpi	r18, 0x06	; 6
    14fe:	08 f0       	brcs	.+2      	; 0x1502 <GetSIRC12+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1500:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<5;x++)			//repeat 5 times for address/device
    1502:	4f 5f       	subi	r20, 0xFF	; 255
    1504:	45 30       	cpi	r20, 0x05	; 5
    1506:	79 f7       	brne	.-34     	; 0x14e6 <GetSIRC12+0x5c>
    1508:	30 93 dd 06 	sts	0x06DD, r19
    150c:	08 95       	ret

0000150e <GetSIRC15>:
{
	char x;
	char lTime;

//StartLook:
	irAddress = irCommand = 0;
    150e:	10 92 d8 06 	sts	0x06D8, r1
    1512:	10 92 dd 06 	sts	0x06DD, r1

	while(irPin);				//wait for it to be low
    1516:	82 99       	sbic	0x10, 2	; 16
    1518:	fe cf       	rjmp	.-4      	; 0x1516 <GetSIRC15+0x8>
    151a:	20 e0       	ldi	r18, 0x00	; 0
    151c:	40 e2       	ldi	r20, 0x20	; 32
    151e:	53 e0       	ldi	r21, 0x03	; 3
    1520:	04 c0       	rjmp	.+8      	; 0x152a <GetSIRC15+0x1c>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    1522:	2f 5f       	subi	r18, 0xFF	; 255
    1524:	ca 01       	movw	r24, r20
    1526:	01 97       	sbiw	r24, 0x01	; 1
    1528:	f1 f7       	brne	.-4      	; 0x1526 <GetSIRC15+0x18>
	irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    152a:	82 9b       	sbis	0x10, 2	; 16
    152c:	fa cf       	rjmp	.-12     	; 0x1522 <GetSIRC15+0x14>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    152e:	2b 50       	subi	r18, 0x0B	; 11
    1530:	23 30       	cpi	r18, 0x03	; 3
    1532:	70 f5       	brcc	.+92     	; 0x1590 <GetSIRC15+0x82>
	{
		return;		//goto StartLook;
    1534:	40 e0       	ldi	r20, 0x00	; 0
    1536:	30 e0       	ldi	r19, 0x00	; 0
    1538:	60 e2       	ldi	r22, 0x20	; 32
    153a:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    153c:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    153e:	82 99       	sbic	0x10, 2	; 16
    1540:	fe cf       	rjmp	.-4      	; 0x153e <GetSIRC15+0x30>
    1542:	20 e0       	ldi	r18, 0x00	; 0
    1544:	04 c0       	rjmp	.+8      	; 0x154e <GetSIRC15+0x40>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    1546:	2f 5f       	subi	r18, 0xFF	; 255
    1548:	cb 01       	movw	r24, r22
    154a:	01 97       	sbiw	r24, 0x01	; 1
    154c:	f1 f7       	brne	.-4      	; 0x154a <GetSIRC15+0x3c>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    154e:	82 9b       	sbis	0x10, 2	; 16
    1550:	fa cf       	rjmp	.-12     	; 0x1546 <GetSIRC15+0x38>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1552:	26 30       	cpi	r18, 0x06	; 6
    1554:	08 f0       	brcs	.+2      	; 0x1558 <GetSIRC15+0x4a>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    1556:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    1558:	4f 5f       	subi	r20, 0xFF	; 255
    155a:	47 30       	cpi	r20, 0x07	; 7
    155c:	79 f7       	brne	.-34     	; 0x153c <GetSIRC15+0x2e>
    155e:	30 93 d8 06 	sts	0x06D8, r19
    1562:	40 e0       	ldi	r20, 0x00	; 0
    1564:	30 e0       	ldi	r19, 0x00	; 0
    1566:	60 e2       	ldi	r22, 0x20	; 32
    1568:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    156a:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    156c:	82 99       	sbic	0x10, 2	; 16
    156e:	fe cf       	rjmp	.-4      	; 0x156c <GetSIRC15+0x5e>
    1570:	20 e0       	ldi	r18, 0x00	; 0
    1572:	04 c0       	rjmp	.+8      	; 0x157c <GetSIRC15+0x6e>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    1574:	2f 5f       	subi	r18, 0xFF	; 255
    1576:	cb 01       	movw	r24, r22
    1578:	01 97       	sbiw	r24, 0x01	; 1
    157a:	f1 f7       	brne	.-4      	; 0x1578 <GetSIRC15+0x6a>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    157c:	82 9b       	sbis	0x10, 2	; 16
    157e:	fa cf       	rjmp	.-12     	; 0x1574 <GetSIRC15+0x66>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1580:	26 30       	cpi	r18, 0x06	; 6
    1582:	08 f0       	brcs	.+2      	; 0x1586 <GetSIRC15+0x78>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    1584:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}

		for(x=0;x<8;x++)			//repeat 8 times for address/device
    1586:	4f 5f       	subi	r20, 0xFF	; 255
    1588:	48 30       	cpi	r20, 0x08	; 8
    158a:	79 f7       	brne	.-34     	; 0x156a <GetSIRC15+0x5c>
    158c:	30 93 dd 06 	sts	0x06DD, r19
    1590:	08 95       	ret

00001592 <GetSIRC20>:
{
	char x;
	char lTime;

//StartLook:
	irExtended = irAddress = irCommand = 0;
    1592:	10 92 d8 06 	sts	0x06D8, r1
    1596:	10 92 dd 06 	sts	0x06DD, r1
    159a:	10 92 df 06 	sts	0x06DF, r1

	while(irPin);				//wait for it to be low
    159e:	82 99       	sbic	0x10, 2	; 16
    15a0:	fe cf       	rjmp	.-4      	; 0x159e <GetSIRC20+0xc>
    15a2:	20 e0       	ldi	r18, 0x00	; 0
    15a4:	40 e2       	ldi	r20, 0x20	; 32
    15a6:	53 e0       	ldi	r21, 0x03	; 3
    15a8:	04 c0       	rjmp	.+8      	; 0x15b2 <GetSIRC20+0x20>
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    {
		lTime++;				//increment every 200uS until pin is high
    15aa:	2f 5f       	subi	r18, 0xFF	; 255
    15ac:	ca 01       	movw	r24, r20
    15ae:	01 97       	sbiw	r24, 0x01	; 1
    15b0:	f1 f7       	brne	.-4      	; 0x15ae <GetSIRC20+0x1c>
	irExtended = irAddress = irCommand = 0;

	while(irPin);				//wait for it to be low
	lTime = 0;					//reset the counter

	while(irPin == 0)			//while the pin is low which is our pulse count
    15b2:	82 9b       	sbis	0x10, 2	; 16
    15b4:	fa cf       	rjmp	.-12     	; 0x15aa <GetSIRC20+0x18>
    {
		lTime++;				//increment every 200uS until pin is high
		_delay_us(200);			//200uS delay
	}

	if((lTime <= 10) || (lTime >= 14))	//Start too short or long and restart
    15b6:	2b 50       	subi	r18, 0x0B	; 11
    15b8:	23 30       	cpi	r18, 0x03	; 3
    15ba:	08 f0       	brcs	.+2      	; 0x15be <GetSIRC20+0x2c>
    15bc:	45 c0       	rjmp	.+138    	; 0x1648 <GetSIRC20+0xb6>
	{
		return;		//goto StartLook;
    15be:	40 e0       	ldi	r20, 0x00	; 0
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	60 e2       	ldi	r22, 0x20	; 32
    15c4:	73 e0       	ldi	r23, 0x03	; 3
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
		{
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1
    15c6:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    15c8:	82 99       	sbic	0x10, 2	; 16
    15ca:	fe cf       	rjmp	.-4      	; 0x15c8 <GetSIRC20+0x36>
    15cc:	20 e0       	ldi	r18, 0x00	; 0
    15ce:	04 c0       	rjmp	.+8      	; 0x15d8 <GetSIRC20+0x46>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
			    lTime++;			//increment every 200uS until pin is high
    15d0:	2f 5f       	subi	r18, 0xFF	; 255
    15d2:	cb 01       	movw	r24, r22
    15d4:	01 97       	sbiw	r24, 0x01	; 1
    15d6:	f1 f7       	brne	.-4      	; 0x15d4 <GetSIRC20+0x42>
			irCommand >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    15d8:	82 9b       	sbis	0x10, 2	; 16
    15da:	fa cf       	rjmp	.-12     	; 0x15d0 <GetSIRC20+0x3e>
			{
			    lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    15dc:	26 30       	cpi	r18, 0x06	; 6
    15de:	08 f0       	brcs	.+2      	; 0x15e2 <GetSIRC20+0x50>
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
    15e0:	30 64       	ori	r19, 0x40	; 64
		return;		//goto StartLook;
	}
	else
	{
		lTime = 0;
		for(x=0;x<7;x++)			//repeat 7 times for command
    15e2:	4f 5f       	subi	r20, 0xFF	; 255
    15e4:	47 30       	cpi	r20, 0x07	; 7
    15e6:	79 f7       	brne	.-34     	; 0x15c6 <GetSIRC20+0x34>
    15e8:	30 93 d8 06 	sts	0x06D8, r19
    15ec:	40 e0       	ldi	r20, 0x00	; 0
    15ee:	30 e0       	ldi	r19, 0x00	; 0
    15f0:	60 e2       	ldi	r22, 0x20	; 32
    15f2:	73 e0       	ldi	r23, 0x03	; 3
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
		{
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1
    15f4:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    15f6:	82 99       	sbic	0x10, 2	; 16
    15f8:	fe cf       	rjmp	.-4      	; 0x15f6 <GetSIRC20+0x64>
    15fa:	20 e0       	ldi	r18, 0x00	; 0
    15fc:	04 c0       	rjmp	.+8      	; 0x1606 <GetSIRC20+0x74>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    15fe:	2f 5f       	subi	r18, 0xFF	; 255
    1600:	cb 01       	movw	r24, r22
    1602:	01 97       	sbiw	r24, 0x01	; 1
    1604:	f1 f7       	brne	.-4      	; 0x1602 <GetSIRC20+0x70>
			irAddress >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1606:	82 9b       	sbis	0x10, 2	; 16
    1608:	fa cf       	rjmp	.-12     	; 0x15fe <GetSIRC20+0x6c>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    160a:	26 30       	cpi	r18, 0x06	; 6
    160c:	08 f0       	brcs	.+2      	; 0x1610 <GetSIRC20+0x7e>
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    160e:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irCommand |= 0x40;		//if its less than 6 its a 0 so dont OR it
		}
		
		for(x=0;x<5;x++)			//repeat 5 times for address/device
    1610:	4f 5f       	subi	r20, 0xFF	; 255
    1612:	45 30       	cpi	r20, 0x05	; 5
    1614:	79 f7       	brne	.-34     	; 0x15f4 <GetSIRC20+0x62>
    1616:	30 93 dd 06 	sts	0x06DD, r19
    161a:	40 e0       	ldi	r20, 0x00	; 0
    161c:	30 e0       	ldi	r19, 0x00	; 0
    161e:	60 e2       	ldi	r22, 0x20	; 32
    1620:	73 e0       	ldi	r23, 0x03	; 3
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
		{
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1
    1622:	36 95       	lsr	r19

			while(irPin);			//wait for it to be low
    1624:	82 99       	sbic	0x10, 2	; 16
    1626:	fe cf       	rjmp	.-4      	; 0x1624 <GetSIRC20+0x92>
    1628:	20 e0       	ldi	r18, 0x00	; 0
    162a:	04 c0       	rjmp	.+8      	; 0x1634 <GetSIRC20+0xa2>
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
			{
				lTime++;			//increment every 200uS until pin is high
    162c:	2f 5f       	subi	r18, 0xFF	; 255
    162e:	cb 01       	movw	r24, r22
    1630:	01 97       	sbiw	r24, 0x01	; 1
    1632:	f1 f7       	brne	.-4      	; 0x1630 <GetSIRC20+0x9e>
			irExtended >>= 1;			//if it was skipped or is done ORing then shift over the 1

			while(irPin);			//wait for it to be low
			lTime = 0;				//reset the counter

			while(irPin == 0)		//while the pin is low which is our pulse count
    1634:	82 9b       	sbis	0x10, 2	; 16
    1636:	fa cf       	rjmp	.-12     	; 0x162c <GetSIRC20+0x9a>
			{
				lTime++;			//increment every 200uS until pin is high
				_delay_us(200);		//200uS delay
			}

			if(lTime >= 6)			//If its high then OR a 1 in else skip
    1638:	26 30       	cpi	r18, 0x06	; 6
    163a:	08 f0       	brcs	.+2      	; 0x163e <GetSIRC20+0xac>
				irExtended |= 0x10;		//if its less than 6 its a 0 so dont OR it			
    163c:	30 61       	ori	r19, 0x10	; 16

			if(lTime >= 6)			//If its high then OR a 1 in else skip
				irAddress |= 0x10;		//if its less than 6 its a 0 so dont OR it			
		}
		
		for(x=0;x<8;x++)			//repeat 8 times for extended bits
    163e:	4f 5f       	subi	r20, 0xFF	; 255
    1640:	48 30       	cpi	r20, 0x08	; 8
    1642:	79 f7       	brne	.-34     	; 0x1622 <GetSIRC20+0x90>
    1644:	30 93 df 06 	sts	0x06DF, r19
    1648:	08 95       	ret

0000164a <__udivmodqi4>:
    164a:	99 1b       	sub	r25, r25
    164c:	79 e0       	ldi	r23, 0x09	; 9
    164e:	04 c0       	rjmp	.+8      	; 0x1658 <__udivmodqi4_ep>

00001650 <__udivmodqi4_loop>:
    1650:	99 1f       	adc	r25, r25
    1652:	96 17       	cp	r25, r22
    1654:	08 f0       	brcs	.+2      	; 0x1658 <__udivmodqi4_ep>
    1656:	96 1b       	sub	r25, r22

00001658 <__udivmodqi4_ep>:
    1658:	88 1f       	adc	r24, r24
    165a:	7a 95       	dec	r23
    165c:	c9 f7       	brne	.-14     	; 0x1650 <__udivmodqi4_loop>
    165e:	80 95       	com	r24
    1660:	08 95       	ret

00001662 <__divmodhi4>:
    1662:	97 fb       	bst	r25, 7
    1664:	09 2e       	mov	r0, r25
    1666:	07 26       	eor	r0, r23
    1668:	0a d0       	rcall	.+20     	; 0x167e <__divmodhi4_neg1>
    166a:	77 fd       	sbrc	r23, 7
    166c:	04 d0       	rcall	.+8      	; 0x1676 <__divmodhi4_neg2>
    166e:	0c d0       	rcall	.+24     	; 0x1688 <__udivmodhi4>
    1670:	06 d0       	rcall	.+12     	; 0x167e <__divmodhi4_neg1>
    1672:	00 20       	and	r0, r0
    1674:	1a f4       	brpl	.+6      	; 0x167c <__divmodhi4_exit>

00001676 <__divmodhi4_neg2>:
    1676:	70 95       	com	r23
    1678:	61 95       	neg	r22
    167a:	7f 4f       	sbci	r23, 0xFF	; 255

0000167c <__divmodhi4_exit>:
    167c:	08 95       	ret

0000167e <__divmodhi4_neg1>:
    167e:	f6 f7       	brtc	.-4      	; 0x167c <__divmodhi4_exit>
    1680:	90 95       	com	r25
    1682:	81 95       	neg	r24
    1684:	9f 4f       	sbci	r25, 0xFF	; 255
    1686:	08 95       	ret

00001688 <__udivmodhi4>:
    1688:	aa 1b       	sub	r26, r26
    168a:	bb 1b       	sub	r27, r27
    168c:	51 e1       	ldi	r21, 0x11	; 17
    168e:	07 c0       	rjmp	.+14     	; 0x169e <__udivmodhi4_ep>

00001690 <__udivmodhi4_loop>:
    1690:	aa 1f       	adc	r26, r26
    1692:	bb 1f       	adc	r27, r27
    1694:	a6 17       	cp	r26, r22
    1696:	b7 07       	cpc	r27, r23
    1698:	10 f0       	brcs	.+4      	; 0x169e <__udivmodhi4_ep>
    169a:	a6 1b       	sub	r26, r22
    169c:	b7 0b       	sbc	r27, r23

0000169e <__udivmodhi4_ep>:
    169e:	88 1f       	adc	r24, r24
    16a0:	99 1f       	adc	r25, r25
    16a2:	5a 95       	dec	r21
    16a4:	a9 f7       	brne	.-22     	; 0x1690 <__udivmodhi4_loop>
    16a6:	80 95       	com	r24
    16a8:	90 95       	com	r25
    16aa:	bc 01       	movw	r22, r24
    16ac:	cd 01       	movw	r24, r26
    16ae:	08 95       	ret

000016b0 <itoa>:
    16b0:	fb 01       	movw	r30, r22
    16b2:	9f 01       	movw	r18, r30
    16b4:	e8 94       	clt
    16b6:	42 30       	cpi	r20, 0x02	; 2
    16b8:	c4 f0       	brlt	.+48     	; 0x16ea <itoa+0x3a>
    16ba:	45 32       	cpi	r20, 0x25	; 37
    16bc:	b4 f4       	brge	.+44     	; 0x16ea <itoa+0x3a>
    16be:	4a 30       	cpi	r20, 0x0A	; 10
    16c0:	29 f4       	brne	.+10     	; 0x16cc <itoa+0x1c>
    16c2:	97 fb       	bst	r25, 7
    16c4:	1e f4       	brtc	.+6      	; 0x16cc <itoa+0x1c>
    16c6:	90 95       	com	r25
    16c8:	81 95       	neg	r24
    16ca:	9f 4f       	sbci	r25, 0xFF	; 255
    16cc:	64 2f       	mov	r22, r20
    16ce:	77 27       	eor	r23, r23
    16d0:	0e 94 44 0b 	call	0x1688	; 0x1688 <__udivmodhi4>
    16d4:	80 5d       	subi	r24, 0xD0	; 208
    16d6:	8a 33       	cpi	r24, 0x3A	; 58
    16d8:	0c f0       	brlt	.+2      	; 0x16dc <itoa+0x2c>
    16da:	89 5d       	subi	r24, 0xD9	; 217
    16dc:	81 93       	st	Z+, r24
    16de:	cb 01       	movw	r24, r22
    16e0:	00 97       	sbiw	r24, 0x00	; 0
    16e2:	a1 f7       	brne	.-24     	; 0x16cc <itoa+0x1c>
    16e4:	16 f4       	brtc	.+4      	; 0x16ea <itoa+0x3a>
    16e6:	5d e2       	ldi	r21, 0x2D	; 45
    16e8:	51 93       	st	Z+, r21
    16ea:	10 82       	st	Z, r1
    16ec:	c9 01       	movw	r24, r18
    16ee:	0c 94 e8 0b 	jmp	0x17d0	; 0x17d0 <strrev>

000016f2 <ltoa>:
    16f2:	fa 01       	movw	r30, r20
    16f4:	cf 93       	push	r28
    16f6:	ff 93       	push	r31
    16f8:	ef 93       	push	r30
    16fa:	22 30       	cpi	r18, 0x02	; 2
    16fc:	44 f1       	brlt	.+80     	; 0x174e <ltoa+0x5c>
    16fe:	25 32       	cpi	r18, 0x25	; 37
    1700:	34 f5       	brge	.+76     	; 0x174e <ltoa+0x5c>
    1702:	c2 2f       	mov	r28, r18
    1704:	e8 94       	clt
    1706:	ca 30       	cpi	r28, 0x0A	; 10
    1708:	49 f4       	brne	.+18     	; 0x171c <ltoa+0x2a>
    170a:	97 fb       	bst	r25, 7
    170c:	3e f4       	brtc	.+14     	; 0x171c <ltoa+0x2a>
    170e:	90 95       	com	r25
    1710:	80 95       	com	r24
    1712:	70 95       	com	r23
    1714:	61 95       	neg	r22
    1716:	7f 4f       	sbci	r23, 0xFF	; 255
    1718:	8f 4f       	sbci	r24, 0xFF	; 255
    171a:	9f 4f       	sbci	r25, 0xFF	; 255
    171c:	2c 2f       	mov	r18, r28
    171e:	33 27       	eor	r19, r19
    1720:	44 27       	eor	r20, r20
    1722:	55 27       	eor	r21, r21
    1724:	ff 93       	push	r31
    1726:	ef 93       	push	r30
    1728:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <__udivmodsi4>
    172c:	ef 91       	pop	r30
    172e:	ff 91       	pop	r31
    1730:	60 5d       	subi	r22, 0xD0	; 208
    1732:	6a 33       	cpi	r22, 0x3A	; 58
    1734:	0c f0       	brlt	.+2      	; 0x1738 <ltoa+0x46>
    1736:	69 5d       	subi	r22, 0xD9	; 217
    1738:	61 93       	st	Z+, r22
    173a:	b9 01       	movw	r22, r18
    173c:	ca 01       	movw	r24, r20
    173e:	60 50       	subi	r22, 0x00	; 0
    1740:	70 40       	sbci	r23, 0x00	; 0
    1742:	80 40       	sbci	r24, 0x00	; 0
    1744:	90 40       	sbci	r25, 0x00	; 0
    1746:	51 f7       	brne	.-44     	; 0x171c <ltoa+0x2a>
    1748:	16 f4       	brtc	.+4      	; 0x174e <ltoa+0x5c>
    174a:	cd e2       	ldi	r28, 0x2D	; 45
    174c:	c1 93       	st	Z+, r28
    174e:	10 82       	st	Z, r1
    1750:	8f 91       	pop	r24
    1752:	9f 91       	pop	r25
    1754:	cf 91       	pop	r28
    1756:	0c 94 e8 0b 	jmp	0x17d0	; 0x17d0 <strrev>

0000175a <ultoa>:
    175a:	fa 01       	movw	r30, r20
    175c:	cf 93       	push	r28
    175e:	ff 93       	push	r31
    1760:	ef 93       	push	r30
    1762:	22 30       	cpi	r18, 0x02	; 2
    1764:	cc f0       	brlt	.+50     	; 0x1798 <ultoa+0x3e>
    1766:	25 32       	cpi	r18, 0x25	; 37
    1768:	bc f4       	brge	.+46     	; 0x1798 <ultoa+0x3e>
    176a:	c2 2f       	mov	r28, r18
    176c:	2c 2f       	mov	r18, r28
    176e:	33 27       	eor	r19, r19
    1770:	44 27       	eor	r20, r20
    1772:	55 27       	eor	r21, r21
    1774:	ff 93       	push	r31
    1776:	ef 93       	push	r30
    1778:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <__udivmodsi4>
    177c:	ef 91       	pop	r30
    177e:	ff 91       	pop	r31
    1780:	60 5d       	subi	r22, 0xD0	; 208
    1782:	6a 33       	cpi	r22, 0x3A	; 58
    1784:	0c f0       	brlt	.+2      	; 0x1788 <ultoa+0x2e>
    1786:	69 5d       	subi	r22, 0xD9	; 217
    1788:	61 93       	st	Z+, r22
    178a:	b9 01       	movw	r22, r18
    178c:	ca 01       	movw	r24, r20
    178e:	60 50       	subi	r22, 0x00	; 0
    1790:	70 40       	sbci	r23, 0x00	; 0
    1792:	80 40       	sbci	r24, 0x00	; 0
    1794:	90 40       	sbci	r25, 0x00	; 0
    1796:	51 f7       	brne	.-44     	; 0x176c <ultoa+0x12>
    1798:	10 82       	st	Z, r1
    179a:	8f 91       	pop	r24
    179c:	9f 91       	pop	r25
    179e:	cf 91       	pop	r28
    17a0:	0c 94 e8 0b 	jmp	0x17d0	; 0x17d0 <strrev>

000017a4 <utoa>:
    17a4:	fb 01       	movw	r30, r22
    17a6:	9f 01       	movw	r18, r30
    17a8:	42 30       	cpi	r20, 0x02	; 2
    17aa:	74 f0       	brlt	.+28     	; 0x17c8 <utoa+0x24>
    17ac:	45 32       	cpi	r20, 0x25	; 37
    17ae:	64 f4       	brge	.+24     	; 0x17c8 <utoa+0x24>
    17b0:	64 2f       	mov	r22, r20
    17b2:	77 27       	eor	r23, r23
    17b4:	0e 94 44 0b 	call	0x1688	; 0x1688 <__udivmodhi4>
    17b8:	80 5d       	subi	r24, 0xD0	; 208
    17ba:	8a 33       	cpi	r24, 0x3A	; 58
    17bc:	0c f0       	brlt	.+2      	; 0x17c0 <utoa+0x1c>
    17be:	89 5d       	subi	r24, 0xD9	; 217
    17c0:	81 93       	st	Z+, r24
    17c2:	cb 01       	movw	r24, r22
    17c4:	00 97       	sbiw	r24, 0x00	; 0
    17c6:	a1 f7       	brne	.-24     	; 0x17b0 <utoa+0xc>
    17c8:	10 82       	st	Z, r1
    17ca:	c9 01       	movw	r24, r18
    17cc:	0c 94 e8 0b 	jmp	0x17d0	; 0x17d0 <strrev>

000017d0 <strrev>:
    17d0:	dc 01       	movw	r26, r24
    17d2:	fc 01       	movw	r30, r24
    17d4:	67 2f       	mov	r22, r23
    17d6:	71 91       	ld	r23, Z+
    17d8:	77 23       	and	r23, r23
    17da:	e1 f7       	brne	.-8      	; 0x17d4 <strrev+0x4>
    17dc:	32 97       	sbiw	r30, 0x02	; 2
    17de:	04 c0       	rjmp	.+8      	; 0x17e8 <strrev+0x18>
    17e0:	7c 91       	ld	r23, X
    17e2:	6d 93       	st	X+, r22
    17e4:	70 83       	st	Z, r23
    17e6:	62 91       	ld	r22, -Z
    17e8:	ae 17       	cp	r26, r30
    17ea:	bf 07       	cpc	r27, r31
    17ec:	c8 f3       	brcs	.-14     	; 0x17e0 <strrev+0x10>
    17ee:	08 95       	ret

000017f0 <__udivmodsi4>:
    17f0:	a1 e2       	ldi	r26, 0x21	; 33
    17f2:	1a 2e       	mov	r1, r26
    17f4:	aa 1b       	sub	r26, r26
    17f6:	bb 1b       	sub	r27, r27
    17f8:	fd 01       	movw	r30, r26
    17fa:	0d c0       	rjmp	.+26     	; 0x1816 <__udivmodsi4_ep>

000017fc <__udivmodsi4_loop>:
    17fc:	aa 1f       	adc	r26, r26
    17fe:	bb 1f       	adc	r27, r27
    1800:	ee 1f       	adc	r30, r30
    1802:	ff 1f       	adc	r31, r31
    1804:	a2 17       	cp	r26, r18
    1806:	b3 07       	cpc	r27, r19
    1808:	e4 07       	cpc	r30, r20
    180a:	f5 07       	cpc	r31, r21
    180c:	20 f0       	brcs	.+8      	; 0x1816 <__udivmodsi4_ep>
    180e:	a2 1b       	sub	r26, r18
    1810:	b3 0b       	sbc	r27, r19
    1812:	e4 0b       	sbc	r30, r20
    1814:	f5 0b       	sbc	r31, r21

00001816 <__udivmodsi4_ep>:
    1816:	66 1f       	adc	r22, r22
    1818:	77 1f       	adc	r23, r23
    181a:	88 1f       	adc	r24, r24
    181c:	99 1f       	adc	r25, r25
    181e:	1a 94       	dec	r1
    1820:	69 f7       	brne	.-38     	; 0x17fc <__udivmodsi4_loop>
    1822:	60 95       	com	r22
    1824:	70 95       	com	r23
    1826:	80 95       	com	r24
    1828:	90 95       	com	r25
    182a:	9b 01       	movw	r18, r22
    182c:	ac 01       	movw	r20, r24
    182e:	bd 01       	movw	r22, r26
    1830:	cf 01       	movw	r24, r30
    1832:	08 95       	ret

00001834 <_exit>:
    1834:	f8 94       	cli

00001836 <__stop_program>:
    1836:	ff cf       	rjmp	.-2      	; 0x1836 <__stop_program>
